<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo搭建个人博客</title>
      <link href="/post/64e2e0e2.html"/>
      <url>/post/64e2e0e2.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-入门并建立个人博客个人博客"><a href="#Hexo-入门并建立个人博客个人博客" class="headerlink" title="Hexo 入门并建立个人博客个人博客"></a>Hexo 入门并建立个人博客个人博客</h1><h3 id="步骤-1-安装-Node-js-和-Git"><a href="#步骤-1-安装-Node-js-和-Git" class="headerlink" title="步骤 1: 安装 Node.js 和 Git"></a>步骤 1: 安装 Node.js 和 Git</h3><p>Hexo 是基于 Node.js 的，因此首先需要安装 Node.js。此外，还需要安装 Git 作为版本控制工具。</p><ul><li><a href="https://nodejs.org/">Node.js</a></li><li><a href="https://git-scm.com/">Git </a></li></ul><p>安装完成后，通过以下命令验证它们是否成功安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure><img src="/post/64e2e0e2/image-20231120201612567.png" class="" title="image-20231120201612567"> <h3 id="步骤-2-安装-Hexo"><a href="#步骤-2-安装-Hexo" class="headerlink" title="步骤 2: 安装 Hexo"></a>步骤 2: 安装 Hexo</h3><p>打开终端（命令行界面）并运行以下命令来安装 Hexo：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="步骤-3-创建-Hexo-项目"><a href="#步骤-3-创建-Hexo-项目" class="headerlink" title="步骤 3: 创建 Hexo 项目"></a>步骤 3: 创建 Hexo 项目</h3><p>选择一个文件夹作为你的博客目录，然后在终端中运行以下命令来初始化 Hexo 项目：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init myblog</span><br><span class="line"><span class="built_in">cd</span> my-blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><blockquote><p><code>hexo init myblog</code></p><p>会从 Hexo 的模板库中克隆一个基本的博客结构到指定的目录（<code>myblog</code>）</p><p>。这个模板包含了一些默认的配置文件、示例文章以及其他必要的文件，提供了一个快速启动 Hexo 博客的起点。会创一个文件夹myblog里面有依赖项</p><blockquote><p><code>hexo init</code>这个命令是自动生成hexo目录时使用的命令，使用他有一个前提是&#x3D;&#x3D;必须是空文件夹&#x3D;&#x3D;</p></blockquote><p><code>npm install</code></p><p>会根据项目根目录下的 <code>package.json</code> 文件中列出的依赖信息，从 npm（Node.js 包管理器）中安装这些依赖项。这些依赖项包括 Hexo 本身以及其他一些插件和工具，它们是构建、生成和部署 Hexo 博客所必需的。</p></blockquote><p>这将在你选择的目录中创建一个 Hexo 项目，并安装所需的依赖项。</p><img src="/post/64e2e0e2/image-20231120202559252.png" class="" title="image-20231120202559252"> <img src="/post/64e2e0e2/image-20231120202009690.png" class="" title="image-20231120202009690"><blockquote><p>至此已经完成了很大一部分了</p></blockquote><h3 id="步骤-4-配置-Hexo"><a href="#步骤-4-配置-Hexo" class="headerlink" title="步骤 4: 配置 Hexo"></a>步骤 4: 配置 Hexo</h3><p>github创建一个仓库</p><img src="/post/64e2e0e2/image-20231120203223928.png" class="" title="image-20231120203223928"> <p>打开 <code>_config.yml</code> 文件以配置 Hexo。需要配置 <code>url</code> 和 <code>deploy</code> 部分，以便在发布博客时正确设置链接。</p><img src="/post/64e2e0e2/image-20231120205038448.png" class="" title="image-20231120205038448"> <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://your-blog-url.com</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/yourusername/yourusername.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><blockquote><ol><li><strong><code>url: https://your-blog-url.com</code>：</strong><ul><li>这个是博客的基本网址，它用于生成你博客文章中的链接。在这里，<code>https://your-blog-url.com</code> 是一个占位符，你需要将它替换成你实际博客的域名或者自定义的网址。</li></ul></li><li><strong><code>deploy</code> 部分：</strong><ul><li>这个部分是用于配置 Hexo 如何部署生成的静态文件。在这个例子中，配置了使用 Git 进行部署。</li><li><strong><code>type: git</code>：</strong> 表示使用 Git 进行部署。</li><li><strong><code>repo: https://github.com/yourusername/yourusername.github.io.git</code>：</strong> 这是你的博客的 GitHub 仓库地址。一般来说，GitHub Pages 会将你的个人页面托管在 <code>https://yourusername.github.io</code>，所以仓库名要按照一定的规则来命名。具体规则是 <code>&lt;yourusername&gt;.github.io</code>，&#x3D;&#x3D;其中 <code>&lt;yourusername&gt;</code> 是你的 GitHub 用户名。这样的仓库名才能被 GitHub 自动识别为一个 GitHub Pages 仓库，从而用于托管你的博客。&#x3D;&#x3D;</li><li><strong><code>branch: master</code>：</strong> 这是你的 GitHub Pages 仓库的分支，一般是 <code>master</code> 分支。这表示 Hexo 会将生成的静态文件推送到这个分支上。</li></ul></li></ol><p>&#x3D;&#x3D;确保 <code>repo</code> 符合 GitHub Pages 的规范，即仓库名为 <code>&lt;yourusername&gt;.github.io</code>。&#x3D;&#x3D;</p></blockquote><h3 id="步骤-5-创建一篇新博文"><a href="#步骤-5-创建一篇新博文" class="headerlink" title="步骤 5: 创建一篇新博文"></a>步骤 5: 创建一篇新博文</h3><p>运行以下命令创建一篇新的博文：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My First Post&quot;</span></span><br></pre></td></tr></table></figure><p>这将在 <code>source/_posts</code> 目录中创建一个 Markdown 文件，其中包含你的新博文的初始内容。</p><h3 id="步骤-6-本地预览"><a href="#步骤-6-本地预览" class="headerlink" title="步骤 6: 本地预览"></a>步骤 6: 本地预览</h3><p>使用以下命令启动本地服务器并在浏览器中预览你的博客：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>然后在浏览器中访问 <code>http://localhost:4000</code>。</p><img src="/post/64e2e0e2/image-20231120202902347.png" class="" title="image-20231120202902347"> <h3 id="步骤-7-发布到-GitHub-Pages"><a href="#步骤-7-发布到-GitHub-Pages" class="headerlink" title="步骤 7: 发布到 GitHub Pages"></a>步骤 7: 发布到 GitHub Pages</h3><p>安装hexo-deployer-git 自动部署发布工具</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="operator">-</span>deployer<span class="operator">-</span>git <span class="comment">--save</span></span><br></pre></td></tr></table></figure><img src="/post/64e2e0e2/image-20231120204051983.png" class="" title="image-20231120204051983"> <p>如果你希望将你的博客部署到 GitHub Pages，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>这将清理之前的部署并将新的博客版本发布到你在 <code>_config.yml</code> 中配置的 GitHub 仓库。</p><img src="/post/64e2e0e2/image-20231120205130146.png" class="" title="image-20231120205130146"> <blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>三连！</p></blockquote><p><a href="https://666xrb.github.io/">666xrb.github.io)</a></p><h3 id="config-yml配置文件"><a href="#config-yml配置文件" class="headerlink" title="config.yml配置文件"></a>config.yml配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Docs: http://hexo.io/docs/configuration.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site #站点信息</span></span><br><span class="line"></span><br><span class="line">title:  <span class="comment">#标题</span></span><br><span class="line"></span><br><span class="line">subtitle:  <span class="comment">#副标题</span></span><br><span class="line"></span><br><span class="line">description:  <span class="comment">#站点描述，给搜索引擎看的</span></span><br><span class="line"></span><br><span class="line">author:  <span class="comment">#作者</span></span><br><span class="line"></span><br><span class="line">email:  <span class="comment">#电子邮箱</span></span><br><span class="line"></span><br><span class="line">language: zh-CN <span class="comment">#语言</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL #链接格式</span></span><br><span class="line"></span><br><span class="line">url:  <span class="comment">#网址</span></span><br><span class="line"></span><br><span class="line">root: / <span class="comment">#根目录</span></span><br><span class="line"></span><br><span class="line">permalink: :year/:month/:day/:title/ <span class="comment">#文章的链接格式</span></span><br><span class="line"></span><br><span class="line">tag_dir: tags <span class="comment">#标签目录</span></span><br><span class="line"></span><br><span class="line">archive_dir: archives <span class="comment">#存档目录</span></span><br><span class="line"></span><br><span class="line">category_dir: categories <span class="comment">#分类目录</span></span><br><span class="line"></span><br><span class="line">code_dir: downloads/code</span><br><span class="line"></span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory #目录</span></span><br><span class="line"></span><br><span class="line">source_dir: <span class="built_in">source</span> <span class="comment">#源文件目录</span></span><br><span class="line"></span><br><span class="line">public_dir: public <span class="comment">#生成的网页文件目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing #写作</span></span><br><span class="line"></span><br><span class="line">new_post_name: :title.md <span class="comment">#新文章标题</span></span><br><span class="line"></span><br><span class="line">default_layout: post <span class="comment">#默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）</span></span><br><span class="line"></span><br><span class="line">titlecase: <span class="literal">false</span> <span class="comment">#标题转换成大写</span></span><br><span class="line"></span><br><span class="line">external_link: <span class="literal">true</span> <span class="comment">#在新选项卡中打开连接</span></span><br><span class="line"></span><br><span class="line">filename_case: 0</span><br><span class="line"></span><br><span class="line">render_drafts: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">post_asset_folder: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">relative_link: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">highlight: <span class="comment">#语法高亮</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">enable</span>: <span class="literal">true</span> <span class="comment">#是否启用</span></span><br><span class="line"></span><br><span class="line">line_number: <span class="literal">true</span> <span class="comment">#显示行号</span></span><br><span class="line"></span><br><span class="line">tab_replace:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag #分类和标签</span></span><br><span class="line"></span><br><span class="line">default_category: uncategorized <span class="comment">#默认分类</span></span><br><span class="line"></span><br><span class="line">category_map:</span><br><span class="line"></span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Archives</span></span><br><span class="line"></span><br><span class="line">2: 开启分页</span><br><span class="line"></span><br><span class="line">1: 禁用分页</span><br><span class="line"></span><br><span class="line">0: 全部禁用</span><br><span class="line"></span><br><span class="line">archive: 2</span><br><span class="line"></span><br><span class="line">category: 2</span><br><span class="line"></span><br><span class="line">tag: 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Server #本地服务器</span></span><br><span class="line"></span><br><span class="line">port: 4000 <span class="comment">#端口号</span></span><br><span class="line"></span><br><span class="line">server_ip: localhost <span class="comment">#IP 地址</span></span><br><span class="line"></span><br><span class="line">logger: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">logger_format: dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format #日期时间格式</span></span><br><span class="line"></span><br><span class="line">date_format: YYYY-MM-DD <span class="comment">#参考http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"></span><br><span class="line">time_format: H:mm:ss</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination #分页</span></span><br><span class="line"></span><br><span class="line">per_page: 10 <span class="comment">#每页文章数，设置成 0 禁用分页</span></span><br><span class="line"></span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disqus #Disqus评论，替换为多说</span></span><br><span class="line"></span><br><span class="line">disqus_shortname:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions #拓展插件</span></span><br><span class="line"></span><br><span class="line">theme: landscape-plus <span class="comment">#主题</span></span><br><span class="line"></span><br><span class="line">exclude_generator:</span><br><span class="line"></span><br><span class="line">plugins: <span class="comment">#插件，例如生成 RSS 和站点地图的</span></span><br><span class="line"></span><br><span class="line">- hexo-generator-feed</span><br><span class="line"></span><br><span class="line">- hexo-generator-sitemap</span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment #部署，将 lmintlcx 改成用户名</span></span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span>: git</span><br><span class="line"></span><br><span class="line">repo: 创建仓库成功后的http地址</span><br><span class="line"></span><br><span class="line">branch: master</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常见的问题"><a href="#常见的问题" class="headerlink" title="常见的问题"></a>常见的问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo  d</span><br></pre></td></tr></table></figure><img src="/post/64e2e0e2/image-20231120204239832.png" class="" title="image-20231120204239832"> <p>source的文章要用命令生成啊</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;sadsda&quot;</span></span><br></pre></td></tr></table></figure><h3 id="博客美化"><a href="#博客美化" class="headerlink" title="博客美化"></a>博客美化</h3><p><a href="https://blog.csdn.net/qq_38157825/article/details/112783083?ops_request_misc=%7B%22request_id%22:%22169548330616800186546490%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=169548330616800186546490&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-112783083-null-null.142%5Ev94%5Econtrol&utm_term=_config.butterfly.yml&spm=1018.2226.3001.4187">【精选】Butterfly主题安装文档(三)之主题配置2_butterfly activate_power_mode-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本</title>
      <link href="/post/563a1179.html"/>
      <url>/post/563a1179.html</url>
      
        <content type="html"><![CDATA[<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><h2 id="Linux是如何操作计算机的硬件？"><a href="#Linux是如何操作计算机的硬件？" class="headerlink" title="Linux是如何操作计算机的硬件？"></a>Linux是如何操作计算机的硬件？</h2><blockquote><p>用linux的内核操作</p></blockquote><hr><h2 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h2><p>是一个文本文件，可以编写shell命令，或者变成，形成一个可以重复执行的脚本文件</p><h2 id="shell介绍"><a href="#shell介绍" class="headerlink" title="shell介绍"></a>shell介绍</h2><blockquote><p>编写shell命令发送给linux内核取执行，操作的是计算机硬件，是&#x3D;&#x3D;<strong>用户和操作计算机硬件的桥梁</strong>&#x3D;&#x3D;</p></blockquote><blockquote><p>shell是命令，也是程序设计语言。</p><p>我们编写shell命令程序，shell</p><img src="/post/563a1179/image-20231031165019467.png" class="" title="image-20231031165019467"></blockquote><h2 id="shell脚本作用"><a href="#shell脚本作用" class="headerlink" title="shell脚本作用"></a>shell脚本作用</h2><p>提高Linux系统的管理工作效率</p><h2 id="shell的运行过程"><a href="#shell的运行过程" class="headerlink" title="shell的运行过程"></a>shell的运行过程</h2><img src="/post/563a1179/image-20231031165244269.png" class="" title="image-20231031165244269"><h2 id="shell解析器"><a href="#shell解析器" class="headerlink" title="shell解析器"></a>shell解析器</h2><img src="/post/563a1179/image-20231031165426731.png" class="" title="image-20231031165426731"> <img src="/post/563a1179/image-20231031165444434.png" class="" title="image-20231031165444434"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure><p>打印当前系统环境使用的shell解析器类型</p><img src="/post/563a1179/image-20231031165556517.png" class="" title="image-20231031165556517"> <h2 id="Shell脚本的编写格式和执行方式"><a href="#Shell脚本的编写格式和执行方式" class="headerlink" title="Shell脚本的编写格式和执行方式"></a>Shell脚本的编写格式和执行方式</h2><blockquote><p>Shell脚本的编写规范</p><p>如何执行Shell脚本呢？</p></blockquote><h3 id="后缀-sh"><a href="#后缀-sh" class="headerlink" title="后缀:   .sh"></a>后缀:   .sh</h3><p>首航格式规范 : 需要指出Shell解析器的类型</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br></pre></td></tr></table></figure><blockquote><p>当前shell脚本文件采用bash解析器运行脚本代码</p></blockquote><h3 id="注释格式"><a href="#注释格式" class="headerlink" title="注释格式"></a>注释格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 注释内容</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;!</span><br><span class="line">注释</span><br><span class="line">注释</span><br><span class="line">!</span><br></pre></td></tr></table></figure><h3 id="Shell-hello-world"><a href="#Shell-hello-world" class="headerlink" title="Shell hello world"></a>Shell hello world</h3><p>》》》</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch hello.sh</span><br><span class="line">vim hello.sh</span><br><span class="line">------------------</span><br><span class="line">vim hello.sh</span><br><span class="line">创建加编辑</span><br></pre></td></tr></table></figure><img src="/post/563a1179/image-20231031170815701.png" class="" title="image-20231031170815701"> <h3 id="如何执行呢？三种方式"><a href="#如何执行呢？三种方式" class="headerlink" title="如何执行呢？三种方式"></a>如何执行呢？三种方式</h3><ol><li><p>sh解析器执行方式</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh 脚本文件</span><br></pre></td></tr></table></figure><p>本质：用<strong>shell解析器运行脚本文件</strong></p><img src="/post/563a1179/image-20231031170935039.png" class="" title="image-20231031170935039"> </blockquote></li><li><p>bash解析器执行方式</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash 脚本文件</span><br></pre></td></tr></table></figure><p>本质：用bash命令执行脚本文件，使<strong>用shell解析器运行脚本文件</strong></p></blockquote></li><li><p>路径执行方式</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./脚本文件</span><br></pre></td></tr></table></figure><img src="/post/563a1179/image-20231031171233560.png" class="" title="image-20231031171233560"> <p>&#x3D;&#x3D;前提需要脚本文件有执行的权限x&#x3D;&#x3D;</p><p>脚本文件添加执行权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x 脚本文件</span><br></pre></td></tr></table></figure><p>执行</p><img src="/post/563a1179/image-20231031171250107.png" class="" title="image-20231031171250107"> <p><code>./</code>前缀是Linux&#x2F;Unix系统中用于运行当前目录下的可执行文件的一种方式，但前提是文件具有执行权限。</p></blockquote></li></ol><h2 id="多命令处理"><a href="#多命令处理" class="headerlink" title="多命令处理"></a>多命令处理</h2><p>Shell（外壳）是计算机操作系统的用户界面，用于与操作系统内核进行交互。</p><p>Shell 可以执行单个命令，也可以执行多个命令，通常使用分号、逻辑运算符和管道等方法来处理多个命令。</p><p>以下是一些关于在Shell中处理多个命令的知识：</p><ol><li><p>命令分隔符：</p><ul><li>分号 <code>;</code>：分号用于将多个命令分隔开，按顺序执行。例如：<code>command1 ; command2</code></li><li>换行符（换行）：通常，&#x3D;&#x3D;每行代表一个命令&#x3D;&#x3D;，可以按&#x3D;&#x3D;顺序&#x3D;&#x3D;执行。</li></ul></li><li><p>逻辑运算符：</p><ul><li>逻辑与 <code>&amp;&amp;</code>：只有在前一个命令成功执行（返回0）时，才执行下一个命令。例如：<code>command1 &amp;&amp; command2</code></li><li>逻辑或 <code>||</code>：只有在前一个命令执行失败（返回非0）时，才执行下一个命令。例如：<code>command1 || command2</code></li></ul></li><li><p>管道 <code>|</code>：</p><ul><li>管道允许将一个命令的输出传递给另一个命令的输入。例如：<code>command1 | command2</code>，其中 <code>command1</code> 的输出作为 <code>command2</code> 的输入。</li></ul></li><li><p>后台执行 <code>&amp;</code>：</p><ul><li>&#x3D;&#x3D;在命令末尾加上 <code>&amp;</code> 符号可以使命令在后台执行&#x3D;&#x3D;，而不会阻塞Shell。例如：<code>command &amp;</code></li></ul></li><li><p>子Shell <code>( )</code>：</p><ul><li>使用括号可以创建子Shell，其中的命令在一个独立的Shell环境中执行。这对于创建临时环境或限定变量范围很有用。例如：<code>(command1; command2)</code></li></ul></li><li><p>控制结构：</p><ul><li>Shell 脚本可以包含条件语句（if-else）、循环（for、while）等控制结构，以便根据条件执行多个命令。</li></ul></li><li><p>脚本文件：</p><ul><li>您可以将多个命令保存在脚本文件中，并通过执行脚本文件来依次运行这些命令。脚本文件通常以 <code>.sh</code> 扩展名。</li></ul></li></ol><h2 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h2><blockquote><p>什么是系统环境变量</p><p>撞我常用的系统环境变量有哪些。</p></blockquote><h3 id="系统环境变量"><a href="#系统环境变量" class="headerlink" title="系统环境变量"></a>系统环境变量</h3><ol><li><strong>PATH</strong>：<code>PATH</code> 环境变量指定了系统在哪些目录中查找可执行文件。当您在终端中输入命令时，系统会依次查找 <code>PATH</code> 中列出的目录，以找到要执行的命令。</li><li><strong>HOME</strong>：<code>HOME</code> 环境变量包含了当前用户的主目录的路径。通常，用户的个人文件和配置文件存储在该目录下。</li><li><strong>USER</strong>：<code>USER</code> 环境变量包含了当前登录用户的用户名。</li><li><strong>SHELL</strong>：<code>SHELL</code> 环境变量指定了当前用户所使用的默认Shell。</li><li><strong>PWD</strong>：<code>PWD</code> 环境变量表示当前工作目录（即，用户当前所在的目录）的路径。</li><li><strong>LANG</strong> 和 *<em>LC_</em> **：这些环境变量控制系统的语言和区域设置，包括日期格式、货币符号等。</li><li><strong>TERM</strong>：<code>TERM</code> 环境变量定义了终端类型，以便应用程序知道如何与终端进行交互。</li><li><strong>PS1</strong> 和 <strong>PS2</strong>：这些环境变量定义了Shell提示符的外观，<code>PS1</code> 用于主提示符，<code>PS2</code> 用于次级提示符（通常出现在多行命令中）。</li><li><strong>TMP</strong> 和 <strong>TEMP</strong>：这些环境变量指定了用于临时文件的目录路径。</li><li><strong>LD_LIBRARY_PATH</strong>：<code>LD_LIBRARY_PATH</code> 环境变量用于指定动态链接库的搜索路径，以便应用程序可以正确地加载共享库。</li><li><strong>EDITOR</strong>：<code>EDITOR</code> 环境变量定义了默认的文本编辑器，通常在编辑文件时使用。</li><li><strong>DISPLAY</strong>：<code>DISPLAY</code> 环境变量用于指定X Window系统的显示器（用于图形用户界面应用程序）。</li><li><strong>MAIL</strong>：<code>MAIL</code> 环境变量包含了用户的邮件存储路径。</li></ol><p>系统环境变量是一种全局性的变量，它们对整个操作系统以及用户环境起着重要的作用。这些变量包括了有关系统配置、用户信息、路径设置以及其他重要信息。</p><img src="/post/563a1179/image-20231031193917693.png" class="" title="image-20231031193917693"><h3 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h3><p>&#x2F;etc&#x2F;profile</p><h3 id="个人用户配置文件"><a href="#个人用户配置文件" class="headerlink" title="个人用户配置文件"></a>个人用户配置文件</h3><p>&#x2F;.bashrc</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $HISTFILE</span><br></pre></td></tr></table></figure><p>得到历史命令</p><h3 id="set命令"><a href="#set命令" class="headerlink" title="set命令"></a>set命令</h3><p><code>set</code> 命令主要用于显示和设置Shell环境变量。具体来说，<code>set</code> 命令有以下几个用途：</p><ol><li><strong>显示环境变量和Shell参数</strong>：显示当前Shell会话中定义的所有环境变量和Shell参数。这包括系统环境变量、用户定义的环境变量以及命令行参数。</li><li><strong>设置局部变量</strong>：您可以使用 <code>set</code> 命令来设置局部变量，这些变量仅在当前Shell会话中可见。例如，<code>set myvar=value</code> 会创建一个名为 <code>myvar</code> 的局部变量，并将其值设置为 <code>value</code>。</li><li><strong>修改环境变量</strong>：通过 <code>set</code> 命令，您可以修改已存在的环境变量的值。例如，<code>set PATH=/new/path:$PATH</code> 可以将 <code>PATH</code> 环境变量的值更新为新的路径。</li><li><strong>取消变量</strong>：使用 <code>set</code> 命令，您可以取消已定义的环境变量或局部变量。例如，<code>set -e myvar</code> 可以删除名为 <code>myvar</code> 的变量。</li><li><strong>设置位置参数</strong>：<code>set</code> 命令还可用于设置位置参数，这些参数通常用在Shell脚本中。例如，<code>set arg1 arg2 arg3</code> 将设置位置参数为 <code>arg1</code>、<code>arg2</code> 和 <code>arg3</code>，这些参数可以在脚本中使用。</li></ol><h3 id="env命令"><a href="#env命令" class="headerlink" title="env命令"></a>env命令</h3><p>查看系统环境变量,没有set那么详细</p><h2 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h2><h3 id="什么是自定义变量"><a href="#什么是自定义变量" class="headerlink" title="什么是自定义变量"></a>什么是自定义变量</h3><blockquote><p>自己定义的变量</p><blockquote><p>自定义全局变量</p><p>自定义局部变量</p><p>自定义常量</p></blockquote></blockquote><h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><p>定义在一个脚本文件中的变量，只能在脚本文件内使用。</p><h3 id="定义规则"><a href="#定义规则" class="headerlink" title="定义规则"></a>定义规则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量名称(不可以数字开头)=value</span><br></pre></td></tr></table></figure><blockquote><p>等号两侧不能有空格</p><p>bash环境中，变量的默认类型是字符串</p><p>如果有空格等特殊符号要用双引号引起来</p><p>不能用关键字作为变量名 </p></blockquote><h3 id="变量的使用-增添"><a href="#变量的使用-增添" class="headerlink" title="变量的使用(增添)"></a>变量的使用(增添)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">var_name</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;var_name&#125;拼接字符串</span></span><br></pre></td></tr></table></figure><img src="/post/563a1179/image-20231031195854712.png" class="" title="image-20231031195854712"> <p>测试</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $path</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;123$&#123;name&#125;333&quot;</span><br></pre></td></tr></table></figure><h3 id="修改变量"><a href="#修改变量" class="headerlink" title="修改变量"></a>修改变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新的复制就好了</span><br></pre></td></tr></table></figure><img src="/post/563a1179/image-20231031195940759.png" class="" title="image-20231031195940759"> <h3 id="删除变量unset"><a href="#删除变量unset" class="headerlink" title="删除变量unset"></a>删除变量unset</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unset 变量</span><br></pre></td></tr></table></figure><img src="/post/563a1179/image-20231031200049226.png" class="" title="image-20231031200049226"> <blockquote><p>这样创建的是一个<strong>局部变量</strong>。</p><p>局部变量只在当前Shell会话中有效，不会在重新启动系统后保留。</p><p>它们通常在<strong>当前终端窗口或Shell会话中使用</strong>，并在会话结束时被销毁。</p><hr><p>要在全局范围内设置变量，以便在系统重启后仍然可用，您通常需要将这些变量添加到Shell的启动文件（如<code>~/.bashrc</code>或<code>~/.bash_profile</code>）或系统范围的配置文件中</p><hr><p><code>unset</code> 命令，它用于删除环境变量或局部变量。您可以使用 <code>unset</code> 命令来删除局部变量，但不能用它来删除全局变量</p></blockquote><p><code>unset myvar</code> 将删除局部变量 <code>myvar</code>，</p><p>&#x3D;&#x3D;该变量将不再在当前Shell会话中可用&#x3D;&#x3D;。</p><p>如果要删除全局变量:</p><p>需要编辑相关的Shell配置文件并将其删除或注释掉，然后重新加载配置文件或重新启动Shell才能生效。</p><h2 id="自定义常量"><a href="#自定义常量" class="headerlink" title="自定义常量"></a>自定义常量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readonly var_name=value</span><br></pre></td></tr></table></figure><img src="/post/563a1179/image-20231031200849092.png" class="" title="image-20231031200849092"> <blockquote><p><code>readonly</code> 命令将一个变量标记为只读（常量）后，</p><p><strong>该变量将不能被修改或恢复为可写变量，</strong></p><p>除非您启动一个<strong>新的Shell会话</strong>。</p><p>&#x3D;&#x3D;只读变量在当前Shell会话中是不可更改的。&#x3D;&#x3D;</p></blockquote><ol><li><p><strong>在新的Shell子进程中修改</strong>：您可以启动一个新的子Shell进程，在子Shell中修改变量。变化不会影响父Shell。</p></li><li><p><strong>使用<code>unset</code>命令删除只读变量</strong>：您可以使用<code>unset</code>命令来删除只读变量。这将从当前Shell中删除该变量，然后您可以重新定义它为一个可写变量。请注意，这仅适用于Bash Shell。</p></li></ol><h2 id="自定义全局变量"><a href="#自定义全局变量" class="headerlink" title="自定义全局变量"></a>自定义全局变量</h2><h3 id="父子shell"><a href="#父子shell" class="headerlink" title="父子shell"></a>父子shell</h3><img src="/post/563a1179/image-20231031201550676.png" class="" title="image-20231031201550676"><p>&#x3D;&#x3D;父Shell是启动子Shell的Shell，而子Shell是由父Shell启动的新Shell会话。&#x3D;&#x3D;</p><h3 id="定义全局变量"><a href="#定义全局变量" class="headerlink" title="定义全局变量"></a>定义全局变量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export var_name=value</span><br></pre></td></tr></table></figure><p>**全局环境变量会一直存在，直到系统重启或手动取消它们的导出。</p><p>&#x3D;&#x3D;如果要永久导出变量&#x3D;&#x3D;，</p><p>通常需要将相应的 <code>export</code> 命令添加到Shell配置文件中，以便在每次登录时自动加载。</p><blockquote><p>全局变量是在Shell脚本中声明的变量，可以在整个脚本中访问，包括在不同的脚本文件中。</p><p>全局变量可以在脚本中的任何地方<strong>访问和修改。</strong></p><hr><p>全局变量的生命周期从它们被声明开始，一直持续到Shell会话结束，或者在某个地方被显式删除。这意味着全局变量在脚本文件执行期间一直存在，并且可以在多个脚本文件中共享。</p><p>&#x3D;&#x3D;<strong>全局变量的生命周期仅限于Shell会话的持续时间</strong>。&#x3D;&#x3D;</p></blockquote><h3 id="案例测试"><a href="#案例测试" class="headerlink" title="案例测试"></a>案例测试</h3><p>测试全局变量在子shell中是否可以使用</p><img src="/post/563a1179/image-20231031202148548.png" class="" title="image-20231031202148548"> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh demo1.sh</span><br></pre></td></tr></table></figure><p>无效</p><p>修改demo1.sh</p><p><code>apple=123</code>-&gt;<code>export apple=123</code></p><img src="/post/563a1179/image-20231031203122052.png" class="" title="image-20231031203122052"> <blockquote><p>在父Shell中设置一个<code>export</code>全局变量，然后在启动的任何子Shell中访问相同的变量</p><p>但是不能在子shell里面试图修改父shell的全局变量,</p><p>在子Shell中尝试修改父Shell创建的全局变量，&#x3D;&#x3D;实际上是在子Shell的环境中创建了一个新的同名局部变量，&#x3D;&#x3D;而不是修改父Shell的全局变量。</p><p>每个Shell会话都有其自己的环境和变量空间，子Shell的环境是相对独立的。</p></blockquote><h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><h3 id="shell脚本传入参数语法"><a href="#shell脚本传入参数语法" class="headerlink" title="shell脚本传入参数语法"></a>shell脚本传入参数语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash 脚本文件 参数1 参数2 》。。。。。。。。。</span><br></pre></td></tr></table></figure><h3 id="n"><a href="#n" class="headerlink" title="$n"></a><code>$n</code></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">n</span></span><br></pre></td></tr></table></figure><blockquote><p>得到第n个输入参数</p><p>$1-$9得到的是第1—-9输入参数</p><p>10以后用${10,11…….}</p><p>&#x3D;&#x3D;特殊的$0代表shell脚本的名称&#x3D;&#x3D;</p></blockquote><p>测试</p><img src="/post/563a1179/image-20231101134438932.png" class="" title="image-20231101134438932"> <img src="/post/563a1179/image-20231101134500296.png" class="" title="image-20231101134500296"> <p><strong>最好加上{}，也方便拼接字符串</strong></p><p>默认只识别$后一个数字$10相当于${1}0</p><p>​</p><h3 id=""><a href="#" class="headerlink" title="$#"></a><code>$#</code></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="comment">#</span></span></span><br></pre></td></tr></table></figure><blockquote><p>显示我们传入参数的个数</p></blockquote><p>测试<br>    <img src="/post/563a1179/image-20231101134740357.png" class="" title="image-20231101134740357"> </p><img src="/post/563a1179/image-20231101134801261.png" class="" title="image-20231101134801261"> <h3 id="和"><a href="#和" class="headerlink" title="$*和$@"></a><code>$*和$@</code></h3><p>&#x3D;&#x3D;<code>$*</code>和<code>$@</code>都表示所有<strong>命令行参数的列表</strong>。它们的区别在于<strong>对待参数中的空格和引号的方式。</strong>&#x3D;&#x3D;</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">*</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">@</span></span><br></pre></td></tr></table></figure><blockquote><p>以列表的形式组织我们的输入的参数</p><p>$*和$@都是$1 $2…………………….$n</p><p>用双引号括起来$*是”$1 $2 $3……….$n”</p><p>$@是”$1” “$2”  “$3”,…………”$n”</p></blockquote><img src="/post/563a1179/image-20231101134950315.png" class="" title="image-20231101134950315"><p>测试</p><img src="/post/563a1179/image-20231101135217376.png" class="" title="image-20231101135217376"> <img src="/post/563a1179/image-20231101135330765.png" class="" title="image-20231101135330765"> <img src="/post/563a1179/image-20231101135240437.png" class="" title="image-20231101135240437"> <p>加入循环</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for 循环变量 in 可循环对象</span><br><span class="line">do</span><br><span class="line">循环体</span><br><span class="line">done</span><br></pre></td></tr></table></figure><img src="/post/563a1179/image-20231101135756044.png" class="" title="image-20231101135756044">  <img src="/post/563a1179/image-20231101135813284.png" class="" title="image-20231101135813284"> <h4 id="加入””的区别"><a href="#加入””的区别" class="headerlink" title="加入””的区别"></a>加入””的区别</h4><img src="/post/563a1179/image-20231101135904981.png" class="" title="image-20231101135904981"> <img src="/post/563a1179/image-20231101135926490.png" class="" title="image-20231101135926490"> <blockquote><ul><li><code>$*</code>将<strong>所有的命令行参数当作一个单词</strong>（字符串）处理，参数之间由IFS分隔，会忽略参数中的引号。</li><li><code>$@</code>将<strong>每个命令行参数当作独立的单词</strong>（字符串）处理，参数之间不会被拆分，会保留参数中的引号。</li></ul></blockquote><h3 id="-1"><a href="#-1" class="headerlink" title="$?"></a><code>$?</code></h3><p>查看上一次命令的返回值。返回0代表成功</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">?</span></span><br></pre></td></tr></table></figure><p>测试</p><img src="/post/563a1179/image-20231101140536918.png" class="" title="image-20231101140536918"> <h3 id="-2"><a href="#-2" class="headerlink" title="$$"></a><code>$$</code></h3><p>得到当前shell的进程ID</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">$</span></span><br></pre></td></tr></table></figure><p>测试</p><img src="/post/563a1179/image-20231101141353020.png" class="" title="image-20231101141353020"> <h2 id="自定义系统环境变量"><a href="#自定义系统环境变量" class="headerlink" title="自定义系统环境变量"></a>自定义系统环境变量</h2><p>​编辑配置文件<br>&#x2F;etc&#x2F;profile</p><img src="/post/563a1179/image-20231101170324099.png" class="" title="image-20231101170324099"> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><img src="/post/563a1179/image-20231101170413135.png" class="" title="image-20231101170413135"> <p>加载一下新的配置文件</p><p>就实现啦一个自定义的系统变量</p><h3 id="ABC-abcdef和export-ABC-abcdef的区别"><a href="#ABC-abcdef和export-ABC-abcdef的区别" class="headerlink" title="ABC=abcdef和export ABC=abcdef的区别"></a><code>ABC=abcdef和export ABC=abcdef的区别</code></h3><blockquote><p><code>ABC=abcdef</code>这将创建一个名为<code>ABC</code>的自定义系统变量并将其值设置为<code>abcdef</code>。</p><p>&#x3D;&#x3D;这个变量只在当前shell环境中可见，对于其他的子进程或新开的shell是不可见的。&#x3D;&#x3D;</p><hr><p>新的shell会话会&#x3D;&#x3D;继承之前设置的系统环境变量&#x3D;&#x3D;。所以即使你在重启后的新shell会话中，你仍然可以使用之前设置的自定义系统变量<code>ABC</code>。</p><hr><p><code>export ABC=abcddef</code>导出系统变量之后</p><p>&#x3D;&#x3D;使得该变量在当前shell环境中可见，并且对于子进程和新开的shell也是可见的。&#x3D;&#x3D;</p></blockquote><p>新开一个shell也能访问的到。</p><img src="/post/563a1179/image-20231101171256144.png" class="" title="image-20231101171256144"> <h2 id="加载流程原理介绍"><a href="#加载流程原理介绍" class="headerlink" title="加载流程原理介绍"></a>加载流程原理介绍</h2><h3 id="交互shell和非交互shell环境的区别"><a href="#交互shell和非交互shell环境的区别" class="headerlink" title="交互shell和非交互shell环境的区别"></a>交互shell和非交互shell环境的区别</h3><blockquote><p>交互shell和非交互shell环境的区别主要体现在以下几个方面：</p><ol><li><p>输入输出：&#x3D;&#x3D;交互shell环境是指用户可以直接与shell进行交互&#x3D;&#x3D;，<strong>通过键盘输入命令并实时查看命令的输出结果</strong>。</p><p>而非交互shell环境是&#x3D;&#x3D;指命令在后台运行&#x3D;&#x3D;，&#x3D;&#x3D;没有实时的输入输出交互。&#x3D;&#x3D;</p></li><li><p>环境变量：&#x3D;&#x3D;交互shell环境通常会加载用户的环境变量，包括用户的个人配置文件、别名和函数等，以便用户可以方便地使用和管理。&#x3D;&#x3D;而非交互shell环境通常不加载这些环境变量，因为&#x3D;&#x3D;<strong>它们通常是在脚本中使用</strong>&#x3D;&#x3D;，不需要用户的交互和配置。</p></li><li><p>执行方式：交互shell环境》》》是通过终端或命令行界面<strong>直接</strong>执行命令</p><p>而非交互shell环境》》》是通过执行脚本文件或者其他程序来<strong>间接</strong>执行命令。</p></li><li><p>运行环境：交互shell环境》》》通常是在用户登录系统后启动的，用户可以通过shell界面来执行命令和操作系统。</p><p>而非交互shell环境》》在系<strong>统启动时自动执行脚本</strong>，或者由其他程序调用执行。</p></li></ol><hr><p>交互shell环境适合用户直接操作和交互，可以实时查看和调试命令的输出结果</p><p>而非交互shell环境适合在脚本或程序中执行命令，不需要用户的实时交互和输入输出。</p></blockquote><h3 id="登录Shell和非登录Shell"><a href="#登录Shell和非登录Shell" class="headerlink" title="登录Shell和非登录Shell"></a>登录Shell和非登录Shell</h3><p>登录Shell（login shell）和非登录Shell（non-login shell）是两种不同的运行环境，它们之间有以下区别：</p><ol><li><p>加载配置文件：&#x3D;&#x3D;登录Shell除了加载系统配置文件还会加载用户的个性化配置文件&#x3D;&#x3D;，例如&#x2F;etc&#x2F;profile,&#x2F;.bash_login和<del>&#x2F;.profile。</del></p><p>而&#x3D;&#x3D;非登录Shell只会加载~&#x2F;.bashrc文件。&#x3D;&#x3D;</p></li><li><p>执行顺序：登录Shell会按照特定的顺序执行配置文件。一般来说，先加载&#x2F;etc&#x2F;profile，然后根据用户的身份和登录方式加载适当的个人配置文件。而非登录Shell只会加载~&#x2F;.bashrc文件。</p></li><li><p>环境变量的可用性：&#x3D;&#x3D;登录Shell中定义的环境变量在整个登录会话中都是可用的，包括子Shell和子进程。&#x3D;&#x3D;</p><p>非登录Shell中定义的环境变量只在当前Shell会话中可用，不会传递给子Shell和子进程。</p></li></ol><p>&#x3D;&#x3D;登录Shell加载更多的配置文件，可以设置全局的环境变量&#x3D;&#x3D;，而非登录Shell只加载少量的配置文件，主要用于用户自定义的个人设置。</p><blockquote><p>可以运行Shell脚本</p><p>使用Shell内置命令</p><p>导入环境变量</p><p>执行命令：可以在非登录Shell中执行各种Shell命令，如<code>ls</code>、<code>cd</code>、<code>mkdir</code>等。这些命令将在当前Shell环境中执行，并且不会影响到父Shell或其他子Shell。</p></blockquote><p>&#x3D;&#x3D;在某些系统中，非登录Shell也可以读取系统配置文件。&#x3D;&#x3D;</p><p>登录环境和非登录环境的区别在于是否读取用户级别的登录环境变量文件。登录环境会读取这些文件，而非登录环境不会。</p><img src="/post/563a1179/image-20231101172959353.png" class="" title="image-20231101172959353"> <h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>&#x2F;etc&#x2F;profile</p><p><code>export V1=123</code></p><p>~&#x2F;.bashrc</p><p><code>export V2=345</code></p><p>demo.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $V1</span><br><span class="line">echo $V2</span><br></pre></td></tr></table></figure><img src="/post/563a1179/image-20231101214910099.png" class="" title="image-20231101214910099"> <blockquote><p>当执行<code>sh -l demo.sh</code>时，在登录状态下执行脚本。</p><p>在登录状态下，shell会加载.bashrc和&#x2F;etc&#x2F;profile文件。两个环境变量V1和V2都会在脚本中可用，所以你会看到输出123和345。</p><p>在非登录状态下，shell只会加载~&#x2F;.bashrc文件，而不会加载系统的…..&#x2F;etc&#x2F;profile文件。</p></blockquote><img src="/post/563a1179/image-20231101175235682.png" class="" title="image-20231101175235682"><h3 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h3><img src="/post/563a1179/image-20231101174550704.png" class="" title="image-20231101174550704"> <p>直接删掉<code>VAR!=VAR1</code>是不可以的</p><img src="/post/563a1179/image-20231101175105835.png" class="" title="image-20231101175105835"> 简单的删除还能使用这个变量<img src="/post/563a1179/image-20231101175132566.png" class="" title="image-20231101175132566"> <p><code>unset 变量</code></p><p>+重新加载我们的配置文件</p><p>才能真正删掉这个变量</p><h3 id="判断当前是登录shell还是非登录shell"><a href="#判断当前是登录shell还是非登录shell" class="headerlink" title="判断当前是登录shell还是非登录shell"></a>判断当前是登录shell还是非登录shell</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $0</span><br></pre></td></tr></table></figure><p>如果是-bash是登录shell环境</p><p>bash就是非登录shell</p><p>但是</p><blockquote><p>在脚本文件里使用就是脚本文件的名字。</p></blockquote><h3 id="切换shell环境命令"><a href="#切换shell环境命令" class="headerlink" title="切换shell环境命令"></a>切换shell环境命令</h3><img src="/post/563a1179/image-20231102134237376.png" class="" title="image-20231102134237376"> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su - 用户</span><br><span class="line">默认是非登录shell</span><br><span class="line">sudo su - 用户 -l</span><br><span class="line">登录shell</span><br></pre></td></tr></table></figure><p>但是<code>-</code></p><blockquote><p><strong>切换后的shell会加载目标用户的配置文件（如<code>.bashrc</code>或<code>.profile</code>），并使用目标用户的环境变量。</strong></p></blockquote><img src="/post/563a1179/image-20231102134641372.png" class="" title="image-20231102134641372"> <p><code>sudo su - 用户</code>命令可以确保切换到目标用户的登录shell，并使用目标用户的环境配置。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line">。。。。</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -l 脚本文件</span><br><span class="line">sh -l 脚本文件</span><br><span class="line">使用bash/sh -l命令来执行脚本文件相当于在一个新的bash登录shell中执行脚本，然后在脚本执行完毕后退出登录shell</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">temp=123</span><br></pre></td></tr></table></figure><h3 id="字符串的表达方式3种"><a href="#字符串的表达方式3种" class="headerlink" title="字符串的表达方式3种"></a>字符串的表达方式3种</h3><ol><li><p>用<code>&#39;&#39;</code>包起来的</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#x27;abc&#x27;</span><br><span class="line">var1=&#x27;hello world&#x27;</span><br></pre></td></tr></table></figure><img src="/post/563a1179/image-20231102140159807.png" class="" title="image-20231102140159807"> <p>&#x3D;&#x3D;不会解析${}，什么都原样输出&#x3D;&#x3D;</p><img src="/post/563a1179/image-20231102140249725.png" class="" title="image-20231102140249725"> <p>甚至连转义符号都不管用</p></li><li><p>用<code>&quot;&quot;</code>包起来的</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;ewdasdas&quot;</span><br><span class="line">var2=&quot;hello world&quot; </span><br></pre></td></tr></table></figure><img src="/post/563a1179/image-20231102140451381.png" class="" title="image-20231102140451381"> <p>&#x3D;&#x3D;会解析变量，转义字符。。。。&#x3D;&#x3D;</p></li><li><p>裸的字符串</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var3=dasdad234</span><br></pre></td></tr></table></figure><img src="/post/563a1179/image-20231102140918459.png" class="" title="image-20231102140918459"> <p>&#x3D;&#x3D;也会像””一样会解析变量&#x3D;&#x3D;但是不能遇到空格，遇到空格就断了&#x2F;&#x2F;&#x2F;&#x2F;</p><p>空格后面的当作参数。&#x2F;命令；了。。。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var3=hello world</span><br></pre></td></tr></table></figure><img src="/post/563a1179/image-20231102141051088.png" class="" title="image-20231102141051088"></li></ol><blockquote><p>使用””是最好的。。。</p></blockquote><h3 id="得到字符串的长度"><a href="#得到字符串的长度" class="headerlink" title="得到字符串的长度"></a>得到字符串的长度</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $&#123;#字符串的变量名&#125;</span><br></pre></td></tr></table></figure><img src="/post/563a1179/image-20231102141414595.png" class="" title="image-20231102141414595"> <h3 id="字符串的拼接3种"><a href="#字符串的拼接3种" class="headerlink" title="字符串的拼接3种"></a>字符串的拼接3种</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var1=&#x27;abc&#x27;</span><br><span class="line">var2=&quot;hello world&quot;</span><br></pre></td></tr></table></figure><ol><li><p>无符号拼接</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var3=$&#123;var1&#125;$&#123;var2&#125;</span><br></pre></td></tr></table></figure><img src="/post/563a1179/image-20231102141953159.png" class="" title="image-20231102141953159"> <p>&#x3D;&#x3D;但是注意中间不能有空格&#x3D;&#x3D;，可以有符号</p><p>因为无符号的字符串就是不可以有空格</p></li><li><p><code>&quot;&quot;</code>拼接</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var3=&quot;$&#123;var1&#125;   $ &#123;var2&#125;&quot;</span><br></pre></td></tr></table></figure><p>很好拼接，很推荐使用。</p></li><li><p>混合拼接</p><img src="/post/563a1179/image-20231102142217715.png" class="" title="image-20231102142217715"> <p>字符串加字符串。。</p></li></ol><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><img src="/post/563a1179/image-20231102142318436.png" class="" title="image-20231102142318436"><blockquote><p>常用的有</p><p><code>$&#123;变量名:start:length&#125;</code></p><p><code>$&#123;变量名:start&#125;</code></p><p><code>$&#123;变量名#*char&#125;</code></p><p><code>$&#123;变量名##*char&#125;</code></p><p><code>$&#123;变量名%char*&#125;</code></p><p><code>$&#123;变量名%%char*&#125;</code></p></blockquote><img src="/post/563a1179/image-20231102143101396.png" class="" title="image-20231102143101396"> <img src="/post/563a1179/image-20231102143850834.png" class="" title="image-20231102143850834"> 0-5取不到5<h2 id="shell数组"><a href="#shell数组" class="headerlink" title="shell数组"></a>shell数组</h2><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><p>之间用的是<code>    </code>来间隔的，不是<code>,</code></p><blockquote><p>第一种方式创建的数组是一个连续的索引数组，下标从0开始递增。</p><p>第二种方式创建的数组是一个关联数组或者称为哈希数组。&#x3D;&#x3D;数组arry1的<strong>下标不再是连续的</strong>，而是显式指定了某些元素的下标。&#x3D;&#x3D;</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arry=(1 2 3 4 5 6)</span><br><span class="line">arry1=([0]=1 [1]=2 [9]=3)</span><br></pre></td></tr></table></figure><img src="/post/563a1179/image-20231102144848081.png" class="" title="image-20231102144848081"> <h3 id="数组的语法"><a href="#数组的语法" class="headerlink" title="数组的语法"></a>数组的语法</h3><img src="/post/563a1179/image-20231102144903248.png" class="" title="image-20231102144903248"> <p>测试</p><img src="/post/563a1179/image-20231102145127651.png" class="" title="image-20231102145127651"> <blockquote><p>第一种方式创建的数组是一个连续的索引数组，下标从0开始递增；</p><p>而第二种方式创建的数组是一个关联数组，可以显式指定元素的下标，下标不一定连续。</p></blockquote><h3 id="数组的拼接"><a href="#数组的拼接" class="headerlink" title="数组的拼接"></a>数组的拼接</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">newarrt=($&#123;arry1[*]&#125; $&#123;arry2[*]&#125;)</span><br></pre></td></tr></table></figure><img src="/post/563a1179/image-20231102145748408.png" class="" title="image-20231102145748408"> <h3 id="数组的删除"><a href="#数组的删除" class="headerlink" title="数组的删除"></a>数组的删除</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unset 数组名[index]</span><br><span class="line">unset 数组名</span><br></pre></td></tr></table></figure><img src="/post/563a1179/image-20231102145939178.png" class="" title="image-20231102145939178"> ]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门</title>
      <link href="/post/8e7db504.html"/>
      <url>/post/8e7db504.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote><p>&#x3D;&#x3D;Git&#x3D;&#x3D;</p><p>git介绍</p><p>git安装</p><p>git命令</p><p>git分支</p><p>idea 继承git</p><hr><p>&#x3D;&#x3D;Github&#x3D;&#x3D;</p><p>创建远程库</p><p>代码推送 push</p><p>代码拉取 pull</p><p>代码克隆 clone</p><p>SSH免密登录</p><p>idea继承github</p><hr><p>&#x3D;&#x3D;Gitee码云&#x3D;&#x3D;</p><p>码云创建远程库</p><p>idea继承gitee码云</p><p>码云连接github进行代码的复制和迁徙</p><hr><p>&#x3D;&#x3D;Gitlab&#x3D;&#x3D;</p><p>GitLab服务器的搭建和部署</p><p>Idea继承GitLab</p></blockquote><h2 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h2><p><a href="https://git-scm.com/">git-scm.com</a></p><p>Git是一个&#x3D;&#x3D;<strong>分布式版本控制系统</strong>&#x3D;&#x3D;，用于跟踪文件和代码的修改。</p><p>它最初由Linus Torvalds创建，用于管理Linux内核的开发。</p><p>Git的设计目标是速度、数据完整性和支持分布式、非线性工作流程。</p><p>Git与其他&#x3D;&#x3D;<strong><a href="#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6">版本控制系统</a></strong>&#x3D;&#x3D;（如SVN）的主要区别在于它是&#x3D;&#x3D;<strong>分布式</strong>&#x3D;&#x3D;的。</p><p>这意味着&#x3D;&#x3D;<strong>每个开发者都可以在本地完整地拥有代码库的副本</strong>&#x3D;&#x3D;</p><p><strong><em>并可以在没有网络连接的情况下进行工作</em>。</strong></p><p>分布式架构使得Git在协作开发和并行开发方面更加灵活，有助于<strong>避免单点故障</strong>和提高开发效率。</p><p>使用Git，可以：</p><ol><li>创建代码仓库（repository）：Git将您的项目存储为一个代码仓库，可以<strong>跟踪文件和目录的变化</strong>。</li><li>记录版本历史：<strong>Git会记录每次提交（commit），包括更改的内容、作者、时间等信息，形成一个完整的版本历史</strong>。history</li><li>分支和合并：<strong>Git允许您创建不同的分支，以便并行开发不同的功能或解决不同的问题，并能够合并分支的更改。</strong></li><li>远程仓库协作：Git支持与远程仓库进行协作，方便团队成员之间的<strong>代码共享</strong>和<strong>合作开发</strong>。</li></ol><blockquote><p>通过学习Git，您可以更好地跟踪和管理代码的变化，协作开发，避免代码冲突，并且在需要时轻松回滚到之前的版本。无论是个人开发者还是团队成员，掌握Git都是很有价值的技能。</p></blockquote><p><em>git可以随意使用Linux命令</em></p><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a><a name="版本控制">版本控制</a></h3><p>&#x3D;&#x3D;<strong>个人开发过度到团队协作</strong>&#x3D;&#x3D;<img src="/post/8e7db504/image-20231021150047145.png" class="" title="image-20231021150047145"></p><ol><li><p>集中式版本控制工具</p><blockquote><p>集中式版本控制工具（Centralized Version Control System，简称CVCS）是一种软件工具，用于&#x3D;&#x3D;<strong>管理和控制文件的版本</strong>&#x3D;&#x3D;。它具有以下特点：</p><ol><li>中央服务器：CVCS使用一个中央服务器作为代码仓库，所有开发者从该服务器拉取代码，并将代码提交到服务器上。服务器存储所有文件的历史版本和变更记录。</li><li>协作开发：开发者可以从中央服务器上获取最新版本的代码，并在自己的工作副本上进行修改。他们可以将修改后的代码提交到服务器，**以便其他人可以获取并&#x3D;&#x3D;继续开发&#x3D;&#x3D;**。</li><li>文件锁定：CVCS通常支持文件级别的锁定机制，<strong>即当一个开发者正在编辑某个文件时，其他开发者无法同时编辑该文件</strong>，以避免冲突和覆盖修改。</li><li>必须联网：CVCS需要开发者与中央服务器进行通信，因此必须处于联网状态才能正常使用。</li></ol><p>一些常见的集中式版本控制工具包括SVN（Subversion）和Perforce。</p><blockquote><p>如果服务器单点故障，如果服务器宕机一个小时，那么一个小时内谁都不能个更新，无法协同工作。</p></blockquote><p>尽管集中式版本控制工具在过去被广泛使用，但随着分布式版本控制系统（如Git）的兴起，越来越多的开发者转向了分布式方式，因为分布式版本控制系统具有更强大的分支和合并功能，并且更适用于协作开发和灵活的工作流程。</p></blockquote></li><li><p>分布式版本控制系统</p><blockquote><p>分布式版本控制工具（Distributed Version Control System，简称DVCS）是一种软件工具，用于管理和控制文件的版本。相比于集中式版本控制工具（如SVN），它具有以下特点：</p><ol><li><p>分布式架构：&#x3D;&#x3D;每个开发者都可以在本地拥有完整的代码仓库，并能够处理版本控制操作。&#x3D;&#x3D;</p></li><li><p>没有文件锁定：因为<strong>每个开发者都拥有完整的代码仓库，所以他们可以同时进行修改而无需锁定文件。</strong>系统可以自动合并代码变更。</p></li><li><p>离线工作：由于每个开发者都有本地版本库，因此他们可以脱机工作，对代码进行修改，然后在联网时将变更推送到其他人。</p></li><li><p>易于分支和合并：DVCS具有强大的分支和合并功能，使得开发者可以创建和管理多个分支，以便开发新特性、修复问题或测试代码，而且合并变得更加容易和安全。</p></li></ol><p>一些常见的DVCS版本控制工具包括Git、Mercurial和Bazaar。</p><p>总体而言，DVCS比CVCS更适合于大型项目和分布式团队开发，因为它具有<strong>更强大的分支和合并能力</strong>，以及更好的<strong>离线工作方式和版本库备份机制。</strong></p></blockquote></li><li><p>&#x3D;&#x3D;二者区别&#x3D;&#x3D;</p><blockquote><p>集中式版本控制系统（Centralized Version Control System，CVCS）和分布式版本控制系统（Distributed Version Control System，DVCS）区别:</p><ol><li><p>架构：CVCS采用集中式架构，&#x3D;&#x3D;所有的代码库和版本历史都保存在中央服务器上&#x3D;&#x3D;，开发者通过连接到服务器进行操作。而DVCS采用&#x3D;&#x3D;<strong>分布式架构，每个开发者都有一个完整的本地代码库</strong>&#x3D;&#x3D;，包含完整的版本历史和所有文件。</p></li><li><p>依赖性：&#x3D;&#x3D;CVCS对中央服务器有较大的依赖性，开发者需要实时连接服务器才能进行版本控制操作。&#x3D;&#x3D;而DVCS不依赖于中央服务器，开发者可以在本地进行版本控制操作，只在需要与他人协作或推送变更时才连接服务器。</p></li><li><p>并发性：&#x3D;&#x3D;CVCS在处理并发修改时存在文件锁定的机制&#x3D;&#x3D;，即同一时间只能有一个开发者对某文件进行修改。而DVCS没有文件锁定，&#x3D;&#x3D;开发者可以同时对同一个文件进行修改，并通过合并操作将修改结果合并到共享的代码库中。&#x3D;&#x3D;</p></li><li><p>分支和合并：CVCS的分支和合并功能相对较弱，需要通过服务器的支持进行操作，并且合并过程可能较为复杂。而DVCS具有强大的分支和合并功能，开发者可以随时创建和管理本地分支，并轻松进行分支合并操作。</p></li><li><p>灵活性和离线工作：<code>CVCS在没有网络连接时无法进行版本控制操作，</code><strong>依赖于中央服务器</strong>。而DVCS由于每个开发者都有完整的代码库，可以在离线状态下进行版本控制操作，只需要在联网时将变更推送到其他人。</p></li></ol><p>总体而言，DVCS相比CVCS更加灵活、强大和适应分布式团队开发，而CVCS适用于中小团队或者需要严格控制权限和集中管理的项目。选择使用哪种版本控制系统取决于项目的规模、团队协作方式和开发流程的需求。</p></blockquote></li></ol><h3 id="Git发展历史"><a href="#Git发展历史" class="headerlink" title="Git发展历史"></a>Git发展历史</h3><p>Git是由Linux之父Linus Torvalds在2005年创立的分布式版本控制系统。Git的历史可以追溯到2002年，当时开源版本控制系统BitKeeper公司禁止Linux社区继续使用免费的BitKeeper工具。此时，Linus Torvalds开始着手开发自己的版本控制系统。</p><p>以下是Git的主要发展历程：</p><ol><li><p>2005年：Git项目正式启动，&#x3D;&#x3D;<strong>Linus Torvalds</strong>&#x3D;&#x3D;发布了Git的第一版，并开始为Linux内核的管理和维护使用Git。</p></li><li><p>2008年：GitHub网站上线，Git得到了广泛的应用和推广。GitHub提供了一个基于Git的代码托管平台，允许开发者协作开发和分享代码。</p></li><li><p>2010年：Git成为了Apache软件基金会的顶级项目之一，进一步推动了Git的普及和应用。</p></li><li><p>2012年：GitHub的用户数量超过一百万，Git在开源社区和商业领域都变得越来越流行。</p></li><li><p>2016年：Git 2.0发布，引入了一些新功能和改进，并且进一步提高了Git的性能和稳定性。</p></li><li><p>2018年：微软宣布收购GitHub，这标志着Git作为全球最大的代码托管平台进入了一个新的发展阶段。</p></li></ol><h3 id="Git工作机制"><a href="#Git工作机制" class="headerlink" title="Git工作机制"></a>Git工作机制</h3><img src="/post/8e7db504/image-20231021232411424.png" class="" title="image-20231021232411424"> <p>工作区: 我们代码在本地磁盘的位置</p><p>暂存区：git<strong>追踪到我们工作区</strong>，也就是把工作区添加到暂存区git add,<strong>这个时候还没有历史版本</strong></p><p><strong><a href="#%E6%9C%AC%E5%9C%B0%E5%BA%93">本地库</a>: git commit到本地库之后，就有了历史版本啦！</strong></p><p>&#x3D;&#x3D;工作区和暂存区都是自己可以想删就删的&#x3D;&#x3D;</p><blockquote><ol><li>本地仓库：每个开发者都有一个本地仓库，用于保存项目的完整历史记录和文件版本。本地仓库包含了项目的所有文件、文件夹以及与项目相关的元数据，如提交历史、分支信息等。</li><li>提交：在 Git 中，你可以通过将文件的修改内容提交（commit）到本地仓库来记录项目的变更。提交是一个原子操作，它会生成一个唯一的标识符（SHA-1 值）来标记这个提交对象，并记录作者、时间戳、提交消息等相关信息。</li><li>分支：Git 使用分支（branch）来管理不同的代码版本。默认情况下，每个 Git 仓库都有一个主分支（通常命名为 “master”），其他分支则可以基于主分支衍生出来。通过创建和切换分支，你可以在不破坏主分支的前提下进行实验性的开发或并行开发。</li><li>远程仓库：除了本地仓库，Git 还支持远程仓库，用于团队协作和代码共享。远程仓库通常位于网络上的服务器上，开发者可以与其进行交互，例如推送（push）自己的本地提交到远程仓库，或者从远程仓库拉取（pull）最新的更新到本地。</li><li>分布式：Git 的分布式特性使得每个开发者都可以具备完整的项目历史记录和文件版本，不依赖于中央服务器。这意味着即使没有网络连接，你仍然可以对代码进行提交、切换分支等操作。当网络恢复后，你可以将本地仓库与远程仓库同步。</li><li>版本合并和冲突解决：当多个开发者在不同的分支上进行开发，并且试图将它们的修改合并到一起时，可能会出现冲突。Git 提供了强大的合并和冲突解决机制，可以帮助开发者协调共享的代码变更。</li></ol></blockquote><p>本地仓库<a name="本地库"></a></p><p>在 Git 中，<strong>本地仓库是指存储在您的计算机上的代码仓库</strong>。它不是虚拟的，而是实际存在于您的文件系统中的目录。</p><p>当您克隆（或初始化）一个 Git 仓库时，Git 将在您的计算机上创建一个&#x3D;&#x3D;<strong>包含项目所有历史记录和代码的目录</strong>&#x3D;&#x3D;。<strong>这个目录就是本地仓库</strong>。</p><p><strong>它包含了存储在 <code>.git</code> 子目录下的各种文件和子目录，这些文件和子目录记录了项目的元数据、分支、提交历史等信息。</strong></p><p>&#x3D;&#x3D;<strong>本地仓库是与远程仓库（例如 GitHub、GitLab）同步的基础。</strong>&#x3D;&#x3D;</p><p>本地仓库中进行代码修改、创建新分支、提交更改等操作，然后将这些更改推送到远程仓库或从远程仓库拉取最新的更改。</p><p><code>及时的进行git add和commit</code>提交到本地库</p><h3 id="Git和代码托管中心"><a href="#Git和代码托管中心" class="headerlink" title="&#x3D;&#x3D;Git和代码托管中心&#x3D;&#x3D;"></a>&#x3D;&#x3D;Git和代码托管中心&#x3D;&#x3D;</h3><p><a href="#%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C">团队协作</a></p><p>代码托管中心是基于网络服务器的远程代码仓库&#x3D;&#x3D;远程库&#x3D;&#x3D;</p><p>在本地库之后可以推送到远程库push</p><hr><blockquote><p>局域网：GitLab</p><p>互联网:Github，Gitee码云</p></blockquote><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p><a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/">淘宝镜像Git</a></p><p><a href="https://blog.csdn.net/qq_38952352/article/details/127656385?ops_request_misc=&request_id=&biz_id=102&utm_term=git%E7%9A%84%E5%AE%89%E8%A3%85&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-127656385.nonecase&spm=1018.2226.3001.4187">git安装教程</a></p><img src="/post/8e7db504/image-20231021233410692.png" class="" title="image-20231021233410692"> <p>&#x3D;&#x3D;<strong>非中文的，没有空格的！路径</strong>&#x3D;&#x3D;</p><img src="/post/8e7db504/image-20231021233500875.png" class="" title="image-20231021233500875"> <img src="/post/8e7db504/image-20231021233700181.png" class="" title="image-20231021233700181"> <p>默认好了</p><img src="/post/8e7db504/image-20231021233753226.png" class="" title="image-20231021233753226"> 再次确认是否在Git下<img src="/post/8e7db504/image-20231021233817468.png" class="" title="image-20231021233817468"> 选择默认的编辑器VIM好了<img src="/post/8e7db504/image-20231021233836700.png" class="" title="image-20231021233836700"> 是否要修改初始化分支的名<img src="/post/8e7db504/image-20231021234006030.png" class="" title="image-20231021234006030"> <p>第二个是在cmd里面也可以用git，</p><img src="/post/8e7db504/image-20231021234151676.png" class="" title="image-20231021234151676"> 默认的协议<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><img src="/post/8e7db504/image-20231021234458443.png" class="" title="image-20231021234458443"> <p>检查是否安装成功，和版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">where git</span><br></pre></td></tr></table></figure><p>就能看到我们git安装的位置了</p><img src="/post/8e7db504/image-20231022193442970.png" class="" title="image-20231022193442970"> <h2 id="Git的常用命令"><a href="#Git的常用命令" class="headerlink" title="Git的常用命令"></a>Git的常用命令</h2><p><strong>最好用github的邮箱，git不会检查你的邮箱格式是否正确</strong></p><p>&#x3D;&#x3D;<strong>签名的作用就是区分不同操作者身份</strong>&#x3D;&#x3D;</p><p><strong>去windows的用户下面找到.gitconfig</strong>就能看到我们的信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">name = xurunbo</span><br><span class="line">email = 1982830095@qq.com</span><br><span class="line">[credential &quot;https://gitee.com&quot;]</span><br><span class="line">provider = generic</span><br><span class="line">[http]</span><br><span class="line">sslverify = false</span><br><span class="line">[gui]</span><br><span class="line">recentrepo = D:/gitBOx/j3dr</span><br><span class="line">[credential]</span><br><span class="line">helper = cache</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="设置用户签名-git-cfg"><a href="#设置用户签名-git-cfg" class="headerlink" title="设置用户签名 git cfg"></a>设置用户签名 git cfg</h3><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git config –global user.name 用户名</td><td>设置用户签名</td></tr><tr><td>git config –global user.email 用户邮箱</td><td>设置用户签名</td></tr><tr><td><strong>git init</strong></td><td>初始化本地库</td></tr><tr><td><strong>git status</strong></td><td>查看本地库状态</td></tr><tr><td><strong>git add 文件名</strong></td><td>添加到暂存区</td></tr><tr><td><strong>git commit -m “日志信息” 文件名</strong></td><td>提交到本地库</td></tr><tr><td><strong>git reflog</strong></td><td>查看历史记录</td></tr><tr><td><strong>git reset –hard 版本号</strong></td><td>版本穿梭</td></tr></tbody></table><p>想在哪里使用git</p><blockquote><ol><li>cd到相关路径</li><li>在目标路径下右键git</li></ol></blockquote><h3 id="git-init初始化本地库"><a href="#git-init初始化本地库" class="headerlink" title="git init初始化本地库"></a>git init初始化本地库</h3><img src="/post/8e7db504/image-20231021235734901.png" class="" title="image-20231021235734901"> <p>git init就可以初始化本地库了</p><p>默认是隐藏的</p><p>Linux语法 -a看到隐藏的文件</p><img src="/post/8e7db504/image-20231021235820736.png" class="" title="image-20231021235820736"> <h3 id="git-status-查看本地库的状态"><a href="#git-status-查看本地库的状态" class="headerlink" title="git status 查看本地库的状态"></a>git status 查看本地库的状态</h3><img src="/post/8e7db504/image-20231021235919516.png" class="" title="image-20231021235919516"> <p>on branch master默认在主分支上</p><p>no commits yet没有任何提交过</p><p>nothiing to commit 也没有什么东西需要提交</p><p>现在我们修改一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim hello.txt</span><br></pre></td></tr></table></figure><p>输入一些内容</p><p>再次查看本地库的状态</p><img src="/post/8e7db504/image-20231022000218413.png" class="" title="image-20231022000218413"> <p>说明发现了未被追踪的文件，没有追踪，只是在工作区</p><p>没有添加任何东西，但是已经有一个未被追踪的文件</p><hr><h3 id="git-add-文件添加到暂存区"><a href="#git-add-文件添加到暂存区" class="headerlink" title="git add 文件添加到暂存区"></a>git add 文件添加到暂存区</h3><p>换行？windows是crlf，Linux是lf</p><img src="/post/8e7db504/image-20231022093307605.png" class="" title="image-20231022093307605"> <p>说明git知道你的hello.txt,git已经追踪这个文件了。也可以删除</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rem --cached 文件</span><br></pre></td></tr></table></figure><p>把暂存区的给删除了</p><h3 id="git-commit-m-“日志信息”-文件"><a href="#git-commit-m-“日志信息”-文件" class="headerlink" title="git commit -m “日志信息” 文件"></a>git commit -m “日志信息” 文件</h3><img src="/post/8e7db504/image-20231022093702717.png" class="" title="image-20231022093702717"> <p>965c6a1就是版本号</p><img src="/post/8e7db504/image-20231022093756704.png" class="" title="image-20231022093756704"> <p>跳过了，工作树是干净的</p><h3 id="查看日志git-reflog-log"><a href="#查看日志git-reflog-log" class="headerlink" title="&#x3D;&#x3D;查看日志git reflog&#x2F;log&#x3D;&#x3D;"></a>&#x3D;&#x3D;查看日志git reflog&#x2F;log&#x3D;&#x3D;</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><blockquote><p><code>git reflog</code> 命令可以列出所有本地仓库中的 Git 引用的修改历史，&#x3D;&#x3D;<strong>包括分支、标签和 HEAD 引用。它显示的是每个引用上的操作历史，</strong>&#x3D;&#x3D;哪些提交对该引用进行了修改以及何时进行了修改。这些操作包括新建、删除、重命名或移动引用等。</p></blockquote><p>领导的身份查看，能看不同分支的提交</p><img src="/post/8e7db504/image-20231022094239014.png" class="" title="image-20231022094239014"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>更详细，能看到谁提交的以及日期</p><p>&#x3D;&#x3D;看的是当前分支当前HEAD指向的版本以前的提交记录&#x3D;&#x3D;</p><p>假如说我的master提交了两次</p><p>我现在新建了一个分支a</p><p>我在分支a上相当于复制了master的两次提交，是独立的.</p><p>但是当我reset 让head指向master带来的第一次提交时候</p><p>git log就只能看到第一次提交了</p><p>我reset让head指向master带来的第二次提交时候</p><p>git log就看到第一和第二次提交了</p><p>同理，我让head指向我现在所在分支的new 提交的时候就能看所有的提交了，包括从master带来的</p><p>总之让HEAD指向你所在分支的最新一次提交，就能看到所有的log记录了</p><p>&#x3D;&#x3D;<strong>通过 <code>git reset</code> 命令移动 HEAD 指针可以让您查看不同的提交记录。当您让 HEAD 指向某个分支或提交时，Git 会重新计算从该提交版本开始的提交历史，并将其作为新的基准点。这样，之前隐藏的提交记录就会被包含在 Git 日志中。</strong>&#x3D;&#x3D;</p><blockquote><p><code>git log</code> 命令用于查看&#x3D;&#x3D;<strong>指定分支的提交历史（或者默认情况下查看当前分支的历史）</strong>&#x3D;&#x3D;，它会按照时间倒序列出所有的提交记录，并显示每个提交的 SHA-1 校验和、作者、提交时间、提交注释等信息。您还可以使用 <code>git log</code> 命令的一些选项来限制要查看的提交数量、显示特定的文件变更等。</p></blockquote><h3 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h3><img src="/post/8e7db504/image-20231022094410088.png" class="" title="image-20231022094410088"><p>说明我们现在工作区的文件还&#x3D;&#x3D;<strong>没有被git追踪没有添加到暂存区</strong>&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add hello.txt</span><br><span class="line">git status</span><br></pre></td></tr></table></figure><img src="/post/8e7db504/image-20231022094519847.png" class="" title="image-20231022094519847"> <p>被添加到暂存区了，然后开始提交到远程库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;第二次提交&quot; hello.txt</span><br></pre></td></tr></table></figure><img src="/post/8e7db504/image-20231022100935420.png" class="" title="image-20231022100935420"> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><img src="/post/8e7db504/image-20231022095011497.png" class="" title="image-20231022095011497"><p>说明当前指针指向的是第三个版本</p><p>直接cat 看的就是第三个版本的内容</p><blockquote><p>工作区文件被修改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>就会冒红</p><p>把被修改的文件添加到暂存区就变绿了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add 文件</span><br></pre></td></tr></table></figure><p>，就可以提交到远程库了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m&quot;第n次提交&quot; 文件</span><br></pre></td></tr></table></figure><p>提交历史中每个提交都有一个唯一的标识符，这个标识符通常称为 “提交哈希值” 或 “提交ID”。它是一个由40个十六进制字符组成的字符串，用于唯一标识一个提交。</p><p>提交哈希值</p><p>060b457964e4daa7b8c4445445521b473d802f6f</p><p>前7位 <code>060b457</code> 是这个提交的简短版本号,用来快速识别提交</p></blockquote><h3 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>能看到有多少个版本号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p><strong>更详细的日志，能看到谁提交的.以及提交日期</strong></p><img src="/post/8e7db504/image-20231022100912826.png" class="" title="image-20231022100912826"> <h3 id="版本穿梭-git-reset-–hard-版本号"><a href="#版本穿梭-git-reset-–hard-版本号" class="headerlink" title="版本穿梭 git reset –hard 版本号"></a>版本穿梭 git reset –hard 版本号</h3><ol><li><p>先查看版本号信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>直接就看到七位的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;当前分支下&#x3D;&#x3D;拿到版本号<em>前七位</em></p></li><li><pre><code>git reset --hard 要穿梭的版本号<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   指针就实现了要穿梭的版本</span><br><span class="line"></span><br><span class="line">   &#123;% asset_img image-20231022101122174.png image-20231022101122174 %&#125; </span><br><span class="line"></span><br><span class="line">   &#123;% asset_img image-20231022101146000.png image-20231022101146000 %&#125; </span><br><span class="line"></span><br><span class="line">   ==**第一行是说明我们的命令要穿梭到4638f14这个版本**==</span><br><span class="line"></span><br><span class="line">3. 此时cat就可以看到历史的版本内容了</span><br><span class="line"></span><br><span class="line">文件的变化</span><br><span class="line"></span><br><span class="line">&gt; &#123;% asset_img image-20231022100200296.png image-20231022100200296 %&#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; 当前是在master这个分支下</span><br><span class="line">&gt;</span><br><span class="line">&gt; 哪个版本呢？</span><br><span class="line">&gt;</span><br><span class="line">&gt; &#123;% asset_img image-20231022100553199.png image-20231022100553199 %&#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; git切换版本，==**底层是移动的HEAD指针**==：</span><br><span class="line">&gt;</span><br><span class="line">&gt; &#123;% asset_img image-20231022101249678.png image-20231022101249678 %&#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br><span class="line">&gt; 在 Git 中，`git checkout` 命令可以通过两种方式指定要切换的提交：</span><br><span class="line">&gt;</span><br><span class="line">&gt; *一种是使用简短版本号，另一种是使用完整的提交哈希值。*</span><br><span class="line">&gt;</span><br><span class="line">&gt; 当您使用简短版本号（通常是提交哈希值的前几位字符）作为参数执行 `git checkout` 命令时，Git 会尝试根据提供的简短版本号匹配到唯一的提交。如果找到了唯一的匹配项，Git 就会将 HEAD 指向该提交，并切换到该提交。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 例如，如果有一个提交哈希值为 `060b457964e4daa7b8c4445445521b473d802f6f`，那么您可以使用 `git checkout 060b457` 或 `git checkout 060b4579` 来切换到该提交。</span><br><span class="line">&gt;</span><br><span class="line">&gt; **使用完整的提交哈希值作为参数执行 `git checkout` 命令则更加明确和精确。无论提交哈希值有多长（通常是40个字符），Git 都可以直接定位到对应的提交，并进行切换。**</span><br><span class="line">&gt;</span><br><span class="line">&gt; 使用简短版本号或完整的提交哈希值都可以用于 `git checkout` 命令来切换到特定的提交。简短版本号是提交哈希值的一部分，用于快速识别提交，而完整的提交哈希值则是唯一且精确地标识一个提交。</span><br><span class="line">&gt;</span><br><span class="line">&gt; ---</span><br><span class="line">&gt;</span><br><span class="line">&gt; `git checkout` 命令提供一个具体的提交哈希值时，Git 会将 HEAD 指向该提交，并处于 &quot;detached HEAD&quot; 状态。这意味着**不在位于任何分支上**，而是直接位于特定的提交上。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 为了防止在 &quot;detached HEAD&quot; 状态下进行的提交被丢失，Git 帮您自动创建了一个临时分支，以便保留您所做的更改。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 这个临时分支没有名称，通常称为 &quot;无名分支&quot; 或 &quot;匿名分支&quot;。它只存在于您当前的工作区中，不会影响到其他分支的进展。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 您可以在这个 &quot;无名分支&quot; 上进行实验性的更改和提交。如果您希望保留这些提交，可以随时将其转换为具有名称的分支，如命令输出中所示：</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>&gt; git switch -c &lt;new-branch-name&gt;&gt; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这将创建一个新的分支，并将它指向当前的 &quot;无名分支&quot;。然后，您可以在新分支上继续进行提交，并且这些提交将得到保留。</span><br><span class="line"></span><br><span class="line">如果您希望放弃当前的 &quot;无名分支&quot;，可以使用以下命令撤销操作：</span><br><span class="line"></span><br></pre></td></tr></table></figure>&gt; git switch -&gt; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这将使 HEAD 返回到之前的位置，即切换回原来分支的状态。</span><br><span class="line"></span><br><span class="line">请注意，创建临时分支的目的是为了保护您在 &quot;detached HEAD&quot; 状态下所做的更改，以防止意外丢失。在实际开发中，建议基于这个临时分支创建一个具有合适名称的新分支，并在那里继续工作，以确保提交的持久性和可追溯性。</span><br><span class="line"></span><br><span class="line">### Git快速复制和粘贴</span><br><span class="line"></span><br><span class="line">鼠标左键两下    复制</span><br><span class="line"></span><br><span class="line">鼠标中键    粘贴</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Git删除跟踪</span><br><span class="line"></span><br><span class="line">删除已经被 Git 跟踪的这些文件。您可以使用以下命令将这些文件从 Git 的跟踪中移除（注意，这不会删除实际的文件）：</span><br><span class="line"></span><br></pre></td></tr></table></figure>git rm --cached -r .ideagit rm --cached -r *.iml<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Git分支操作</span><br><span class="line"></span><br><span class="line">### 分支的介绍</span><br><span class="line"></span><br><span class="line">在版本控制过程中，同时推进多个任务，为了每个都可以独立的玩</span><br><span class="line"></span><br><span class="line">开启副本,(分支)</span><br><span class="line"></span><br><span class="line">:同时并行推进多个功能开发，提高效率</span><br><span class="line"></span><br><span class="line">### 分支的操作</span><br><span class="line"></span><br><span class="line">| 命令名称            | 作用                             |      |</span><br><span class="line">| ------------------- | -------------------------------- | ---- |</span><br><span class="line">| git branch 分支名   | 创建分支                         |      |</span><br><span class="line">| git branch -v       | 查看分支                         |      |</span><br><span class="line">| git checkout 分支名 | 切换分支                         |      |</span><br><span class="line">| git merge 分支名    | 把指定的分支**合并到当前分支上** |      |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 查看分支git branch -v</span><br><span class="line"></span><br></pre></td></tr></table></figure>git branch -v<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022102129352.png image-20231022102129352 %&#125; </span><br><span class="line"></span><br><span class="line">*代表我们当前所在的分支</span><br><span class="line"></span><br><span class="line">后面代表的是HEAD指针当前指的本本，和对应的日志信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 创建分支git branch 分支名</span><br><span class="line"></span><br></pre></td></tr></table></figure>git branch hot-fix<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022102325382.png image-20231022102325382 %&#125; </span><br><span class="line"></span><br><span class="line">&gt; 新分支会在当前所在的提交上创建。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 这意味着新分支将包含==**与当前分支相同的代码快照**==（即**相同的提交历史和文件内容**）。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 创建分支后，默认情况下，您仍然停留在当前分支，新分支并未成为当前活动分支。</span><br><span class="line">&gt;</span><br><span class="line">&gt; ==**每个分支都有自己独立的提交历史和文件状态**==</span><br><span class="line"></span><br><span class="line">### 切换分支git chekout 分支名</span><br><span class="line"></span><br></pre></td></tr></table></figure>git checkout 要切换到的分支<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022102712638.png image-20231022102712638 %&#125; </span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022102856571.png image-20231022102856571 %&#125; </span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022102920495.png image-20231022102920495 %&#125; </span><br><span class="line"></span><br><span class="line">### 合并分支git merge 分支名</span><br><span class="line"></span><br><span class="line">#### 正常合并</span><br><span class="line"></span><br></pre></td></tr></table></figure>git merge 要合并到当前分支的分支<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> &#123;% asset_img image-20231022121438260.png image-20231022121438260 %&#125; </span><br><span class="line"></span><br><span class="line">git merge后git的历史记录的基点还在原来的位置</span><br><span class="line"></span><br><span class="line">#### 冲突合并</span><br><span class="line"></span><br><span class="line">==**两个分支在同一个位置出有两套完全不同的修改**==Git无法选择的时候,需要人为的修改</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022122940097.png image-20231022122940097 %&#125; 原来的状态</span><br><span class="line"></span><br><span class="line">1. 在master下对hello.txt文件的第一行进行修改</span><br><span class="line"></span><br><span class="line">   &#123;% asset_img image-20231022123013671.png image-20231022123013671 %&#125; </span><br><span class="line"></span><br><span class="line">2. 提交到暂存区和本地库</span><br><span class="line"></span><br></pre></td></tr></table></figure>git add hello.txtgit commit -m &quot;mastertest&quot; hello.txt<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   &#123;% asset_img image-20231022123059354.png image-20231022123059354 %&#125; </span><br><span class="line"></span><br><span class="line">3. 切换到hot_fix分支</span><br><span class="line"></span><br><span class="line">4. 也对同一个文件进行编辑</span><br><span class="line"></span><br><span class="line">   &#123;% asset_img image-20231022123140100.png image-20231022123140100 %&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>vim hello.txt在第一行也修改<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. 提交到暂存区和本地库</span><br><span class="line"></span><br><span class="line">   &#123;% asset_img image-20231022123234810.png image-20231022123234810 %&#125; </span><br><span class="line"></span><br><span class="line">6. 回到master分支进行合并</span><br><span class="line"></span><br></pre></td></tr></table></figure>git merge hot_fix<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   &#123;% asset_img image-20231022123335887.png image-20231022123335887 %&#125; </span><br><span class="line"></span><br><span class="line">   Git帮我i们自动合并不了了</span><br><span class="line"></span><br><span class="line">   此时会进入master|merge状态</span><br><span class="line"></span><br><span class="line">7. 编辑冲突的文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>vim hello.txt<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   &#123;% asset_img image-20231022123436508.png image-20231022123436508 %&#125; </span><br><span class="line"></span><br><span class="line">   &lt;&lt;&lt;&lt;&lt;和=包起来的是当前分支的内容，=和&gt;&gt;&gt;&gt;&gt;&gt;抱起来的是和过来的分支的内容</span><br><span class="line"></span><br><span class="line">   手动保留并且删掉现在用于区分的行</span><br><span class="line"></span><br><span class="line">   &#123;% asset_img image-20231022123549247.png image-20231022123549247 %&#125; </span><br><span class="line"></span><br><span class="line">8. ==**然后提交暂存区和本地库**==</span><br><span class="line"></span><br></pre></td></tr></table></figure>git add hello.txt<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">★★★★★★</span><br><span class="line"></span><br></pre></td></tr></table></figure>git commit -m &quot;mergecommit&quot;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022124055271.png image-20231022124055271 %&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure># 完成合并并解决冲突git merge &lt;branch-name&gt;# 确保所有更改都正确添加到工作区# 提交整个合并结果git commit -m &quot;Merge branch &lt;branch-name&gt;&quot;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这时不需要指定文件名</span><br><span class="line"></span><br><span class="line">如果指定了就会报错</span><br><span class="line"></span><br></pre></td></tr></table></figure>git commit -m &quot;mergecommit&quot; hello.txt<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   &#123;% asset_img image-20231022123910704.png image-20231022123910704 %&#125; </span><br><span class="line"></span><br><span class="line">   并且会合并一个分支在master下</span><br><span class="line"></span><br><span class="line">   &#123;% asset_img image-20231022124155578.png image-20231022124155578 %&#125; </span><br><span class="line"></span><br><span class="line">   **但是不影响hot_fix下的内容，独立哦**智慧修改合并的分支不会修改来合并的那个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 合并的原理</span><br><span class="line"></span><br><span class="line">&gt; HEAD是指向那个分支的指针 </span><br><span class="line">&gt;</span><br><span class="line">&gt; refs下单分支名文件存的是对应的版本号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## &lt;a name=&quot;团队协作&quot;&gt;Git团队协作&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">团队协作</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022151510299.png image-20231022151510299 %&#125;</span><br><span class="line"></span><br><span class="line">跨团队协作</span><br><span class="line"></span><br><span class="line">作为团队外 的人修改。</span><br><span class="line"></span><br><span class="line">先fork再clone修改</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022151847436.png image-20231022151847436 %&#125;</span><br><span class="line"></span><br><span class="line">## GitHub操作</span><br><span class="line"></span><br><span class="line">### 创建远程仓库</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022152417413.png image-20231022152417413 %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建好后</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022153942795.png image-20231022153942795 %&#125;</span><br><span class="line"></span><br><span class="line">得到远程库的链接</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 创建别名</span><br><span class="line"></span><br><span class="line">前提确保当前所在的目录是一个 Git 仓库</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ol><p>git remote add 别名 远程库链接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022154210775.png image-20231022154210775 %&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>git remote -v</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">查看别名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 本地库推送到远程库push</span><br><span class="line"></span><br><span class="line">不是谁都可以push的，一是我们自己，[加入成员](#V)的成员</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>git push 别名&#x2F;远程库链接 分支</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">最小单位是分支</span><br><span class="line"></span><br><span class="line">不是文件</span><br><span class="line"></span><br><span class="line">然后刷新网页久能看到</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022154408168.png image-20231022154408168 %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 更新(拉取远程库到)本地库pull</span><br><span class="line"></span><br><span class="line">拉取是在原有基础上合并当前代码，克隆是克隆到文件夹，前者要登录</span><br><span class="line"></span><br><span class="line">修改内容</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022154658735.png image-20231022154658735 %&#125;</span><br><span class="line"></span><br><span class="line">拉取本地库</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>git pull 远程库别名&#x2F;链接 分支</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022154746072.png image-20231022154746072 %&#125; </span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022154757238.png image-20231022154757238 %&#125; </span><br><span class="line"></span><br><span class="line">拉取动作会自动帮我们提交本地库</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022154847881.png image-20231022154847881 %&#125; </span><br><span class="line"></span><br><span class="line">### 克隆远程库到本地</span><br><span class="line"></span><br><span class="line">==**克隆是不需要登录账号的**，也没有认证，也不需要加入团队，Public==</span><br><span class="line"></span><br><span class="line">克隆是我们现在本地库没有的</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022155252914.png image-20231022155252914 %&#125; </span><br><span class="line"></span><br><span class="line">先拿到项目的远程库链接</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>git clone 远程库的链接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">起别名需要我们当前目录下是个git仓库，也就是有.git文件夹</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022155942539.png image-20231022155942539 %&#125; </span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022155637868.png image-20231022155637868 %&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Git clone会帮我们干三件事</span><br><span class="line"></span><br><span class="line">&gt; 1. 拉取源代码</span><br><span class="line">&gt;</span><br><span class="line">&gt;    &#123;% asset_img image-20231022160104315.png image-20231022160104315 %&#125; </span><br><span class="line">&gt;</span><br><span class="line">&gt; 2. 初始化本地仓库</span><br><span class="line">&gt;</span><br><span class="line">&gt;    &#123;% asset_img image-20231022160039509.png image-20231022160039509 %&#125; </span><br><span class="line">&gt;</span><br><span class="line">&gt; 3. origin作为这个远程库的别名</span><br><span class="line">&gt;</span><br><span class="line">&gt;    &#123;% asset_img image-20231022160048548.png image-20231022160048548 %&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### &lt;a name=&quot;加入团队&quot;&gt;github加入团队&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建一个团队工作的项目在github上</span><br><span class="line"></span><br><span class="line">进入项目</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022161240189.png image-20231022161240189 %&#125; </span><br><span class="line"></span><br><span class="line">只需要对方的名就可以了</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022161421305.png image-20231022161421305 %&#125;</span><br><span class="line"></span><br><span class="line">然后复制这个邀请函给对方就可以了</span><br><span class="line"></span><br><span class="line">对方点击后</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022161544666.png image-20231022161544666 %&#125; 就可以选择接受和委婉拒绝了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### ssh免密登录</span><br><span class="line"></span><br><span class="line">==**个人的windows连接到github就不需要频繁登录了**==</span><br><span class="line"></span><br><span class="line">&gt; 要在本地生成 SSH 密钥对，可以按照以下步骤进行操作：</span><br><span class="line">&gt;</span><br><span class="line">&gt; 1. 打开终端或命令提示符窗口。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 2. 输入以下命令来生成 SSH 密钥：</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><blockquote><p>   shellCopy Codessh-keygen -t rsa -b 4096 -C “<a href="mailto:&#121;&#111;&#117;&#114;&#x5f;&#x65;&#x6d;&#97;&#105;&#x6c;&#x40;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#x6d;">&#121;&#111;&#117;&#114;&#x5f;&#x65;&#x6d;&#97;&#105;&#x6c;&#x40;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#x6d;</a>“<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   这里将 `your_email@example.com` 替换为**您关联的电子邮件地址**。此邮箱将作为 SSH 密钥标识符的一部分。</span><br><span class="line"></span><br><span class="line">   &gt; 这两个参数是用于生成 SSH 密钥对时指定密钥类型和密钥长度的。`-t` 参数指定密钥类型，常见的有 RSA、DSA 和 ECDSA；`-b` 参数指定密钥长度。4096 是一般安全性设置下的推荐值，可以提供更加安全的密钥。的机器资源有限或者您要求更快的操作速度，也可以使用更短的密钥长度。</span><br><span class="line"></span><br><span class="line">3. 按 Enter 键接受默认的文件保存路径和文件名（通常是 `~/.ssh/id_rsa`）。</span><br><span class="line"></span><br><span class="line">4. 接下来，您可以选择为密钥对设置一个密码。如果您希望在使用私钥时输入密码以提高安全性，请设置密码，并确保记住它。如果不想设置密码，直接按 Enter 跳过。</span><br><span class="line"></span><br><span class="line">5. 此时，`ssh-keygen` 命令会生成两个文件：私钥文件（`id_rsa`）和公钥文件（`id_rsa.pub`）。</span><br><span class="line"></span><br><span class="line">6. 公钥 (`id_rsa.pub`) 是需要在远程服务器上进行配置的部分。使用文本编辑器打开公钥文件，将其中的内容复制到粘贴板中。</span><br><span class="line"></span><br><span class="line">7. 登录到您要访问的远程服务器的帐户（例如 GitHub、GitLab 或其他主机）。</span><br><span class="line"></span><br><span class="line">8. 在远程服务器的用户设置或配置页面上，找到 SSH 密钥相关的选项，然后添加公钥。</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022164655760.png image-20231022164655760 %&#125;  </span><br><span class="line"></span><br><span class="line">在~/.ssh生成两个钥</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022165526266.png image-20231022165526266 %&#125; </span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022170013157.png image-20231022170013157 %&#125; </span><br><span class="line"></span><br><span class="line">就可以免密登录了，使用ssh来pull</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>git pull ssh的协议链接</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Git跨团队协作</span><br><span class="line"></span><br><span class="line">作为团队外的人</span><br><span class="line"></span><br><span class="line">先fork有问题的项目</span><br><span class="line"></span><br><span class="line">然后增添修改，可以在github上修改</span><br><span class="line"></span><br><span class="line">也可以clone，在本地库上修改.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022164204585.png image-20231022164204585 %&#125; </span><br><span class="line"></span><br><span class="line">可以发起pull请求</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022164355990.png image-20231022164355990 %&#125; </span><br><span class="line"></span><br><span class="line">可留下一段话，可以看哪里被修改了</span><br><span class="line"></span><br><span class="line">然后就发起pull request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [2023最新版IntelliJ IDEA安装教程](https://blog.csdn.net/Javachichi/article/details/131302807?ops_request_misc=%7B%22request%5Fid%22%3A%22169796587616800225570949%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169796587616800225570949&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-131302807-null-null.142^v96^control&amp;utm_term=idea安装教程2023&amp;spm=1018.2226.3001.4187)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## IDEA继承Git</span><br><span class="line"></span><br><span class="line">### 配置Git忽略文件</span><br><span class="line"></span><br><span class="line">### 什么是ignore文件</span><br><span class="line"></span><br><span class="line">&gt; `.gitignore` 文件（通常称为 &quot;ignore 文件&quot;）是 Git 版本控制系统中的一个文件。它用于指定哪些文件和目录应该被 Git 忽略，从而使 Git 在执行诸如提交、合并等操作时不会将这些文件包含在内。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 例如，您可能需要忽略以下文件或目录：</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 临时文件或日志文件</span><br><span class="line">&gt; - 编译生成的二进制文件</span><br><span class="line">&gt; - IDE 或编辑器生成的配置文件</span><br><span class="line">&gt; - 敏感信息、密码或机密信息的配置文件</span><br><span class="line">&gt;</span><br><span class="line">&gt; 如果这些文件被包含在 Git 版本库中，会导致版本库变得庞大且难以维护。使用 `.gitignore` 文件，您可以确保这些文件被 Git 忽略，同时保持版本库的清洁和可维护性。</span><br><span class="line"></span><br><span class="line">为什么忽略？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20231022192725698.png image-20231022192725698 %&#125; 不想要这些东西</span><br><span class="line"></span><br><span class="line">与项目的实际功能无关。不参与在服务器的运行.</span><br><span class="line"></span><br><span class="line">屏蔽掉久能忽略IDE之间的差异</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建xxx.ignore文件</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>.jar<br>.zip<br>.gzip<br>.xml<br>###忽略.json文件<br>*.json</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### IDEA继承git步骤</span><br><span class="line"></span><br><span class="line">1. 先找到我们git安装的位置</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   whiere git<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. idea配置</span><br><span class="line"></span><br><span class="line">   &#123;% asset_img image-20231022195245336.png image-20231022195245336 %&#125;</span><br><span class="line"></span><br><span class="line">3. &#123;% asset_img image-20231022195337154.png image-20231022195337154 %&#125; </span><br><span class="line"></span><br><span class="line">   VCS 是 Version Control System</span><br><span class="line"></span><br><span class="line">   这一步是</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git init</p><pre><code>本地库的初始化,生成.git文件4. &#123;% asset_img image-20231022195427361.png image-20231022195427361 %&#125; 选择文件/文件进行add或者commit5. &#123;% asset_img image-20231022195647169.png image-20231022195647169 %&#125; 6. 外部git验证&#123;% asset_img image-20231022195716702.png image-20231022195716702 %&#125; ### ignore的作用&#123;% asset_img image-20231022200029504.png image-20231022200029504 %&#125; 上传后没有idea什么的文件</code></pre>]]></content>
      
      
      <categories>
          
          <category> 版本管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习</title>
      <link href="/post/deb5175a.html"/>
      <url>/post/deb5175a.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p><a href="http://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/">Centos</a></p><hr><p><a href="https://blog.csdn.net/m0_50519965/article/details/116175873?ops_request_misc=%7B%22request_id%22:%22169465038316800188541621%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=169465038316800188541621&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-116175873-null-null.142%5Ev93%5Econtrol&utm_term=vmware16%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&spm=1018.2226.3001.4187">VMware16的安装及VMware配置Linux虚拟机(详解版)_vmware16安装-CSDN博客</a></p><h2 id="Linux导言"><a href="#Linux导言" class="headerlink" title="Linux导言"></a>Linux导言</h2><p>Linux 是一种自由和开放源码的类 UNIX 操作系统。</p><p>Linux 英文解释为 <strong>Linux is not Unix</strong>。</p><p>Linux 是在 1991 由林纳斯·托瓦兹在赫尔辛基大学上学时创立的，主要受到 Minix 和 Unix 思想的启发。</p><p>本教程，我们将为大家介绍如何使用 Linux。</p><p>Linux 其实很容易学，相信你们能很快学会。</p><h2 id="适配"><a href="#适配" class="headerlink" title="适配"></a>适配</h2><p> Linux 的发行版本 Centos 为例来为大家介绍 Linux 系统的应用。</p><h2 id="开源-的linux"><a href="#开源-的linux" class="headerlink" title="开源 的linux"></a>开源 的linux</h2><p>Linux 遵循 GNU 通用公共许可证（GPL），任何个人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。</p><p>由于 Linux 是自由软件，任何人都可以创建一个符合自己需求的 Linux 发行版。</p><p>目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。</p><img src="/post/deb5175a/image-20231007082555838.png" class="" title="image-20231007082555838"><h2 id="Linux发行版"><a href="#Linux发行版" class="headerlink" title="Linux发行版"></a>Linux发行版</h2><blockquote><p>以下是五个常用的Linux发行版以及它们的特点和简要介绍：</p><ol><li><p>Ubuntu：</p><ul><li>特点：用户友好、稳定、易用。</li><li>简要介绍：Ubuntu是基于Debian的一款流行的Linux发行版，以其简单易用和广泛的社区支持而受到欢迎。它提供了用户友好的桌面环境（如GNOME），并且有大量的软件包可供选择。</li></ul></li><li><p>CentOS：</p><ul><li>特点：稳定、安全、面向企业。</li><li>简要介绍：CentOS是一款由Red Hat Enterprise Linux（RHEL）源代码重新编译而成的免费、开源的Linux发行版。它以其出色的稳定性和安全性而闻名，并广泛应用于企业服务器环境。</li></ul></li><li><p>Fedora：</p><ul><li>特点：先进、新颖、面向开发者。</li><li>简要介绍：Fedora是由社区推动的创新型Linux发行版，旨在为用户提供最新的软件和技术。它在桌面和服务器上都具有出色的性能，并且对开发者友好，提供了很多开发工具和库。</li></ul></li><li><p>Debian：</p><ul><li>特点：稳定、自由、广泛支持。</li><li>简要介绍：Debian是一款非常稳定的Linux发行版，强调自由软件和广泛的硬件支持。它采用了一种包管理系统（APT），提供了庞大的软件仓库，并有强大的社区支持。</li></ul></li><li><p>openSUSE：</p><ul><li>特点：灵活、易用、面向桌面和服务器。</li><li>简要介绍：openSUSE是一款多功能的Linux发行版，适用于桌面和服务器环境。它注重用户友好性和用户体验，并提供了多种桌面环境选择（如KDE和GNOME）。此外，它还以其易用的包管理器（YaST）而闻名。</li></ul></li></ol><p>这些Linux发行版都有各自的特点和适用场景，选择哪个发行版主要取决于您的需求和熟悉程度。无论选择哪个发行版，都能获得强大的开源操作系统和丰富的软件生态系统。</p></blockquote><h2 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h2><p>Linux 内核最初只是由芬兰人&#x3D;&#x3D;林纳斯·托瓦兹&#x3D;&#x3D;（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。</p><p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p><p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><h3 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h3><ol><li>Linux内核（最核心的功能）</li><li>系统级应用程序（出厂自带的程序）</li><li><img src="/post/deb5175a/image-20231012081139215.png" class="" title="image-20231012081139215"></li></ol><p><a href="http://www.kernel.org内核/">www.kernel.org内核</a></p><h2 id="Linux应用领域"><a href="#Linux应用领域" class="headerlink" title="Linux应用领域"></a>Linux应用领域</h2><p>今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或 LNMP（Linux + Nginx+ MySQL + PHP）组合。</p><p>目前 Linux 不仅在家庭与企业中使用，并且在政府中也很受欢迎。</p><ul><li>巴西联邦政府由于支持 Linux 而世界闻名。</li><li>有新闻报道俄罗斯军队自己制造的 Linux 发布版的，做为 G.H.ost 项目已经取得成果。</li><li>印度的 Kerala 联邦计划在向全联邦的高中推广使用 Linux。</li><li>中华人民共和国为取得技术独立，在龙芯处理器中排他性地使用 Linux。</li><li>在西班牙的一些地区开发了自己的 Linux 发布版，并且在政府与教育领域广泛使用，如 Extremadura 地区的 gnuLinEx 和 Andalusia 地区的 Guadalinex。</li><li>葡萄牙同样使用自己的 Linux 发布版 Caixa Mágica，用于 Magalh?es 笔记本电脑和 e-escola 政府软件。</li><li>法国和德国同样开始逐步采用 Linux。</li></ul><h2 id="Linux-Windows"><a href="#Linux-Windows" class="headerlink" title="Linux&amp;Windows"></a>Linux&amp;Windows</h2><p>目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下</p><img src="/post/deb5175a/image-20231007082725236.png" class="" title="image-20231007082725236"><h2 id="Linux-系统启动过程"><a href="#Linux-系统启动过程" class="headerlink" title="Linux 系统启动过程"></a>Linux 系统启动过程</h2><p>linux启动时我们会看到许多启动信息。</p><p>Linux系统的启动过程并不是大家想象中的那么复杂，其过程可以分为5个阶段：</p><ul><li>内核的引导。</li><li>运行 init。</li><li>系统初始化。</li><li>建立终端 。</li><li>用户登录系统。</li></ul><blockquote><p>init程序的类型：</p></blockquote><blockquote><ul><li><strong>SysV:</strong> init, CentOS 5之前, 配置文件： &#x2F;etc&#x2F;inittab。</li><li><strong>Upstart:</strong> init,CentOS 6, 配置文件： &#x2F;etc&#x2F;inittab, &#x2F;etc&#x2F;init&#x2F;*.conf。</li><li><strong>Systemd：</strong> systemd, CentOS 7,配置文件： &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system、 &#x2F;etc&#x2F;systemd&#x2F;system。</li></ul></blockquote><h3 id="内核引导"><a href="#内核引导" class="headerlink" title="内核引导"></a>内核引导</h3><p>当计算机打开电源后，首先是&#x3D;&#x3D;BIOS开机自检，&#x3D;&#x3D;按照BIOS中设置的启动设备（通常是硬盘）来启动。</p><p>操作系统接管硬件以后，&#x3D;&#x3D;首先读入 &#x2F;boot 目录下的内核文件。&#x3D;&#x3D;</p><h3 id="运行Init"><a href="#运行Init" class="headerlink" title="运行Init"></a>运行Init</h3><p>&#x3D;&#x3D;init 进程是系统所有进程的起点&#x3D;&#x3D;，你可以把它比拟成&#x3D;&#x3D;系统所有进程的老祖宗&#x3D;&#x3D;，&#x3D;&#x3D;没有这个进程，系统中任何进程都不会启动。&#x3D;&#x3D;</p><p>init 程序首先是需要读取配置文件 &#x2F;etc&#x2F;inittab。</p><p>&#x3D;&#x3D;真正的rc启动脚本实际上都是放在&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;目录下。&#x3D;&#x3D;</p><h4 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h4><blockquote><ol><li>运行级别0（halt）：系统关机，无法执行任何任务。</li><li>运行级别1（single user）：单用户模式，系统进入最小化的运行环境，只有root用户可以登录。用于系统维护和故障排除。</li><li>运行级别2（multi-user）：多用户模式，没有图形界面（GUI），支持网络服务。这是命令行模式下的标准运行级别。</li><li>运行级别3（multi-user with networking）：和运行级别2类似，但同时启动网络服务，适用于服务器环境。</li><li>运行级别4（unused）：保留给用户自定义的运行级别。</li><li>运行级别5（graphical）：图形界面（GUI）模式，通常基于X Window系统。适用于桌面系统。</li><li>运行级别6（reboot）：系统重启。</li></ol></blockquote><p>许多程序需要开机启动。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。</p><p>&#x3D;&#x3D;init进程的一大任务，就是去运行这些开机启动的程序。&#x3D;&#x3D;</p><p>但是，&#x3D;&#x3D;不同的场合需要启动不同的程序&#x3D;&#x3D;，比如用作服务器时，需要启动Apache，用作桌面就不需要。</p><p>Linux允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（runlevel）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。</p><h3 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h3><p>在init的配置文件中有这么一行： si::sysinit:&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit　它调用执行了&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。</p><p>&#x3D;&#x3D;它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l5:5:wait:/etc/rc.d/rc 5</span><br></pre></td></tr></table></figure><h3 id="建立终端"><a href="#建立终端" class="headerlink" title="建立终端"></a>建立终端</h3><p>rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。</p><p>init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1:2345:respawn:/sbin/mingetty tty1</span><br><span class="line">2:2345:respawn:/sbin/mingetty tty2</span><br><span class="line">3:2345:respawn:/sbin/mingetty tty3</span><br><span class="line">4:2345:respawn:/sbin/mingetty tty4</span><br><span class="line">5:2345:respawn:/sbin/mingetty tty5</span><br><span class="line">6:2345:respawn:/sbin/mingetty tty6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。</p><h3 id="用户登录系统"><a href="#用户登录系统" class="headerlink" title="用户登录系统"></a>用户登录系统</h3><p>一般来说，用户的登录方式有三种：</p><ul><li>（1）命令行登录</li><li>（2）ssh登录</li><li>（3）图形界面登录</li></ul><p>对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器。</p><p>而本文主要讲的还是文本方式登录的情况：当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。</p><p>Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数。</p><p>然后 login 会对用户名进行分析：如果用户名不是 root，且存在 &#x2F;etc&#x2F;nologin 文件，login 将输出 nologin 文件的内容，然后退出。</p><p>这通常用来系统维护时防止非root用户登录。只有&#x2F;etc&#x2F;securetty中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录。</p><p>&#x2F;etc&#x2F;usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。</p><h4 id="图形模式与文字模式的切换方式"><a href="#图形模式与文字模式的切换方式" class="headerlink" title="图形模式与文字模式的切换方式"></a>图形模式与文字模式的切换方式</h4><p>Linux预设提供了六个命令窗口终端机让我们来登录。</p><p>默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。</p><p>如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。</p><p>当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。</p><p>&#x3D;&#x3D;如果你用的vmware 虚拟机，命令窗口切换的快捷键为 Alt + Space + F1<del>F6. 如果你在图形界面下请按Alt + Shift + Ctrl + F1</del>F6 切换至命令窗口。&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231007085428743.png" class="" title="image-20231007085428743"><h3 id="Linux-关机"><a href="#Linux-关机" class="headerlink" title="Linux 关机"></a>Linux 关机</h3><p>在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p><p>正确的关机流程为：sync &gt; shutdown &gt; reboot &gt; halt</p><p>关机指令为：shutdown ，<code>你可以man shutdown 来看一下帮助文档。</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sync 将数据由内存同步到硬盘中。</span><br><span class="line"></span><br><span class="line">shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span><br><span class="line"></span><br><span class="line">shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。</span><br><span class="line"></span><br><span class="line">shutdown –h now 立马关机</span><br><span class="line"></span><br><span class="line">shutdown –h 20:25 系统会在今天20:25关机</span><br><span class="line"></span><br><span class="line">shutdown –h +10 十分钟后关机</span><br><span class="line"></span><br><span class="line">shutdown –r now 系统立马重启</span><br><span class="line"></span><br><span class="line">shutdown –r +10 系统十分钟后重启</span><br><span class="line"></span><br><span class="line">reboot 就是重启，等同于 shutdown –r now</span><br><span class="line"></span><br><span class="line">halt 关闭系统，等同于shutdown –h now 和 poweroff</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中&#x3D;&#x3D;</p><h2 id="Linux系统目录结构"><a href="#Linux系统目录结构" class="headerlink" title="Linux系统目录结构"></a>Linux系统目录结构</h2><p>登录系统后，在当前命令窗口下输入命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /</span><br></pre></td></tr></table></figure><img src="/post/deb5175a/image-20231007090522196.png" class="" title="image-20231007090522196"><img src="/post/deb5175a/image-20231007090438747.png" class="" title="image-20231007090438747"><p>以下是对这些目录的解释：</p><ul><li><p><strong>&#x2F;bin</strong>：<br>bin 是 &#x3D;&#x3D;Binaries (二进制文件) 的缩写&#x3D;&#x3D;, 这个目录存放着最经常使用的命令。</p></li><li><p><strong>&#x2F;boot：</strong><br>这里存放的是&#x3D;&#x3D;启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件&#x3D;&#x3D;。</p></li><li><p><strong>&#x2F;dev ：</strong><br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p></li><li><p><strong>&#x2F;etc：</strong><br>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的&#x3D;&#x3D;系统管理所需要的配置文件和子目录&#x3D;&#x3D;。</p></li><li><p><strong>&#x2F;home</strong>：<br>用户的主目录，在 Linux 中，&#x3D;&#x3D;每个用户都有一个自己的目录&#x3D;&#x3D;，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p></li><li><p><strong>&#x2F;lib</strong>：<br>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p><strong>&#x2F;lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></li><li><p><strong>&#x2F;media</strong>：<br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p></li><li><p><strong>&#x2F;mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。</p></li><li><p><strong>&#x2F;opt</strong>：<br>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p></li><li><p><strong>&#x2F;proc</strong>：<br>proc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br></pre></td></tr></table></figure></li><li><p><strong>&#x2F;root</strong>：<br>&#x3D;&#x3D;该目录为系统管理员，也称作超级权限者的用户主目录。&#x3D;&#x3D;</p></li><li><p><strong>&#x2F;sbin</strong>：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p></li><li><p><strong>&#x2F;selinux</strong>：<br>这个目录是 Redhat&#x2F;CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p></li><li><p><strong>&#x2F;srv</strong>：<br>该目录存放一些服务启动之后需要提取的数据。</p></li><li><p><strong>&#x2F;sys</strong>：</p><p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</p><p>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</p><p>该文件系统是内核设备树的一个直观反映。</p><p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p></li><li><p><strong>&#x2F;tmp</strong>：<br>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p></li><li><p><strong>&#x2F;usr</strong>：<br>usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p></li><li><p><strong>&#x2F;usr&#x2F;bin：</strong><br>系统用户使用的应用程序。</p></li><li><p><strong>&#x2F;usr&#x2F;sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p></li><li><p><strong>&#x2F;usr&#x2F;src：</strong><br>内核源代码默认的放置目录。</p></li><li><p><strong>&#x2F;var</strong>：<br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></li><li><p><strong>&#x2F;run</strong>：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 &#x2F;var&#x2F;run 目录，应该让它指向 run。</p></li></ul><p>在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。</p><p><strong>&#x2F;etc</strong>： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。</p><p><strong>&#x2F;bin, &#x2F;sbin, &#x2F;usr&#x2F;bin, &#x2F;usr&#x2F;sbin</strong>: 这是系统预设的执行文件的放置目录，比如 <strong>ls</strong> 就是在 <strong>&#x2F;bin&#x2F;ls</strong> 目录下的。</p><p>值得提出的是 <strong>&#x2F;bin</strong>、**&#x2F;usr&#x2F;bin** 是给系统用户使用的指令（除 root 外的通用用户），而&#x2F;sbin, &#x2F;usr&#x2F;sbin 则是给 root 使用的指令。</p><p><strong>&#x2F;var</strong>： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 &#x2F;var&#x2F;log 目录下，另外 mail 的预设放置也是在这里。</p><h2 id="学会使用帮助"><a href="#学会使用帮助" class="headerlink" title="&#x3D;&#x3D;学会使用帮助&#x3D;&#x3D;"></a>&#x3D;&#x3D;学会使用帮助&#x3D;&#x3D;</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不会的 --help</span><br><span class="line">man 不会的</span><br></pre></td></tr></table></figure><h2 id="Linux忘记密码解决办法"><a href="#Linux忘记密码解决办法" class="headerlink" title="Linux忘记密码解决办法"></a>Linux忘记密码解决办法</h2><ol><li><p>&#x3D;&#x3D;在开机时按下Shift键&#x3D;&#x3D;，进入grub菜单。</p></li><li><p>在grub菜单中选择要启动的CentOS内核版本，&#x3D;&#x3D;并按下”e”键进入编辑模式。edit&#x3D;&#x3D;</p></li><li><p>在编辑模式中，找到以”linux16”开头的行，然后在该行的末尾添加以下内容：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rd.break enforcing=0</span><br></pre></td></tr></table></figure><p>添加完毕后，按下Ctrl+X或F10来启动系统。</p><ol start="4"><li><p>系统启动后，进入emergency mode，并且会挂载根文件系统为只读模式。</p></li><li><p>输入以下命令来重新挂载根文件系统为可写模式：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o remount,rw /sysroot</span><br></pre></td></tr></table></figure><ol start="6"><li>输入以下命令来切换到chroot环境：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chroot /sysroot</span><br></pre></td></tr></table></figure><ol start="7"><li>输入以下命令来重置密码：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><p>其中，”username”为您忘记密码的账户名。</p><ol start="8"><li>输入以下命令来重新生成SELinux策略：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch /.autorelabel</span><br></pre></td></tr></table></figure><ol start="9"><li>输入以下命令来退出chroot环境：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><ol start="10"><li>输入以下命令来重新挂载根文件系统为只读模式：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o remount,ro /sysroot</span><br></pre></td></tr></table></figure><ol start="11"><li>输入以下命令来重启系统：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>系统将会重新启动，并且您可以使用新密码登录您的CentOS Linux系统。请注意，这种方法只适用于您有root权限的情况。如果您没有root权限，您需要联系系统管理员或使用其他方法来重置密码。</p><h2 id="使用命令行学习Linux"><a href="#使用命令行学习Linux" class="headerlink" title="使用命令行学习Linux"></a>使用命令行学习Linux</h2><p>Linux大多使用命令行而不使用图形界面</p><p>&#x3D;&#x3D;命令：本质上就是执行的二进制可执行程序&#x3D;&#x3D;</p><p>优点:快，资源占用少</p><h3 id="FInalShell"><a href="#FInalShell" class="headerlink" title="FInalShell"></a>FInalShell</h3><p><a href="http://www.hostbuf.com/?install_fs">FinalShell官网 (hostbuf.com)</a></p><p>第三方软件操控Linux</p><p>SSH</p><ol><li>在Vmware里输入ifconfig看到我们虚拟机的<a href="#ip">IP</a></li><li><img src="/post/deb5175a/image-20231012082721816.png" class="" title="image-20231012082721816"></li><li><img src="/post/deb5175a/image-20231012082956881.png" class="" title="image-20231012082956881"></li><li><img src="/post/deb5175a/image-20231012083019511.png" class="" title="image-20231012083019511"></li><li><img src="/post/deb5175a/image-20231012083238491.png" class="" title="image-20231012083238491"></li></ol><p>验证是否连接，二者都输入ls，结果一样！</p><img src="/post/deb5175a/image-20231012083517172.png" class="" title="image-20231012083517172"><h3 id="虚拟机快照（后悔药）"><a href="#虚拟机快照（后悔药）" class="headerlink" title="&#x3D;&#x3D;虚拟机快照（后悔药）&#x3D;&#x3D;"></a>&#x3D;&#x3D;虚拟机快照（后悔药）&#x3D;&#x3D;</h3><p>通过将当前的虚拟机的状态保存下来，在以后开源通过快照回复虚拟机到保存的状态。</p><p>&#x3D;&#x3D;推荐在关机状态下进行快照&#x3D;&#x3D;</p><p>make: </p><ol><li>在Vmware里右键我们的虚拟机，快照管理器，然后</li><li><img src="/post/deb5175a/image-20231012083830514.png" class="" title="image-20231012083830514"></li><li>转到拍照，然后转到想去的状态。</li></ol><h2 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h2><ol><li><p>没有盘符，&#x3D;&#x3D;只有一个跟目录 &#x2F; 所有的文件都在它下面&#x3D;&#x3D;，windows可以由多个顶级目录CDE<img src="/post/deb5175a/image-20231012084249798.png" class="" title="image-20231012084249798"></p></li><li><p>&#x3D;&#x3D;在Linux里路径的层级关系用   &#x2F;  表示&#x3D;&#x3D;，在window里用   \   表示</p><blockquote><p>形象记忆：windows的w的第一笔画</p><p>Linux右边重变成了&#x2F;-</p></blockquote><p>&#x2F;home&#x2F;xurunbo</p></li><li><p>永远以&#x2F;开始，&#x2F;有两种含义</p><ol><li>根目录</li><li>层次关系</li></ol></li></ol><img src="/post/deb5175a/image-20231012084523777.png" class="" title="image-20231012084523777"><blockquote><ol><li>&#x2F;test&#x2F;hello.txt</li><li>&#x2F;itheima.txt</li><li>&#x2F;itcast&#x2F;itheima&#x2F;hello.txt</li></ol></blockquote><h2 id="★★★Linux命令入门"><a href="#★★★Linux命令入门" class="headerlink" title="★★★Linux命令入门"></a>★★★Linux命令入门</h2><h3 id="Linux命令基础"><a href="#Linux命令基础" class="headerlink" title="Linux命令基础"></a>Linux命令基础</h3><blockquote><ol><li>什么是命令？</li><li>命令的基本格式？</li></ol></blockquote><p>命令行：Linux的终端，用纯字符的形式操作系统，用各种命令去操作操作系统</p><p>给命令，它给我们字符化反馈</p><p>基础格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command [-options] [parametet]</span><br></pre></td></tr></table></figure><p><strong>command: 命令本身</strong></p><p><strong>-options：可选的一些选项，控制命令的行为细节</strong></p><p><strong>parameter：命令的参数，多数用于命令的指向目标等</strong></p><p>&#x3D;&#x3D;命令，选项，参数&#x3D;&#x3D;</p><h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><h4 id="ls命令简介"><a href="#ls命令简介" class="headerlink" title="ls命令简介"></a>ls命令简介</h4><blockquote><p>ls作用？</p><p>当前工作目录？</p><p>HOME目录？</p><p>如何形象记忆？</p></blockquote><p>function：列出目录下的内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls [-a -l -h] [linux路径]</span><br></pre></td></tr></table></figure><p>默认情况下ls得到使当前&#x3D;&#x3D;工作目录&#x3D;&#x3D;下的内容（当前路径）</p><img src="/post/deb5175a/image-20231012085808165.png" class="" title="image-20231012085808165"><p>&#x3D;&#x3D;当前登录用户的HOME目录作为工作目录，每一个用后都有这个HOME&#x3D;&#x3D;</p><p>ls和ls &#x2F;home&#x2F;xurunbo是等价的</p><img src="/post/deb5175a/image-20231012085639894.png" class="" title="image-20231012085639894"><p>HOME目录：每一个用户在Linux系统的专属目录&#x2F;home&#x2F;用户</p><h4 id="ls的参数和选项"><a href="#ls的参数和选项" class="headerlink" title="ls的参数和选项"></a>ls的参数和选项</h4><blockquote><p>-a？</p><p>-l？</p><p>-h？</p></blockquote><ol><li><p>-a是all的意思,[&#x3D;&#x3D;可以看到隐藏的文件&#x2F;文件夹&#x3D;&#x3D;]</p><img src="/post/deb5175a/image-20231012090306999.png" class="" title="image-20231012090306999"></li><li><p><strong>-l是list的意思，&#x3D;&#x3D;以列表的形式表示&#x3D;&#x3D;，并展示更多的信息，创建时间</strong></p><img src="/post/deb5175a/image-20231012090514715.png" class="" title="image-20231012090514715"><blockquote><p>二者的混合使用，既可以看到隐藏的东西，又以list的形式看、</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -a -l /</span><br><span class="line">ls -al /</span><br></pre></td></tr></table></figure><img src="/post/deb5175a/image-20231012090706425.png" class="" title="image-20231012090706425"></blockquote></li><li><p>&#x3D;&#x3D;-h和-l一般一起出现，显示文件的大小信息&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231012090943537.png" class="" title="image-20231012090943537"></li></ol><p>总结ls -alh一气呵成</p><p>list:动词，列出</p><h3 id="cd-pwd命令"><a href="#cd-pwd命令" class="headerlink" title="cd-pwd命令"></a>cd-pwd命令</h3><h4 id="cd切换工作目录"><a href="#cd切换工作目录" class="headerlink" title="cd切换工作目录"></a>cd切换工作目录</h4><blockquote><p>cd如何切换工作目录？</p><p>cd命令格式？有选项吗？</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd [Linux路径]</span><br></pre></td></tr></table></figure><p>默认我们是在当前用户的工作目录如果想切换该怎么办呢?</p><img src="/post/deb5175a/image-20231012091917969.png" class="" title="image-20231012091917969"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd 空格</span><br></pre></td></tr></table></figure><p>回到我们当前用户的工作目录也就是&#x2F;home&#x2F;xurunbo</p><h4 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h4><blockquote><p>pwd命令的作用？</p><p>pwd命令格式？有选项和参数吗？</p><p>pwd如何记忆？</p></blockquote><p>function：&#x3D;&#x3D;查看当前的目录&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;没有选项和参数&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231012092525570.png" class="" title="image-20231012092525570"><p>pwd：”Print Working Directory”打印工作中(当前)的目录</p><h3 id="相对-绝对路径，和特殊路径符"><a href="#相对-绝对路径，和特殊路径符" class="headerlink" title="相对&#x2F;绝对路径，和特殊路径符"></a>相对&#x2F;绝对路径，和特殊路径符</h3><blockquote><p>相对和绝对路径的概念和写法？</p><p>掌握几种特殊的路径写法？</p><p>当前，上一级如何写？</p></blockquote><p>绝对目录：&#x3D;&#x3D;以 根目录&#x2F; 为起点找到目标文件&#x3D;&#x3D;，路径以&#x2F;开头</p><p>相对路径：&#x3D;&#x3D;从当前目录为起点&#x3D;&#x3D;，找目标文件</p><img src="/post/deb5175a/image-20231012093317268.png" class="" title="image-20231012093317268"><p>前面的 ~代表当前的工作目录&#x2F;home&#x2F;xurunbo</p><p>&#x2F; 代表根目录</p><p>文件夹名字 代表在这个文件夹下</p><p>特殊路径符</p><blockquote><ol><li>.      表示当前目录</li><li>..           上一级 cd ..</li><li>~       Home目录   &#x3D;&#x3D;&#x2F;home&#x2F;xurunbo  cd</li></ol></blockquote><img src="/post/deb5175a/image-20231012143222052.png" class="" title="image-20231012143222052"><p>&#x3D;&#x3D;相对路径方便&#x3D;&#x3D;</p><p>例题<img src="/post/deb5175a/image-20231012143648199.png" class="" title="image-20231012143648199"></p><h3 id="mkdir命令-p"><a href="#mkdir命令-p" class="headerlink" title="mkdir命令 -p"></a>mkdir命令 -p</h3><blockquote><ol><li>mkdir是干什么的？</li><li>如何使用？</li><li>如何记忆-p mkdir？</li><li>什么是权限问题？</li></ol></blockquote><p>function：创建新的目录（文件夹）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir [-p] Linux路径</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;-p表示自动创建不存在的父目录，用于创建连续多层级的目录&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231012145501451.png" class="" title="image-20231012145501451"><img src="/post/deb5175a/image-20231012145634285.png" class="" title="image-20231012145634285"><p>问题引入；</p><ol><li>创建连续的文件，或者说嵌套的。就无法成功</li><li>需要加-p来完成</li></ol><img src="/post/deb5175a/image-20231012145949680.png" class="" title="image-20231012145949680"><p>将其理解为 “parents”（父级目录）的缩写。通过使用 <code>-p</code> 参数，<code>mkdir</code> 命令会&#x3D;&#x3D;自动创建指定路径上的所有父级目录，而不需要手动逐级创建。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;注意权限问题，当我们出了home去操作就无法成功了&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231012150451823.png" class="" title="image-20231012150451823"><h3 id="touch-cat-more命令"><a href="#touch-cat-more命令" class="headerlink" title="touch-cat-more命令"></a>touch-cat-more命令</h3><blockquote><ol><li>touch是干嘛的？有选项吗？</li><li>cat是干嘛的？有选项吗？</li><li>more是干嘛的？有选项吗？</li></ol></blockquote><h4 id="touch命令-创文件"><a href="#touch命令-创文件" class="headerlink" title="touch命令(创文件)"></a>touch命令(创文件)</h4><blockquote><ol><li>如何使用touch创建文件？</li><li>语法格式？</li><li>如何记忆？</li><li>有选项吗？</li></ol></blockquote><p>function：创建文件.txt………….</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch Linux路径</span><br></pre></td></tr></table></figure><img src="/post/deb5175a/image-20231012151027144.png" class="" title="image-20231012151027144"><p>ls -h前缀是d的是文件夹，是-的代表文件</p><img src="/post/deb5175a/image-20231012151135053.png" class="" title="image-20231012151135053"><p>理解为 “touch”（触摸）文件的意思。通过使用 <code>touch</code> 命令，你可以 “触摸” 文件，即创建一个新的空文件或者更新文件的时间戳，而不改变文件的内容。</p><h4 id="cat命令-查看文件"><a href="#cat命令-查看文件" class="headerlink" title="&#x3D;&#x3D;cat命令(查看文件)&#x3D;&#x3D;"></a>&#x3D;&#x3D;cat命令(查看文件)&#x3D;&#x3D;</h4><blockquote><p>如何使用cat查看文件内容？</p><p>如何记忆？</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat Linux路径</span><br></pre></td></tr></table></figure><p><code>cat</code> 命令是用来查看文件内容的命令。它的名字 “cat” 是 “concatenate”（连接）的缩写。通过使用 <code>cat</code> 命令，你可以将一个或多个文件的内容连接起来，并将结果输出到标准输出（通常是终端）。</p><img src="/post/deb5175a/image-20231012151618958.png" class="" title="image-20231012151618958"><h4 id="more命令-翻页查看文件"><a href="#more命令-翻页查看文件" class="headerlink" title="&#x3D;&#x3D;more命令(翻页查看文件)&#x3D;&#x3D;"></a>&#x3D;&#x3D;more命令(翻页查看文件)&#x3D;&#x3D;</h4><blockquote><ol><li>和cat的区别？</li><li>语法使用？</li><li>如何往下加载？如何退出？</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">more Linux路径</span><br></pre></td></tr></table></figure><p>cat是显示全部内容</p><p>more可以像电子书一样看一页一页，空格或者回车往下翻</p><p>q退出</p><img src="/post/deb5175a/image-20231012152539129.png" class="" title="image-20231012152539129"><h3 id="cp-mv-rm命令"><a href="#cp-mv-rm命令" class="headerlink" title="cp-mv-rm命令"></a>cp-mv-rm命令</h3><blockquote><ol><li>cp是干嘛的？</li></ol></blockquote><h4 id="cp命令-复制-r"><a href="#cp命令-复制-r" class="headerlink" title="cp命令(复制)  -r"></a>cp命令(复制)  -r</h4><blockquote><ol><li>语法格式？</li><li>作用？</li><li>如何记忆-r参数？</li></ol></blockquote><p>function：复制文件夹使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp [-r] 参数1 参数2</span><br><span class="line">参数以是别人的作业，参数2是抄到哪里？target</span><br></pre></td></tr></table></figure><p>如果目标不存在就创建并copy</p><img src="/post/deb5175a/image-20231012154116623.png" class="" title="image-20231012154116623"><p>&#x3D;&#x3D;-r：代表当复制文件夹的时候递归！&#x3D;&#x3D;recursively（递归地）</p><img src="/post/deb5175a/image-20231012155229635.png" class="" title="image-20231012155229635"><h4 id="mv命令-移动文件"><a href="#mv命令-移动文件" class="headerlink" title="mv命令(移动文件)"></a>mv命令(移动文件)</h4><blockquote><ol><li>语法格式？</li><li>有选项吗？</li><li>改名效果是什么？》</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv 参数1 参数2</span><br></pre></td></tr></table></figure><p>参数一是原来的位置，参数二是新的位置</p><p>&#x3D;&#x3D;参数二是否存在的影响&#x3D;&#x3D;</p><p>移动文件</p><img src="/post/deb5175a/image-20231012160135950.png" class="" title="image-20231012160135950"><p>改名效果</p><img src="/post/deb5175a/image-20231012160217768.png" class="" title="image-20231012160217768"><p>移动文件夹</p><img src="/post/deb5175a/image-20231012155848997.png" class="" title="image-20231012155848997"><p>改名效果“当在同一个路径下移动且    目标不存在，也就是参数二不存在的时候就是改名效果</p><img src="/post/deb5175a/image-20231012155810579.png" class="" title="image-20231012155810579"><h4 id="rm命令-删除文件-r-f"><a href="#rm命令-删除文件-r-f" class="headerlink" title="&#x3D;&#x3D;rm命令(删除文件)&#x3D;&#x3D; -r -f"></a>&#x3D;&#x3D;rm命令(删除文件)&#x3D;&#x3D; -r -f</h4><blockquote><ol><li>语法格式？</li><li>参数 -r -f作用？记忆方式？</li><li>r是recursively</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm [-r -f] 参数1 参数2 参数3 参数4。。。。。。。。。。。。。。。参数n</span><br></pre></td></tr></table></figure><p>参数是被删除的文件</p><p>-r用于删除文件夹</p><p>-f是force是强制删除 而且一般用户的强力删除是没有确认信息的，root跟用户的删除有提示。</p><p>删除文件：</p><img src="/post/deb5175a/image-20231012160707983.png" class="" title="image-20231012160707983"><p>删除文件夹&#x3D;&#x3D;-r也相当于递归recursively&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231012160747453.png" class="" title="image-20231012160747453"><p>删除多个&#x3D;&#x3D;追加多个参数就好了&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231012161125487.png" class="" title="image-20231012161125487"><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>rm命令支持通配符*用来模糊匹配</p><p>*可以匹配任意内容包括空</p><p>test*表示匹配任何以test结尾的内容</p><p>*test表示匹配任何以test开头的内容</p><p>*test表示匹配任何包含test的内容</p><img src="/post/deb5175a/image-20231012162335928.png" class="" title="image-20231012162335928"><p>-f（提示给超级用户看的，当你不强力删除的时候）</p><img src="/post/deb5175a/image-20231012163555047.png" class="" title="image-20231012163555047"><p>超级用户的登录 </p><blockquote><ol><li><pre><code>su - rootsu -输入密码进入了<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 想退出了直接exit</span><br><span class="line"></span><br><span class="line">3. 删库跑路牢饭管饱</span><br><span class="line"></span><br><span class="line">   rm -rf /*</span><br><span class="line"></span><br><span class="line">   强制删除根目录下的所有文件</span><br><span class="line"></span><br><span class="line">### which-find命令</span><br><span class="line"></span><br><span class="line">1. which如何使用</span><br><span class="line">2. find如何使用？</span><br><span class="line"></span><br><span class="line">#### which(查找命令)</span><br><span class="line"></span><br><span class="line">==命令cd，ls[其实本质就是二进制的可执行程序](#环境变量)==</span><br><span class="line"></span><br><span class="line">1. 语法格式？</span><br><span class="line">2. 查找什么的？</span><br><span class="line"></span><br><span class="line">function找命令的位置</span><br><span class="line"></span><br></pre></td></tr></table></figure>which 要查找的命令</code></pre></li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### find(查找文件)</span><br><span class="line"></span><br><span class="line">==按照文件名==查找</span><br><span class="line"></span><br><span class="line">1. ==(-name)按照文件名查找==</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   find 起始路径 -name 所查找的文件名<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   在使用 `find` 命令时， `-name` 选项用于指定要查找的文件名。</span><br><span class="line"></span><br><span class="line">   ==如果文件名中不含有空格或其他特殊字符==，则不加双引号和加双引号的效果是相同的。</span><br><span class="line"></span><br><span class="line">   所以最好还是带上</span><br><span class="line"></span><br><span class="line">2. 全盘搜索(/)</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   find &#x2F; -name “test”<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 配合通配符查找</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>    find &#x2F; -name “test*”<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">==按照文件大小查找==</span><br><span class="line"></span><br><span class="line">1. (-size)按照问年间大小查找</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   find 起始路径 -size +|-n[kMG]<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   -size通过文件大小查找，+|-代表大于和小于，n代表大小数字，kMG分别代表kB，MB，GB</span><br><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   find / -size +10k</span><br><span class="line">   find / -size 10k找的是size=10kb的</span><br><span class="line">   小写k</span><br><span class="line">   find / -size +10M</span><br><span class="line">   find / -size +10G</span><br></pre></td></tr></table></figure></p><h3 id="grep-wc-管道符"><a href="#grep-wc-管道符" class="headerlink" title="grep-wc-管道符"></a>grep-wc-管道符</h3><blockquote><ol><li>如何用grep命令过滤文件内容？</li><li>如何用wc命令统计内容数量?</li><li>管道符是什么？如何使用？</li></ol></blockquote><h4 id="grep命令-过滤文件行-n"><a href="#grep命令-过滤文件行-n" class="headerlink" title="grep命令(过滤文件行)-n"></a>grep命令(过滤文件行)-n</h4><blockquote><p>如何使用和记忆？</p><p>&#x3D;&#x3D;可以作为输入端口?&#x3D;&#x3D;</p></blockquote><p>function:从文件中通过指定关键字过滤文件行，哪一行包含关键字就被过滤出来了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep [-n] &quot;关键字&quot; Linux文件路径(可以作为内容的输入端口)</span><br></pre></td></tr></table></figure><p>关键字中不带空格和特殊符号的时候加不加“”都是ok的</p><p>&#x3D;&#x3D;推荐加””这个习惯&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231013100905987.png" class="" title="image-20231013100905987"><p>只要行中包含这个关键字就被过滤出来了</p><img src="/post/deb5175a/image-20231013103729927.png" class="" title="image-20231013103729927"><p>“g”、“r”、“e”、“p”，然后为每个字母找到一个关键词。例如，“g”可以代表“global”（全局），“r”可以代表“regular”（正则表达式），“e”可以代表“expression”（表达式），“p”可以代表“pattern”（模式）。这样，你可以将grep命令记忆为“全局正则表达式模式”。</p><p>&#x3D;&#x3D;可以作为内容的输入端口)&#x3D;&#x3D;</p><p>和管道符配合使用</p><img src="/post/deb5175a/image-20231013103014377.png" class="" title="image-20231013103014377"><h4 id="wc命令-文件内容统计-★★★★★"><a href="#wc命令-文件内容统计-★★★★★" class="headerlink" title="wc命令(文件内容统计)★★★★★"></a>wc命令(文件内容统计)★★★★★</h4><blockquote><p>如何使用和记忆？</p><p>也可以</p></blockquote><p>function：统计文件内容的信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wc [-c|-w|-l-m] Linux文件路径</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;字节数是代表的大小，字符数代表的是字母个数，&#x3D;&#x3D;</p><p> -c, –bytes            print the byte counts<br>  -m, –chars            print the character counts<br>  -l, –lines            print the newline counts</p><p> -L, –max-line-length 显示最长行的长度</p><p> -w, –words                   显示单词计数</p><img src="/post/deb5175a/image-20231013102459475.png" class="" title="image-20231013102459475"><p>&#x3D;&#x3D;默认是得到，行数，单词数，字节数.&#x3D;&#x3D;</p><p>w是word    c是character，统计单词字符的</p><h4 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h4><p>&#x3D;&#x3D;|&#x3D;&#x3D;</p><p>左边|右边</p><p>左边 | 右边</p><p>都是ok的</p><p>&#x3D;&#x3D;将左边命令得到的结果作为右边命令的输入&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231013103022475.png" class="" title="image-20231013103022475"><img src="/post/deb5175a/image-20231013103156900.png" class="" title="image-20231013103156900"><p>只要能产生内容输入的命令都可以和管道符配合使用</p><p>&#x3D;&#x3D;Linux文件路径(可以作为内容的输入端口)&#x3D;&#x3D;</p><p>嵌套使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat test.txt | grep -n &quot;ok&quot; | wc -l</span><br></pre></td></tr></table></figure><img src="/post/deb5175a/image-20231013104048797.png" class="" title="image-20231013104048797"><img src="/post/deb5175a/image-20231013104341314.png" class="" title="image-20231013104341314"><img src="/post/deb5175a/image-20231013104659495.png" class="" title="image-20231013104659495"><h3 id="echo-tali命令-重定向符号"><a href="#echo-tali命令-重定向符号" class="headerlink" title="echo-tali命令-重定向符号"></a>echo-tali命令-重定向符号</h3><blockquote><ol><li>echo如何使用？</li><li>tail如何使用？</li><li>什么是重定向符号?</li><li>加不加”” 有区别吗？</li></ol></blockquote><h4 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h4><blockquote><p>echo是干什么的如何使用？</p></blockquote><p>function:打印语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;要输出的内容&quot;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;内容比较复制的时候加上””更好&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;hello world&quot;</span><br><span class="line">echo hello world</span><br><span class="line">虽然二者都一样但是后者容易误解为参数</span><br></pre></td></tr></table></figure><img src="/post/deb5175a/image-20231013133029898.png" class="" title="image-20231013133029898"><h4 id="反引号-模板字符"><a href="#反引号-模板字符" class="headerlink" title="反引号&#96;&#96;(模板字符)"></a>反引号&#96;&#96;(模板字符)</h4><blockquote><p>类似python的模板字符串</p></blockquote><p>function :当我们想echo输出命令的内容的时候而不是输出命令的文本</p><img src="/post/deb5175a/image-20231013133447412.png" class="" title="image-20231013133447412"><h4 id="重定向-和-写入"><a href="#重定向-和-写入" class="headerlink" title="重定向&gt;和&gt;&gt;(写入)"></a>重定向&gt;和&gt;&gt;(写入)</h4><blockquote><p>如何使用？区分&gt; 和 &gt;&gt;</p></blockquote><p>function:向文件写入内容，修改内容</p><p>&gt; 的时候会覆盖掉原来的内容</p><img src="/post/deb5175a/image-20231013134014901.png" class="" title="image-20231013134014901"><p>&gt;&gt;的时候会追加在原来的内容的后面</p><img src="/post/deb5175a/image-20231013134054540.png" class="" title="image-20231013134054540"><p>&#x3D;&#x3D;只要是能产生输出的命令都可以作为&gt;和&gt;&gt;的左值&#x3D;&#x3D;</p><h4 id="tail命令-查看尾-f-num"><a href="#tail命令-查看尾-f-num" class="headerlink" title="tail命令(查看尾) -f -num"></a>tail命令(查看尾) -f -num</h4><blockquote><p>如何使用？</p><p>两个参数都代表什么意思？</p><p>num是简单的-num吗还是-一个确实的参数？</p></blockquote><p>&#x3D;&#x3D;(持续)function:查看一个文件的尾巴的倒数num行数据&#x3D;&#x3D;</p><p><code>tail -num text.txt</code></p><p>num要写一个实际的数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -20 text.txt</span><br><span class="line">而不是</span><br><span class="line">tail -num text.txt</span><br></pre></td></tr></table></figure><p>默认是看倒数10条数据</p><img src="/post/deb5175a/image-20231013134921569.png" class="" title="image-20231013134921569"><p>&#x3D;&#x3D;-f监听开始&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231013135204101.png" class="" title="image-20231013135204101"><p>就可以实时看新的信息了</p><p>&#x3D;&#x3D;开始监听和指定倒数多少行已经没意义了&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -f Linux路径</span><br></pre></td></tr></table></figure><p>想要退出就CTRL+C</p><h3 id="VI编辑器"><a href="#VI编辑器" class="headerlink" title="VI编辑器"></a>VI编辑器</h3><img src="/post/deb5175a/image-20231014094248596.png" class="" title="image-20231014094248596"><blockquote><ol><li><p>&#x3D;&#x3D;命令模式&#x3D;&#x3D;</p><p>所敲的案件编译器都理解为命令，驱动执行不同的功能，不能自由的编辑文本</p></li><li><p>&#x3D;&#x3D;输入模式&#x3D;&#x3D;</p><p>也就是所谓的编辑模式，可以自由的文本便辑</p></li><li><p>&#x3D;&#x3D;底线命令模式&#x3D;&#x3D;</p><p>以：开始，通常用于文件的保存，退出</p></li></ol></blockquote><p>vim&#x3D;vi++</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi Linux文件路径</span><br><span class="line">vim Linux文件路径</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;如果文件路径表示文件就用于编辑已有文件&#x3D;&#x3D;</p><p>&#x3D;&#x3D;如果文件路径的文件不存在吗就用于编辑新文件&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231014094922363.png" class="" title="image-20231014094922363"><blockquote><ol><li><p>默认进入的是命令模式</p><ol><li>i，进入输入模式。ESC回到命令模式</li><li>在命令模式下，输入dd删除一行的内容，u是撤销CTRL是反向撤销</li></ol></li><li><p>输入:进入底线命令模式</p><p>wq：保存并退出</p><p>w是写入并保存，但是不退出</p><p>q单独退出，不保存</p><p>输入wq再按下enter</p></li><li><p>默认情况下修改了内容但是不保存想直接退出，是会提示的</p><img src="/post/deb5175a/image-20231014095737998.png" class="" title="image-20231014095737998"><p>&#x3D;&#x3D;强制退出!q&#x3D;&#x3D;</p><p>命令模式下的快捷键</p><img src="/post/deb5175a/image-20231014095912732.png" class="" title="image-20231014095912732"><img src="/post/deb5175a/image-20231014100056356.png" class="" title="image-20231014100056356"><img src="/post/deb5175a/image-20231014100419393.png" class="" title="image-20231014100419393"><p>gg,G</p><p>dgg,dG</p><p>删除的包含当前行</p><p>底线命令模式下:</p><img src="/post/deb5175a/image-20231014101814961.png" class="" title="image-20231014101814961"><p>set paste用于保证i输入的时候粘贴的内容不会错乱</p></li></ol></blockquote><h3 id="Linux的root用户"><a href="#Linux的root用户" class="headerlink" title="Linux的root用户"></a>Linux的root用户</h3><p>windows和mac，Linux都是采用多用户的管理模式进行权限管理</p><p>root用户有最大的系统从操作权限</p><p>也就是有的手机root是干嘛的了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su - root</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;su————-S(switch)—-W(which)&#x3D;&#x3D;</p><h3 id="选择用户"><a href="#选择用户" class="headerlink" title="&#x3D;&#x3D;选择用户&#x3D;&#x3D;"></a>&#x3D;&#x3D;选择用户&#x3D;&#x3D;</h3><p>进入root用户</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su [-] 用户名</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;-可选，表示是否在切换环境后是否加载环境变量&#x3D;&#x3D;</p><p>&#x3D;&#x3D;想要退出当前用户，就用exit或者CTRL+D&#x3D;&#x3D;</p><p>》》》》</p><blockquote><p>一般情况下，普通用户在home内权限是不受限制的</p><p>但是出来home大多数都只有制度和执行权限，没有修改权限</p></blockquote><img src="/post/deb5175a/image-20231014103123239.png" class="" title="image-20231014103123239"><h3 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h3><blockquote><p>是干什么的？</p><p>每个用户都可以随便使用sudo吗？</p><p>如何给用户添加认证?</p><p>有了sudo认证的普通用户可以方便的进入root吗？如何输？</p></blockquote><p>普通用户出了home就很弱鸡了</p><img src="/post/deb5175a/image-20231014103753012.png" class="" title="image-20231014103753012"><p>因为sudo是给普通用户的当前命令添加临时的root权限</p><p>但是也不是随便每个用户都可以随便使用sudo的，得有root的认证</p><p>如何认证呢？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入root里面</span><br><span class="line">visudo</span><br><span class="line">命令模式下输入G到最下面</span><br><span class="line">用户名 ALL=(ALL)NOPASSWD: ALL</span><br><span class="line">:wq</span><br></pre></td></tr></table></figure><p>就实现了给用户名添加了sudu认证</p><p>&#x3D;&#x3D;当一个用户有了sudu认证之后，也就是说有了root的钥匙 了，也可以进入root的家&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su -</span><br><span class="line">就进入了root的家</span><br></pre></td></tr></table></figure><h3 id="用户-用户组"><a href="#用户-用户组" class="headerlink" title="用户&amp;用户组"></a>用户&amp;用户组</h3><blockquote><ol><li>用户和用户组和root的关系</li><li>如何创建和删除组？</li><li>普通用户可以创建组吗？</li><li>&#x3D;&#x3D;Linux权限管控的单元式用户级别和用户组级别&#x3D;&#x3D;</li></ol></blockquote><p>Linux：可以配置多个用户</p><p>​可以配置多个用户组</p><p>用户可以加入到多个用户组中</p><img src="/post/deb5175a/image-20231014170328423.png" class="" title="image-20231014170328423"><blockquote><p>创建用户组</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupadd 用户组名</span><br></pre></td></tr></table></figure><p>删除用户组</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupdel 用户组名</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;二者必须在root用户执行&#x3D;&#x3D;</p></blockquote><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><blockquote><p>有了用户组后，如何创建用户？</p><p>如何删除用户呢？</p><p>如何查看用户是哪一个组的呢？</p><p>如何修改用户的组呢？</p><p>如何形象记忆-g和-d和-r呢</p></blockquote><p>&#x3D;&#x3D;都得在root下或者sudo执行&#x3D;&#x3D;</p><ol><li><p>创建用户</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useradd [-g -d] 用户名</span><br></pre></td></tr></table></figure><p>-g是用来指定用户的组的，如果没有那就是默认创建一个用户名的组并且加入一个用户。</p><p>-d是用来指定用户home路径，默认是在&#x2F;home&#x2F;用户的</p><blockquote><p>默认创建</p><img src="/post/deb5175a/image-20231014171615773.png" class="" title="image-20231014171615773"><p>使用-g指定用户的组和使用-d指定用户的home路径</p><img src="/post/deb5175a/image-20231014171913140.png" class="" title="image-20231014171913140"><p>&#x3D;&#x3D;-g（group组指定用户的组的）&#x3D;&#x3D;</p><p>&#x3D;&#x3D;-d（directory目录指定用户的home路径）&#x3D;&#x3D;</p></blockquote></li><li><p>删除用户</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">userdel 用户名</span><br></pre></td></tr></table></figure><p>这样是删除了这个用户，但是没有删除用户在home目录</p><img src="/post/deb5175a/image-20231014173230467.png" class="" title="image-20231014173230467"><p>删除彻底</p><img src="/post/deb5175a/image-20231014173344580.png" class="" title="image-20231014173344580">==-r就是recursively删除一个目录（文件夹)就得迭代！==</blockquote></li><li><p>查看用户所属的组</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id 用户名</span><br></pre></td></tr></table></figure><img src="/post/deb5175a/image-20231014173729362.png" class="" title="image-20231014173729362"><p>得到用户名，用户的所属组</p></blockquote></li><li><p>修改用户所属的组</p><p>-a 是add添加到G的组下面</p><p>&#x3D;&#x3D;原来的还在那个组里面，一个用户可以在多个组&#x3D;&#x3D;<a href="https://blog.csdn.net/wushibo123/article/details/124619123">【2023最新版】Hexo+github搭建个人博客并绑定个人域名_hexo部署github绑定自定义域名-CSDN博客</a></p><p>-G也就是group咯</p><p>这个顺序没必要记忆用-h查看帮助文档</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usermod -aG 新的组 要被修改的用户名</span><br></pre></td></tr></table></figure><img src="/post/deb5175a/image-20231014180447738.png" class="" title="image-20231014180447738"></li><li><p>查看所有用户</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd</span><br></pre></td></tr></table></figure><img src="/post/deb5175a/image-20231014175019972.png" class="" title="image-20231014175019972"></li><li><p>查看所有的组</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /etc/group</span><br></pre></td></tr></table></figure></li></ol><img src="/post/deb5175a/image-20231014180647822.png" class="" title="image-20231014180647822"><p><strong>查看组和用户的另一种方法</strong></p><blockquote><p>查看组</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getent group</span><br><span class="line">等价于</span><br><span class="line">cat /etc/group</span><br></pre></td></tr></table></figure><p>查看用户</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getent passwd</span><br><span class="line">cat /etc/passwd</span><br></pre></td></tr></table></figure></blockquote><h3 id="查看Linux权限管控信息"><a href="#查看Linux权限管控信息" class="headerlink" title="查看Linux权限管控信息"></a>查看Linux权限管控信息</h3><blockquote><p>如何查看权限？</p><p>认知权限信息?</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -al</span><br></pre></td></tr></table></figure><ol><li>第一列代表文件&#x2F;目录的权限。</li><li>&#x3D;&#x3D;第二列代表文件&#x2F;目录的硬链接数&#x3D;&#x3D;。</li><li>第三列代表文件&#x2F;目录的所有者。   <strong>&#x3D;&#x3D;所属用户&#x3D;&#x3D;</strong></li><li>第四列代表文件&#x2F;目录的所属组。</li><li>第五列代表文件&#x2F;目录的大小（以字节为单位）。</li><li>第六列代表文件&#x2F;目录的修改日期和时间。</li><li>第七列代表文件&#x2F;目录的名称。</li></ol><blockquote><p>硬链接数是一个重要的属性，它表示有多少个文件名指向同一个文件或目录。</p><p><a href="#%E7%A1%AC%E8%BF%9E%E6%8E%A5&%E5%88%A0%E9%99%A4">当硬链接数为0时，文件或目录被认为是删除的，占用的磁盘空间会被释放。</a></p><p>只有当所有硬链接都被删除时，文件或目录才会真正被删除。</p></blockquote><img src="/post/deb5175a/image-20231014234949177.png" class="" title="image-20231014234949177"><p>&#x3D;&#x3D;认知权限信息&#x3D;&#x3D;</p><p>分为10个槽位</p><p>x   xyz  xyz xyz</p><p>&#x3D;&#x3D;从左到右，由近到远&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231014235055002.png" class="" title="image-20231014235055002"><p>l:表示是<a href="#%E6%9D%83%E9%99%90l">软连接</a>&#x2F;硬连接</p><p><strong>d:directory表示是一个文件夹</strong></p><p><strong>-:表示是一个文件</strong></p><p>&#x3D;&#x3D;r：读，w：写，x：执行&#x3D;&#x3D;</p><p>x——excute</p><blockquote> <img src="/post/deb5175a/image-20231014235553291.png" class="" title="image-20231014235553291"></blockquote><h3 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h3><blockquote><p>需要iroot权限吗</p><p>-R是干嘛的</p><p>chmod如何形象记忆？（change）（mode）</p><p>谁都可以修改吗？</p></blockquote><p>&#x3D;&#x3D;需要是root或者文件&#x2F;文件夹的所属用户&#x3D;&#x3D;</p><p>》》》《《《</p><h4 id="所属用户"><a href="#所属用户" class="headerlink" title="所属用户"></a>所属用户</h4><p>所属用户是指创建该文件或文件夹的用户，也就是该文件或文件夹的所有者。每个用户都有一个唯一的用户ID（UID）来标识自己。</p><p>所属用户对文件或文件夹有特定的权限，可以控制对其的访问、修改和执行操作。只有所属用户或具有特定权限的用户才能对文件或文件夹进行操作。</p><p>》》》《《《</p><p>function：修改文件，文件夹的权限信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod [-R] 权限 文件或文件夹</span><br></pre></td></tr></table></figure><p><code>权限:u(user)=       ,g(group)=        ,o(other)=   </code></p><p>&#x3D;&#x3D;用，号隔开&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231015120120566.png" class="" title="image-20231015120120566"> <img src="/post/deb5175a/image-20231015120131004.png" class="" title="image-20231015120131004"> <img src="/post/deb5175a/image-20231015120158642.png" class="" title="image-20231015120158642"> <img src="/post/deb5175a/image-20231015120208266.png" class="" title="image-20231015120208266"> <img src="/post/deb5175a/image-20231015120223520.png" class="" title="image-20231015120223520"> <p>rwx</p><p>-必须出现在最后面</p><p>例如你想要rx</p><p>不能写r-x</p><p>遇到-就停止了</p><img src="/post/deb5175a/image-20231015120404566.png" class="" title="image-20231015120404566"> <img src="/post/deb5175a/image-20231015120411744.png" class="" title="image-20231015120411744"> <hr><p>&#x3D;&#x3D;加了-R就可以迭代的修改文件夹里的所有文件&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231015120609960.png" class="" title="image-20231015120609960"> <h3 id="chmodPlus"><a href="#chmodPlus" class="headerlink" title="chmodPlus"></a>chmodPlus</h3><p>&#x3D;&#x3D;RWX:4 2 1&#x3D;&#x3D;</p><p>ugo:x y z</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod xyz [-R] 文件或者文件夹</span><br></pre></td></tr></table></figure><table><thead><tr><th>0</th><th>没有任何权限</th><th>—</th></tr></thead><tbody><tr><td>1</td><td>只有x权限</td><td>–x</td></tr><tr><td>2</td><td>只有w权限</td><td>-w-</td></tr><tr><td>3</td><td>有wx权限</td><td>-wx</td></tr><tr><td>4</td><td>只有r权限</td><td>r–</td></tr><tr><td>5</td><td>有r和x权限</td><td>r-x</td></tr><tr><td>6</td><td>有r和w权限</td><td>rw-</td></tr><tr><td>7</td><td>全都有！</td><td>rwx</td></tr></tbody></table><img src="/post/deb5175a/image-20231015122645831.png" class="" title="image-20231015122645831"> <p>chmod——-Change Mode</p><h3 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h3><blockquote><p>是干什么的？</p><p>如何使用？</p><p>如何形象记忆？[]:[] 类比ls -l得到的每一列的信息</p><p>谁都可以修改吗？</p></blockquote><p>&#x3D;&#x3D;普通用户是没有办法使用chown的&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231015125500572.png" class="" title="image-20231015125500572"> <p>人家要不要呢？是没有办法强加的。</p><p>function：修改文件或者文件夹的所属用户或者用户组</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown [-R] [用户名]:[用户组] 文件或者文件夹的Linux路径</span><br></pre></td></tr></table></figure><p>修改所属用户</p><img src="/post/deb5175a/image-20231015124306613.png" class="" title="image-20231015124306613"> <img src="/post/deb5175a/image-20231015124317369.png" class="" title="image-20231015124317369"> <img src="/post/deb5175a/image-20231015124325153.png" class="" title="image-20231015124325153"> <p>修改用户组</p><img src="/post/deb5175a/image-20231015124702807.png" class="" title="image-20231015124702807"> <p><strong>&#x3D;&#x3D;-R的修改其子文件都同步修改&#x3D;&#x3D;</strong></p><img src="/post/deb5175a/image-20231015125105195.png" class="" title="image-20231015125105195"> <h2 id="各类小技巧快捷键CTRL-cdae"><a href="#各类小技巧快捷键CTRL-cdae" class="headerlink" title="各类小技巧快捷键CTRL+cd&lt;–&gt;ae"></a>各类小技巧快捷键CTRL+cd&lt;–&gt;ae</h2><blockquote><p>如何看历史命令？</p><p>强制停止？ CTRL+C</p><p>退出，登出？ CTRL+D</p><p>历史命令搜索的两种方法？!+命令和CTRL+R</p><p>光标移动？</p><p>如何形象记忆CTRL+a和e呢</p></blockquote><ol><li><p>CTRL+C强制停止（程序运行）</p><p>命令写错了直接CTRL+C就是取消掉改行命令了</p></li><li><p>CTRL+D退出，登出，退出账户的登录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python就直接进入python的罕井中了</span><br></pre></td></tr></table></figure><p>CTRL+D可以&#x3D;&#x3D;退出某些特定程序的专属页面&#x3D;&#x3D;</p><p><code>但是不能用于退出VI/VIM</code></p></li><li><p>history 查看我们输入过的</p><img src="/post/deb5175a/image-20231015215042584.png" class="" title="image-20231015215042584"> <p>序号越大的是最新的</p><p>配合grep和管道符查筛选</p><img src="/post/deb5175a/image-20231015215114208.png" class="" title="image-20231015215114208"> <blockquote><ol><li><p>!+命令前缀</p><p>!p</p><pre><code>   他会从history的结果从下往上开始找到第一个开始匹配就执行了</code></pre></li></ol><p>&#x3D;&#x3D;历史命令搜索&#x3D;&#x3D;</p><ol start="2"><li><p>CTRL+R</p><img src="/post/deb5175a/image-20231015215705653.png" class="" title="image-20231015215705653"> <ol><li>按下&lt;-或者-&gt;就可以得到所显示的命令了</li><li>回车直接执行所显示的命令</li></ol></li></ol></blockquote></li><li><p>光标移动CTRL+-&gt;&#x2F;&lt;-</p><blockquote><p>CTRL+&gt;光标向右跳过一个单词</p><p>CTRL+&lt;光标向左跳过一个单词</p><p>上面二者也适用于md文档</p><p>CTRL+a光标跳到开头</p><p>CTRL+e光标跳到结尾</p><p><code>a==（ahead向前）,e==(end末尾)</code></p></blockquote></li><li><p>清屏</p><p><code>clear</code></p><p>或者</p><p>CTRL+L</p><p><strong>&#x3D;&#x3D;l&#x3D;（clean）&#x3D;&#x3D;</strong></p></li></ol><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><blockquote><p>如何使用yum为centos系统安装软件？</p><p>如何使用apt为ubuntu安装软件？</p></blockquote><p>操作系统安装软件的方式</p><ol><li><p>下载安装包自行安装</p><blockquote><p>windows用.exe文件.msi等</p><p>mac用dmg.pkg等</p></blockquote></li><li><p>系统的应用商店内安装</p><blockquote><p>windows的Microsoft Store商店</p><p>Mac的appstore</p></blockquote></li><li><p>&#x3D;&#x3D;Linux系统也同样支持这两种方式&#x3D;&#x3D;</p><blockquote><p><strong><code>centos用yum管理器,ubuntu用apk管理器==</code></strong></p><ol><li><p>用Linux命令行内的&#x3D;&#x3D;“应用商店”&#x3D;&#x3D;—-<strong>yum命令安装软件</strong></p><p><a href="#yum%E5%91%BD%E4%BB%A4">yum命令安装软件</a></p><p><a href="#apt%E4%B8%BAubuntu%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6">apt为ubuntu安装软件</a></p></li><li><p>在Linux中，常见的安装包格式有以下几种：</p><ol><li>DEB包：DEB（Debian）是Debian及其衍生发行版（如Ubuntu、Linux Mint等）使用的安装包格式。DEB包以.deb为扩展名，可以使用dpkg命令进行安装、升级和移除。</li><li>&#x3D;&#x3D;RPM包&#x3D;&#x3D;：RPM（Red Hat Package Manager）是Red Hat及其衍生发行版（如Fedora、CentOS等）使用的安装包格式。RPM包以.rpm为扩展名，可以使用yum或dnf命令进行安装、升级和移除。</li><li>&#x3D;&#x3D;TAR包&#x3D;&#x3D;：TAR（Tape Archive）是一种常见的归档文件格式，在Linux中经常用于打包和压缩文件。TAR包通常以.tar为扩展名，可以使用tar命令进行解压和提取。</li><li>压缩包：常见的压缩包格式如GZ、BZ2、XZ等，通常用于将多个文件或目录进行压缩和归档。这些压缩包可以使用相应的解压命令（如gzip、bzip2、xz等）进行解压缩。</li></ol><p><strong>&#x3D;&#x3D;Linux上的软件包管理系统（如yum、apt等）通常会自动处理软件包的依赖关系，因此安装软件时不需要手动下载和安装依赖的软件包。&#x3D;&#x3D;</strong></p></li></ol></blockquote></li></ol><p>&#x3D;&#x3D;简单总结&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231015224600897.png" class="" title="image-20231015224600897"><hr><h3 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a><a name="yum命令">yum命令</a></h3><blockquote><p>干嘛的？</p><p>如何用？</p><p>yum如何形象记忆》？</p><p>和<a href="#curl-O">curl -O</a>的区别？</p></blockquote><h4 id="yum命令语法和作用"><a href="#yum命令语法和作用" class="headerlink" title="yum命令语法和作用"></a>yum命令语法和作用</h4><p>funtion：RPM<strong>包软件管理器</strong>，用于<strong>自动化安装配置LInux的软件，并可以自动解决依赖问题</strong></p><p><code>yum下载的会默认写入环境变量，并且通常可以用systemctl去操作服务状态</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y [install |remove | search] 软件名称</span><br></pre></td></tr></table></figure><ol><li>install ：安装</li><li>remove :卸载</li><li>search：搜索</li><li>&#x3D;&#x3D;update: 更新&#x3D;&#x3D;</li></ol><hr><ul><li><p>&#x3D;&#x3D;安装软件需要切换到root或者有sudo权限才能正常安装Linux的软件&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;yum需要先联网&#x3D;&#x3D;</p></li></ul><hr><p>（（（（（（（（（（（yum&#x3D;yummy（美味的）<code>操作系统饮用软件</code>））））））））</p><h4 id="install安装一个拓展"><a href="#install安装一个拓展" class="headerlink" title="install安装一个拓展"></a>install安装一个拓展</h4><p>（如果这个过程包含的依赖项也会帮我们安装上）</p><img src="/post/deb5175a/image-20231015222807876.png" class="" title="image-20231015222807876"> <h4 id="serach查找-“应用商店”-里面是否有这个软件？"><a href="#serach查找-“应用商店”-里面是否有这个软件？" class="headerlink" title="serach查找&#x3D;&#x3D;“应用商店”&#x3D;&#x3D;里面是否有这个软件？"></a>serach查找&#x3D;&#x3D;“应用商店”&#x3D;&#x3D;里面是否有这个软件？</h4><img src="/post/deb5175a/image-20231015222903089.png" class="" title="image-20231015222903089"><h4 id="remove卸载掉刚刚安装的wget程序"><a href="#remove卸载掉刚刚安装的wget程序" class="headerlink" title="remove卸载掉刚刚安装的wget程序"></a>remove卸载掉刚刚安装的wget程序</h4><img src="/post/deb5175a/image-20231015223249637.png" class="" title="image-20231015223249637"><img src="/post/deb5175a/image-20231015223304969.png" class="" title="image-20231015223304969"> <p>验证删除掉了</p><h4 id="update更新我们的软件"><a href="#update更新我们的软件" class="headerlink" title="update更新我们的软件"></a>update更新我们的软件</h4><img src="/post/deb5175a/image-20231015223413084.png" class="" title="image-20231015223413084"> <h3 id="ubuntu的apt命令（拓展）"><a href="#ubuntu的apt命令（拓展）" class="headerlink" title="ubuntu的apt命令（拓展）"></a><a name="apt为ubuntu安装软件">ubuntu的apt命令（拓展）</a></h3><p>和centos差不多</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apk [-y] [install | search | update| remove] 软件名字</span><br></pre></td></tr></table></figure><h2 id="systmctl命令"><a href="#systmctl命令" class="headerlink" title="systmctl命令"></a>systmctl命令</h2><blockquote><p>如何使用systemctl命令控制软件的启动和关闭</p><p>如何形象记忆Systmctl呢</p></blockquote><h4 id="systmctl命令-1"><a href="#systmctl命令-1" class="headerlink" title="systmctl命令"></a><a name="systemctl">systmctl命令</a></h4><p>&#x3D;&#x3D;能够被systemctl管理的软件，一般也称之为<code>服务</code>&#x3D;&#x3D;</p><p>&#x3D;&#x3D;<em><strong>systemctl：：system（系统）ctl（control控制）</strong></em>&#x3D;&#x3D;</p><p>function:管理软件的启动停止，开机自启</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start|stop|restart|status|enable|disable 服务名</span><br></pre></td></tr></table></figure><ul><li>系统内置的服务很多</li><li><ul><li>Networkmanagers</li><li>network</li><li>firewalld</li><li>sshd，ssh服务</li></ul></li></ul><hr><h4 id="statues查看服务"><a href="#statues查看服务" class="headerlink" title="statues查看服务"></a>statues查看服务</h4><img src="/post/deb5175a/image-20231016134002273.png" class="" title="image-20231016134002273"> <h4 id="stop关闭服务-需要sudo权限"><a href="#stop关闭服务-需要sudo权限" class="headerlink" title="stop关闭服务&#x3D;&#x3D;需要sudo权限&#x3D;&#x3D;"></a>stop关闭服务&#x3D;&#x3D;需要sudo权限&#x3D;&#x3D;</h4><img src="/post/deb5175a/image-20231016134921469.png" class="" title="image-20231016134921469"> <h4 id="再次启动-需要sudo权限"><a href="#再次启动-需要sudo权限" class="headerlink" title="再次启动&#x3D;&#x3D;需要sudo权限&#x3D;&#x3D;"></a>再次启动&#x3D;&#x3D;需要sudo权限&#x3D;&#x3D;</h4><img src="/post/deb5175a/image-20231016135053481.png" class="" title="image-20231016135053481"> <h4 id="启动自启动-需要sudo权限"><a href="#启动自启动-需要sudo权限" class="headerlink" title="启动自启动&#x3D;&#x3D;需要sudo权限&#x3D;&#x3D;"></a>启动自启动&#x3D;&#x3D;需要sudo权限&#x3D;&#x3D;</h4><img src="/post/deb5175a/image-20231016135530338.png" class="" title="image-20231016135530338"><h4 id="关闭自启动-需要sudo权限"><a href="#关闭自启动-需要sudo权限" class="headerlink" title="关闭自启动&#x3D;&#x3D;需要sudo权限&#x3D;&#x3D;"></a>关闭自启动&#x3D;&#x3D;需要sudo权限&#x3D;&#x3D;</h4><img src="/post/deb5175a/image-20231016135553077.png" class="" title="image-20231016135553077"> <hr><p>很多软件安装完后都会自动集成到systmctl中</p><p>对于哪些不自动集成到systemctl的软件呢？</p><p>&#x3D;&#x3D;软件!&#x3D;服务&#x3D;&#x3D;</p><p>当然我们也可以<a href="#%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0">手动（注册）添加</a></p><img src="/post/deb5175a/image-20231016140008397.png" class="" title="image-20231016140008397"><h2 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h2><blockquote><p>什么是软连接？</p><p>如何使用&#x3D;&#x3D;ln命令&#x3D;&#x3D;创建软连接？</p><p>如何形象记忆ln呢？</p></blockquote><h4 id="软连接ln-s"><a href="#软连接ln-s" class="headerlink" title="软连接ln -s"></a>软连接ln -s</h4><p><strong>function：类似Windows的快捷方式，可以将文件，文件夹链接到其他位置</strong></p><p>软链接，它实际上是一个指向原始文件的符号链接，也就是一个<strong>指针</strong></p><p>&#x3D;&#x3D;<strong>ln：（link）（new）</strong>&#x3D;&#x3D;\</p><p>&#x3D;&#x3D;-s:：：（source）&#x2F;set&#x3D;&#x3D;</p><p><strong><code>指定源文件或目录。软链接是指向源文件或目录的特殊文件</code></strong></p><p>用于更新链接的命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s 参数1 参数2</span><br></pre></td></tr></table></figure><ul><li>-s选项，创建软连接</li><li>参数1是被链接的文件&#x2F;文件夹</li><li>参数2是要链接到哪?</li></ul><hr><h4 id="s为文件-文件夹添加new-link"><a href="#s为文件-文件夹添加new-link" class="headerlink" title="-s为文件&#x2F;文件夹添加new link"></a>-s为文件&#x2F;文件夹添加new link<a name="权限l"></a></h4><img src="/post/deb5175a/image-20231016142159544.png" class="" title="image-20231016142159544"> <hr>  <img src="/post/deb5175a/image-20231016143852224.png" class="" title="image-20231016143852224"><img src="/post/deb5175a/image-20231016143834145.png" class="" title="image-20231016143834145"> <p>&#x3D;&#x3D;不要忘记加-s&#x3D;&#x3D;</p><p>创建一个硬链接。硬链接是指向同一个文件的多个文件名，它们共享同样的数据块。在这个命令中，<code>/etc/yum.conf</code>是源文件，<code>~/yum.conf</code>是目标文件，通过执行这条命令，会在当前用户的主目录下创建一个名为<code>yum.conf</code>的硬链接，指向<code>/etc/yum.conf</code>文件。</p><p>硬链接只能在同一个文件系统中创建，而软链接（使用<code>-s</code>选项）可以跨越不同的文件系统。</p><h4 id="软连接和硬连接的区别"><a href="#软连接和硬连接的区别" class="headerlink" title="软连接和硬连接的区别"></a>软连接和硬连接的区别</h4><blockquote><p>软链接和硬链接都是&#x3D;&#x3D;用于创建文件链接的方式&#x3D;&#x3D;它们有以下区别：</p><ol><li><p>软链接是一个特殊的文件，它指向另一个文件或目录，类似于快捷方式。而&#x3D;&#x3D;硬链接是多个文件名指向同一个文件的不同入口，它们共享同样的数据块。&#x3D;&#x3D;</p></li><li><p><strong>软链接可以跨越不同的文件系统，而硬链接只能在同一个文件系统中创建。</strong></p></li><li><p>软链接可以指向目录，而硬链接只能指向文件。&#x3D;&#x3D;软的更灵活&#x3D;&#x3D;</p></li><li><p>当原始文件被删除时，软链接会失效，而硬链接不会受到影响，因为它们共享同样的数据块。</p><blockquote><p><a name="硬连接&删除">硬连接&amp;删除</a>:</p><p>当一个文件被删除时，实际上是删除了该文件在文件系统中的目录项，也就是该文件的文件名和它的数据块之间的映射关系。</p><p><strong>当原始文件被删除时，物理数据块并没有立即被删除。</strong>实际上，文件系统会在<strong>文件的所有硬链接都被删除后，才会释放该文件占用的物理空间</strong>。这是因为文件系统会维护一个引用计数，记录每个文件的硬链接数量。只有当引用计数为0时，文件系统才会释放对应的数据块。</p><img src="/post/deb5175a/image-20231016143325664.png" class="" title="image-20231016143325664"> <p>&#x3D;&#x3D;此列就是硬链接数&#x3D;&#x3D;</p><p>即使删除了原始文件，只要还有其他硬链接指向相同的数据块，该数据块就不会被释放。只有当所有硬链接都被删除后，文件系统才会回收相应的物理空间。</p></blockquote></li><li><p>软链接可以使用相对路径或绝对路径创建，而硬链接只能使用相对路径创建。-&gt;&#x3D;&#x3D;相对赢&#x3D;&#x3D;</p></li></ol><p>软链接是一种更加灵活的文件链接方式，而硬链接则更加节省空间，因为多个链接共享同样的数据块。</p></blockquote><h2 id="日期和时区"><a href="#日期和时区" class="headerlink" title="日期和时区"></a>日期和时区</h2><blockquote><p>掌握date命令查看和修改日期时间</p><p>掌握修改Linux系统的时区</p><p>掌握使用ntp进行时间同步和校准</p></blockquote><h4 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h4><p>function:查看系统的时间</p><p>&#x3D;&#x3D;-d：-d选项用于指定要显示或设置的日期和时间&#x3D;&#x3D;</p><p>&#x3D;&#x3D;-s设置当前系统的时期&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231016222116358.png" class="" title="image-20231016222116358"> <h4 id="d-格式化字符串简单的日期计算"><a href="#d-格式化字符串简单的日期计算" class="headerlink" title="-d+格式化字符串简单的日期计算"></a>-d+格式化字符串简单的日期计算</h4><img src="/post/deb5175a/image-20231016224521198.png" class="" title="image-20231016224521198"> <blockquote><p>date -d “+x year|month|date|month|hour|second”  +%……………………………..</p><p>&#x3D;&#x3D;显示标志的时间</p></blockquote><h4 id="s-set-设置当前系统的时期和时间"><a href="#s-set-设置当前系统的时期和时间" class="headerlink" title="-s(set)设置当前系统的时期和时间"></a>-s(set)设置当前系统的时期和时间</h4><ul><li>设置系统的日期和时间为指定日期和时间：<code>date -s &quot;2022-01-01 12:00:00&quot;</code></li><li>显示指定日期和时间的格式化输出<code>date -d &quot;2022-01-01 12:00:00&quot; +&quot;%Y-%m-%d %H:%M:%S&quot;</code></li></ul><hr><p>&#x3D;&#x3D;<strong>格式化字符串含有空格等特殊符号的话加上“”</strong>&#x3D;&#x3D;</p><hr><h4 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h4><p>默认是中国UTC东八区</p><p>》》》</p><p>PDT和CST是时区的缩写，分别代表太平洋夏令时（Pacific Daylight Time）和中部标准时间（Central Standard Time）。</p><img src="/post/deb5175a/image-20231016225115839.png" class="" title="image-20231016225115839"> <h4 id="Network-Time-Protocol-ntp-ntpd自动校准时间"><a href="#Network-Time-Protocol-ntp-ntpd自动校准时间" class="headerlink" title="Network Time Protocol::ntp|ntpd自动校准时间"></a>Network Time Protocol::ntp|ntpd自动校准时间</h4><ol><li><p>用<a href="#yum%E5%91%BD%E4%BB%A4">yum</a>安装npt</p><img src="/post/deb5175a/image-20231016225657720.png" class="" title="image-20231016225657720"></li><li><p>启动yumd服务</p><img src="/post/deb5175a/image-20231016230324917.png" class="" title="image-20231016230324917"> </li><li><p>启动yumd的自启动服务</p><p>&#x3D;&#x3D;<strong>当ntpd启动后会定期的帮助我们联网校准系统的时间</strong>&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231016230705240.png" class="" title="image-20231016230705240"></li><li><p>手动校准</p><blockquote><p>ntpdate -u ntp.aliyun.com</p><p>等待5，6S</p><p>就校准好了！还有偏差</p><img src="/post/deb5175a/image-20231016230957113.png" class="" title="image-20231016230957113"></blockquote></li></ol><h2 id="IP地址主机名"><a href="#IP地址主机名" class="headerlink" title="IP地址主机名"></a><a name="ip">IP</a>地址主机名</h2><h3 id="IP和主机名"><a href="#IP和主机名" class="headerlink" title="IP和主机名"></a>IP和主机名</h3><blockquote><ol><li>什么是IP地址</li><li>什么是主机名</li><li>什么是 &#x3D;&#x3D;域名解析&#x3D;&#x3D;</li></ol></blockquote><h4 id="IPV4和IPV的区别"><a href="#IPV4和IPV的区别" class="headerlink" title="IPV4和IPV的区别"></a>IPV4和IPV的区别</h4><p>IPv4和IPv6是互联网协议（Internet Protocol）的两个版本。</p><ol><li><p>地址空间：&#x3D;&#x3D;IPv4使用32位地址，最多可分配40亿个地址，&#x3D;&#x3D;而I&#x3D;&#x3D;Pv6使用128位地址，可分配的地址数量极其巨大，足以满足未来互联网的需求。&#x3D;&#x3D;</p></li><li><p>地址表示：&#x3D;&#x3D;IPv4地址使用点分十进制表示&#x3D;&#x3D;，如192.168.0.1，而&#x3D;&#x3D;IPv6地址使用冒号分隔的十六进制&#x3D;&#x3D;表示，如2001:0db8:85a3:0000:0000:8a2e:0370:7334。</p><blockquote><p>ipv4:</p><p>a.b.c.d——–192.168.0.1</p><p>a,b,c,d是0-255的数字</p></blockquote></li><li><p>地址配置：IPv4地址通常由网络管理员&#x3D;&#x3D;手动配置或通过动态主机配置协议（DHCP）自动分配&#x3D;&#x3D;，而IPv6地址通常通过无状态地址自动配置（SLAAC）或动态主机配置协议（DHCPv6）自动分配。</p></li><li><p>安全性：IPv6在设计时考虑了安全性，支持IPsec（Internet Protocol Security）协议，可以提供端到端的加密和认证功能。而&#x3D;&#x3D;IPv4需要额外的协议来实现类似的安全性。&#x3D;&#x3D;</p></li><li><p>支持的协议：IPv4支持的协议有限，而IPv6支持更多的协议，如移动IP（Mobile IP）、多播（Multicast）等。</p></li><li><p>网络性能：由于IPv6地址空间更大，IPv6可以减少网络地址转换（NAT）的使用，提高网络性能和连接质量。</p></li></ol><p>总的来说，IPv6相对于IPv4具有更大的地址空间、更好的安全性、更多的协议支持和更好的网络性能，是未来互联网的发展方向。然而，&#x3D;&#x3D;<strong>由于IPv4的广泛应用和设备的兼容性问题，目前IPv4仍然是主要的互联网协议。</strong>&#x3D;&#x3D;</p><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>&#x3D;&#x3D;因为每一台联网的电脑都会有一个地址，相当于电脑的身份证？&#x3D;&#x3D;</p><blockquote><p>IP地址是互联网中<strong>用于标识设备的一串数字</strong>。可以将其类比为房子的地址</p><p>用来确定设备在网络中的位置和通信的目标。</p></blockquote><p>ipv4:</p><p>a.b.c.d——–192.168.0.1</p><p>a,b,c,d是0-255的数字</p><h4 id="查看虚拟机的IP地址"><a href="#查看虚拟机的IP地址" class="headerlink" title="查看虚拟机的IP地址"></a>查看虚拟机的IP地址</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><img src="/post/deb5175a/image-20231017200700611.png" class="" title="image-20231017200700611"> ens33：主网卡<h4 id="特殊的IP地址"><a href="#特殊的IP地址" class="headerlink" title="特殊的IP地址"></a>特殊的IP地址</h4><p><strong><code>127.0.0.1==本机</code></strong>&#x3D;&#x3D;回环IP&#x3D;&#x3D;</p><p>0.0.0.0</p><ul><li><strong>可以指代本机</strong>，</li><li>确定绑定关系,</li><li>表示所有IP的意思（放行规则设置位0.0.0.表示允许任意IP访问）</li></ul><hr><h4 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h4><p>function：标识一个计算机</p><img src="/post/deb5175a/image-20231017201035156.png" class="" title="image-20231017201035156"> <h4 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h4><p>查看主机</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostname</span><br></pre></td></tr></table></figure><p>就显示了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname 新的主机名</span><br></pre></td></tr></table></figure><img src="/post/deb5175a/image-20231017201242951.png" class="" title="image-20231017201242951"> <p>重新登录后就可以了</p><img src="/post/deb5175a/image-20231017201536111.png" class="" title="image-20231017201536111"> <h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p><strong>ip地址记不住，记住域名就ok了</strong></p><p>baidu</p><p><code>IP地址和域名的映射关系</code></p><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><img src="/post/deb5175a/image-20231017202010816.png" class="" title="image-20231017202010816"><blockquote><ol><li><p>先看自己本机是否记录有对应网站的IP地址&#x3D;&#x3D;<strong>首先</strong>&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231017202135278.png" class="" title="image-20231017202135278"></li><li><p>如果没有再联网去DNS服务器找到<a href="http://www.baidu.com的ip地址/">www.baidu.com的IP地址</a></p></li></ol></blockquote><h4 id="自己添加域名映射"><a href="#自己添加域名映射" class="headerlink" title="自己添加域名映射"></a>自己添加域名映射</h4><p>&#x3D;&#x3D;不用IP地址而是用主机名&#x3D;&#x3D;</p><p>因为finalshell是通过Windows访问Linux</p><blockquote><ol><li><p>管理员身份运行记事本</p></li><li><p>打开hosts文件</p><img src="/post/deb5175a/image-20231017204304997.png" class="" title="image-20231017204304997"> </li><li><p>加上虚拟机的IP地址加上空格和域名</p></li><li><img src="/post/deb5175a/image-20231017204239375.png" class="" title="image-20231017204239375"> </li><li><p>就可以实现域名到IP地址的映射啦</p></li></ol><p>WIN+R输入 ping 和网页地址就可以得到网页的IP地址啦</p></blockquote><h4 id="DHCP自动分配IP地址和其他网络配置信息"><a href="#DHCP自动分配IP地址和其他网络配置信息" class="headerlink" title="DHCP自动分配IP地址和其他网络配置信息"></a>DHCP自动分配IP地址和其他网络配置信息</h4><p>DHCP（Dynamic Host Configuration Protocol）是一种网络协议，用于&#x3D;&#x3D;自动分配IP地址和其他网络配置信息给计算机和其他设备。&#x3D;&#x3D;</p><p>作用类似于租房中介，&#x3D;&#x3D;帮助设备在网络中找到可用的IP地址，并提供其他必要的网络配置&#x3D;&#x3D;。</p><p>》》》</p><p>在DHCP中，你的计算机就是租房的需求方，DHCP服务器就是租房中介。当你的计算机连接到网络时，它会向DHCP服务器发送一个请求，请求一个可用的IP地址和其他网络配置信息。DHCP服务器会检查可用的IP地址池，并为你的计算机分配一个IP地址，并提供其他必要的网络配置，比如子网掩码、默认网关、DNS服务器等。</p><p>此后，你的计算机就能够在网络中正常通信了。</p><h3 id="虚拟机配置固定IP地址"><a href="#虚拟机配置固定IP地址" class="headerlink" title="虚拟机配置固定IP地址"></a>虚拟机配置固定IP地址</h3><blockquote><p>windows如何在VMware中配置Linux的固定IP地址</p></blockquote><ol><li><p>为什么需要固定的IP呢？</p><p>因为我们的虚拟机是通过DHCP服务获取的，会频繁变更</p><p>个人，办公电脑的IP变化与否无所谓，但是我们要远程链接我们的虚拟机，IP地址经常变换就不方便</p></li><li><p>还有我们自己添加的&#x3D;&#x3D;虚拟机的IP地址和主机名的映射&#x3D;&#x3D;如果IP地址频繁更改就需要频繁的在hosts 中修改</p></li></ol><hr><h4 id="Vmware-Workstation配置固定IP"><a href="#Vmware-Workstation配置固定IP" class="headerlink" title="Vmware Workstation配置固定IP"></a>Vmware Workstation配置固定IP</h4><ol><li><p>在VMware中设置</p><img src="/post/deb5175a/image-20231017214638066.png" class="" title="image-20231017214638066"> <blockquote><p>子网IP为192.168.88.0，这表示该局域网中的设备可以使用从192.168.88.1到192.168.88.254的IP地址。</p><hr><p>网关的IP地址可以是该局域网中的任何设备的IP地址，通常是路由器的IP地址。将网关设置为192.168.88.1意味着你将局域网中的路由器指定为网关。</p></blockquote></li><li><p>NAT设置</p><img src="/post/deb5175a/image-20231017215011422.png" class="" title="image-20231017215011422"> <hr></li><li><p>在LInux的配置文件里配置</p><p>&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</p><img src="/post/deb5175a/image-20231017215442839.png" class="" title="image-20231017215442839"> <p>&#x3D;&#x3D;目标：把ip修改为192.168.88.86&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231017215645493.png" class="" title="image-20231017215645493"> <p>网关是GATEWAY不是NETWAY。。。。。可以设置多个DNS服务器，以备份或提高解析速度。在设置DNS时，你可以指定多个DNS服务器的IP地址，设备将按顺序尝试连接这些服务器，直到成功解析域名或达到超时。</p><p>然后用到<a href="#systmctl%E5%91%BD%E4%BB%A4">systemctl</a>的重启network服务就可以啦</p><img src="/post/deb5175a/image-20231017220109323.png" class="" title="image-20231017220109323"></li></ol><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><blockquote><p>DNS（Domain Name System）是用于&#x3D;&#x3D;<strong>将域名转换为相应IP地址的系统</strong>&#x3D;&#x3D;。它充当了互联网上的电话簿，将用户输入的&#x3D;&#x3D;域名翻译成计算机可以理解的IP地址&#x3D;&#x3D;，以便正确地连接到目标服务器。</p><p>网关是192.168.88.2。&#x3D;&#x3D;<strong>通常可以将该网关设置为你的设备的默认DNS服务器</strong>&#x3D;&#x3D;。这样，当你的设备需要解析域名时，它将向网关发出DNS查询请求。</p><p>2.&#x3D;&#x3D;<strong>还可以使用其他可用的公共DNS服务器，如114.114.114.114</strong>&#x3D;&#x3D;。你可以将该IP地址设置为你的设备的DNS服务器，以便使用该服务器来解析域名。</p><p>可以&#x3D;&#x3D;<strong>设置多个DNS服务器，以备份或提高解析速度</strong>。&#x3D;&#x3D;在设置DNS时，你可以指定多个DNS服务器的IP地址，设备将按顺序尝试连接这些服务器，直到成功解析域名或达到超时。</p></blockquote><p>就得到啦固定的IP地址</p><img src="/post/deb5175a/image-20231017220304627.png" class="" title="image-20231017220304627"> <p>再利用域名解析，就可以实现自己添加域名映射啦</p><img src="/post/deb5175a/image-20231017220341282.png" class="" title="image-20231017220341282"> <h2 id="网络请求和下载"><a href="#网络请求和下载" class="headerlink" title="网络请求和下载"></a>网络请求和下载</h2><blockquote><p>使用ping测试网络连接的延迟和稳定性。</p><p>使用</p><p>使用</p></blockquote><h3 id="ping命令-c"><a href="#ping命令-c" class="headerlink" title="ping命令 -c"></a>ping命令 -c</h3><p>function ：用于测试网络连接的延迟和稳定性。</p><p>测试一个网站或者IP服务器的状态是否正常</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping [-c num] 网址(ip或者主机名)</span><br><span class="line">网址可以是一个IP地址或一个域名。</span><br></pre></td></tr></table></figure><blockquote><p><strong>ping命令比喻为发送一个小信使去询问目标主机是否能够回答，并测量信使返回的时间。</strong></p><p>如果目标主机能够回答，那么ping命令会显示往返时间，这表示网络连接正常。</p><p>如果目标主机无法回答，或者往返时间非常长，那么ping命令会显示超时或延迟较高的信息，这表示网络连接存在问题。</p></blockquote><p>&#x3D;&#x3D;-c：：：count———指定测试次数&#x3D;&#x3D;</p><h3 id="wget命令-b"><a href="#wget命令-b" class="headerlink" title="wget命令 -b"></a>wget命令 -b</h3><p>funtion：非交互式的下载文件&#x3D;&#x3D;用于从指定的URL下载文件。&#x3D;&#x3D;</p><p> <a href="http://archive.apache.org/dist/hadoop/common/hadoop-3.3.0/hadoop-3.3.0.tar.gz">http://archive.apache.org/dist/hadoop/common/hadoop-3.3.0/hadoop-3.3.0.tar.gz</a></p><p>阿帕奇hadoop的安装包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget [-b] url</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;<strong>-b：是在后台下载</strong>&#x3D;&#x3D;并且下载日志保存在wget-log文件下面</p><hr><p>常用选项：</p><ul><li><code>-O</code>：指定下载文件的保存路径和文件名。</li><li><code>-P</code>：指定下载文件的保存路径。</li><li><code>-c</code>：断点续传，如果下载中断，可以从中断的地方继续下载。</li><li><code>-r</code>：递归下载，下载指定URL中的所有文件。</li><li><code>-np</code>：不下载上级目录。</li><li><code>-nH</code>：不创建主机目录。</li><li><code>-nd</code>：不创建目录。</li><li><code>-A</code>：只下载指定后缀名的文件。</li><li><code>-U</code>：设置User-Agent标头，模拟浏览器请求。</li><li><code>-q</code>：静默模式，不显示下载进度。</li><li><code>-h</code>：显示wget命令的帮助信息。</li></ul><img src="/post/deb5175a/image-20231018161110552.png" class="" title="image-20231018161110552"> <h3 id="curl命令-O"><a href="#curl命令-O" class="headerlink" title="curl命令 -O"></a>curl命令 -O</h3><p>function：用于&#x3D;&#x3D;从指定的URL获取数据并输出到终端或保存到文件中。&#x3D;&#x3D;</p><p>可以发起网络请求</p><p>可以下载文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl [-O] url</span><br></pre></td></tr></table></figure><p><code>curl url</code>获取的是url页面的源代码</p><p><code>cur -O url</code>下载文件，也有对应的进度条</p><p>&#x3D;&#x3D;其中O代表Output（输出）。这是因为使用curl -O命令时，curl会将从URL下载的文件保存到当前目录下，&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231018162603235.png" class="" title="image-20231018162603235"> <p>&#x3D;&#x3D;<strong>默认是放在当前工作目录下面的</strong>&#x3D;&#x3D;</p><p>&#x3D;&#x3D;获取主机的公网IP地址&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231018161623614.png" class="" title="image-20231018161623614"> <h3 id="curl和yum的区别"><a href="#curl和yum的区别" class="headerlink" title="curl和yum的区别"></a><a name="curl-O">curl和yum的区别</a></h3><blockquote><p>在Linux中，yum和curl -O&#x3D;&#x3D;都可以用于下载文件，但它们的使用场景和功能略有不同。&#x3D;&#x3D;</p><ol><li>yum下载文件：<br>yum是Linux系统中的&#x3D;&#x3D;包管理器&#x3D;&#x3D;，&#x3D;&#x3D;主要用于安装、更新和删除软件包&#x3D;&#x3D;。它可以从软件源中下载软件包及其依赖项，&#x3D;&#x3D;并自动解决依赖关系&#x3D;&#x3D;。yum下载文件的主要目的是为了安装软件包，&#x3D;&#x3D;下载的文件通常是软件包的<strong>二进制文件或安装脚本</strong>&#x3D;&#x3D;。使用yum下载文件时，可以使用以下命令：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install package_name</span><br></pre></td></tr></table></figure><p>yum会根据软件源中的配置文件，从指定的软件源中下载软件包及其依赖项，并自动进行安装。</p><ol start="2"><li>curl -O下载文件：<br>curl是一个强大的命令行工具，&#x3D;&#x3D;<strong>用于与网络服务进行数据交互</strong>&#x3D;&#x3D;。它支持各种协议，包括HTTP、HTTPS、FTP等。&#x3D;&#x3D;<strong>curl -O命令用于从指定的URL下载文件，并将文件保存在当前目录下，文件名与URL中的文件名相同</strong>&#x3D;&#x3D;。使用curl -O下载文件时，可以使用以下命令：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -O http://example.com/file.txt</span><br></pre></td></tr></table></figure><p>curl -O命令适用于从任何支持的协议下载文件，无论是软件包、文本文件还是其他类型的文件。&#x3D;&#x3D;<strong>它不会自动解决依赖关系，只是简单地下载文件并保存到本地。</strong>&#x3D;&#x3D;</p><p>总结：</p><ul><li>yum下载文件主要用于安装软件包，下载的文件通常是软件包的二进制文件或安装脚本。</li><li>curl -O下载文件适用于从任何支持的协议下载文件，无论是软件包、文本文件还是其他类型的文件。它&#x3D;&#x3D;不会自动解决依赖关系，只是简单地下载文件并保存到本地。&#x3D;&#x3D;</li></ul></blockquote><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><blockquote><p>什么是端口</p><p>netstat命令如何使用</p></blockquote><p>&#x3D;&#x3D;IP&#x3D;&#x3D;是用来在互联网上找到这个计算机</p><p>&#x3D;&#x3D;端口&#x3D;&#x3D;就是这台电脑上面的住户（程序）</p><p>Linux支持六万个端口</p><ul><li>公认端口 用于：&#x3D;&#x3D;系统内置和知名程序使用&#x3D;&#x3D;</li><li><strong>注册端口</strong> 1024-五万 随意使用，用于松散的绑定一些程序&#x2F;服务</li><li>动态端口 ：5w-6w 通常不会固定绑定程序，而是当程序对外网络连接的时候使用</li></ul><img src="/post/deb5175a/image-20231019124053175.png" class="" title="image-20231019124053175"><h3 id="nmap程序"><a href="#nmap程序" class="headerlink" title="nmap程序"></a>nmap程序</h3><p><strong>扫描指定IP对外暴露的端口</strong></p><ol><li><pre><code>sudo yum -y install nmap<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   nmap 127.0.0.1(IP)</span><br></pre></td></tr></table></figure></code></pre></li></ol><p>nmap查看系统的端口使用情况</p><img src="/post/deb5175a/image-20231019125045570.png" class="" title="image-20231019125045570"><h3 id="netstat程序"><a href="#netstat程序" class="headerlink" title="netstat程序"></a>netstat程序</h3><blockquote><p>netstat查看<strong>本机端口</strong>的占用情况</p></blockquote><ol><li><pre><code>sudo yum -y install netstat<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   netstat -anp 端口</span><br></pre></td></tr></table></figure></code></pre></li><li><p>可以配合管道符和grep</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -anp | grep 22</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;anp&#x3D;&#x3D;</p><blockquote><p>a:all 所有链接TCP，UDP。。</p><p>n：numeric数字格式的IP</p><p>p：process进程信息</p></blockquote></li></ol><img src="/post/deb5175a/image-20231019163541554.png" class="" title="image-20231019163541554"> <img src="/post/deb5175a/image-20231019131045120.png" class="" title="image-20231019131045120"> <p>具体来说，”netstat -anp”会显示以下内容：</p><ul><li>“Proto”列显示网络连接所使用的&#x3D;&#x3D;协议&#x3D;&#x3D;，如TCP或UDP。</li><li>“Recv-Q”和”Send-Q”列显示&#x3D;&#x3D;接收队列和发送队列中的数据量。&#x3D;&#x3D;</li><li>“Local Address”列显示&#x3D;&#x3D;本地计算机的IP地址和端口号。&#x3D;&#x3D;</li><li>“Foreign Address”列显示&#x3D;&#x3D;远程计算机的IP地址和端口号。&#x3D;&#x3D;</li><li>“State”列显示连接的状态，&#x3D;&#x3D;如ESTABLISHED（已建立）、LISTEN（监听）等。&#x3D;&#x3D;</li><li>“PID&#x2F;Program name”列显示<strong>与连接相关的进程ID和进程名称</strong>。</li></ul><p>查看当前系统上所有的网络连接，并了解与这些连接相关的进程和端口信息。</p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><blockquote><p>进程是什么？</p><p>如何查看进程？关闭进程？</p></blockquote><p>程序运行在操作系统中，是呗操作系统所管理的。</p><p>每个程序在运行的时候，操作系统注册为系统中的一个进程</p><p><strong>并位每个进程都分配一个独有的&#x3D;&#x3D;进程ID&#x3D;&#x3D;</strong></p><h3 id="Linux查看系统的进程信息"><a href="#Linux查看系统的进程信息" class="headerlink" title="Linux查看系统的进程信息"></a>Linux查看系统的进程信息</h3><p>function:查看Linux系统的进程信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps [-f -e]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef |grep 进程名</span><br></pre></td></tr></table></figure><blockquote><p>p : process  进程</p><p>s :snapshot   快照</p><p>进程快照</p></blockquote><blockquote><p>-f ：full，-e：everything</p><p>-f &#x3D;&#x3D;full&#x3D;&#x3D; format 显示全部的进程</p><p>-e &#x3D;&#x3D;everythiing &#x3D;&#x3D;processes   以完全格式化的形式展示信息</p></blockquote><img src="/post/deb5175a/image-20231019131809628.png" class="" title="image-20231019131809628"><p>依次为</p><ol><li><p>UID是进程所属的用户ID</p></li><li><p>PID是进程号</p></li><li><p>PPID进程的父PID</p><p>程序不一定是由&#x3D;&#x3D;用户启动的&#x3D;&#x3D;也可能是&#x3D;&#x3D;程序启动程序&#x3D;&#x3D;</p></li><li><p>C是CPU占用率</p></li><li><p>STIME是进程的启动时间  start time</p></li><li><p>TIME是进程占用CPU时间<strong>，累计</strong></p></li><li><p>CMD表示&#x3D;&#x3D;启动路径&#x3D;&#x3D;</p></li></ol><h3 id="查看进程-ps-ef"><a href="#查看进程-ps-ef" class="headerlink" title="查看进程 ps -ef"></a>查看进程 ps -ef</h3><p>先输入”tail”命令会启动一个进程，等待用户输入要查看的文件名或路径。由于没有输入文件名或路径，该进程会一直等待用户输入，因此会阻塞住。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail</span><br></pre></td></tr></table></figure><p>再复制一个标签输入</p><img src="/post/deb5175a/image-20231019132609126.png" class="" title="image-20231019132609126"> <p>&#x3D;&#x3D;<strong>我们输入的命令本身也是一个程序，所以一般不看过滤出来的最后一条结果</strong>&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231019133211697.png" class="" title="image-20231019133211697"> <h3 id="关闭进程-kill-9"><a href="#关闭进程-kill-9" class="headerlink" title="关闭进程  kill [-9]"></a>关闭进程  kill [-9]</h3><p>function：关闭进程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill [-9] 进程ID</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;<strong>-9强制关闭掉</strong>&#x3D;&#x3D;</p><p>没有-9就是自我了断，发送信号。</p><img src="/post/deb5175a/image-20231019140045952.png" class="" title="image-20231019140045952"> <p>复制一个窗口</p><img src="/post/deb5175a/image-20231019140111107.png" class="" title="image-20231019140111107"> <p>查看到该进程的进程ID</p><img src="/post/deb5175a/image-20231019140127988.png" class="" title="image-20231019140127988"> <p>文明催关</p><img src="/post/deb5175a/image-20231019140305308.png" class="" title="image-20231019140305308"> <p>一般都是关闭的，收到要关闭的信号了，就关闭。</p><p>但有一些流氓</p><img src="/post/deb5175a/image-20231019140428488.png" class="" title="image-20231019140428488"> <p>暴力关闭</p><img src="/post/deb5175a/image-20231019140246411.png" class="" title="image-20231019140246411"> <h2 id="主机状态监控"><a href="#主机状态监控" class="headerlink" title="主机状态监控"></a>主机状态监控</h2><h3 id="系统资源状态监控"><a href="#系统资源状态监控" class="headerlink" title="系统资源状态监控"></a>系统资源状态监控</h3><h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><img src="/post/deb5175a/image-20231020132424008.png" class="" title="image-20231020132424008"><blockquote><p>-p:  person指定进程好好看</p><p>-d  delay：时间间隔</p><p>-c：command：摄像头仔细的观察完整的命令</p><p>-n ：number设置固定的刷新次数</p><p>-b：”background”，即在后台非交互式地运行。一般配合重定向到指定文件</p><p>-i : inspect 检查，正在运行的进程</p><p>-u：查看指定用户的进程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top -b &gt;1.txt</span><br></pre></td></tr></table></figure><p>就可以看到整张，然后more一页一页观看</p></blockquote><h4 id="top的交互式选项"><a href="#top的交互式选项" class="headerlink" title="top的交互式选项"></a>top的交互式选项</h4><blockquote><p>h : help 能看到一些帮助文档</p><p>c :等价于-c  command能让我们看更全面的 启动路径</p><p>i 等价于 inspect 查看正在运行的进程信息</p><hr><p>l :load  ：切换显示平均负载和启动时间信息</p><p>m: mem内存  ：切换显示内存信息</p><p>t : toggle (切换)切换显示CPu的使用情（控制1，2行的显示）</p><hr><p>P : ppercentage根据CPU使用&#x3D;&#x3D;率&#x3D;&#x3D;进行排序</p><p>M:Mem，根据内存大小RES排序</p><p>T:根据时间使用来排序</p><hr><p>E ：切换顶部内存显示单位&#x2F;&#x2F;</p><p>e:切换进程内存显示单位&#x2F;&#x2F;</p><p>f :fields selection 选择要展示的项目&#x3D;&#x3D;<strong>用空格来选择</strong>&#x3D;&#x3D;</p></blockquote><p>&#x3D;&#x3D;PMT,lmt,f,hic&#x3D;&#x3D;</p><p>当然仅仅top就很好用了</p><h4 id="top的实例解释"><a href="#top的实例解释" class="headerlink" title="top的实例解释"></a>top的实例解释</h4><p>&#x3D;&#x3D;默认每5minute刷新一次&#x3D;&#x3D;</p><hr><img src="/post/deb5175a/image-20231020123315381.png" class="" title="image-20231020123315381"> <p>top：命令名称</p><p>12：33：06：系统时间</p><p>up 6minuts：启动了6分钟</p><p>2users：有两个用户登录</p><p>Load average：&#x3D;&#x3D;系统平均负载：分<strong>别代表1，5，15分钟的平均负载</strong>&#x3D;&#x3D;</p><hr><img src="/post/deb5175a/image-20231020123445297.png" class="" title="image-20231020123445297"> ==<p>task：185total：总计有185个子进程</p><p>1 running：有一个进程正在进行</p><p>184sleeping：184个正在睡觉</p><p>stoppped：0个停止了</p><p>0 zomibe：0个是<a href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B">僵尸进程</a></p><hr><img src="/post/deb5175a/image-20231020125142369.png" class="" title="image-20231020125142369"> ==t==<p>CPU占用率</p><p>13.7us:代表用户cpu占用率</p><p>15.6sy:系统占用cpu占用率</p><hr><img src="/post/deb5175a/image-20231020125905624.png" class="" title="image-20231020125905624"> <p>&#x3D;&#x3D;物理内存&#x3D;&#x3D;</p><p>free：剩多少</p><p>used：用了多少</p><p>buff&#x2F;cache：系统缓存</p><img src="/post/deb5175a/image-20231020130128610.png" class="" title="image-20231020130128610"> <p>&#x3D;&#x3D;虚拟内存&#x3D;&#x3D;</p><p>总量</p><p>剩余</p><p>用了</p><p>可用</p><p>不太关心</p><hr><img src="/post/deb5175a/image-20231020130758496.png" class="" title="image-20231020130758496"> <p>PID:（process ID）：进程ID</p><p>USER：所属用户</p><p>PR：进程优先级</p><p>NI：进程负优先级</p><p>VIRT：所占用的&#x3D;&#x3D;虚拟内存&#x3D;&#x3D;</p><p>RES: 所占用的物理内存</p><p>SHR：所占用的共享内存</p><p>%CPU：所占用的&#x3D;&#x3D;CPU率&#x3D;&#x3D;</p><p>%MEM：进程占用&#x3D;&#x3D;内存率&#x3D;&#x3D;</p><p>TIME+：进程的启动时间</p><p>COMMAND：是进程的&#x3D;&#x3D;启动路径&#x3D;&#x3D;或者&#x3D;&#x3D;文件路径&#x3D;&#x3D;</p><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a><a name="僵尸进程">僵尸进程</a></h4><p>》》》</p><blockquote><p>僵尸进程是指在操作系统中:</p><p>一个子进程在<strong>完成任务后</strong>，但是其父进程<strong>没有及时回收其资源</strong>，导致子进程的进程描述符仍然存在于进程表中，<strong>但是已经没有运行的实体进程与之对应。这样的进程称为僵尸进程。</strong>&#x3D;&#x3D;僵尸进程不占用系统资源，但是会占用进程表中的一个条目&#x3D;&#x3D;，如果大量的僵尸进程存在，可能会&#x3D;&#x3D;<strong>导致进程表耗尽</strong>，&#x3D;&#x3D;<strong>从而影响系统的正常运行</strong>。</p></blockquote><h3 id="磁盘的信息监控"><a href="#磁盘的信息监控" class="headerlink" title="磁盘的信息监控"></a>磁盘的信息监控</h3><blockquote><p>df如何形象化记忆？</p><p>iostat命令</p></blockquote><h4 id="df命令-h"><a href="#df命令-h" class="headerlink" title="df命令-h"></a>df命令-h</h4><p>function：查看硬盘的使用情况：磁盘空间查看命令，用于显示文件系统的磁盘使用情况，包括磁盘总大小、已用空间、可用空间和文件系统的挂载点等信息。</p><ul><li>d disk</li><li>f free</li><li>&#x3D;&#x3D;查看磁盘的剩余情况&#x3D;&#x3D;&#x3D;</li><li>-h参数则是用来以人类可读的方式显示磁盘空间信息</li><li>h:human人类</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">df [-h]</span><br></pre></td></tr></table></figure><blockquote><ul><li>-h：以易读的方式显示磁盘空间大小；</li><li>-T：显示文件系统类型；</li><li>-i：显示inode的使用情况。</li></ul></blockquote><img src="/post/deb5175a/image-20231020143802455.png" class="" title="image-20231020143802455"> <h4 id="iostat命令-x-num1-num2"><a href="#iostat命令-x-num1-num2" class="headerlink" title="iostat命令 -x num1 num2"></a>iostat命令 -x num1 num2</h4><blockquote><p>查看系统</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iostat [-x] [num1 nun2]</span><br><span class="line">num1是delay刷新间隔</span><br><span class="line">num2是刷新次数</span><br></pre></td></tr></table></figure><img src="/post/deb5175a/image-20231020144615032.png" class="" title="image-20231020144615032"> <ul><li>sda:虚拟机的硬盘</li><li>tps:每秒传输次数</li><li>每秒读</li><li>每秒写</li><li>总读取</li><li>总写出</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iostat -x</span><br></pre></td></tr></table></figure><img src="/post/deb5175a/image-20231020145053322.png" class="" title="image-20231020145053322"><img src="/post/deb5175a/image-20231020144540410.png" class="" title="image-20231020144540410"><p>主要看这三个</p><h3 id="网络状态监控"><a href="#网络状态监控" class="headerlink" title="网络状态监控"></a>网络状态监控</h3><h4 id="sar命令"><a href="#sar命令" class="headerlink" title="sar命令"></a>sar命令</h4><blockquote><p>如何形象化记忆？</p></blockquote><p>function：查看网络状态的相关信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sar -n 设备 [num1 num2]</span><br></pre></td></tr></table></figure><blockquote><p>-n :查看网络</p><p>DEV：表示查看网络接口</p><p>nmu1；是刷新间隔</p><p>num2：是查看次数</p></blockquote><img src="/post/deb5175a/image-20231020145946359.png" class="" title="image-20231020145946359"><img src="/post/deb5175a/image-20231020150156998.png" class="" title="image-20231020150156998"> <blockquote><p>rxKB&#x2F;s：是我们下载的时候接受的数据包大小</p><p>txKB&#x2F;s 是我们上传的时候发送的数据包的大小</p></blockquote><p>还有最后一次的统计数据</p><h4 id="》》》"><a href="#》》》" class="headerlink" title="》》》"></a>》》》</h4><p>Linux中的sar -n 设备 [num1 num2]命令：</p><ol><li>将sar视为<strong>“系统活动报告</strong>”（System Activity Report）<strong>，而-n代表“网络”（Network）。</strong></li><li><strong>设备可以被视为网络接口（例如eth0，eth1等）。</strong></li><li>[num1 num2]表示可选的两个数字参数，可以将其视为&#x3D;&#x3D;时间间隔&#x3D;&#x3D;和&#x3D;&#x3D;刷新次数&#x3D;&#x3D;。</li></ol><blockquote><p>系统活动报告中的网络接口活动情况（System Activity Report）+-n(network)</p></blockquote><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a><a name="环境变量">环境变量</a></h2><blockquote><p>环境变量是干嘛的？</p><p>如何表示的？</p><p>为什么我们在任何目录下都可以使用cd命令呢?</p></blockquote><h3 id="环境变量-1"><a href="#环境变量-1" class="headerlink" title="环境变量"></a>环境变量</h3><p>Linux环境变量是一种&#x3D;&#x3D;<strong>存储在操作系统中的字符串，用于指定操作系统运行程序时所需的各种信息。</strong>&#x3D;&#x3D;</p><p>操作系统在运行的时候，记录的一些关键性信息，<strong>用于辅助系统运行。</strong></p><p>》》</p><p>常见的环境变量包括</p><p>PATH（指定可执行文件的搜索路径）</p><p>HOME（指定当前用户的主目录）</p><p>LANG（指定默认的语言设置）</p><hr><p>当在Linux中运行一个程序时，它会自动读取指定的环境变量</p><h3 id="env命令"><a href="#env命令" class="headerlink" title="env命令"></a>env命令</h3><p>function：查看Linux&#x3D;&#x3D;<strong>系统中的系统变量</strong>&#x3D;&#x3D;</p><p><code>env命令只能查看当前环境中的全局环境变量，而不会显示用户级别的环境变量。</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">env</span><br></pre></td></tr></table></figure><blockquote><p>env命令用于显示当前系统的环境变量。</p><p>语法：<br>env [选项] [键值对]… [命令]</p><p>选项：<br>-i，&#x3D;&#x3D;清除现有的环境变量，只使用指定的键值对&#x3D;&#x3D;<br>-u，&#x3D;&#x3D;移除指定的环境变量&#x3D;&#x3D;<br>-h，显示帮助信息</p><p>示例：</p><ol><li><p>显示所有环境变量：<br>env</p></li><li><p>显示指定环境变量的值：<br>env 变量名</p></li><li><p>设置新的环境变量：<br>env 变量名&#x3D;值 命令</p></li><li><p>清除现有的环境变量，只使用指定的键值对：<br>env -i 变量名&#x3D;值 命令</p></li><li><p>移除指定的环境变量：<br>env -u 变量名 命令</p></li></ol></blockquote><img src="/post/deb5175a/image-20231020153930700.png" class="" title="image-20231020153930700"> <p>得到的是键值对的数据</p><h3 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a><a name="PATH">PATH</a></h3><p>为什么我们在任何目录下都可以使用cd命令呢？这就是借助环境变量PAth这个项目的值做到的</p><blockquote><p>PATH环境变量是一个用冒号分隔的目录列表，用于指示系统在哪些路径中查找可执行程序。</p><p>当在命令行上输入一个命令时，系统会按照PATH环境变量所列出的路径顺序&#x3D;&#x3D;<strong>去查找对应的可执行文件</strong>&#x3D;&#x3D;，并执行找到的第一个匹配项。</p><hr><p>这意味着，如果一个可执行文件的路径没有包含在PATH环境变量中，就需要使用完整路径或切换到包含该文件的目录来执行它。</p><p>通过将常用的可执行文件所在的目录添加到PATH环境变量中，可以方便地在任何位置执行这些命令，而不必每次都输入完整的路径</p></blockquote><img src="/post/deb5175a/image-20231020153739977.png" class="" title="image-20231020153739977"> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;<strong>PATH指定了默认搜索路径</strong>&#x3D;&#x3D;</p><p>当我们执行cd命令到时候，他就会从PATH里的一个个搜索路径下去找对应的可执行文件</p><h3 id="符号"><a href="#符号" class="headerlink" title="$符号"></a>$符号</h3><blockquote><p>$符号呗用于&#x3D;&#x3D;<strong>取”变量“</strong>&#x3D;&#x3D;</p><p>环境变量记录的信息，除了给操作系统自己使用外，如果我们想取用，就用到了$符号</p><p>取得环境变量的值就可以</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ 环境变量名</span><br></pre></td></tr></table></figure><p>进阶</p><img src="/post/deb5175a/image-20231020155149829.png" class="" title="image-20231020155149829"></blockquote><h3 id="自定义环境变量"><a href="#自定义环境变量" class="headerlink" title="自定义环境变量"></a>自定义环境变量</h3><img src="/post/deb5175a/image-20231020160630278.png" class="" title="image-20231020160630278"> <h4 id="创建临时变量"><a href="#创建临时变量" class="headerlink" title="&#x3D;&#x3D;创建临时变量&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>创建临时变量</strong>&#x3D;&#x3D;</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export 变量名=变量值</span><br></pre></td></tr></table></figure><blockquote><p>重启虚拟机，或者切换用户，都看不到这个变量</p></blockquote><h4 id="创建长久环境变量"><a href="#创建长久环境变量" class="headerlink" title="创建长久环境变量"></a>创建长久环境变量</h4><p>&#x3D;&#x3D;重启不影响&#x3D;&#x3D;</p><p>souce 配置文件</p><p>重新读取</p><ol><li><p>在当前用户下创建</p><img src="/post/deb5175a/image-20231020160926269.png" class="" title="image-20231020160926269"> <p>编辑.bashrc</p><img src="/post/deb5175a/image-20231020160953331.png" class="" title="image-20231020160953331"> <p>&#x3D;&#x3D;<strong>source ~&#x2F;.bashr</strong>c&#x3D;&#x3D;</p><p>就创建了一个长久的变量</p></li><li><p>在全局用户下创建一个&#x3D;&#x3D;<strong>全局环境变量</strong>&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231020161508885.png" class="" title="image-20231020161508885"> <p>编辑&#x2F;etc&#x2F;profile</p><img src="/post/deb5175a/image-20231020161904749.png" class="" title="image-20231020161904749"> <p>&#x3D;&#x3D;<strong>source &#x2F;etc&#x2F;profile</strong>&#x3D;&#x3D;</p><img src="/post/deb5175a/image-20231020162110015.png" class="" title="image-20231020162110015"></li></ol><p>全局环境变量可以在env中筛选到</p><p>全局环境变量是在系统范围内定义的，对所有用户都可见。</p><p>source 配置文件</p><p>让自定义的变量生效</p><h3 id="自定义环境变量PATH"><a href="#自定义环境变量PATH" class="headerlink" title="自定义环境变量PATH"></a><a href="#PATH">自定义环境变量PATH</a></h3><ol><li><p>创建一个文件</p><p>并且写入简单的命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim mv</span><br></pre></td></tr></table></figure><blockquote><p>echo “哈哈哈”</p></blockquote><p>然后修改其权限</p><p>因为默认是不可以执行的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 mv</span><br></pre></td></tr></table></figure></li><li><p>开始执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./mv</span><br></pre></td></tr></table></figure></li><li><p><code>./</code>在Linux中表示当前目录。当您在命令行上运行某个可执行文件时，如果该文件位于当前目录下，那么您需要在命令前&#x3D;&#x3D;<strong>加上<code>./</code>来告诉系统去当前目录中查找该文件并且执行它。</strong>&#x3D;&#x3D;</p><p>.&#x2F;文件 表示使用路径的方式执行文件，需要文件有‘x’执行权限</p><img src="/post/deb5175a/image-20231020164352326.png" class="" title="image-20231020164352326"></li></ol><p>&#x3D;&#x3D;这样知识简单的执行这个文件&#x3D;&#x3D;</p><p>我们输入mv是不可以执行的</p><hr><hr><p>真正是要添加到文件夹下面</p><ol><li><p>我们进入root用户</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir myenv</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim myenv/myenv</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure></li><li><p>修改可执行权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 myenv</span><br></pre></td></tr></table></figure></li><li><p>使用上面的.&#x2F;可以执行</p></li><li><p>添加到临时环境变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/root/myenv</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;<strong>添加到文件夹下就好了，他是在这个目录下找我们写的可执行文件</strong>&#x3D;&#x3D;</p></li><li><p>测试</p><img src="/post/deb5175a/image-20231020170204411.png" class="" title="image-20231020170204411"> </li><li><hr><p>现在重启后(临时环境变量没有啦)</p><img src="/post/deb5175a/image-20231020170704414.png" class="" title="image-20231020170704414"> <hr><p>创建全局环境变量PATH</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure><img src="/post/deb5175a/image-20231020170848487.png" class="" title="image-20231020170848487"> <p>就可以在root，任意位置输入myenv就可以输出helloworld</p></li></ol><h2 id="文件上传和下载"><a href="#文件上传和下载" class="headerlink" title="文件上传和下载"></a>文件上传和下载</h2><blockquote><p>rz,sz命令？</p><p>如何上传和下载文件？</p><p>如何形象化记忆lrzsz</p></blockquote><h3 id="文件的下载"><a href="#文件的下载" class="headerlink" title="文件的下载"></a>文件的下载</h3><img src="/post/deb5175a/image-20231020231404408.png" class="" title="image-20231020231404408"> <p>下面的目录是根据finalshell登录的信息xurunbo</p><p>那就是普通用户</p><p>如果想得到root用户的文件夹</p><p>就root登录</p><p>而不是再shell中简单的切换到root里面</p><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>就从我们主机拖拽文件拖进去就好了</p><h3 id="rz-sz命令"><a href="#rz-sz命令" class="headerlink" title="rz,sz命令"></a>rz,sz命令</h3><blockquote><p>如何形象化记忆？rz和sz</p><p>如何使用呢？</p></blockquote><hr><hr><blockquote><p>不用finalshell的进行传输文件</p><p>而是用命令</p><ol><li><p>安装 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install lrzsz</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>R</strong>eceive <strong>Z</strong>ipped（rz）：rz命令是将文件从远程计算机发送到本地计算机，可以将字母R理解为“接收”或“接受”。另外，“Zipped”表示传输的文件通常都是经过压缩处理的，因此将字母Z与rz相关联也有助于记忆。</li><li><strong>S</strong>end <strong>Z</strong>ipped（sz）：sz命令是将文件从本地计算机发送到远程计算机，可以将字母S理解为“发送”或“发出”。同样，“Zipped”表示传输的文件通常都是经过压缩处理的，因此将字母Z与sz相关联也有助于记忆</li></ul></blockquote></li><li><p>rz.sz都需要再findshell里面进行</p><ol><li><p>rz的使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rz</span><br></pre></td></tr></table></figure><img src="/post/deb5175a/image-20231020232416582.png" class="" title="image-20231020232416582"><p>&#x3D;&#x3D;<strong>会默认的下载到当前工作目录下也就是~&#x2F;</strong>&#x3D;&#x3D; </p></li><li><p>sz的使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sz Linux文件</span><br></pre></td></tr></table></figure><p>默认会在我们主机的桌面创建一个fsdownload的文件夹，放在里面</p></li></ol><p>&#x3D;&#x3D;<strong>拖拽的形式会更快一些</strong>&#x3D;&#x3D;</p></li></ol></blockquote><h2 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h2><blockquote><p>如何tar命令&#x3D;&#x3D;压缩或者解压&#x3D;&#x3D;tar&#x2F;gzip文件？</p><p>如何用zip，unzip命令&#x3D;&#x3D;压缩或解压&#x3D;&#x3D;zip文件？</p></blockquote><p>Linux常用:tar，和gzip 和zip</p><p>windows常常用：zip，7zip，rar</p><hr><ul><li>.tar是归档文件，简单的组装到.tar的文件夹内，没有减少太多体积，简单的封装</li><li>.gz常见额外i.tar.gz,gzip使用gzip压缩算法，将文件压缩到一个文件内，可以极大的减少压缩后的体积</li></ul><h3 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h3><p>function：压缩文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar [-c -v -z -x -f ]</span><br></pre></td></tr></table></figure><blockquote><p>-c :（creat创建）创建压缩文件  —压缩模式</p><p>-x  ：(extract提取)创建解压文件—–解压模式</p><p>-z 用gzip的压缩方式,&#x3D;&#x3D;<strong>后缀是.gz或者.tar.gz</strong>&#x3D;&#x3D;</p><p>-v （visual）可视化</p><p>-f 指定&#x3D;&#x3D;压缩的目的地&#x3D;&#x3D;，或者&#x3D;&#x3D;要解压的文件&#x3D;&#x3D;</p><p>-C：指定解压的位置，因为此时f指定的是要解压的文件,所以-C是和解压配合使用的</p></blockquote><h3 id="tar压缩文件"><a href="#tar压缩文件" class="headerlink" title="tar压缩文件"></a>tar压缩文件</h3><ol><li><img src="/post/deb5175a/image-20231021093928848.png" class="" title="image-20231021093928848"> </li><li><pre><code>tar -cvf cvf.tar 1.txt 2.txt 3.txt<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   &#123;% asset_img image-20231021094039705.png image-20231021094039705 %&#125; </span><br><span class="line"></span><br><span class="line">3. &#123;% asset_img image-20231021094102442.png image-20231021094102442 %&#125; </span><br><span class="line"></span><br><span class="line">   &gt; 就得到了一个tar的简单压缩文件，默认是在当前工作目录下</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; f的参数就是指定压缩到哪里</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; ==**f一定在最后,且第一个参数对应的是f的参数**==</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">gzip的压缩方式</span><br><span class="line"></span><br><span class="line">1. ```</span><br><span class="line">   tar -zcvf zcvf.gz 1.txt 2.txt 3.txt</span><br></pre></td></tr></table></figure></code></pre></li><li><img src="/post/deb5175a/image-20231021094426024.png" class="" title="image-20231021094426024"> </li><li><img src="/post/deb5175a/image-20231021094438157.png" class="" title="image-20231021094438157"> <p>解压效果非常显著</p></li></ol><h3 id="tar解压文件"><a href="#tar解压文件" class="headerlink" title="tar解压文件"></a>tar解压文件</h3><ol><li><p>解压简单.tar 文件</p></li><li><pre><code>tar -xvf cvf.tar<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   默认是在当前目录下</span><br><span class="line"></span><br><span class="line">3. ```</span><br><span class="line">   tar -xvf cvf.tar -C /test/xvf</span><br></pre></td></tr></table></figure>指定解压到哪里</code></pre></li><li><p>如何解压的是gzip问格式的文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf cvf.tar</span><br><span class="line">tar -zxvf cvf.gz -C /test/xvf</span><br></pre></td></tr></table></figure><blockquote><p>z一定要在前面，告诉他我是解压gzip文件的</p><p>f一定在后面，用来指定**&#x3D;&#x3D;被解压的文件&#x3D;&#x3D;<strong>，和</strong>&#x3D;&#x3D;压缩到哪的文件&#x3D;&#x3D;**</p><p>-C必须单独使用，指定我解压的目的地，和其他参数分开，但是不能帮助创建文件夹</p></blockquote></li></ol><h3 id="zip命令"><a href="#zip命令" class="headerlink" title="zip命令"></a>zip命令</h3><p>&#x3D;&#x3D;好用&#x3D;&#x3D;</p><p>用来zip</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zip [-r] 参数1，2，3，4，</span><br><span class="line">参数一就是要解压的位置</span><br><span class="line">默认是在当前工作目录下</span><br></pre></td></tr></table></figure><p>-r就是recursive迭代</p><p>被压缩的目标内有文件夹的时候使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zip test.zip 1.txt 2.txt 3.txt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zip -r test.zip abc 1.txt</span><br></pre></td></tr></table></figure><h3 id="unzip命令"><a href="#unzip命令" class="headerlink" title="unzip命令"></a>unzip命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip 文件.zip [-d]</span><br></pre></td></tr></table></figure><p>默认解压到当前工作目录下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip 文件.zip -d 指定目录</span><br></pre></td></tr></table></figure><blockquote><p>比tar好用</p><p>没有zip严格</p><p>可以帮忙创建文件夹</p><p>-C用法和tar一样(单独指出)</p><p>&#x3D;&#x3D;<strong>解压的时候同名的文件会被覆盖！</strong>&#x3D;&#x3D;</p></blockquote><p>seeyouagain</p><img src="/post/deb5175a/image-20231021102513209.png" class="" title="image-20231021102513209"> ]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好听的歌</title>
      <link href="/post/2feff901.html"/>
      <url>/post/2feff901.html</url>
      
        <content type="html"><![CDATA[<img src="/post/2feff901/xiawanzhechangyu.png" class="" title="xiawanzhechangyu"><p>&#x3D;&#x3D;下完这场雨&#x3D;&#x3D;</p>]]></content>
      
      
      <categories>
          
          <category> 歌曲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学</title>
      <link href="/post/3fb56f9d.html"/>
      <url>/post/3fb56f9d.html</url>
      
        <content type="html"><![CDATA[<h1 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h1><h2 id="S1–数理逻辑"><a href="#S1–数理逻辑" class="headerlink" title="S1–数理逻辑"></a>S1–数理逻辑</h2><h3 id="Z1命题逻辑的基本概念"><a href="#Z1命题逻辑的基本概念" class="headerlink" title="Z1命题逻辑的基本概念"></a>Z1命题逻辑的基本概念</h3><h4 id="J1命题与联结词"><a href="#J1命题与联结词" class="headerlink" title="J1命题与联结词"></a>J1命题与联结词</h4><h5 id="命题：能判断-真假-的-陈述句-成为命题"><a href="#命题：能判断-真假-的-陈述句-成为命题" class="headerlink" title="命题：能判断&#x3D;&#x3D;真假&#x3D;&#x3D;的&#x3D;&#x3D;陈述句&#x3D;&#x3D;成为命题"></a>命题：能判断&#x3D;&#x3D;真假&#x3D;&#x3D;的&#x3D;&#x3D;陈述句&#x3D;&#x3D;成为命题</h5><blockquote><ol><li><h3 id="陈述句"><a href="#陈述句" class="headerlink" title="陈述句"></a>陈述句</h3></li><li><h3 id="能判断真假"><a href="#能判断真假" class="headerlink" title="能判断真假"></a>能判断真假</h3></li></ol></blockquote><p>&#x3D;&#x3D;真值&#x3D;&#x3D;命题判断真假的结果</p><p>True或者False</p><p>&#x3D;&#x3D;任何命题的真值都是唯一的&#x3D;&#x3D;</p><p>例子：</p><blockquote><img src="/post/3fb56f9d/image-20231006133043982.png" class="" title="image-20231006133043982"><p>1,2,7</p><p>3的值是不确定的</p><p>7–&#x3D;&#x3D;未知不代表他真值不唯一&#x3D;&#x3D;</p></blockquote><img src="/post/3fb56f9d/image-20231006132756425.png" class="" title="image-20231006132756425"><p>素数：大衣与的自然数，除了1和它自身外不能被其他自然数整除的数</p><p>其他的就是&#x3D;&#x3D;合数&#x3D;&#x3D;</p><p><code>我正在说假话</code></p><p>假设是真的，我在说假话</p><p>如果是假的，我再说真话</p><p>真假都有对应的方法，真值不唯一</p><hr><p>如果说话者实际上正在说谎，那么这个陈述句的真值为真。</p><p>但如果说话者实际上没有说谎，那么这个陈述句的真值为假。</p><p>因此，它的真值取决于说话者的实际情况。是&#x3D;&#x3D;悖论&#x3D;&#x3D;</p><p>&#x3D;&#x3D;悖论不是命题&#x3D;&#x3D;</p><p>&#x3D;&#x3D;悖论&#x3D;&#x3D;是指一个陈述或推理过程，包含自相矛盾或导致无限循环的情况。</p><blockquote><p>我正在救火”这个陈述，而事实上你并没有在救火，那么这个陈述就是一个悖论，因为它包含了自相矛盾的信息。这是一个自我矛盾的陈述，因为你声称正在做某事，但实际上并没有在做。</p></blockquote><h5 id="联结词"><a href="#联结词" class="headerlink" title="联结词"></a>联结词</h5><ol><li>且（and）&#x3D;&#x3D;合取&#x3D;&#x3D;：表示两个条件同时满足。</li><li>或（or）：&#x3D;&#x3D;析取&#x3D;&#x3D;表示两个条件中至少有一个满足。</li><li>非（not）：&#x3D;&#x3D;非&#x3D;&#x3D;表示取反或否定一个条件。</li><li>若…则…（if…then…）&#x3D;&#x3D;蕴含联结词&#x3D;&#x3D;：表示条件语句，如果前面的条件成立，则后面的条件也成立。</li><li>&#x3D;&#x3D;等价式&lt;-&gt;当且仅当二者都为真或者都为假的时候才为真&#x3D;&#x3D;</li></ol><p>&#x3D;&#x3D;<strong>蕴含连接词仅当p真q假的时候整体为假，其余全真</strong>&#x3D;&#x3D;</p><blockquote><p>自然语言里</p><p>&#x3D;&#x3D;p-&gt;q&#x3D;&#x3D;</p><p>等价于</p><p>只要p就q</p><p>如果p就q</p><p>若p就q</p><p>p仅当q</p><h3 id="只有q才p"><a href="#只有q才p" class="headerlink" title="&#x3D;&#x3D;只有q才p&#x3D;&#x3D;"></a>&#x3D;&#x3D;只有q才p&#x3D;&#x3D;</h3><h3 id="除非q才p"><a href="#除非q才p" class="headerlink" title="&#x3D;&#x3D;除非q才p&#x3D;&#x3D;"></a>&#x3D;&#x3D;除非q才p&#x3D;&#x3D;</h3><h3 id="除非q否则非p"><a href="#除非q否则非p" class="headerlink" title="&#x3D;&#x3D;除非q否则非p&#x3D;&#x3D;"></a>&#x3D;&#x3D;除非q否则非p&#x3D;&#x3D;</h3><hr><hr><ol><li><p>相容或（inclusive or）：也称为&#x3D;&#x3D;逻辑或&#x3D;（logical or），&#x3D;&#x3D;表示两个条件中至少有一个成立，或者两个条件都成立&#x3D;&#x3D;。例如，如果A为真或者B为真，或者A和B都为真，则相容或成立。</p><p>&#x3D;&#x3D;pVq&#x3D;&#x3D;</p></li><li><p>排斥或（exclusive or）：也称为&#x3D;&#x3D;异或&#x3D;&#x3D;（xor），表示&#x3D;&#x3D;两个条件中只有一个成立，而不能同时成立&#x3D;&#x3D;。换句话说，如果A为真，B为假，或者A为假，B为真，则排斥或成立。如果A和B都为真，或者都为假，则排斥或不成立</p><p>&#x3D;&#x3D;（pA非q）V（非pAq）&#x3D;&#x3D;</p></li><li><table><thead><tr><th>p,q</th><th>pVq逻辑或</th><th>(pA非q）V（非pAq)异或</th></tr></thead><tbody><tr><td>0 0</td><td>0</td><td>0</td></tr><tr><td>0 1</td><td>1</td><td>1</td></tr><tr><td>1 0</td><td>1</td><td>1</td></tr><tr><td>1 1</td><td>1</td><td>0</td></tr></tbody></table><p>&#x3D;&#x3D;p,q在p与q<strong>不同时为真的条件</strong>下，p与q的<strong>相容或</strong>可以写成p与q的<strong>排斥或</strong>&#x3D;&#x3D;</p></li></ol></blockquote><h5 id="用于"><a href="#用于" class="headerlink" title="&#x3D;&#x3D;用于&#x3D;&#x3D;"></a>&#x3D;&#x3D;用于&#x3D;&#x3D;</h5><img src="/post/3fb56f9d/image-20231006144956602.png" class="" title="image-20231006144956602"><h4 id="J2命题公式及其赋值"><a href="#J2命题公式及其赋值" class="headerlink" title="J2命题公式及其赋值"></a>J2命题公式及其赋值</h4><img src="/post/3fb56f9d/image-20231006134529570.png" class="" title="image-20231006134529570"><img src="/post/3fb56f9d/image-20231006134707736.png" class="" title="image-20231006134707736"><h5 id="合式公式"><a href="#合式公式" class="headerlink" title="合式公式"></a>合式公式</h5><img src="/post/3fb56f9d/image-20231006134817928.png" class="" title="image-20231006134817928"><img src="/post/3fb56f9d/image-20231006135000240.png" class="" title="image-20231006135000240"><h5 id="公式的层次"><a href="#公式的层次" class="headerlink" title="公式的层次"></a>公式的层次</h5><img src="/post/3fb56f9d/image-20231006141001130.png" class="" title="image-20231006141001130"><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><img src="/post/3fb56f9d/image-20231006141330344.png" class="" title="image-20231006141330344"><p>单个是0层</p><p>p,q</p><p>非qVp</p><p>相当于1 和 0 取最大然后加上中间联结词造成的1等于两层</p><p>&#x3D;&#x3D;不能简单的数联结词&#x3D;&#x3D;</p><h5 id="公式的赋值"><a href="#公式的赋值" class="headerlink" title="公式的赋值"></a>公式的赋值</h5><img src="/post/3fb56f9d/image-20231006141540826.png" class="" title="image-20231006141540826"><img src="/post/3fb56f9d/image-20231006141642336.png" class="" title="image-20231006141642336"><p>&#x3D;&#x3D;含有n个命题变变项的公式共有2<sup>n</sup>个不同的赋值&#x3D;&#x3D;</p><p>例如A:pVq</p><table><thead><tr><th>p</th><th>q</th><th>pVq</th><th>~~</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>成真赋值</td></tr><tr><td>0</td><td>0</td><td>0</td><td>成假赋值</td></tr><tr><td>1</td><td>0</td><td>1</td><td>成真赋值</td></tr><tr><td>0</td><td>1</td><td>1</td><td>成真赋值</td></tr></tbody></table><p>四种不同的赋值</p><p>也叫</p><h5 id="真值表"><a href="#真值表" class="headerlink" title="真值表"></a>真值表</h5><p>列出2<sup>n</sup>个赋值</p><img src="/post/3fb56f9d/image-20231006142223309.png" class="" title="image-20231006142223309"><p>0 0</p><p>0 1</p><p>1 0</p><p>1 1</p><p>这才是(二进制)标准</p><img src="/post/3fb56f9d/image-20231006142407034.png" class="" title="image-20231006142407034"><h5 id="公式的分类"><a href="#公式的分类" class="headerlink" title="公式的分类"></a>公式的分类</h5><img src="/post/3fb56f9d/image-20231006142536683.png" class="" title="image-20231006142536683"><p>分成三类</p><blockquote><ol><li>永真式</li><li>矛盾式</li><li>非永真式的可满足式</li></ol></blockquote><p>永真式一定式可满足式</p><p>反之不成立</p><img src="/post/3fb56f9d/image-20231006142846827.png" class="" title="image-20231006142846827"><h5 id="哑元"><a href="#哑元" class="headerlink" title="哑元"></a>哑元</h5><img src="/post/3fb56f9d/image-20231006143030416.png" class="" title="image-20231006143030416"><h3 id="Z2命题逻辑与等值演算"><a href="#Z2命题逻辑与等值演算" class="headerlink" title="Z2命题逻辑与等值演算"></a>Z2命题逻辑与等值演算</h3><h4 id="J1等值式"><a href="#J1等值式" class="headerlink" title="J1等值式"></a>J1等值式</h4><h5 id="等值式的概念"><a href="#等值式的概念" class="headerlink" title="等值式的概念"></a>等值式的概念</h5><img src="/post/3fb56f9d/image-20231006154136085.png" class="" title="image-20231006154136085"><img src="/post/3fb56f9d/image-20231006152801748.png" class="" title="image-20231006152801748"><h5 id="判断等值式的方法"><a href="#判断等值式的方法" class="headerlink" title="判断等值式的方法"></a>判断等值式的方法</h5><ol><li><p>真值表</p><img src="/post/3fb56f9d/image-20231006153009577.png" class="" title="image-20231006153009577"><p>&#x3D;&#x3D;真值表的最后一列可以省略&#x3D;&#x3D;</p></li><li><p>等值演算</p><p>引入：当命题变相太多的时候就麻烦了</p><blockquote><img src="/post/3fb56f9d/image-20231006153341382.png" class="" title="image-20231006153341382"><img src="/post/3fb56f9d/image-20231006153352543.png" class="" title="image-20231006153352543"><p>&#x3D;&#x3D;用等值式及等值规则进行推算的过程称为等值演算&#x3D;&#x3D;</p></blockquote></li><li><p>范式</p></li></ol><h5 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h5><img src="/post/3fb56f9d/image-20231006154429418.png" class="" title="image-20231006154429418"><img src="/post/3fb56f9d/image-20231006154503965.png" class="" title="image-20231006154503965"><hr><hr><img src="/post/3fb56f9d/image-20231006155231983.png" class="" title="image-20231006155231983"><h5 id="等值演算运算规则"><a href="#等值演算运算规则" class="headerlink" title="等值演算运算规则"></a>等值演算运算规则</h5><blockquote><p>在等值演算中，析取（disjunction）、合取（conjunction）和蕴含（implication）的运算顺序是从左到右进行的。</p><p>具体来说，如果有一个等值演算表达式如下： A ∨ B ∧ C → D</p><p>首先进行析取运算 A ∨ B，然后进行合取运算 (A ∨ B) ∧ C，最后进行蕴含运算 ((A ∨ B) ∧ C) → D。</p><p>需要注意的是，&#x3D;&#x3D;等值演算中的运算顺序并不会改变运算结果，因为等值演算中的运算符是满足结合律和交换律的。&#x3D;&#x3D;</p><p>关于计算方向，等值演算中的运算符是没有固定的计算方向的。换句话说，无论是析取、合取还是蕴含，都是&#x3D;&#x3D;&#x3D;从左到右进&#x3D;&#x3D;行计算的。</p><img src="/post/3fb56f9d/image-20231006155005201.png" class="" title="image-20231006155005201"></blockquote><h5 id="判断公式类型原理"><a href="#判断公式类型原理" class="headerlink" title="判断公式类型原理"></a>判断公式类型原理</h5><img src="/post/3fb56f9d/image-20231006155337977.png" class="" title="image-20231006155337977"><h4 id="J2析取范式，合取范式"><a href="#J2析取范式，合取范式" class="headerlink" title="J2析取范式，合取范式"></a>J2析取范式，合取范式</h4><h5 id="文字，简单合区式，简单析取式定义"><a href="#文字，简单合区式，简单析取式定义" class="headerlink" title="文字，简单合区式，简单析取式定义"></a>文字，简单合区式，简单析取式定义</h5><p>&#x3D;&#x3D;<strong>单个文字既是简单合取式又是简单析取式</strong>&#x3D;&#x3D;</p><img src="/post/3fb56f9d/image-20231006155549491.png" class="" title="image-20231006155549491"><img src="/post/3fb56f9d/image-20231006155640521.png" class="" title="image-20231006155640521"><h5 id="定理"><a href="#定理" class="headerlink" title="&#x3D;&#x3D;定理&#x3D;&#x3D;"></a>&#x3D;&#x3D;定理&#x3D;&#x3D;</h5><img src="/post/3fb56f9d/image-20231006155821346.png" class="" title="image-20231006155821346"><img src="/post/3fb56f9d/image-20231006160336127.png" class="" title="image-20231006160336127"><p>&#x3D;&#x3D;析取对应的是重言式&#x3D;&#x3D;</p><p>&#x3D;&#x3D;合区对应的是矛盾式&#x3D;&#x3D;</p><h5 id="范式定义"><a href="#范式定义" class="headerlink" title="范式定义"></a>范式定义</h5><img src="/post/3fb56f9d/image-20231006160526696.png" class="" title="image-20231006160526696"><p>&#x3D;&#x3D;一个文字既可以式析取式也可以是合取式&#x3D;&#x3D;</p><img src="/post/3fb56f9d/image-20231006160538153.png" class="" title="image-20231006160538153"><h5 id="经典案例》》》"><a href="#经典案例》》》" class="headerlink" title="经典案例》》》"></a>经典案例》》》</h5><blockquote><p>非q合取r</p><p>既可以看作合取范式也可以看作析取范式</p><ol><li>当看作整体的时候，两个文字的合取，得到的是简单合取式，也就是析取范式</li><li>当看成两部分的时候，一个文字既可以式析取式也可以是合取式，这时候这两边都看成式简单析取式，最终就是合取范式咯</li></ol></blockquote><h5 id="范式的性质"><a href="#范式的性质" class="headerlink" title="范式的性质"></a>范式的性质</h5><img src="/post/3fb56f9d/image-20231006161556261.png" class="" title="image-20231006161556261"><img src="/post/3fb56f9d/image-20231006161610724.png" class="" title="image-20231006161610724"> <hr><img src="/post/3fb56f9d/image-20231006161745602.png" class="" title="image-20231006161745602"><img src="/post/3fb56f9d/image-20231006161759179.png" class="" title="image-20231006161759179"><h5 id="求范式的步骤"><a href="#求范式的步骤" class="headerlink" title="求范式的步骤"></a>求范式的步骤</h5><p><a name="求范式"></a></p><img src="/post/3fb56f9d/image-20231006162007573.png" class="" title="image-20231006162007573"><p>&#x3D;&#x3D;字典顺序通常是按照英文字母的顺序进行排列，从小写字母 a 到 z。&#x3D;&#x3D;</p><h5 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h5><img src="/post/3fb56f9d/image-20231006164331993.png" class="" title="image-20231006164331993"><img src="/post/3fb56f9d/image-20231006164441937.png" class="" title="image-20231006164441937"><p>&#x3D;&#x3D;析取范式和合取范式是不唯一的&#x3D;&#x3D;</p><h4 id="J3范式的唯一性—–主范式"><a href="#J3范式的唯一性—–主范式" class="headerlink" title="J3范式的唯一性—–主范式"></a>J3范式的唯一性—–主范式</h4><p><a name="极项"></a></p><img src="/post/3fb56f9d/image-20231007205632246.png" class="" title="image-20231007205632246"><p><strong>非x和x只能痴线一个且必须出现</strong></p><h5 id="极小项与极大项的性质"><a href="#极小项与极大项的性质" class="headerlink" title="极小项与极大项的性质"></a>极小项与极大项的性质<img src="/post/3fb56f9d/image-20231007205913760.png" class="" title="image-20231007205913760"></h5><p><strong>类似，因为每个命题变相只能以自身或者非自身出现，那么组成的极小（大）项可以有2<sup>n</sup>个</strong></p><p><em><em>之后二进制对应的十进制数叫做极小（大）项的角标记作mi</em>(Mi)</em>*</p><p><strong>极大项的成假赋值只有一个也就是全部都是0的时候V</strong></p><p>析取范式里面的是极小项</p><p>合取范式里面的是极大项</p><h5 id="p，q形成的极小项与极大项"><a href="#p，q形成的极小项与极大项" class="headerlink" title="p，q形成的极小项与极大项"></a>p，q形成的极小项与极大项</h5><p>&#x3D;&#x3D;根据对应的成真&#x2F;假赋值结果得到二进制&#x3D;&#x3D;</p><img src="/post/3fb56f9d/image-20231007214345387.png" class="" title="image-20231007214345387"><hr><hr><img src="/post/3fb56f9d/image-20231007210311896.png" class="" title="image-20231007210311896"><h5 id="p，q，r形成的极小项与极大项"><a href="#p，q，r形成的极小项与极大项" class="headerlink" title="p，q，r形成的极小项与极大项"></a>p，q，r形成的极小项与极大项</h5><img src="/post/3fb56f9d/image-20231007210443216.png" class="" title="image-20231007210443216"><h5 id="极小项与极大项的关系"><a href="#极小项与极大项的关系" class="headerlink" title="极小项与极大项的关系"></a>极小项与极大项的关系</h5><p>设mi与Mi是命题变相P1P2P3P4。。。形成的极小项和极大项则</p><p>&#x3D;&#x3D;观察可以得到非mi等于Mi&#x3D;&#x3D;</p><p><code>非Mi=mi</code></p><p><code>非mi=Mi</code></p><h5 id="主范式的定义"><a href="#主范式的定义" class="headerlink" title="主范式的定义"></a>主范式的定义</h5><img src="/post/3fb56f9d/image-20231007210824016.png" class="" title="image-20231007210824016"><p>这样就唯一了！</p><h5 id="主范式的存在性和唯一性定理"><a href="#主范式的存在性和唯一性定理" class="headerlink" title="&#x3D;&#x3D;主范式的存在性和唯一性定理&#x3D;&#x3D;"></a>&#x3D;&#x3D;主范式的存在性和唯一性定理&#x3D;&#x3D;</h5><p><strong>任何命题公式都存在与之等值的&#x3D;&#x3D;主析取范式&#x3D;&#x3D;和&#x3D;&#x3D;主合取范式&#x3D;&#x3D;，并且是唯一的</strong></p><h6 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h6><img src="/post/3fb56f9d/image-20231007211521765.png" class="" title="image-20231007211521765"><img src="/post/3fb56f9d/image-20231007211610430.png" class="" title="image-20231007211610430"><h6 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h6><img src="/post/3fb56f9d/image-20231007211818242.png" class="" title="image-20231007211818242"><p>&#x3D;&#x3D;要做到都是主析取范式，bc都要保证每一项都含所有命题或者其否定。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;但是，bc不等值。所以一个含p,另一个只能含非p&#x3D;&#x3D;</p><h5 id="★求主析取范式-主合取范式★"><a href="#★求主析取范式-主合取范式★" class="headerlink" title="★求主析取范式&#x2F;主合取范式★"></a>★求主析取范式&#x2F;主合取范式★</h5><blockquote><ol><li><p><a href="#%E6%B1%82%E8%8C%83%E5%BC%8F">求析取范式&#x2F;合取范式</a></p></li><li><p>&#x3D;&#x3D;把析取（合取）范式的每一项都换成极小（大）项&#x3D;&#x3D;——-<a href="#%E6%9E%81%E9%A1%B9">极小&#x2F;大项</a></p></li><li><p>根据极小项的成真赋值只有一种得到p,q,r。。。。 现在的取值得到二进制</p></li><li><p>根据极大项的成假赋值只有一种得到p,q,r。。。。 现在的取值得到二进制</p><p>》主析取式里面的（）项是（合取式）极小项—成真赋值唯一</p><p>》主合取式里面的（）项是（析取式）极大项 —成假赋值唯一</p></li></ol></blockquote><h5 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h5><h6 id="求主析取饭式"><a href="#求主析取饭式" class="headerlink" title="&#x3D;&#x3D;求主析取饭式&#x3D;&#x3D;"></a>&#x3D;&#x3D;求主析取饭式&#x3D;&#x3D;</h6><img src="/post/3fb56f9d/image-20231007215059903.png" class="" title="image-20231007215059903"><h6 id="求主合取范式"><a href="#求主合取范式" class="headerlink" title="求主合取范式"></a>求主合取范式</h6><img src="/post/3fb56f9d/image-20231007220022671.png" class="" title="image-20231007220022671"><p>&#x3D;&#x3D;重复就保留一个就好了&#x3D;&#x3D;</p><h5 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h5><img src="/post/3fb56f9d/image-20231007220119397.png" class="" title="image-20231007220119397"><img src="/post/3fb56f9d/image-20231007220422033.png" class="" title="image-20231007220422033"><img src="/post/3fb56f9d/image-20231007220605988.png" class="" title="image-20231007220605988"><p>&#x3D;&#x3D;总结：根据公式中的命题变相的个数决定极小&#x2F;大项中文字的个数而且还是字典排序&#x3D;&#x3D;</p><p>p14</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10_5_learn_p</title>
      <link href="/post/22a81635.html"/>
      <url>/post/22a81635.html</url>
      
        <content type="html"><![CDATA[<h1 id="10-5-learn"><a href="#10-5-learn" class="headerlink" title="10.5_learn"></a>10.5_learn</h1><h2 id="字符串的split"><a href="#字符串的split" class="headerlink" title="字符串的split"></a>字符串的split</h2><p>在 Python 中，字符串的 <code>split()</code> 方法用于将字符串按照指定的分隔符进行分割，并返回一个由分割后的子字符串组成的列表。</p><p>不指定分隔符，默认情况下 <code>split()</code> 方法会以空格作为分隔符。</p><h2 id="序列解包"><a href="#序列解包" class="headerlink" title="序列解包"></a>序列解包</h2><p>在 Python 中，序列解包（Sequence Unpacking）是一种快捷的赋值方式，可以同时将一个序列中的元素分别赋值给多个变量。它可以应用于任何可迭代对象，如列表、元组、字符串等。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a,b,c = <span class="built_in">input</span>(<span class="string">&quot;请输入三个值（以空格分隔）：&quot;</span>).split()</span><br><span class="line">a=<span class="built_in">int</span>(a)</span><br><span class="line">b=<span class="built_in">int</span>(b)</span><br><span class="line">c=<span class="built_in">int</span>(c)</span><br><span class="line"><span class="built_in">print</span>(a+b+c)</span><br></pre></td></tr></table></figure><p>注意事项</p><blockquote><ol><li><p>元素数量匹配：序列解包的元素数量必须与变量数量完全匹配，否则会引发 <code>ValueError</code> 异常。这意味着如果你有一个包含三个元素的可迭代对象，你必须使用三个变量进行解包。</p></li><li><p>占位符：在某些情况下，你可能只需要解包部分元素，而不需要使用全部的元素。为了达到这个目的，你可以使用占位符 <code>_</code> 来忽略解包的特定元素。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pythonCopy Codea, _, c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>在这个例子中，我们忽略了第二个元素，将第一个和第三个元素分别赋值给变量 <code>a</code> 和 <code>c</code>。</p></li><li><p>&#x3D;&#x3D;<strong>星号表达式</strong>&#x3D;&#x3D;：当解包的元素数量不确定时，你可以使用星号表达式来收集剩余的元素。星号表达式用于指定一个变量名，&#x3D;&#x3D;在解包时它将被赋值为一个列表&#x3D;&#x3D;，其中包含所有剩余的元素。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, *rest =<span class="string">&quot;helloworld&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(rest)  </span><br><span class="line"><span class="comment"># h</span></span><br><span class="line"><span class="comment"># [&#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure><p>在这个例子中，变量 <code>a</code> 接收第一个元素，而变量 <code>rest</code> 接收剩余的元素作为列表。</p></li><li><p>可迭代对象类型：序列解包可以应用于任何可迭代对象，如列表、元组、字符串等。确保你正在使用一个可迭代对象来进行解包操作。</p></li></ol></blockquote><h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>range(m,n)</p><p>得到一个序列[m,n-1]</p><blockquote><ol><li>范围：<code>a</code> 是序列的起始值，<code>b</code> 是序列的结束值。生成的序列包含的整数范围是 <code>[a, b)</code>，也就是从 <code>a</code> 开始，直到 <code>b-1</code> 结束。</li><li>步长：<code>range()</code> 函数还可以接受一个可选的第三个参数 <code>step</code>，用于指定每个元素之间的步长。默认步长为 1。例如，<code>range(1, 5, 2)</code> 将生成 1、3 这两个数。</li><li>迭代器：<code>range()</code> 返回的是一个迭代器对象，而不是一个列表。&#x3D;&#x3D;这意味着它并不会立即生成整个序列，而是在每次迭代时生成序列的下一个值。这样可以节省内存空间。&#x3D;&#x3D;</li><li>转换为列表：如果需要将序列转换为列表，可以使用 <code>list()</code> 函数，例如 <code>list(range(1, 5))</code>。</li><li>使用技巧：<code>range()</code> 函数在循环中经常使用，特别是当你需要迭代一定次数的时候。</li></ol></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a=int(input())</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>,<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d &quot;</span>%(i),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="comment"># 13579</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>当 <code>range()</code> 函数只有一个参数 <code>n</code> 时，它将生成一个从 0 开始、步长为 1、不包含 <code>n</code> 的整数序列。换句话说，生成的范围是 <code>[0, n-1]</code>。</strong></p><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>Python 中的整数转换为小数时，通常使用内置函数 <code>float()</code> 将其转换为浮点数（floating-point number），&#x3D;&#x3D;而不是使用 <code>double</code> 类型。&#x3D;&#x3D;</p><p>因为 Python 的浮点数类型默认使用双精度浮点数（double-precision floating-point number），它能够表示的范围和精度已经非常高了，因此在一般情况下没有必要使用更高精度的数据类型。</p><p>Python 的浮点数采用 IEEE 754 标准表示，使用 64 位二进制数来表示一个浮点数。由于 Python 中整数的数值范围相对较大，在 64 位浮点数的范围内，整数转换为浮点数时不会出现精度问题。</p><p><strong>在 Python 中，默认情况下，整数转换为浮点数时会以添加 <code>.0</code> 的形式表示。转换后的浮点数会保留与整数相同的数值，只是类型变为了浮点数。</strong></p><p>对于浮点数的小数部分，Python 会根据需要自动进行舍入和精度处理。默认情况下，Python 的浮点数类型可表示大约 15 位的有效数字。然而，具体的精度可能因底层计算机硬件和操作系统等因素而有所差异。</p><h2 id="字符串的乘法"><a href="#字符串的乘法" class="headerlink" title="字符串的乘法"></a>字符串的乘法</h2><p>可以使用字符串乘法操作符 <code>*</code> 来将一个字符串重复多次。</p><p><code>string</code> 表示要重复的字符串，<code>n</code> 表示要重复的次数。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">m,n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">str</span>(m)*n)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到n个m的数据</p><p>mmmmmmmmm.&gt;&gt;&gt;&gt;&gt;n个</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">m,n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">str</span>(m)*n)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcplus</span>(<span class="params">m,n</span>):</span><br><span class="line">    result=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        result+=<span class="built_in">str</span>(m)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(result)</span><br><span class="line"></span><br><span class="line">a,b=<span class="built_in">input</span>().split()</span><br><span class="line">a=<span class="built_in">int</span>(a)</span><br><span class="line">b=<span class="built_in">int</span>(b)</span><br><span class="line">c=<span class="built_in">range</span>(<span class="number">1</span>,b+<span class="number">1</span>)</span><br><span class="line"><span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">    <span class="built_in">sum</span>+=funcplus(a,i)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="占位符-哑巴变量"><a href="#占位符-哑巴变量" class="headerlink" title="_占位符,哑巴变量"></a>_占位符,哑巴变量</h2><p>Python 中，下划线 <code>_</code> 通常用作一个临时的占位符或哑变量。它的具体用法和含义取决于上下文。</p><blockquote><ol><li>作为临时变量名：</li><li>不关心的变量</li></ol></blockquote><p>Python 中的 <code>_</code> 并没有特殊的语法意义，它只是一个普通的变量名，因此它的值可以被重新赋值，并且可以在代码中使用。但是约定俗成地，将 <code>_</code> 视为一个通用的占位符是一种常见的做法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#打印十次1</span></span><br></pre></td></tr></table></figure><h2 id="python的1-2和从c-c-的1-2"><a href="#python的1-2和从c-c-的1-2" class="headerlink" title="python的1&#x2F;2和从c&#x2F;c++的1&#x2F;2"></a>python的1&#x2F;2和从c&#x2F;c++的1&#x2F;2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># 2*n+1</span></span><br><span class="line">a=<span class="literal">None</span></span><br><span class="line"><span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    a=<span class="number">1</span>/(<span class="number">2</span>*i+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">sum</span>+=a</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%.6f&quot;</span>%(<span class="built_in">sum</span>)) </span><br></pre></td></tr></table></figure><hr><h2 id=""><a href="#" class="headerlink" title="**"></a>**</h2><p><img src="/10.5_learn/image-20231005214859092.png" alt="image-20231005214859092"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    a=i+<span class="number">1</span></span><br><span class="line">    b=<span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">    c=(-<span class="number">1</span>)**(a+<span class="number">1</span>)</span><br><span class="line">    result=c*(a/b)</span><br><span class="line">    <span class="built_in">sum</span>+=result</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%.3f&quot;</span>%(<span class="built_in">sum</span>))</span><br></pre></td></tr></table></figure><h2 id="转化为十进制"><a href="#转化为十进制" class="headerlink" title="转化为十进制"></a>转化为十进制</h2><ul><li><p><code>str(m)</code>：将整数 <code>m</code> 转换为字符串类型。这一步是为了将整数转换为可以在指定进制下表示的字符串。</p></li><li><p><code>int(str(m), n)</code>：将字符串 <code>str(m)</code> 以进制 <code>n</code> 解析为一个十进制的整数。这一步是将指定进制下的字符串转换为十进制的整数。</p><blockquote><ol><li><code>int(x)</code>：将对象 <code>x</code> 转换为整数。如果 <code>x</code> 是一个字符串，则会尝试将其解析为整数。如果 <code>x</code> 是一个浮点数，则会将其转换为整数并丢弃小数部分。如果 <code>x</code> 是一个布尔值 <code>True</code>，则会转换为整数 <code>1</code>，如果是布尔值 <code>False</code>，则会转换为整数 <code>0</code>。如果 <code>x</code> 是一个其他类型的对象，则会调用 <code>x.__int__()</code> 方法来进行转换。</li><li><code>int(x, base)</code>：将字符串 <code>x</code> 以 <code>base</code> 进制解析为一个整数。<code>base</code> 的取值范围是 2 到 36，表示进制的基数。字符串 <code>x</code> 必须是合法的在进制 <code>base</code> 下的表示，否则会引发 <code>ValueError</code> 异常。</li></ol></blockquote></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num,base=<span class="built_in">input</span>().split()</span><br><span class="line">num=<span class="built_in">int</span>(num)</span><br><span class="line">base=<span class="built_in">int</span>(base)</span><br><span class="line"></span><br><span class="line">diget=<span class="number">0</span><span class="comment">#初始化最终的十进制数</span></span><br><span class="line">m=<span class="number">0</span><span class="comment">#初始化幂</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> num&gt;<span class="number">0</span>:</span><br><span class="line">    temp=num%<span class="number">10</span><span class="comment">#得到当前位的数</span></span><br><span class="line">    num//=<span class="number">10</span><span class="comment">#去掉当前位的数字开始为下一位准备</span></span><br><span class="line">    diget+=temp*(base**m)<span class="comment">#将当前位的数字乘以对应的进制幂加到十进制结果中</span></span><br><span class="line">    m=m+<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(diget)</span><br></pre></td></tr></table></figure><h2 id="递增区别"><a href="#递增区别" class="headerlink" title="递增区别"></a>递增区别</h2><p>Python 没有像 C++ 那样的自增运算符 ++。在 Python 中，你可以使用变量本身进行递增，例如：<code>x += 1</code></p>]]></content>
      
      
      <categories>
          
          <category> learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9_27_learn_p</title>
      <link href="/post/ed67a573.html"/>
      <url>/post/ed67a573.html</url>
      
        <content type="html"><![CDATA[<h2 id="decode"><a href="#decode" class="headerlink" title="decode"></a>decode</h2><p>字符串的 <code>decode()</code> 方法用于将字节序列解码为字符串。它是 <code>encode()</code> 方法的逆操作。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes_object.decode(encoding=&quot;utf-8&quot;, errors=&quot;strict&quot;)</span><br></pre></td></tr></table></figure><p>其中，<code>bytes_object</code> 为要解码的&#x3D;&#x3D;字节序列&#x3D;&#x3D;，<code>encoding</code> 为&#x3D;&#x3D;指定的编码方式&#x3D;&#x3D;，<code>errors</code> 为可选参数，表示解码过程中遇到无法解码的字节应该如何处理。</p><p>将字节序列以 UTF-8 编码解码为字符串：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bytes_obj = <span class="string">b&quot;\xe4\xbd\xa0\xe5\xa5\xbd&quot;</span></span><br><span class="line">decoded_str = bytes_obj.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(decoded_str)  <span class="comment"># 输出：你好</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="encode"><a href="#encode" class="headerlink" title="encode"></a>encode</h2><p><code>encode()</code> 是字符串对象的一个方法，用于将字符串转换为指定的字节序列（即编码）。该方法接受一个参数，即表示所需编码的字符集（如 UTF-8、ASCII 等）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string.encode(encoding)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将字符串转换为 UTF-8 编码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&quot;你好&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串以 UTF-8 编码转换为字节序列</span></span><br><span class="line">encoded_text = text.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(encoded_text)  <span class="comment"># 输出：b&#x27;\xe4\xbd\xa0\xe5\xa5\xbd&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><p>&#x3D;&#x3D;在 Python 中，默认情况下，一个字符是一个字节&#x3D;&#x3D;。然而，对于汉字（中文字符），它们通常使用多个字节来表示。具体地说，UTF-8 编码是一种常见的字符编码方式，它使用变长字节序列来表示字符，其中&#x3D;&#x3D;大部分汉字使用三个字节表示。&#x3D;&#x3D;</p><p>要确定一个字符串的字节数，可以使用 <code>len()</code> 函数&#x3D;&#x3D;获取字符串的字符数。&#x3D;&#x3D;</p><p>如果字符串使用 UTF-8 编码，则可以通过将字符串转换为字节类型，然后获取长度来计算字节数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text =<span class="string">&quot;你好啊&quot;</span></span><br><span class="line">byte=text.encode(<span class="string">&quot;utf-8&quot;</span>)<span class="comment">#得到字节数组</span></span><br><span class="line"><span class="comment"># print(type(text))</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(byte))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;字符串的字节个数是<span class="subst">&#123;<span class="built_in">len</span>(byte)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="sys得到当前环境的编码格式"><a href="#sys得到当前环境的编码格式" class="headerlink" title="sys得到当前环境的编码格式"></a>sys得到当前环境的编码格式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.getdefaultencoding())</span><br></pre></td></tr></table></figure><h2 id="文件读取的open"><a href="#文件读取的open" class="headerlink" title="文件读取的open"></a>文件读取的open</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f=open(&quot;./1.txt&quot;, &quot;r&quot;)</span><br><span class="line">print(f.read(3))</span><br></pre></td></tr></table></figure><ol><li><p>默认是以gbk解码的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f=<span class="built_in">open</span>(<span class="string">&quot;./1.txt&quot;</span>, <span class="string">&quot;r&quot;</span>,errors=<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="comment"># 鍝堝搱鍝堝搱鍝堝搱</span></span><br><span class="line"><span class="comment"># 鍛滃憸鍛滃憸鍛</span></span><br><span class="line"><span class="comment"># 鍣㈠櫌鍣㈠櫌</span></span><br></pre></td></tr></table></figure></li><li><p>当解码格式和编码格式相同的时候read()的参数就是对应个数据</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打开文件&quot;</span>)</span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&quot;./1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">printf(f.read(<span class="number">3</span>))</span><br><span class="line">文件是全中文，此时得到的是前三个字符,而不是三个字节，因为解码的格式是utf8和文件的编码格式相同</span><br></pre></td></tr></table></figure></li><li><p>解码格式和编码格式不同的时候就用到,强行用默认的gbk解码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f=<span class="built_in">open</span>(<span class="string">&quot;./1.txt&quot;</span>, <span class="string">&quot;r&quot;</span>,errors=<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="comment"># 鍝堝搱鍝堝搱鍝堝搱</span></span><br><span class="line"><span class="comment"># 鍛滃憸鍛滃憸鍛</span></span><br><span class="line"><span class="comment"># 鍣㈠櫌鍣㈠櫌</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tree_Hole</title>
      <link href="/post/f58d7a3b.html"/>
      <url>/post/f58d7a3b.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cppp2.0</title>
      <link href="/post/b4ccccea.html"/>
      <url>/post/b4ccccea.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h1><p>本阶段主要针对C++&#x3D;&#x3D;面向对象&#x3D;&#x3D;编程技术做详细讲解，探讨C++中的核心和精髓。</p><h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p><ul><li>代码区：存放<strong>函数体</strong>的<strong>二进制代码</strong>，由<strong>操作系统</strong>进行管理的</li><li>注释不在代码区</li><li>全局区：存放<strong>全局变量和静态变量以及常量</strong></li><li>栈区：由<strong>编译器自动分配释放</strong>, 存放<strong>函数的参数值</strong>,<strong>局部变量</strong>等</li><li>堆区：由**程序员分配和释放,**<strong><strong>若程序员不释放,程序结束时由操作系统回收</strong></strong></li></ul><p><strong>内存四区意义：</strong></p><p>不同区域存放的数据，<strong>赋予不同的生命周期</strong>, 给我们更大的<strong>灵活编程</strong></p><h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>​<strong>在程序编译后，生成了exe可执行程序</strong>，<strong>未执行该程序前</strong>分为两个区域</p><p>​<strong>代码区：</strong></p><p>​存放 CPU 执行的机器指令</p><p>​代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，<strong>只需要在内存中有一份代码即可</strong></p><p>​代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令,<strong>金币变点券</strong></p><p>​<strong>全局区：</strong></p><p>​<strong>全局变量 和 静态变量</strong>存放在此.</p><p>​全局区还包含了<strong>常量区</strong>, <strong>字符串常量和全局常量</strong>存放在此.</p><p>&#x3D;&#x3D;<strong>局部常量也局部变量都在栈区</strong>&#x3D;&#x3D;</p><p>​&#x3D;&#x3D;该区域的数据在程序结束后由操作系统释放&#x3D;&#x3D;.</p><img src="/post/b4ccccea/image-20230725153630117.png" class="" title="image-20230725153630117"><hr><p>(int)指针的地址，是不被定义的行为.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">10</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;a)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;b)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;g_a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;g_b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;s_a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;s_b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;<span class="string">&quot;hello world&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;c_g_a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;c_g_b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;c_l_a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;c_l_b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印结果：</p><p><strong>局部变量</strong>a地址为： 6422044<br><strong>局部变量</strong>b地址为： 6422040<br>全局变量g_a地址为： 4206608<br>全局变量g_b地址为： 4206612<br>静态变量s_a地址为： 4206616<br>静态变量s_b地址为： 4206620<br>字符串常量地址为： 4210842<br>全局常量c_g_a地址为： 4210692<br>全局常量c_g_b地址为： 4210696<br><strong>局部常量</strong>c_l_a地址为： 6422036<br><strong>局部常量</strong>c_l_b地址为： 6422032<br>请按任意键继续. . .</p><img src="/post/b4ccccea/1545017602518.png" class="" width="1545017602518"><p>总结：</p><ul><li>C++中在<strong>程序运行前</strong>分为全局区和代码区</li><li>代码区特点是<strong>共享和只读</strong></li><li>全局区中存放&#x3D;&#x3D;全局变量、静态变量、常量&#x3D;&#x3D;,<strong>不包括局部常量和局部变量</strong></li><li>常量区中存放 const修饰的<strong>全局常量  和 字符串常量</strong></li></ul><h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p>​<strong>栈区：</strong><strong><strong>编译器的天下.</strong></strong></p><p>​由<strong>编译器</strong>自动分配释放, 存放<strong>函数的参数值,局部变量</strong>等</p><p>​注意事项：<strong>不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;<span class="comment">//理论上第一次打印10</span></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;<span class="comment">//第二次打印乱码，就是因为编译器帮你做了一次保留，栈区的数据由编译器主宰。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>堆区：</strong></p><p>​由<strong>程序员分配释放,若程序员不释放,程序结束时由操作系统回收</strong></p><p>​在C++中<strong>主要利用new在堆区开辟内存</strong></p><p>​&#x3D;&#x3D;并且返回new出来内存的地址，也就是指针！&#x3D;&#x3D;</p><img src="/post/b4ccccea/image-20230725160019240.png" class="" title="image-20230725160019240"><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;<span class="comment">//都是10，因为堆区的数据只有点击了x才被释放。在此之前一直存在。不像堆区离开了局部（函数）就被释放了，虽然编译器会帮你保留一次，但第二次就要出问题了。</span></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>堆区数据由程序员管理开辟和释放</p><p>堆区数据利用new关键字进行开辟内存</p><h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>​C++中利用&#x3D;&#x3D;new&#x3D;&#x3D;操作符在堆区开辟数据</p><p>​堆区开辟的数据，<strong>由程序员手动开辟，手动释放</strong>，释放利用操作符 &#x3D;&#x3D;delete&#x3D;&#x3D;</p><p>​语法：<code> new 数据类型</code>(初始值)</p><p>​利用new创建的数据，<strong>会返回该数据对应的类型的指针(地址)</strong></p><p>int *a&#x3D;new int(10)</p><p>​&#x3D;&#x3D;最后需要delete对应的指针！&#x3D;&#x3D;加new返回的 指针！</p><blockquote><img src="/post/b4ccccea/image-20230725160534499.png" class="" title="image-20230725160534499"></blockquote><p>​&#x3D;&#x3D;<strong>释放的空间不可访问</strong>&#x3D;&#x3D;</p><p><strong>示例1： 基本语法</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用delete释放堆区数据</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//15735568</span></span><br></pre></td></tr></table></figure><p><strong>示例2：开辟数组</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//开辟字符串,开辟字符串数组的时候换成[]再加个数</span></span><br><span class="line">    string* str=<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    cout&lt;&lt;*str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = i + <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []  arr;</span><br><span class="line">    <span class="keyword">delete</span> str;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p><strong>作用： <strong>给</strong>变量</strong>起别名</p><p>土豆，马铃薯都是。。</p><p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p><p>类型得相同</p><img src="/post/b4ccccea/image-20230725170131910.png" class="" title="image-20230725170131910"><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h3><ul><li><strong>引用必须初始化</strong></li><li>引用在初始化后，不可以改变也就是</li><li>一旦引用被初始化绑定到一个对象上，它将一直引用该对象，无法改变引用所绑定的对象。</li></ul><p>示例：</p><img src="/post/b4ccccea/image-20230725170414023.png" class="" title="image-20230725170414023"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line"><span class="type">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line">    <span class="comment">//实际上是操作a的值。。</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利<strong>用引用的技术让形参修饰实参</strong></p><p><strong>优点：</strong>可以简化指针修改实参</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sp1</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sp2</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=*a;</span><br><span class="line">    *a=*b;</span><br><span class="line">    *b=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sp3</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入两个数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;值传递，不可以修改实参的本身&quot;</span>&lt;&lt;endl;</span><br><span class="line">      <span class="built_in">sp1</span>(a,b);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;地址传递--指针，可以修改实参的本身&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">sp2</span>(&amp;a,&amp;b);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;地址传递--引用，可以修改实参的本身&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">sp3</span>(a,b);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>总结：<strong>通过引用参数产生的效果同按地址传递是一样的</strong>。引用的语法更清楚简单</p><h5 id="当引用作为一个函数形参时，它所引用的变量的生命周期必须保证在函数的执行期间内是有效的。在函数执行期间内，对于引用所指向的变量所进行的任何修改都将影响到函数调用方式中的原始变量。"><a href="#当引用作为一个函数形参时，它所引用的变量的生命周期必须保证在函数的执行期间内是有效的。在函数执行期间内，对于引用所指向的变量所进行的任何修改都将影响到函数调用方式中的原始变量。" class="headerlink" title="当引用作为一个函数形参时，它所引用的变量的生命周期必须保证在函数的执行期间内是有效的。在函数执行期间内，对于引用所指向的变量所进行的任何修改都将影响到函数调用方式中的原始变量。"></a>当引用作为一个函数形参时，它所引用的变量的生命周期必须保证在函数的执行期间内是有效的。在函数执行期间内，对于引用所指向的变量所进行的任何修改都将影响到函数调用方式中的原始变量。</h5><p>引用和指针操作最大的区别在于，指<strong>针的方式借助的形参会占用栈区空间</strong>，而用引用则不会，<strong>因此引用节省了栈区空间！</strong></p></blockquote><hr><h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>作用：引用是可以<strong>作为函数的返回值</strong>存在的</p><p>注意：**&#x3D;&#x3D;不要返回局部变量引用和地址&#x3D;&#x3D;**</p><p><strong>也要用引用的形式去接受</strong></p><p><strong>变量有可以同时存在多个别名，别名与别名与变量之间的操作是共通的</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;b=a;</span><br><span class="line">    <span class="type">int</span> &amp;c=a;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;c=&quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用法：<em>函数调用作为左值</em></p><hr><p>在 C++ 中，<strong>不建议返回指向局部变量的引用，因为局部变量在函数执行完毕后会被销毁，而引用仍然指向该变量的内存地址。</strong>这样会导致返回的引用指向一个无效的内存位置，访问该引用可能会导致未定义行为。</p><p><strong>而静态变量是在程序运行期间一直存在的，不会在函数执行完毕后被销毁。</strong>因此，返回静态变量的引用是安全的，因为静态变量的生命周期超出了函数的作用域。</p><hr><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回a的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span><span class="comment">//全局区，在整个程序运行完才释放</span></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">    <span class="comment">//返回的a是以类型“int&amp;”返回的，所以必须要以类型“int&amp;”去接收，这里用ref去接收，即int&amp; ref = a  ，即ref为a的别名</span></span><br><span class="line"><span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果函数做左值，那么必须返回引用,ref2也是a的别名</span></span><br><span class="line"><span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">////</span></span><br><span class="line">    <span class="comment">//int &amp;别名=1000 也相当于是a的别名只不过是函数</span></span><br><span class="line"><span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">////</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>int * const 变量名字&#x3D;</p><p>费曼学习法，先学面向过程C，在学面向对象CSharp，然后又滚来学C++面向对象过程（滑稽）</p><h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p><blockquote><p>常量指针是指 指针指向的数据不可更改</p><p>const指针常量是值 指针的指向不可更改</p></blockquote><p>讲解示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line"><span class="type">int</span>&amp; ref = a; </span><br><span class="line">ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">func</span>(a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p><h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p><strong>作用：</strong>常量引用<strong>主要用来修饰形参，防止误操作</strong></p><p>在函数形参列表中，可以加改变实参</p><p>引用必须引用一块合法的内存空间</p><p>int&amp; a&#x3D;10;  不可以</p><p>const int&amp; a&#x3D;10  可以</p><p>相当于，编译器帮助这样处理.</p><p>{</p><p>int temp&#x3D;10;</p><p>const int&amp; a&#x3D;temp;</p><p>}</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="comment">//v += 10;</span></span><br><span class="line">cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="comment">//void showValue(const int* const name) &#123;</span></span><br><span class="line"><span class="comment">//v += 10;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; v &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line"><span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p><p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p><p>&#x3D;&#x3D;如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值&#x3D;&#x3D;</p><h6 id="如果函数声明有默认值，函数实现的时候就不能有默认参数"><a href="#如果函数声明有默认值，函数实现的时候就不能有默认参数" class="headerlink" title="&#x3D;&#x3D;如果函数声明有默认值，函数实现的时候就不能有默认参数&#x3D;&#x3D;"></a>&#x3D;&#x3D;如果函数<strong>声明有默认值</strong>，函数实现的时候就不能有默认参数&#x3D;&#x3D;</h6><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p><p>占一个位置，可以接受实参。</p><p><strong>占位参数必须填补</strong></p><p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> =<span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h4 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p><p><strong>函数重载满足条件：</strong></p><ul><li><p>同一个作用域下</p></li><li><p>函数名称相同</p></li><li><p>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong>（前提是参数类型不同！！！）</p></li><li><blockquote><p>函数的返回值类型不可以重载！！！</p></blockquote></li></ul><p><strong>注意:</strong>  <strong>函数的返回值不可以作为函数重载的条件</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h4><ul><li><strong>引用作为重载条件</strong></li><li>函数重载碰到<strong>函数默认参数</strong></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">func</span>(a); <span class="comment">//调用无const</span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const</span></span><br><span class="line">    相当于弄了一个临时变量</span><br><span class="line">      <span class="comment">//  int &amp;a=10 不可以</span></span><br><span class="line">      <span class="comment">//  const int &amp;a=10;可以</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免 二义性！~！！</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="&#x3D;&#x3D;4 类和对象&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>4</strong> 类和对象&#x3D;&#x3D;</h2><p>C++面向对象的三大特性为：&#x3D;&#x3D;封装、继承、多态&#x3D;&#x3D;</p><p>C++认为&#x3D;&#x3D;万事万物都皆为对象&#x3D;&#x3D;，对象上有其属性和行为</p><blockquote><p><strong>类里面的属性和行为都是成员！</strong></p><p><strong>创建具体的对象的过程叫做类的实例化！</strong></p></blockquote><p><strong>例如：</strong></p><p>​人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p><p>​车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、开空调…</p><p>​具有相同性质的&#x3D;&#x3D;对象&#x3D;&#x3D;，我们可以抽象称为&#x3D;&#x3D;类&#x3D;&#x3D;，人属于人类，车属于车类</p><h3 id="4-1-封装–1"><a href="#4-1-封装–1" class="headerlink" title="4.1 封装–1"></a>4.1 封装–1</h3><h4 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1  封装的意义"></a>4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p><p>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为<strong>加以权限控制</strong></li></ul><p><strong>封装意义一：</strong></p><p>​在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p><p><strong>示例1：</strong>设计一个圆类，求圆的周长</p><p><strong>示例代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="type">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//行为</span></span><br><span class="line"><span class="comment">//获取到圆的周长</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//2 * pi  * r</span></span><br><span class="line"><span class="comment">//获取圆的周长</span></span><br><span class="line"><span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过圆类，创建圆的对象</span></span><br><span class="line"><span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">Circle c1;</span><br><span class="line">c1.m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p><p><strong>示例2代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setname</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setid</span><span class="params">(string number)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;number=number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showmessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="keyword">this</span>-&gt;name&lt;&lt;<span class="string">&quot;----&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;number&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    string number;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    student xrb;</span><br><span class="line">    xrb.<span class="built_in">setname</span>(<span class="string">&quot;徐润波&quot;</span>);</span><br><span class="line">    xrb.<span class="built_in">setid</span>(<span class="string">&quot;542207230725&quot;</span>);</span><br><span class="line">    xrb.<span class="built_in">showmessage</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>封装意义二：</strong></p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ol><li>public        公共权限  </li><li>protected 保护权限</li><li>private      私有权限</li></ol><blockquote><p>在C++中，类的成员可以不同的访问权限，包括私有（private）、保护（protected）和公共（public）权限。这些权限决定了类的成员对于<strong>类内部和类外部</strong>的<strong>可见性和可访问性。</strong></p><p><strong>私有权限（private）是最严格的权限</strong>，它表示<strong>只有类内部的成员函数可以访问该成员，</strong>类外部的代码无法直接访问私有成员。私有成员对于类外部的用户是隐藏的，只有类内部的函数可以直接访问和操作私有成员。私有成员常用于封装类的实现细节，以确保数据的安全性和一致性。</p><p>保护权限（protected）<strong>介于私有权限和公共权限之间。</strong>保护成员<strong>可以被类内部的成员函数和派生类的成员函数访问</strong>，但对于类外部的代码是不可见的。<strong>保护成员常用于实现继承中的数据共享和派生类的访问控制。</strong></p><p>区别总结如下：</p><ul><li><strong>私有权限（private）：只有类内部的成员函数可以访问，类外部的代码无法直接访问。</strong></li><li>*<em>保护权限（protected）：类内部的成员函数和派生类的成员函数可以访问，类外部的代码无法直接访问。</em></li><li><strong>公共权限（public）：类内部的成员函数和类外部的代码都可以访问。</strong></li></ul><p>需要注意的是，这些<strong>访问权限只是在编译时进行的静态检查</strong>，<em><strong>而不是运行时的限制</strong></em>。因此，通过类的<strong>公共成员函数可以间接地访问私有和保护成员</strong>。</p></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string m_Car;</span><br><span class="line"></span><br><span class="line"><span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">m_Password = <span class="number">123456</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line"><span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line"><span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p><p>区别：</p><blockquote><ul><li><h4 id="struct-默认权限为公共"><a href="#struct-默认权限为公共" class="headerlink" title="struct 默认权限为公共"></a>struct 默认权限为公共</h4></li><li><h4 id="class-默认权限为私有"><a href="#class-默认权限为私有" class="headerlink" title="class   默认权限为私有"></a>class   默认权限为私有</h4></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">C1 c1;</span><br><span class="line">c1.m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">C2 c2;</span><br><span class="line">c2.m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 &#x3D;&#x3D;成员属性设置为私有&#x3D;&#x3D;"></a>4.1.3 &#x3D;&#x3D;成员属性设置为私有&#x3D;&#x3D;</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以<strong>自己控制读写权限</strong></p><p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p><hr><p><em>在 C++ 中，私有成员是类的成员，<strong>只有类的成员函数可以直接访问和修改私有成员。</strong>其他函数或代码块无法直接访问和修改私有成员。</em></p><p><em>然而，<strong>可以通过指针间接访问和修改私有成员</strong>。如果你有一个指向类对象的指针，你可以使用指针来访问和修改私有成员。这是因为<strong>指针可以具有与类成员函数相同的访问权限。</strong></em></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateMember;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPrivateMember</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        privateMember = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getPrivateMember</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateMember;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    MyClass* ptr = &amp;obj;</span><br><span class="line"></span><br><span class="line">    ptr-&gt;<span class="built_in">setPrivateMember</span>(<span class="number">200</span>);</span><br><span class="line">    <span class="type">int</span> value = ptr-&gt;<span class="built_in">getPrivateMember</span>();</span><br><span class="line">    cout&lt;&lt;value&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//姓名设置可读可写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取年龄</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置年龄</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情人设置为只写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">        m_Lover = lover;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">    string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Person p;</span><br><span class="line">    <span class="comment">//姓名设置</span></span><br><span class="line">    p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//年龄设置</span></span><br><span class="line">    p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情人设置</span></span><br><span class="line">    p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习案例1：设计立方体类</strong></p><p>设计立方体类(Cube)</p><p>求出立方体的面积和体积</p><p>分别用全局函数和成员函数判断两个立方体是否相等。</p><img src="/post/b4ccccea/1545533548532.png" class="" width="1545533548532"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cubic</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getwidth</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setwidth</span><span class="params">(<span class="type">int</span> width)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;width=width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getlength</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setlength</span><span class="params">(<span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;length=length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getheight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setheight</span><span class="params">(<span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;height=height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">caculateV</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;length*<span class="keyword">this</span>-&gt;height*<span class="keyword">this</span>-&gt;width;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cubic abc;</span><br><span class="line">    abc.<span class="built_in">setwidth</span>(<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;得到立方体的宽度&quot;</span>&lt;&lt;abc.<span class="built_in">getwidth</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    abc.<span class="built_in">setlength</span>(<span class="number">4</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;得到立方体的长度&quot;</span>&lt;&lt;abc.<span class="built_in">getlength</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    abc.<span class="built_in">setheight</span>(<span class="number">5</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;得到立方体的高度&quot;</span>&lt;&lt;abc.<span class="built_in">getheight</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;得到立方体的体积V=&quot;</span>&lt;&lt;abc.<span class="built_in">caculateV</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到立方体的宽度3</span></span><br><span class="line"><span class="comment">//得到立方体的长度4</span></span><br><span class="line"><span class="comment">//得到立方体的高度5</span></span><br><span class="line"><span class="comment">//得到立方体的体积V=60</span></span><br><span class="line"><span class="comment">//请按任意键继续. .</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习案例2：点和圆的关系</strong></p><p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p><img src="/post/b4ccccea/1545533829184.png" class="" width="1545533829184"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getx</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setx</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gety</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sety</span><span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y=y;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setx</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;c_x=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sety</span><span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;c_y=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setr</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;c_r=r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;c_r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">CaculateTheRelationshipBetweenCircleAndPoint</span><span class="params">(point abc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> p_x=abc.<span class="built_in">getx</span>();</span><br><span class="line">        <span class="type">int</span> p_y=abc.<span class="built_in">gety</span>();</span><br><span class="line">        <span class="type">int</span> distance=<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">sqrt</span>((p_x-<span class="keyword">this</span>-&gt;c_x)*(p_x-<span class="keyword">this</span>-&gt;c_x)-(p_y-<span class="keyword">this</span>-&gt;c_y)*(p_y-<span class="keyword">this</span>-&gt;c_y)));</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> c_x;</span><br><span class="line">    <span class="type">int</span> c_y;</span><br><span class="line">    <span class="type">int</span> c_r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    circle circle;</span><br><span class="line">    circle.<span class="built_in">setx</span>(<span class="number">0</span>);</span><br><span class="line">    circle.<span class="built_in">sety</span>(<span class="number">1</span>);</span><br><span class="line">    circle.<span class="built_in">setr</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    point point;</span><br><span class="line"></span><br><span class="line">    point.<span class="built_in">setx</span>(<span class="number">2</span>);</span><br><span class="line">    point.<span class="built_in">sety</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result=circle.<span class="built_in">CaculateTheRelationshipBetweenCircleAndPoint</span>(point);</span><br><span class="line">    <span class="keyword">if</span>(result==circle.<span class="built_in">getr</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;点在圆上！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(result&gt;circle.<span class="built_in">getr</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;点在园外!!!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;点在园内！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//点在园外!!!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="static-cast和reinterpret-cast"><a href="#static-cast和reinterpret-cast" class="headerlink" title="static_cast&lt;&gt;和reinterpret_cast&lt;&gt;"></a><em><strong>static_cast&lt;&gt;和reinterpret_cast&lt;&gt;</strong></em></h4><blockquote><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast&lt;&gt;"></a>static_cast&lt;&gt;</h2><p><code>static_cast&lt;&gt;</code> 是 C++ 中的一种<strong>类型转换运算符</strong>，用于在编译时进行类型转换。它可以用于将一种类型转换为另一种类型，包括基本类型、类类型和指针类型。</p><p><code>static_cast&lt;&gt;</code> 的语法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;目标类型&gt;(表达式)</span><br></pre></td></tr></table></figure><p>其中，<code>目标类型</code> 是你希望将表达式转换为的类型，而 <code>表达式</code> 则是要进行转换的值或<strong>变量</strong>。</p><p>下面是一些示例用法：</p><ol><li>将整数转换为浮点数：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> result = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(num);</span><br></pre></td></tr></table></figure><ol start="2"><li>将浮点数转换为整数：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> num = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(num);</span><br></pre></td></tr></table></figure><ol start="3"><li><em>将指针类型转换为另一种指针类型</em>：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">char</span>* result = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(ptr);</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>static_cast&lt;&gt;</code> <strong>不会执行运行时的类型检查</strong>，因此转换的安全性需要由开发者自行保证。如果转换是不安全的，建议使用更加安全的类型转换运算符，如 <code>dynamic_cast&lt;&gt;</code> 或 <code>reinterpret_cast&lt;&gt;</code>。</p><p>总结起来，<code>static_cast&lt;&gt;</code> 是 C++ 中一种常用的类型转换运算符，<strong>用于在编译时进行类型转换</strong>。它可以将一种类型转换为另一种类型，但需要开发者自行确保转换的安全性。</p><hr><hr><hr><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast&lt;&gt;"></a>reinterpret_cast&lt;&gt;</h2><p><code>reinterpret_cast&lt;&gt;</code> 是 C++ 中的一种类型转换运算符，用<strong>于执行底层的强制类型转换</strong>。它可以将一个指针或引用转换为另一种指针或引用类型，甚至可以将指针或引用转换为整数类型。</p><p><code>reinterpret_cast&lt;&gt;</code> 的语法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reinterpret_cast</span>&lt;目标类型&gt;(表达式)</span><br></pre></td></tr></table></figure><p>其中，<code>目标类型</code> 是你希望将表达式转换为的类型，而 <code>表达式</code> 则是要进行转换的值或变量。</p><p>下面是一些示例用法：</p><ol><li>将指针类型转换为另一种指针类型：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">char</span>* result = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ptr);</span><br></pre></td></tr></table></figure><ol start="2"><li>将指针类型转换为整数类型：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">uintptr_t</span> result = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(ptr);</span><br></pre></td></tr></table></figure><ol start="3"><li>将整数类型转换为指针类型：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">uintptr_t</span> num = <span class="number">12345</span>;</span><br><span class="line"><span class="type">int</span>* result = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(num);</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>reinterpret_cast&lt;&gt;</code> 执行的是一种底层的强制类型转换，<strong>它可以绕过编译器的类型检查</strong>，因此需要开发者自行确保转换的安全性。使用 <code>reinterpret_cast&lt;&gt;</code> 进行类型转换时应该非常小心，确保转换的结果在语义上是合理的。</p><p>总结起来，<code>reinterpret_cast&lt;&gt;</code> 是 C++ 中一种类型转换运算符，用于执行底层的强制类型转换。它可以将指针或引用转换为另一种指针或引用类型，甚至可以将指针或引用转换为整数类型。使用 <code>reinterpret_cast&lt;&gt;</code> 进行类型转换时需要非常小心，确保转换的安全性和语义正确性。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">10</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;a)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;b)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><ul><li>生活中我们买的电子产品都基本会有<strong>出厂设置</strong>，在某一天我们不用时候也会删除一些自己信息数据保证安全</li><li>C++中的<strong>面向对象来源于生活，</strong>每个对象也都会有<strong>初始设置</strong>以及 对象销毁前的<strong>清理数据</strong>的设置。</li></ul><h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p><p><strong>多个对象的时候，先构造的后析构！！</strong></p><p><strong>在类外调用类的成员</strong></p><p><strong>类名::成员</strong></p><blockquote><p>​一个对象或者变量没有初始状态，对其使用后果是未知</p><p>​同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p></blockquote><p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这<strong>两个函数将会被编译器自动调用</strong>，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译<strong>器强制要我们做的事情</strong>，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p><p><strong>编译器提供的构造函数和析构函数是-&#x3D;空实现-&#x3D;。</strong></p><ul><li>构造函数：主要作用在于创建对象时<strong>为对象的成员属性赋值</strong>，<strong>构造函数由编译器自动调用</strong>，无须手动调用。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong><em>系统自动调用</em>，执行一些<strong>清理工作</strong>。</li></ul><p>可以写在类内</p><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><blockquote><ol><li><strong>构造函数，没有返回值也写void</strong></li><li><strong>函数名称与类名相同</strong></li><li><strong>构造函数可以有参数，因此可以发生重载</strong></li><li>程序在<strong>调用对象时候会自动调用构造</strong>，无须手动调用**,而且只会调用一次**</li></ol></blockquote><p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p><blockquote><ol><li><h5 id="析构函数，没有返回值也写void"><a href="#析构函数，没有返回值也写void" class="headerlink" title="析构函数，没有返回值也写void"></a>析构函数，没有返回值也写void</h5></li><li><h5 id="函数名称是类名，但前面要加个"><a href="#函数名称是类名，但前面要加个" class="headerlink" title="函数名称是类名，但前面要加个~"></a>函数名称是类名，但前面要加个~</h5></li><li><h5 id="函数不可以有参数，不能发生重载"><a href="#函数不可以有参数，不能发生重载" class="headerlink" title="函数不可以有参数，不能发生重载"></a>函数不可以有参数，不能发生重载</h5></li><li><h5 id="程序在对象销毁前对自动调用析构函数，无需手动调用，且只会调用一次"><a href="#程序在对象销毁前对自动调用析构函数，无需手动调用，且只会调用一次" class="headerlink" title="程序在对象销毁前对自动调用析构函数，无需手动调用，且只会调用一次"></a>程序在<em>对象销毁前</em>对自动调用析构函数，无需手动调用，且只会调用一次</h5></li></ol></blockquote><hr><p>C++ 类的构造函数和析构函数可以在类的定义外部进行定义和实现。这样做的目的是将类的声明和实现分离，使代码更加清晰和可维护。</p><p><strong>构造函数和析构函数的定义和实现可以放在类的定义之后的任何地方，通常会放在类的定义之后的源文件中。</strong></p><p>以下是一个示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyClass.h 头文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateMember;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(); <span class="comment">// 构造函数的声明</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>(); <span class="comment">// 析构函数的声明</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyClass.cpp 源文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">    <span class="comment">// 构造函数的实现</span></span><br><span class="line">    privateMember = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass::~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">    <span class="comment">// 析构函数的实现</span></span><br><span class="line">    <span class="comment">// 可以进行资源的释放等清理工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>MyClass</code> 类的构造函数和析构函数的声明放在了头文件 <code>MyClass.h</code> 中，而定义和实现则放在了源文件 <code>MyClass.cpp</code> 中。这样可以使类的接口和实现分离，提高代码的可读性和可维护性。</p><p><strong>如果构造函数和析构函数的定义和实现在类的定义内部，编译器会隐式地将它们声明为内联函数。</strong>而将它们定义在类的定义外部时，不会自动成为内联函数，需要显式地在定义中加上 <code>inline</code> 关键字来指示编译器将其作为内联函数处理。</p><blockquote><p><strong>当编译器将函数的定义插入到调用它的地方时，这被称为内联展开</strong>。相比于生成函数调用，内联展开具有以下优点和缺点：</p><p>优点：</p><ol><li><strong>减少函数调用的开销</strong>：函数调用涉及到保存和恢复寄存器、跳转到函数代码、返回地址等操作，这些操作会消耗一定的时间和空间。通过内联展开，可以避免这些开销，从而提高程序的执行效率。</li><li><strong>优化循环和递归</strong>：内联展开可以优化循环和递归函数的性能。将循环或递归函数内联展开，可以减少函数调用的次数，避免重复的栈帧创建和销毁，从而加快循环或递归的执行速度。</li><li><strong>提高编译器优化的机会</strong>：内联展开可以<strong>提供更多的代码上下文信息给编译器</strong>，使其有更多的优化机会。例如，编译器可以进行常量折叠、循环展开、代码复制等优化，从而进一步提高程序的执行效率。</li></ol><p>缺点：</p><ol><li><strong>增加代码的体积</strong>：内联展开会将函数的定义插入到调用它的地方，这会增加代码的体积。如果函数体很大，内联展开可能会导致代码膨胀，<strong>增加可执行文件的大小。</strong></li><li>增加编译时间：内联展开会增加编译器的工作量，因为编译器需要将函数的定义插入到每个调用它的地方。<strong>如果程序中有大量的函数调用，内联展开可能会导致编译时间的增加。</strong></li><li>可读性下降：内联展开会使代码变得更加冗长，可读性可能会下降。特别是对于复杂的函数体，将其内联展开可能会使代码难以理解和维护。</li></ol><p>综上所述，<strong>内联展开可以提高程序的执行效率，特别是对于频繁调用的小型函数和循环或递归函数。</strong>然而，内联展开也会增加代码的体积和编译时间，并可能降低代码的可读性。因此，在使用内联展开时需要权衡这些优缺点，并根据具体的情况进行选择。</p></blockquote><hr><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;我是构造函数，调用对象前会自动执行，只执行一次，没有返回值也不写void，可以有参数也就说我一般用于创建对象的同时对其成员进行赋值&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;我是析构函数，对象销毁前会被自动执行，没有返回值也不写void，不可以有参数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;begin&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;end&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//begin</span></span><br><span class="line"><span class="comment">//我是构造函数，调用对象前会自动执行，只执行一次，没有返回值也不写void，可以有参数也就说我一般用于创建对象的同时对其成员进行赋值</span></span><br><span class="line"><span class="comment">//我是析构函数，对象销毁前会被自动执行，没有返回值也不写void，不可以有参数</span></span><br><span class="line"><span class="comment">//end</span></span><br></pre></td></tr></table></figure><h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p><p>​按参数分为： 无参构造和有参构造</p><p>​按类型分为： 普通构造（简单的有参无参）和拷贝构造</p><p>三种调用方式：</p><p>​括号法</p><p>​显示法</p><p>​隐式转换法</p><hr><p><strong>注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</strong></p><hr><blockquote><p>C++ 中的构造函数可以分为以下几种类型：</p><ol><li><p>无参构造(默认构造)（Default Constructor）：没有参数的构造函数。如果一个类没有定义任何构造函数，编译器会自动生成一个默认构造函数。默认构造函数用于创建对象时不需要提供任何参数。</p></li><li><p>有参构造（Parameterized Constructor）：带有参数的构造函数，可以在<strong>创建对象时传递参数来初始化对象的成员变量。</strong></p></li><li><p>拷贝构造函数（Copy Constructor）：*<em>用于创建一个新对象并将其初始化为已有对象的副本。</em>**<em>拷贝构造函数的参数是 &gt; <strong>同类型的对象的引用</strong></em>*。</p></li><li><p>深拷贝构造函数（Move Constructor）：用于将一个对象的资源（如动态分配的内存）转移到另一个对象中，通常用于提高程序的性能。</p></li></ol><p>构造函数的调用方式有以下几种：</p><ol><li><p>直接调用：通过类名和参数列表直接调用构造函数来创建对象。例如：<code>MyClass obj(10);</code></p></li><li><p>隐式调用：在不显式调用构造函数的情况下，使用类的对象声明来创建对象。例如：<code>MyClass obj = 10;</code></p></li><li><p>拷贝初始化：使用一个已存在的对象来初始化新对象，会调用拷贝构造函数。例如：<code>MyClass obj2 = obj1;</code></p></li><li><p>动态创建对象：使用 <code>new</code> 运算符在堆上动态创建对象，会调用构造函数。例如：<code>MyClass* ptr = new MyClass();</code></p></li></ol><p>需要注意的是，<strong>构造函数在对象创建时自动调用，无法手动调用构造函数来重新初始化已经存在的对象</strong>。构造函数的调用顺序是<strong>先调用基类的构造函数，再调用成员对象的构造函数，最后调用派生类的构造函数</strong>。析构函数的调用顺序与构造函数相反，先调用派生类的析构函数，再调用成员对象的析构函数，最后调用基类的析构函数。</p></blockquote><p>推荐使用括号</p><p>了解匿名对象</p><p>有参构造函数直接Person（10）的时候创了一个匿名对象。</p><p>相当于没人接受这个对象。</p><p>要想利用拷贝构造函数，先有一个自己同类型的对象，然后再以引用的形式传入就ok了</p><img src="/post/b4ccccea/image-20230726211121976.png" class="" title="image-20230726211121976"><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.1  括号法，常用</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line"><span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.2 显式法</span></span><br><span class="line">Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line"><span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构，直接构造析构然后立马销毁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.3 隐式转换法</span></span><br><span class="line">Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line"><span class="comment">//Person p5(p4);</span></span><br><span class="line">    <span class="comment">///数声明和对象定义的语法非常相似，都可以使用括号来表示。</span></span><br><span class="line">    <span class="comment">//使用额外的括号：可以在匿名对象的括号外面再加一对括号，这样编译器就不会将其解释为函数声明。</span></span><br><span class="line"><span class="comment">//MyClass obj((MyClass())); // 使用括号明确告诉编译器我们要定义一个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = p.mAge;</span><br><span class="line">默认的简单拷贝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li><strong>值传递</strong>的方式给函数参数传值</li><li>以<strong>值方式</strong>返回局部对象</li></ul><blockquote><ol><li><p><code>Person newman3 = man;</code> 和 <code>Person newman3; newman3 = man;</code> 是有区别的。</p><ol><li><code>Person newman3 = man;</code> 使用<strong>拷贝初始化的方式创建了一个新的对象</strong> <code>newman3</code>，并将 <code>man</code> 对象的值复制给 <code>newman3</code>。这里会<strong>调用拷贝构造函数来完成对象的复制初始化。</strong></li><li>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</li><li><code>Person newman3; newman3 = man;</code> 首先创建了一个新的对象 <code>newman3</code>，但它<strong>是通过默认构造函数创建的</strong>，并不包含任何数据。然后，通<strong>过赋值操作符 <code>=</code> 将 <code>man</code> 对象的值赋给了 <code>newman3</code><strong>。这里会调用</strong>赋值运算符重载函数来完成对象的赋值操作。</strong></li></ol><p>总体来说，两种形式都会将 <code>man</code> 对象的值复制到 <code>newman3</code> 对象中，但是在实现细节上有所不同。<strong>拷贝初始化会调用拷贝构造函数</strong>，<strong>而赋值操作会调用赋值运算符重载函数</strong>。在某些情况下，拷贝构造函数和赋值运算符重载函数的实现可能会有差异，因此两种形式可能具有不同的行为。<strong>在一般情况下</strong>，如果需要创建并初始化一个新对象，<strong>建议使用拷贝初始化的方式</strong>，而不是先创建对象再赋值的方式。</p></li><li><p><strong>值传递是指将实参的值</strong>复制一份传递给函数的形参。<strong>在函数调用时，会创建一个新的变量（形参），并将实参的值复制到形参中。</strong>&#x3D;&#x3D;在函数内部，对形参的修改不会影响到实参的值。&#x3D;&#x3D;当函数执行完毕后，形参的生命周期结束<strong>，它所占用的内存会被释放。</strong></p><p>text02()在你的例子中，<code>doWork</code> 函数的形参 <code>p1</code> 是通过值传递的方式进行传递的。当你调用 <code>doWork(p)</code> 时，会创建一个新的 <code>Person</code> 对象 <code>p1</code>，并将 <code>p</code> 对象的值复制给 <code>p1</code>。</p></li><li><p>可以以值方式返回<strong>局部对象</strong>。当函数返回一个对象时，编<strong><em>译器会执行对象的拷贝构造函数来创建一个临时对象，并将其作为返回值</em>。这个临时对象是在函数调用栈上分配的</strong>，<strong>它的生命周期与函数的返回值绑定。</strong></p><p>&#x2F;&#x2F;</p><p><strong>假如说我用a来接受这个局部对象，那么这个临时对象将会在a的销毁的时候同时销毁</strong></p><img src="/post/b4ccccea/image-20230727153838243.png" class="" title="image-20230727153838243"></li></ol></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = p.mAge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line"><span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person newman3;</span></span><br><span class="line"><span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p; <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> p1;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//此时return *this;也会拷贝一个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h4><p>默认情况下，创建一个类的时候，c++编译器至少给一个类添加3个函数,</p><p>1．默认构造函数(无参，函数体为空)</p><p>2．默认析构函数(无参，函数体为空)</p><p>3．默认拷贝构造函数，对属性进行值拷贝</p><p>构造函数调用规则如下：</p><ul><li><p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</p></li><li><p>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;<span class="comment">//18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4><p><strong>深浅拷贝是面试经典问题，也是常见的一个坑</strong></p><p>浅拷贝：<strong>简单的赋值拷贝操作</strong>  编译器提供的那个拷贝构造函数，浅拷贝</p><p>深拷贝：<strong>在堆区重新申请空间，进行拷贝操作</strong></p><img src="/post/b4ccccea/image-20230727164829489.png" class="" title="image-20230727164829489"><p><strong>这是编译器帮忙写的浅拷贝</strong></p><img src="/post/b4ccccea/image-20230727172119889.png" class="" title="image-20230727172119889"><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age, <span class="type">int</span> height) &#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">m_age = age;</span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数  </span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_age = a.m_age;</span><br><span class="line"><span class="comment">//m_height = a.m_height;</span></span><br><span class="line"><span class="comment">//利用拷贝对象的数据来开辟一个新的空间。</span></span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*a.m_height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line"><span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">160</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"><span class="comment">//Person p2 = p1;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：<strong>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</strong></p></blockquote><ol><li><p>自己写拷贝构造函数，用拷贝对象的数据来开辟对应的空间</p></li><li><pre><code class="c++">//拷贝构造函数  Person(const Person&amp; a)&#123;    cout &lt;&lt; &quot;拷贝构造函数&quot; &lt;&lt; endl;    m_age = a.m_age;    //m_height = a.m_height;    //利用拷贝对象的数据来开辟一个新的空间。    m_height = new int(*a.m_height);&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 析构函数PLUS！</span><br><span class="line"></span><br><span class="line">4. ```c++</span><br><span class="line">   //析构函数</span><br><span class="line">   ~Person() &#123;</span><br><span class="line">   cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">   if (m_height != NULL)</span><br><span class="line">   &#123;</span><br><span class="line">   delete m_height;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><p>只有new出来的空间才能用delete，而且只能delete一次！</p><h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p><strong>作用：</strong></p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p><p><code>//初始化列表方式初始化</code></p><p><code>Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c)&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">////传统方式初始化</span></span><br><span class="line"><span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line"><span class="comment">//m_A = a;</span></span><br><span class="line"><span class="comment">//m_B = b;</span></span><br><span class="line"><span class="comment">//m_C = c;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表方式初始化</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="&#x3D;&#x3D;4.2.7 类对象作为类成员&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.2.7 类对象作为类成员&#x3D;&#x3D;</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>B类中有对象A作为成员，A为对象成员</p><p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p><blockquote><p><strong>&#x2F;&#x2F;构造的顺序是 ：先调用<em>对象成员</em>的构造，再调用本类构造</strong><br><strong>&#x2F;&#x2F;析构顺序与构造相反</strong></p></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Phone</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">m_PhoneName = name;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Phone</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line">Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line"><span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line"><span class="comment">//析构顺序与构造相反</span></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>();</span><br><span class="line">~<span class="built_in">Son</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Father</span>();</span><br><span class="line">~<span class="built_in">Father</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Son* a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Father::<span class="built_in">Father</span>()</span><br><span class="line">&#123;</span><br><span class="line">a = <span class="keyword">new</span> Son;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;父亲被构造了&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father::~<span class="built_in">Father</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;父亲被析构了&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son::<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;儿子被构造了&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son::~<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;儿子被析构了&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Father father;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>();</span><br><span class="line">~<span class="built_in">Son</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Father</span>();</span><br><span class="line">~<span class="built_in">Father</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Son a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Father::<span class="built_in">Father</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;父亲被构造了&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father::~<span class="built_in">Father</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;父亲被析构了&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son::<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;儿子被构造了&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son::~<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;儿子被析构了&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Father father;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这两种都是先构造儿子后构造父亲，析构相反</strong></p><p><strong>只有在父亲的构造函数里面再栈区开辟一个儿子对象的时候才是先构造父亲，然后构造儿子，其他相反</strong></p><h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4><p><strong>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</strong></p><p>—————————————-<em>可以通过类名访问静态成员</em>————————————————-</p><p><strong><em>静态成员分为</em>：</strong></p><ul><li><strong>静态成员变量</strong><ul><li><strong>所有对象共享同一份数据</strong></li><li><strong>在编译阶段分配内存</strong>（全局区运行前）</li><li><strong>类内声明，类外初始化</strong>（记得加作用域！！！！）</li></ul></li><li><strong>静态成员函数</strong><ul><li><strong>所有对象共享同一个函数</strong></li><li><strong>静态成员函数只能访问静态成员变量</strong></li></ul></li></ul><blockquote><p><strong>静态成员变量也有私有的时候。外部不能直接访问</strong></p><p><strong>可以通过类名访问静态成员</strong></p><p><strong>普通的成员public变量不可以直接用类名：：变量名访问！！！</strong></p></blockquote><p><strong>示例1 ：</strong>静态成员变量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员变量特点：</span></span><br><span class="line"><span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line"><span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line"><span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过对象</span></span><br><span class="line">Person p1;</span><br><span class="line">p1.m_A = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p2.m_A = <span class="number">200</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong>静态成员函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数特点：</span></span><br><span class="line"><span class="comment">//1 程序共享一个函数</span></span><br><span class="line"><span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//静态static成员函数它只属于类本身不属于每一个对象实例，独立存在。非静态成员，仅当实例化对象之后才存在。静态成员函数产生在前，非静态成员函数产生在后，静态函数无法访问一个不存在的东西。也就是静态成员函数离不能用this指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"><span class="type">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过对象</span></span><br><span class="line">Person p1;</span><br><span class="line">p1.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名</span></span><br><span class="line">Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，<strong>类内的成员变量和成员函数分开存储</strong></p><p>只有<strong>非静态成员变量才属于类的对象上</strong></p><blockquote><h5 id="只有非静态成员变量在真正属于类！！！！！"><a href="#只有非静态成员变量在真正属于类！！！！！" class="headerlink" title="只有非静态成员变量在真正属于类！！！！！"></a>只有非静态成员变量在真正属于类！！！！！</h5><h5 id="空对象占用1字节，为了区分空对象。"><a href="#空对象占用1字节，为了区分空对象。" class="headerlink" title="空对象占用1字节，为了区分空对象。"></a>空对象占用1字节，为了区分空对象。</h5><h5 id="也就是类的大小是根据非静态成员变量的"><a href="#也就是类的大小是根据非静态成员变量的" class="headerlink" title="也就是类的大小是根据非静态成员变量的"></a>也就是类的大小是根据非静态成员变量的</h5></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">mA = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line"><span class="type">int</span> mA;</span><br><span class="line"><span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mB;</span><br><span class="line"><span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4</span></span><br></pre></td></tr></table></figure><h4 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>c++通过提供特殊的对象指针，this指针，解决上述问题。<em><strong>this指针指向被调用的成员函数所属的对象</strong></em></p><blockquote><p><strong>this指针是隐含每一个非静态成员函数内的一种指针</strong></p><p><strong>this指针不需要定义，直接使用即可</strong></p><p><strong>静态成员函数没有this指针</strong></p><p>本质是指针常量！！！，已经指向了a，不可以修改指向，但可以修改值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showperson</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span> = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_a = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Person a;</span><br><span class="line">a.<span class="built_in">showperson</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>this指针的用途：</p><ul><li>当形参和成员变量同名时，可用this指针来区分</li><li>*<em>在类的非静态成员函数中返回对象本身，可使用return <em>this</em></em></li></ul><h5 id="链式编程思想！！！"><a href="#链式编程思想！！！" class="headerlink" title="&#x3D;&#x3D;链式编程思想！！！&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>链式编程思想！！！</strong>&#x3D;&#x3D;</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line"><span class="comment">//返回对象本身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line">p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><blockquote><p>类类型的指针，在成员里this就是指针。</p></blockquote><p>但不能用空指针访问里面的属性，可以用函数。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showperosn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是person类&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showpp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//代码健壮！！！</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sdadasdassdasdasdasdsda&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person* p = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;<span class="built_in">showperosn</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">p-&gt;<span class="built_in">showpp</span>(); <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p><blockquote><ul><li><strong>成员函数后</strong>加const后我们称为这个函数为<strong>常函数</strong></li><li><strong>常函数内不可以修改成员属性</strong></li><li><strong>成员属性声明时加关键字mutable后，在常函数中依然可以修改</strong></li></ul></blockquote><p><strong>常对象：</strong></p><ul><li><strong>声明对象前加const称该对象为常对象</strong></li><li><strong>常对象只能调用常函数</strong></li><li><strong>常对象可以修改静态变量的值</strong></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">m_A = <span class="number">0</span>;</span><br><span class="line">m_B = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line"><span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//const Type* const pointer;</span></span><br><span class="line"><span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line"><span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//mA = 10000;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常对象访问成员函数</span></span><br><span class="line">person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p><p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p><p>但是呢，你也可以允许你的好闺蜜好基友进去。</p><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是<strong>让一个函数或者类 访问另一个类中私有成员</strong></p><p>友元的关键字为  &#x3D;&#x3D;friend&#x3D;&#x3D;</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodgay</span><span class="params">(building* building)</span></span>;<span class="comment">//写在类里面就ok，最好在上面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">building</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_sittingrom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">m_bedroom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_sittingrom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_bedroom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodgay</span><span class="params">(building* building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友 全局函数正在访问:&quot;</span> &lt;&lt;building-&gt;m_sittingrom&lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友 全局函数正在访问:&quot;</span> &lt;&lt; building-&gt;m_bedroom&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">building b;</span><br><span class="line"><span class="built_in">goodgay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">text01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">goodGay</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">goodGay gg;</span><br><span class="line">gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="comment">//你可以在goodGay类的定义之前提供一个Building类的前向声明来解决编译错误。</span></span><br><span class="line"><span class="comment">//但是，在这种情况下，你不能直接在goodGay类的构造函数中使用new来创建Building对象，因为编译器仍然无法识别Building类的具体定义。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">goodGay</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Building* building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">goodGay gg;</span><br><span class="line">gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p><blockquote><p>通过成员函数重载</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public: </span><br><span class="line">person(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_a = a;</span><br><span class="line">this-&gt;m_b = b;</span><br><span class="line">&#125;</span><br><span class="line">person operator+(person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">person p3(0, 0);</span><br><span class="line">p3.m_a = this-&gt;m_a + p.m_a;</span><br><span class="line">p3.m_b = this-&gt;m_b + p.m_b;</span><br><span class="line">return p3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int m_a;</span><br><span class="line">int m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">person p1(10, 10);</span><br><span class="line">person p2(20, 20);</span><br><span class="line">person p3=p1+(p2);</span><br><span class="line">cout &lt;&lt; p3.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;_------------------&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p3.m_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过全局函数重载</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//person fucn(person&amp; p1, person&amp; p2)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//person p3(0,0);</span></span><br><span class="line"><span class="comment">//p3.m_a = p1.m_a + p2.m_a;</span></span><br><span class="line"><span class="comment">//p3.m_b = p3.m_b + p2.m_b;</span></span><br><span class="line"><span class="comment">//return p3;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">person <span class="keyword">operator</span>+(person&amp; p1, person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">person <span class="title">p3</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">p3.m_a = p1.m_a + p2.m_a;</span><br><span class="line">p3.m_b = p1.m_b + p2.m_b;</span><br><span class="line"><span class="keyword">return</span> p3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//person p3 = func(p1, p2);</span></span><br><span class="line">    <span class="comment">//可以简写为这样！</span></span><br><span class="line">person p3 = p1 + p2;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p3.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;_------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p3.m_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>运算符对应的函数重载</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person <span class="keyword">operator</span>+(person&amp; p1, person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">person <span class="title">p3</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">p3.m_a = p1.m_a + p2.m_a;</span><br><span class="line">p3.m_b = p1.m_b + p2.m_b;</span><br><span class="line"><span class="keyword">return</span> p3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person <span class="keyword">operator</span>+(person&amp; p1, <span class="type">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">person <span class="title">p3</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">p3.m_a = p1.m_a + num;</span><br><span class="line">p3.m_b = p1.m_b + num;</span><br><span class="line"><span class="keyword">return</span> p3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//person p3 = operator+(p1, p2);</span></span><br><span class="line">person p3 = p1 + p2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//现在如果</span></span><br><span class="line">person p4 = p1 + <span class="number">100</span>;<span class="comment">//person + int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p3.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p3.m_b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;_------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p4.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p4.m_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>通过成员函数或者全局函数写一个目标重载运算符的作用函数,然后把函数的名字改为operator+就可以说使用+号来重载了</li><li>不把函数名改写为operator+之前的加号还默认是原来的样子!!!!</li><li>熟练之后直接函数名字就是operator+</li><li>如果二者同时存在的时候就会报错</li></ol></blockquote><blockquote><p>总结1：对于<strong>内置的数据类型</strong>的表达式的的运算符是不可能改变的1+1&#x3D;2,变成1+1&#x3D;0?不可以</p></blockquote><blockquote><p>总结2：不要滥用运算符重载,加号运算符重载,实现就不要用减号..</p></blockquote><h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="&#x3D;&#x3D;4.5.2 左移运算符重载&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.5.2 左移运算符重载&#x3D;&#x3D;</h4><p>作用：可以输出自定义数据类型</p><p>加个cosnt最好，引用作为函数参数传递的时候不修改最好加上cosnt！！！！！！！！！</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p) <span class="comment">//本质operator&lt;&lt;(cout,p) 简化cout&lt;&lt;p;</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a ;</span><br><span class="line">cout &lt;&lt; p.m_b;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链式思想,返回cout对应的</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> person&amp; p) <span class="comment">//本质operator&lt;&lt;(cout,p) 简化cout&lt;&lt;p;</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a ;</span><br><span class="line">cout &lt;&lt; p.m_b;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也是ok的因为,引用本来就是起别名,而真正传入的实参确实cout所以</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line"><span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个,所以要用引用的形式修改,否则覆盖不了原来的cout</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结<strong>：重载左移运算符配合友元可以实现输出自定义数据类型</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, person&amp; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>(<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout对象和我的p对象</span></span><br><span class="line"><span class="comment">//void operator&lt;&lt;(cout)  // p.operator&lt;&lt;(cout)  简化为p&lt;&lt;cout</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, person&amp; p) <span class="comment">//本质operator&lt;&lt;(cout,p) 简化cout&lt;&lt;p;</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a ;</span><br><span class="line">cout &lt;&lt; p.m_b;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl &lt;&lt; <span class="string">&quot;helloworld&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p><p>但用引用可以节省空间，而且不怕拷贝函数有错误。</p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>++() &#123;  <span class="comment">// 前置递增运算符重载</span></span><br><span class="line">  <span class="comment">// 执行递增操作</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回递增后的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;  <span class="comment">// 后置递增运算符重载</span></span><br><span class="line">  MyClass temp = *<span class="keyword">this</span>;  <span class="comment">// 创建一个临时对象保存当前对象的值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行递增操作</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> temp;  <span class="comment">// 返回之前的对象</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//class MyClass &#123;</span></span><br><span class="line"><span class="comment">//    // 类定义</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>++(MyClass&amp; obj) &#123;  <span class="comment">// 前置递增运算符重载</span></span><br><span class="line"><span class="comment">// 执行递增操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> obj;  <span class="comment">// 返回递增后的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass <span class="keyword">operator</span>++(MyClass&amp; obj, <span class="type">int</span>) &#123;  <span class="comment">// 后置递增运算符重载</span></span><br><span class="line">MyClass temp = obj;  <span class="comment">// 创建一个临时对象保存当前对象的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行递增操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> temp;  <span class="comment">// 返回之前的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意conse，会有一定的影响，如果引用做函数参数的时候确认是不修改的 话就加上const！！！</span></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>前置++</p><p>返回引用！！可以链式</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, person&amp; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//p.operator++(person&amp; p)</span></span><br><span class="line">person&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数重载的时候</span></span><br><span class="line">person&amp; <span class="keyword">operator</span>++(person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">p.m_a++;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意conse，会有一定的影响，如果引用做函数参数的时候确认是不修改的 话就加上const！！！</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">person p;</span><br><span class="line">cout &lt;&lt; ++(++p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>后置递增！</p><p>返回同类，不可以用链式</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p);</span><br><span class="line"><span class="keyword">friend</span> person <span class="keyword">operator</span>++(person&amp; obj, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person <span class="keyword">operator</span>++(person&amp; obj, <span class="type">int</span>) &#123;  <span class="comment">// 后置递增运算符重载</span></span><br><span class="line">person temp = obj;  <span class="comment">// 创建一个临时对象保存当前对象的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行递增操作</span></span><br><span class="line">obj.m_a++;=</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> temp;  <span class="comment">// 返回之前的对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意conse，会有一定的影响，如果引用做函数参数的时候确认是不修改的 话就加上const！！！</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">person myInt;</span><br><span class="line">cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">person p;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><blockquote><h4 id="总结：-前置递增返回引用，后置递增返回值"><a href="#总结：-前置递增返回引用，后置递增返回值" class="headerlink" title="总结： 前置递增返回引用，后置递增返回值"></a>总结： 前置递增返回引用，后置递增返回值</h4></blockquote><p>递减！！的成员函数 的 写法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person&amp; <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a--;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">person <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">person temp = *<span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a--;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">person myInt;</span><br><span class="line">cout &lt;&lt; --myInt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">person myInt;</span><br><span class="line">cout &lt;&lt; myInt--&lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">person p;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递减的全局函数重载写法！！</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p);</span><br><span class="line"><span class="keyword">friend</span> person&amp; <span class="keyword">operator</span>--(person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> person <span class="keyword">operator</span>--(person&amp; p, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person&amp; <span class="keyword">operator</span>--(person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">p.m_a--;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person <span class="keyword">operator</span>--(person&amp; p,<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">person temp = p;</span><br><span class="line">p.m_a--;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">person myInt;</span><br><span class="line">cout &lt;&lt; --myInt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">person myInt;</span><br><span class="line">cout &lt;&lt; myInt--&lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">person p;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p><blockquote><ol><li><h5 id="默认构造函数-无参，函数体为空"><a href="#默认构造函数-无参，函数体为空" class="headerlink" title="默认构造函数(无参，函数体为空)"></a>默认构造函数(无参，函数体为空)</h5></li><li><h5 id="默认析构函数-无参，函数体为空"><a href="#默认析构函数-无参，函数体为空" class="headerlink" title="默认析构函数(无参，函数体为空)"></a>默认析构函数(无参，函数体为空)</h5></li><li><h5 id="默认拷贝构造函数，对属性进行值拷贝"><a href="#默认拷贝构造函数，对属性进行值拷贝" class="headerlink" title="默认拷贝构造函数，对属性进行值拷贝"></a>默认拷贝构造函数，对属性进行值拷贝</h5></li><li><h5 id="赋值运算符-operator-对属性进行值拷贝"><a href="#赋值运算符-operator-对属性进行值拷贝" class="headerlink" title="赋值运算符 operator&#x3D;, 对属性进行值拷贝"></a>赋值运算符 operator&#x3D;, 对属性进行值拷贝</h5></li></ol></blockquote><ol><li>也是浅拷贝</li></ol><p><strong>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</strong></p><p>类中有属性指向堆区，就要考虑深拷贝了</p><hr><p><strong>思考，指出那里出现了问题????</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>(<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in">int</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;p;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="comment">//此处使用拷贝构造函数的隐式转换</span></span><br><span class="line">    <span class="comment">//person p3=p1</span></span><br><span class="line">    <span class="comment">//由于我们并没有写自己的深拷贝,也就是说还用的是编译器帮我们写的浅拷贝,造成了简单的赋值操作,让我么两个指针都指向了同一块数据,然后释放了两次就鸡; </span></span><br><span class="line">    <span class="comment">//我们只是写了自己的=的重载.</span></span><br><span class="line">    <span class="comment">//避免了重载的时候释放两次同一个位置</span></span><br><span class="line">    <span class="comment">//p2=p1这样的操作不会有问题</span></span><br><span class="line">person p3 = p1;</span><br><span class="line">cout &lt;&lt; *p1.p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p2.p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p3.p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/post/b4ccccea/image-20230729143751080.png" class="" title="image-20230729143751080"><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载赋值运算符 </span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line"><span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回自身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄的指针</span></span><br><span class="line"><span class="type">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//int a = 10;</span></span><br><span class="line"><span class="comment">//int b = 20;</span></span><br><span class="line"><span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c = b = a;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="可以是实现这样的操作，从右到左赋值！！！"><a href="#可以是实现这样的操作，从右到左赋值！！！" class="headerlink" title="可以是实现这样的操作，从右到左赋值！！！"></a>可以是实现这样的操作，从右到左赋值！！！</h4></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//test();</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">a = b = c;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a  &lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b  &lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c=&quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>给&#x3D;进行链式思想实连等</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>(<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in">int</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;p;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> person&amp; pp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//需要看原来的堆区是否有数据，如果有需要先释放干净，然后再利用数据开辟空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in">int</span>(*pp.p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">person p3 =(<span class="number">30</span>);</span><br><span class="line">p3 = p2 = p1;</span><br><span class="line">cout &lt;&lt; *p1.p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p2.p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p3.p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="4-5-5-关系运算符重载—返回BOOL"><a href="#4-5-5-关系运算符重载—返回BOOL" class="headerlink" title="4.5.5 关系运算符重载—返回BOOL"></a>4.5.5 关系运算符重载—返回BOOL</h4><p><strong>作用：</strong>重<strong>载关系运算符，可以让两个自定义类型对象进行对比操作</strong></p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;name == p2.name &amp;&amp; <span class="keyword">this</span>-&gt;age == p2.age)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////////</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> == p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;name != p2.name &amp;&amp; <span class="keyword">this</span>-&gt;age != p2.age)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////全局函数重载的时候</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(person&amp; p1, person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p1.name == p2.name &amp;&amp; p1.age == p2.age)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(person&amp; p1, person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p1.name == p2.name &amp;&amp; p1.age == p2.age)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//全局记得加上友元!!!@#@#@#@#@#!#!</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>(string name, <span class="type">int</span> age):<span class="built_in">name</span>(name), <span class="built_in">age</span>(age)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;name == p2.name &amp;&amp; <span class="keyword">this</span>-&gt;age == p2.age)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="string">&quot;tom&quot;</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line"><span class="function">person <span class="title">p2</span><span class="params">(<span class="string">&quot;tom&quot;</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line">person p3 = <span class="built_in">person</span>(<span class="string">&quot;jerry&quot;</span>,<span class="number">20</span>);</span><br><span class="line"><span class="comment">///erson p4 = p2;//浅拷贝！！！危险，如果指针操纵他—+析构释放，就要考虑深拷贝！！！</span></span><br><span class="line"><span class="keyword">if</span> (p1==p2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1和p2是相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1和p2是不相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载()"></a>4.5.6 函数调用运算符重载()</h4><ul><li>函数调用运算符 ()  也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><blockquote><h4 id="刚试了一下，operator（）（）只能在类里面定义，报错说不允许他为全局函数。"><a href="#刚试了一下，operator（）（）只能在类里面定义，报错说不允许他为全局函数。" class="headerlink" title="刚试了一下，operator（）（）只能在类里面定义，报错说不允许他为全局函数。"></a>刚试了一下，operator（）（）只能在类里面定义，报错说不允许他为全局函数。</h4></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line"><span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line"><span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line"><span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myadd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+<span class="number">1</span> + b+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//匿名对象调用  </span></span><br><span class="line"><span class="comment">//有参构造Person(10)单独写就是匿名对象  当前行结束之后，马上析构，直接构造析构然后立马销毁</span></span><br><span class="line"><span class="comment">//Person()单独写就是匿名对象  当前行结束之后，马上析构，直接构造析构然后立马销毁</span></span><br><span class="line">person p;</span><br><span class="line"><span class="built_in">p</span>(<span class="string">&quot;你好啊）OP&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----匿名函数----------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">person</span>()(<span class="string">&quot;你好啊匿名函数&quot;</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">Myadd add;</span><br><span class="line">cout&lt;&lt;<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">30</span>)&lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----匿名函数----------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Myadd</span>()(<span class="number">90</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-继承–2"><a href="#4-6-继承–2" class="headerlink" title="4.6  继承–2"></a>4.6  继承–2</h3><p><strong>继承是面向对象三大特性之一</strong></p><p>有些类与类之间存在特殊的关系，例如下图中：</p><img src="/post/b4ccccea/1544861202252.png" class="" width="1544861202252"><p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p>重要但不难</p><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p><strong>普通实现：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.<span class="built_in">header</span>();</span><br><span class="line">cp.<span class="built_in">footer</span>();</span><br><span class="line">cp.<span class="built_in">left</span>();</span><br><span class="line">cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承实现：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.<span class="built_in">header</span>();</span><br><span class="line">cp.<span class="built_in">footer</span>();</span><br><span class="line">cp.<span class="built_in">left</span>();</span><br><span class="line">cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>继承的好处：&#x3D;&#x3D;可以减少重复的代码&#x3D;&#x3D;</p><blockquote><p>class A : public B; </p><p><strong>A 类称为子类 或 派生类</strong></p><p><strong>B 类称为父类 或 基类</strong></p></blockquote><p><strong>派生类中的成员，包含两大部分</strong>：</p><p><strong>一类是从基类继承过来的，一类是自己增加的成员。</strong></p><p>从基类继承过过来的表现其共性，而新增的成员体现了<strong>其个性</strong>。</p><h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p><p><strong>继承方式一共有三种：</strong></p><blockquote><ul><li><h4 id="公共继承-原来是啥还是啥，只不过不可以访问父亲的私有的"><a href="#公共继承-原来是啥还是啥，只不过不可以访问父亲的私有的" class="headerlink" title="公共继承,原来是啥还是啥，只不过不可以访问父亲的私有的"></a>公共继承,原来是啥还是啥，只不过不可以访问父亲的私有的</h4></li><li><h4 id="保护继承-除了private都变成protected"><a href="#保护继承-除了private都变成protected" class="headerlink" title="保护继承  除了private都变成protected"></a>保护继承  除了private都变成protected</h4></li><li><h4 id="私有继承-全变成private；"><a href="#私有继承-全变成private；" class="headerlink" title="私有继承 全变成private；"></a>私有继承 全变成private；</h4></li></ul><p>在C++中，<strong>派生类确实继承了基类的所有成员，包括私有成员。</strong>但是，<strong>私有成员在派生类中是不可访问的。</strong>这<strong>意味着派生类无法直接访问或继承基类的私有成员。</strong></p><p><strong>私有成员只能在基类内部访问</strong>，派生类无法直接访问或继承私有成员。这是因为<strong>私有成员被设计为只能在基类内部使用，对外部是不可见的。****派生类只能通过基类的公有和保护成员来访问和操作私有成员</strong>。</p><p><strong>只是编译器把父类的private给隐藏了，子类不可访问</strong></p></blockquote><img src="/post/b4ccccea/clip_image002.png" class="" title="img"><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son1 s1;</span><br><span class="line">s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2 s;</span><br><span class="line"><span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line"><span class="comment">//m_A;</span></span><br><span class="line"><span class="comment">//m_B;</span></span><br><span class="line"><span class="comment">//m_C;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="&#x3D;&#x3D;4.6.3 继承中的对象模型&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.6.3 继承中的对象模型&#x3D;&#x3D;</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p><blockquote><p><strong>在C++中，子类继承了父类的函数，但子类函数和父类函数并不指向同一块地址。</strong></p><p><strong>当子类继承父类的函数时，子类会创建一个新的函数，该函数与父类的函数具有相同的名称和参数列表，但是可以有不同的实现（重写）或相同的实现（继承）。</strong></p><p><strong>子类函数和父类函数是两个独立的函数，它们具有不同的地址。子类对象可以通过子类函数来调用子类的实现，而父类对象可以通过父类函数来调用父类的实现。</strong></p><hr><p><strong>在C++中，子类继承了父类的成员变量，但子类的成员变量和父类的成员变量并不指向同一块地址。子类对象包含了父类对象的所有成员变量，但它们在内存中是独立存储的。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> parentVar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Parent parent;</span><br><span class="line">    Child child;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印父类成员变量地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;父类成员变量地址：&quot;</span> &lt;&lt; &amp;(parent.parentVar) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印子类成员变量地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子类成员变量地址：&quot;</span> &lt;&lt; &amp;(child.parentVar) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//16</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用工具查看：</p><img src="/post/b4ccccea/image-20230729223112618.png" class="" title="image-20230729223112618"><p>打开工具窗口后，定位到当前CPP文件的盘符</p><img src="/post/b4ccccea/image-20230729222903401.png" class="" title="image-20230729222903401"><p>然后输入： cl &#x2F;d1 reportSingleClassLayout查看的类名   所属文件名</p><p>table</p><p>效果如下图：</p><img src="/post/b4ccccea/1545882158050.png" class="" width="1545882158050"><blockquote><p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote><h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><p><strong>因为是继承，肯定要先创建一个父类</strong></p><p><strong>先父亲后儿子，和之前的类里面有别的类的时候，</strong></p><p>4.2.7 类对象作为类成员是有区别的</p><p>类里面有类的时候是先构造里面的然后再构造外面的！！！</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="总结：继承中-先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反"><a href="#总结：继承中-先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反" class="headerlink" title="总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反"></a>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</h4></blockquote><h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><blockquote><ul><li><h4 id="访问子类同名成员-直接访问即可"><a href="#访问子类同名成员-直接访问即可" class="headerlink" title="访问子类同名成员   直接访问即可"></a>访问子类同名成员   直接访问即可</h4></li><li><h4 id="访问父类同名成员-需要加作用域"><a href="#访问父类同名成员-需要加作用域" class="headerlink" title="访问父类同名成员   需要加作用域"></a>访问父类同名成员   需要加作用域</h4></li><li><p>直接调用就是儿子的，</p><p><strong>&#x2F;&#x2F;当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</strong><br><strong>&#x2F;&#x2F;如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</strong></p></li></ul></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这是父类的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Base1</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这是父类的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是父亲！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B ;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是儿子！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Son1</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这是子类的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Son1</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这是子类的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_A=<span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line"><span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son1 s1;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;子类的同名是&quot;</span>&lt;&lt; s1.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;父类的同名是&quot;</span> &lt;&lt; s1.Base1::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">s1.<span class="built_in">func</span>();</span><br><span class="line">s1.Base1::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s1.Base1::<span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Son1) &lt;&lt; endl;</span><br><span class="line"><span class="comment">//16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><blockquote><ol><li><h5 id="子类对象可以直接访问到子类中同名成员"><a href="#子类对象可以直接访问到子类中同名成员" class="headerlink" title="子类对象可以直接访问到子类中同名成员"></a>子类对象可以直接访问到子类中同名成员</h5></li><li><h5 id="子类对象加作用域可以访问到父类同名成员"><a href="#子类对象加作用域可以访问到父类同名成员" class="headerlink" title="子类对象加作用域可以访问到父类同名成员"></a>子类对象加作用域可以访问到父类同名成员</h5></li><li><h5 id="当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数-包括重载的，都没用，加作用域可以访问到父类中同名函数"><a href="#当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数-包括重载的，都没用，加作用域可以访问到父类中同名函数" class="headerlink" title="当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数,包括重载的，都没用，加作用域可以访问到父类中同名函数"></a>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数,包括重载的，都没用，<em>加作用域</em>可以访问到父类中同名函数</h5></li></ol></blockquote><h4 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h4><p><strong>1.静态成员可以通过类名来访问！</strong></p><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p><strong>静态成员和非静态成员出现同名，处理方式一致</strong></p><p>想要使用父亲的就加作用域就欧克了！！！</p><blockquote><h5 id="访问子类同名成员-直接访问即可-1"><a href="#访问子类同名成员-直接访问即可-1" class="headerlink" title="访问子类同名成员   直接访问即可"></a>访问子类同名成员   直接访问即可</h5><h5 id="访问父类同名成员-需要加作用域-1"><a href="#访问父类同名成员-需要加作用域-1" class="headerlink" title="访问父类同名成员   需要加作用域"></a>访问父类同名成员   需要加作用域</h5></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">    <span class="comment">//第一个双冒号：代表通过类名方式访问，第二个双冒号是，代表访问父类的作用域下！！！！</span></span><br><span class="line">Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认是Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;要想用父亲的就加作用域Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Base::m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//想要用子类来访问父类的静态成员变量就得用这种</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认是Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;要想用父亲的就加作用域Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Base::m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//想要用子类来访问父类的静态成员变量就得用这种</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">    <span class="comment">//第一个双冒号：代表通过类名方式访问，第二个双冒号是，代表访问父类的作用域下！！！！</span></span><br><span class="line">Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p></blockquote><h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p><hr><p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><hr><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><p>子类想用自己的 就类名.使用</p><p>子类想用爹爹们的 就用 子类名.父类::对应的数据</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base2</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_C = <span class="number">300</span>;</span><br><span class="line">m_D = <span class="number">400</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line"><span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote><h4 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p><p>​两个派生类继承同一个基类</p><p>​又有某个类同时继承者两个派生类</p><p>​这种继承被称为菱形继承，或者钻石继承</p><p><strong>典型的菱形继承案例：</strong></p><img src="/post/b4ccccea/clip_image002.jpg" class="" title="IMG_256"><p><strong>菱形继承问题：</strong></p><ol><li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</code></pre></li><li><pre><code>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</code></pre></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SheepTuo st;</span><br><span class="line">st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul><blockquote><p><strong>解释虚继承（virtual inheritance）的概念</strong></p><p>在C++中，当一个类被继承时，子类会包含父类的成员变量和成员函数。如果一个类被多个子类继承，那么每个子类都会包含一份父类的成员变量和成员函数，这可能会导致冗余和浪费。</p><p>为了解决这个问题，C++引入了虚继承（virtual inheritance）的概念。虚继承可以确保在多继承中，对于公共的基类，只有一份实例存在于继承体系中。通过使用<code>virtual</code>关键字来声明虚继承。</p><p>在您的代码中，<code>Sheep</code>和<code>Tuo</code>类都使用了虚继承，它们都继承自虚基类<code>Animal</code>。而<code>SheepTuo</code>类继承自<code>Sheep</code>和<code>Tuo</code>类。</p><p>在加入虚继承之前，<code>SheepTuo</code>类中会包含两份<code>m_Age</code>成员变量，分别来自于<code>Sheep</code>和<code>Tuo</code>类。而加入虚继承后，<code>SheepTuo</code>类中只会包含一份<code>m_Age</code>成员变量，来自于虚基类<code>Animal</code>。</p><p>因此，加入虚继承后，<code>SheepTuo</code>对象的大小（占用的字节数）会减小。在您的代码中，输出<code>sizeof(st)</code>可以看到<code>SheepTuo</code>对象的大小变为4。</p><p>另外，由于虚继承的特性，通过类名作用域来访问虚基类的成员变量。在您的代码中，使用<code>st.Sheep::m_Age</code>和<code>st.Tuo::m_Age</code>来访问<code>Sheep</code>和<code>Tuo</code>类中的<code>m_Age</code>成员变量。</p><p>最后，注释掉的<code>cout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;</code>语句会导致编译错误，因为在虚继承中，访问虚基类的成员变量需要使用类名作用域。</p><hr><p>在虚继承中，除了会包含虚基类的成员变量，还会包含一些额外的信息来处理虚继承的相关操作，比如虚基类指针或虚基类表。这些额外的信息会导致对象的大小增加。</p><hr><p><strong>确定虚基类的大小？想吧你哈哈</strong></p><p>确定虚基类指针或虚基类表所占字节的具体方法是依赖于编译器和系统的实现细节的。不同的编译器和系统可能会有不同的实现方式。</p><p>一种常见的实现方式是，在虚继承中，编译器会为每个包含虚基类的类生成一个虚基类表（vtable）。虚基类表是一个数据结构，用于存储虚基类的相关信息，比如虚基类的偏移量等。</p><p>虚基类指针是一个指向虚基类表的指针，用于在运行时动态查找虚基类的成员。虚基类指针的大小通常是一个指针的大小，即在32位系统中通常是4个字节，在64位系统中通常是8个字节。</p><p>虚基类表的大小取决于虚基类的数量和虚基类的成员变量和成员函数的数量。每个虚基类在虚基类表中占据一定的空间，用于存储虚基类的相关信息。</p></blockquote><h3 id="4-7-多态–3"><a href="#4-7-多态–3" class="headerlink" title="4.7  多态–3"></a>4.7  多态–3</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li>静态多态: <strong>函数重载 和 运算符重载属于静态多态，复用函数名</strong></li><li>动态多态: <strong>派生类和虚函数实现运行时多态</strong></li></ul><p>静态多态和动态多态区别：</p><ul><li><strong>静态多态的函数地址早绑定  -  编译阶段确定函数地址</strong></li><li><strong>动态多态的函数地址晚绑定</strong>  -  运行阶段确定函数地址</li></ul><hr><p><strong>等号左边编译类型右边运行类型，早绑定看编译类型，晚绑定看运行类型</strong></p><p><strong>Animal&amp; animal与传入的东西</strong></p><hr><p>&#x3D;&#x3D;就相当于重载函数，本来必须在同一作用域下才能重载，vritual允许父子类之间函数重载&#x3D;&#x3D;</p><p>下面通过案例进行讲解多态</p><blockquote><p>&#x2F;函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</p><p>&#x2F;&#x2F;我们希望传入什么对象，那么就调用什么对象的函数<br>&#x2F;&#x2F;如果函数地址在编译阶段就能确定，那么静态联编<br>&#x2F;&#x2F;如果函数地址在运行阶段才能确定，就是动态联编</p><hr><p>&#x2F;&#x2F;多态满足条件：<br>&#x2F;&#x2F;1、有继承关系<br>&#x2F;&#x2F;2、子类重写父类中的虚函数,,此时加不加 virtual都欧克<br>&#x2F;&#x2F;多态使用：<br><strong>———————————————&#x2F;&#x2F;父类指针或引用指向子类对象</strong>—————————————————-</p><p>父亲类 *pointer&#x3D;new 子类名;</p><p>父亲类&amp;p&#x3D;子类具体对象</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建+法计算器</span></span><br><span class="line">addCalculator add;</span><br><span class="line">AbstractCalculator&amp; abc = add;</span><br><span class="line"></span><br><span class="line">abc.a = <span class="number">10</span>;</span><br><span class="line">abc.b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc.<span class="built_in">getresult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">////////////////////////</span></span><br><span class="line"><span class="comment">//创建+法计算器</span></span><br><span class="line">AbstractCalculator* abc = <span class="keyword">new</span> <span class="built_in">addCalculator</span>();</span><br><span class="line"></span><br><span class="line">abc-&gt;a = <span class="number">10</span>;</span><br><span class="line">abc-&gt;b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;<span class="built_in">getresult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//释放对应的数据</span></span><br><span class="line"><span class="keyword">delete</span> abc;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//Speak函数就是虚函数</span></span><br><span class="line"><span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;动物在叫！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;喵喵喵！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//早绑定，编译阶段就把函数地址给绑定了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">(Animal&amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal.<span class="built_in">Speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal am;</span><br><span class="line">Cat cat;</span><br><span class="line"><span class="built_in">speak</span>(am);</span><br><span class="line"><span class="built_in">speak</span>(cat);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>没有重写speak函数的时候，通过继承，把父亲的虚函数也也继承下来了，而且在虚基表里是父类的函数</strong></p><img src="/post/b4ccccea/image-20230730140026926.png" class="" title="image-20230730140026926"><p>重写后</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;喵喵喵！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/post/b4ccccea/image-20230730140251440.png" class="" title="image-20230730140251440"><p>总结：</p><blockquote><p>C++中的多态是通过<strong>虚函数实现的</strong>。当<strong>基类指针或引用指向派生类对象时</strong>，可以通过<strong>该指针或引用调用虚函数时，会根据对象的实际类型来确定调用哪个类的虚函数。</strong></p><p>在C++中，<strong>每个包含虚函数的类都有一个虚函数表（vtable）</strong>。<strong>虚函数表是一个存储指向虚函数地址的指针数组。****每个对象都有一个指向其类的虚函数表的指针，称为虚函数指针（vptr）。</strong></p><p><strong>当对象被创建时，编译器会在对象的内存布局中添加一个隐藏的虚函数指针。</strong>这个指针指向该类的虚函数表。**&#x3D;&#x3D;如果类没有虚函数，那么它也不会有虚函数表和虚函数指针。&#x3D;&#x3D;**</p><p>当调用一个虚函数时，<strong>编译器会根据对象的虚函数指针找到对应的虚函数表，</strong>然<strong>后根据函数在虚函数表中的索引找到要调用的函数地址。</strong>这个过程是<strong>在运行时动态确定的</strong>，因此可以实现多态。</p><p>继承和重写是多态的基础。<strong>当派生类继承基类时，它会继承基类的虚函数，并可以选择重写这些虚函数。</strong></p><p>.<strong>通过重写，派生类可以为基类的虚函数提供自己的实现</strong>。</p><p>当使用基类指针或引用调用虚函数时，根据对象的实际类型，将调用派生类的虚函数。</p></blockquote><p>多态满足条件</p><ul><li><strong>有继承关系</strong></li><li><strong>子类重写父类中的虚函数</strong></li></ul><p>多态使用条件</p><ul><li><strong>父类指针或引用指向子类对象</strong></li></ul><p>重写：<strong>函数返回值类型  函数名 参数列表 完全一致称为重写</strong></p><h4 id="4-7-2-多态案例一-计算器类"><a href="#4-7-2-多态案例一-计算器类" class="headerlink" title="4.7.2 多态案例一-计算器类"></a>4.7.2 多态案例一-计算器类</h4><p><strong>‘’字符,””字符串</strong></p><p><strong>delete会把指针指向的内存权限释放，让这块内存可以被其他进程使用</strong></p><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getresult</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//+是一个字符串const char*</span></span><br><span class="line"><span class="comment">//或者strcmp(c,&#x27;+&#x27;)==0</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> a * b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Caculator caculator;</span><br><span class="line">caculator.a = <span class="number">10</span>;</span><br><span class="line">caculator.b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; caculator.<span class="built_in">getresult</span>(<span class="string">&#x27;+&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; caculator.<span class="built_in">getresult</span>(<span class="string">&#x27;-&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; caculator.<span class="built_in">getresult</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; caculator.<span class="built_in">getresult</span>(<span class="string">&#x27;/&#x27;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getresult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">addCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getresult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">jianCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getresult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">chengCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getresult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">chuCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getresult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建+法计算器</span></span><br><span class="line">AbstractCalculator* abc = <span class="keyword">new</span> <span class="built_in">addCalculator</span>();</span><br><span class="line"></span><br><span class="line">abc-&gt;a = <span class="number">10</span>;</span><br><span class="line">abc-&gt;b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;<span class="built_in">getresult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//释放对应的数据</span></span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建-法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> <span class="built_in">jianCalculator</span>();</span><br><span class="line">abc-&gt;a = <span class="number">10</span>;</span><br><span class="line">abc-&gt;b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;<span class="built_in">getresult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建*法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> <span class="built_in">chengCalculator</span>();</span><br><span class="line">abc-&gt;a = <span class="number">10</span>;</span><br><span class="line">abc-&gt;b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;<span class="built_in">getresult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line"><span class="comment">//创建/法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> <span class="built_in">chuCalculator</span>();</span><br><span class="line">abc-&gt;a = <span class="number">10</span>;</span><br><span class="line">abc-&gt;b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;<span class="built_in">getresult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line"><span class="comment">//销毁一次后仅仅完成了空间的释放,此时还可以使用,即指向关系依然存在,</span></span><br><span class="line"><span class="comment">//但如果释放了两次以上指向关系将不存在,但一般不建议这样使用,</span></span><br><span class="line"><span class="comment">//既然释放了某空间,紧接着给该空间的指针赋值为NULL或者指向一个地方,养成良好的编程风格</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p><p><strong><strong>&#x2F;&#x2F;销毁一次后仅仅完成了空间的释放,此时还可以使用,即指向关系依然存在,</strong><br>    <strong>&#x2F;&#x2F;但如果释放了两次以上指向关系将不存在,但一般不建议这样使用,</strong><br>    &#x2F;&#x2F;既然释放了某空间,紧接着给该空间的指针赋值为NULL或者指向一个地方,养成良好的编程风格</strong></p></blockquote><h4 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="&#x3D;&#x3D;4.7.3 纯虚函数和抽象类&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.7.3 纯虚函数和抽象类&#x3D;&#x3D;</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><blockquote><p><strong>抽象类不能实例化，但是能定义一个指向该类的指针</strong></p></blockquote><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><hr><p><strong>当类中有了纯虚函数，这个类也称为&#x3D;&#x3D;抽象类&#x3D;&#x3D;</strong></p><p><strong>纯虚函数是在<em>基类</em>中声明为纯虚函数的虚函数，它没有实现，只是用来作为接口的占位符，要求派生类必须实现这个函数。</strong></p><hr><p><strong>抽象类特点</strong>：</p><ul><li><strong>无法实例化对象</strong></li><li><strong>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</strong></li></ul><blockquote><p>纯虚函数来自</p><ol><li><strong>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></strong></li><li><strong>继承抽象类但不重写对应的纯虚函数！！！！！！！</strong></li><li>有虚析构函数或者纯虚析构函数</li></ol></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line"><span class="comment">//抽象类无法实例化对象</span></span><br><span class="line"><span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base * base = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">base = <span class="keyword">new</span> Son;</span><br><span class="line">base-&gt;<span class="built_in">func</span>();</span><br><span class="line"><span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-4-多态案例二-制作饮品"><a href="#4-7-4-多态案例二-制作饮品" class="headerlink" title="4.7.4 多态案例二-制作饮品"></a>4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p><p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><img src="/post/b4ccccea/1545985945198.png" class="" width="1545985945198"><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Makedrink</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">zhushui</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">chongru</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">daorubeizhong</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">jiaruzuoliao</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//规定流程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Makeit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">zhushui</span>();</span><br><span class="line"><span class="built_in">chongru</span>();</span><br><span class="line"><span class="built_in">daorubeizhong</span>();</span><br><span class="line"><span class="built_in">jiaruzuoliao</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MakeCha</span> :<span class="keyword">public</span> Makedrink</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zhushui</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;做茶的时候煮水&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chongru</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡茶叶&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">daorubeizhong</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;倒入杯子&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">jiaruzuoliao</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加柠檬&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Makecoffee</span> :<span class="keyword">public</span> Makedrink</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zhushui</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;做咖啡的时候煮水&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chongru</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡咖啡&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">daorubeizhong</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;倒入杯子&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">jiaruzuoliao</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加牛奶和冰糖&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dowork</span><span class="params">(Makedrink* abc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">abc-&gt;<span class="built_in">Makeit</span>();</span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Makedrink* mc = <span class="keyword">new</span> <span class="built_in">MakeCha</span>();</span><br><span class="line"><span class="built_in">Dowork</span>(mc);</span><br><span class="line"><span class="built_in">Dowork</span>(<span class="keyword">new</span> MakeCha);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;现在开始制作咖啡&quot;</span> &lt;&lt; endl;</span><br><span class="line">Makedrink* cf = <span class="keyword">new</span> <span class="built_in">Makecoffee</span>();</span><br><span class="line"><span class="built_in">Dowork</span>(cf);</span><br><span class="line"><span class="built_in">Dowork</span>(<span class="keyword">new</span> MakeCha);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h4><p><strong>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</strong></p><p><strong>也就是说不运行子类的析构函数！！！造成内存泄漏</strong></p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>​<strong>如果改成纯虚析构的话需要在函数外部进行 函数实现</strong></p><p>​<strong>或者就是简单的弄一个虚析构函数就ok了</strong></p><p>虚析构和纯虚析构共性：</p><ul><li><strong>可以解决父类指针释放子类对象</strong></li><li><strong>都需要有具体的函数实现</strong>，纯虚析构函数的实现必须在外部！</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p><strong>虚析构函数通常在希望通过基类指针或引用来删除派生类对象时使用。这样可以确保派生类的析构函数被正确调用，避免内存泄漏。</strong></p><p>虚析构语法：</p><p><code>virtual ~类名()&#123;&#125;</code></p><p>纯虚析构语法：</p><p><code> virtual ~类名() = 0;</code></p><p><strong>必须需要有外部实现！！！</strong></p><p><code>类名::~类名()&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//不加virtual的时候不会走子类的 析构函数 造成内存泄露</span></span><br><span class="line"><span class="comment">//析构函数加上virtual关键字，变成虚析构函数  就会走子类的析构函数了</span></span><br><span class="line"><span class="comment">//virtual ~Animal()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者是纯虚析构函数，但要有函数实现！！且在外部</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cat</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//虚函数的重写</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; *m_Name &lt;&lt; <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Cat</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_Name;</span><br><span class="line">m_Name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string* m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal* animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line"><span class="comment">//怎么解决？给基类增加一个虚析构函数 或者纯虚析构函数，但是明显是虚析构函数简单a Aaaaa</span></span><br><span class="line"><span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line"><span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><blockquote><h4 id="1-虚析构或纯虚析构就是用来解决通过父类指针释放子类对象"><a href="#1-虚析构或纯虚析构就是用来解决通过父类指针释放子类对象" class="headerlink" title="1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象"></a>1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</h4><h4 id="2-如果子类中没有堆区数据，可以不写为虚析构或纯虚析构"><a href="#2-如果子类中没有堆区数据，可以不写为虚析构或纯虚析构" class="headerlink" title="2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构"></a>2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</h4><h4 id="3-拥有纯虚析构函数的类也属于抽象类"><a href="#3-拥有纯虚析构函数的类也属于抽象类" class="headerlink" title="3. 拥有纯虚析构函数的类也属于抽象类"></a>3. 拥有纯虚析构函数的类也属于抽象类</h4></blockquote><h4 id="4-7-6-多态案例三-电脑组装"><a href="#4-7-6-多态案例三-电脑组装" class="headerlink" title="&#x3D;&#x3D;4.7.6 多态案例三-电脑组装&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.7.6 多态案例三-电脑组装&#x3D;&#x3D;</h4><p><strong>案例描述：</strong></p><p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p><p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p><p>测试时组装三台不同的电脑进行工作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的计算函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的存储函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Computer</span>(CPU* cpu, VideoCard* vc, Memory* mem)</span><br><span class="line">&#123;</span><br><span class="line">m_cpu = cpu;</span><br><span class="line">m_vc = vc;</span><br><span class="line">m_mem = mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供工作的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">~<span class="built_in">Computer</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放CPU零件</span></span><br><span class="line"><span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_cpu;</span><br><span class="line">m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放显卡零件</span></span><br><span class="line"><span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_vc;</span><br><span class="line">m_vc = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存条零件</span></span><br><span class="line"><span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_mem;</span><br><span class="line">m_mem = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">CPU* m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">VideoCard* m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">Memory* m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//第一台电脑零件</span></span><br><span class="line">CPU* intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">VideoCard* intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">Memory* intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//创建第一台电脑</span></span><br><span class="line">Computer* computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//第二台电脑组装</span></span><br><span class="line">Computer* computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);</span><br><span class="line">computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer2;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//第三台电脑组装</span></span><br><span class="line">Computer* computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);</span><br><span class="line">computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过<strong>文件可以将数据持久化</strong></p><p>C++中对文件操作需要包含头文件 &#x3D;&#x3D;&lt; fstream &gt;&#x3D;&#x3D;</p><p>文件类型分为两种：</p><ol><li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li><li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li></ol><p>操作文件的三大类:</p><ol><li>ofstream：写操作</li><li>ifstream： 读操作</li><li>fstream ： 读写操作</li></ol><h3 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h3><h4 id="5-1-1写文件"><a href="#5-1-1写文件" class="headerlink" title="5.1.1写文件"></a>5.1.1写文件</h4><p>   写文件步骤如下：</p><ol><li><p>包含头文件   </p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象  </p><p>ofstream ofs;</p></li><li><p>打开文件</p><p>ofs.open(“文件路径”,打开方式);</p></li><li><p>写数据</p><p>ofs &lt;&lt; “写入的数据”;</p></li><li><p>关闭文件</p><p>ofs.close();</p></li></ol><p>文件打开方式：</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p><p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p><blockquote><p>在C++中，<code>|</code> 是位运算符中的按位或运算符。当它用于两个整数时，它将对这两个整数的每个位执行逻辑或操作。</p><p>在文件操作中，<code>|</code> 运算符通常用于将多个标志（flag）组合在一起。在你提供的例子中，<code>ios::binary | ios::out</code> 将 <code>ios::binary</code> 和 <code>ios::out</code> 这两个标志进行按位或运算，以便将它们组合在一起。</p><p><code>ios::binary</code> 是 <code>ios</code> 类中的一个标志，表示以二进制模式打开文件。在二进制模式下，文件将以字节流的形式进行读写，而不会进行任何文本转换。</p><p><code>ios::out</code> 是另一个 <code>ios</code> 类中的标志，表示以写入模式打开文件。在写入模式下，文件将被打开以供写入操作。</p><p>通过将这两个标志使用 <code>|</code> 运算符组合在一起，你可以同时指定二进制模式和写入模式来打开文件。</p></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件操作必须包含头文件 fstream</li><li>读文件可以利用 ofstream  ，或者fstream类</li><li>打开文件时候需要指定操作文件的路径，以及打开方式</li><li>利用&lt;&lt;可以向文件中写数据</li><li>操作完毕，要关闭文件</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.包含fstream头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.测试写操作ooooo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.1创建对象!</span></span><br><span class="line"><span class="comment">//fstream a;</span></span><br><span class="line"><span class="comment">//也是ok的，为了区分，先引入总的头文件fstream，再用其分类ostream创建具体要写的对象</span></span><br><span class="line">ofstream a;</span><br><span class="line"><span class="comment">//1.2打开文件</span></span><br><span class="line">a.<span class="built_in">open</span>(<span class="string">&quot;E:/PROPORECODE/文件的读写操作/12.txt&quot;</span>, ios::out);</span><br><span class="line"><span class="comment">//1.3写入操作</span></span><br><span class="line">a &lt;&lt; <span class="string">&quot;你好啊&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//1.4关闭文件</span></span><br><span class="line">a.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-2读文件"><a href="#5-1-2读文件" class="headerlink" title="5.1.2读文件"></a>5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步骤如下：</p><ol><li><p>包含头文件   </p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象  </p><p>ifstream ifs;</p></li><li><p>打开文件并判断文件是否打开成功</p><p>ifs.open(“文件路径”,打开方式);</p></li><li><p>读数据</p><p>四种方式读取</p></li><li><p>关闭文件</p><p>ifs.close();</p></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//1.包含fstream头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.测试写操作ooooo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.1创建对象!</span></span><br><span class="line"><span class="comment">//fstream a;</span></span><br><span class="line"><span class="comment">//也是ok的，为了区分，先引入总的头文件fstream，再用其分类ostream创建具体要写的对象</span></span><br><span class="line">ofstream a;</span><br><span class="line"><span class="comment">//1.2打开文件</span></span><br><span class="line">a.<span class="built_in">open</span>(<span class="string">&quot;E:/PROPORECODE/文件的读写操作/11.txt&quot;</span>, ios::out | ios::binary);</span><br><span class="line"><span class="comment">//1.3写入操作</span></span><br><span class="line"><span class="comment">//&quot;你好啊&quot; &lt;&lt; endl;都被写进去了</span></span><br><span class="line">a &lt;&lt; <span class="string">&quot;你好啊dasdad &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//1.4关闭文件</span></span><br><span class="line">a.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.测试读文件</span></span><br><span class="line"><span class="comment">//2.1创建读的对象iiii</span></span><br><span class="line">fstream b;</span><br><span class="line">b.<span class="built_in">open</span>(<span class="string">&quot;E:/PROPORECODE/文件的读写操作/11.txt&quot;</span>, ios::in);</span><br><span class="line"><span class="keyword">if</span> (b.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;打开成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;打开失败！，草！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//读取1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//char bufer[1024];</span></span><br><span class="line"><span class="comment">//while (b&gt;&gt;bufer)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; bufer;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//读取2类内的getline</span></span><br><span class="line"><span class="comment">//char bufer[1024] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//while (b.getline(bufer, sizeof(bufer)))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; bufer &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//读取3全局getline</span></span><br><span class="line"><span class="comment">//string str;</span></span><br><span class="line"><span class="comment">//while (getline(b,str))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; str &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> (c=b.<span class="built_in">get</span>()!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从右到左！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><blockquote><ul><li><strong>读文件可以利用 ifstream  ，或者fstream类</strong></li><li><strong>利用is_open函数可以判断文件是否打开成功</strong></li><li><strong>close 关闭文件</strong></li></ul></blockquote><h3 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为 &#x3D;&#x3D;ios::binary&#x3D;&#x3D;</p><h4 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> name[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">fstream <span class="title">a</span><span class="params">(<span class="string">&quot;E:/PROPORECODE/文件的读写操作/21.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">MyStruct xrb = &#123; <span class="number">18</span>,<span class="string">&quot;李四&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//结构体的实例化</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">a.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;xrb, <span class="built_in">sizeof</span>(str));</span><br><span class="line"></span><br><span class="line">a.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件输出流对象 可以通过write函数，以二进制方式写数据</li></ul><h4 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> name[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">fstream <span class="title">a</span><span class="params">(<span class="string">&quot;E:/PROPORECODE/文件的读写操作/21.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">MyStruct xrb = &#123; <span class="number">18</span>,<span class="string">&quot;李四&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//结构体的实例化</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">a.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;xrb, <span class="built_in">sizeof</span>(xrb));</span><br><span class="line"></span><br><span class="line">a.<span class="built_in">close</span>();</span><br><span class="line">fstream b;</span><br><span class="line">b.<span class="built_in">open</span>(<span class="string">&quot;E:/PROPORECODE/文件的读写操作/21.txt&quot;</span>, ios::in | ios::binary);</span><br><span class="line"><span class="keyword">if</span> (b.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;读取成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">MyStruct l;</span><br><span class="line">b.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;l, <span class="built_in">sizeof</span>(l));</span><br><span class="line">cout &lt;&lt; l.age &lt;&lt; l.name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文件输入流对象 可以通过read函数，以二进制方式读数据</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="/post/a378bd8e.html"/>
      <url>/post/a378bd8e.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python程序设计"><a href="#Python程序设计" class="headerlink" title="Python程序设计"></a>Python程序设计</h1><h3 id="2-1语法特点"><a href="#2-1语法特点" class="headerlink" title="2.1语法特点"></a>2.1语法特点</h3><h6 id="python没有花括号，需要严格的缩进格式。就是空格数是相同的"><a href="#python没有花括号，需要严格的缩进格式。就是空格数是相同的" class="headerlink" title="python没有花括号，需要严格的缩进格式。就是空格数是相同的"></a>python没有花括号，需要严格的缩进格式。就是空格数是相同的</h6><h6 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释#"></a>单行注释#</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">0</span></span><br><span class="line">b=<span class="number">0</span></span><br><span class="line">c=<span class="string">&quot;你好&quot;</span></span><br><span class="line"><span class="comment"># 允许同时为多个变量赋值</span></span><br><span class="line">p=l=k=<span class="number">5</span></span><br><span class="line"><span class="comment"># 可以变量之间相互赋值</span></span><br><span class="line"><span class="comment"># 同一个变量可以反复赋值</span></span><br><span class="line">d=<span class="string">&quot;12.3&quot;</span></span><br><span class="line"><span class="comment"># 弱语言类型，根据赋予的值来决定具体的数据类型</span></span><br><span class="line">a=<span class="built_in">input</span>(<span class="string">&quot;请输入a&quot;</span>)</span><br><span class="line">b=<span class="built_in">input</span>(<span class="string">&quot;请输入b&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> a&gt;b:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好吗&quot;</span>)</span><br></pre></td></tr></table></figure><h6 id="多行注释用”””或’’’抱起来"><a href="#多行注释用”””或’’’抱起来" class="headerlink" title="多行注释用”””或’’’抱起来"></a>多行注释用”””或’’’抱起来</h6><h6 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h6><blockquote><p>在代码中固定不变的值</p></blockquote><h6 id="语句换行-书写换行，实际一行"><a href="#语句换行-书写换行，实际一行" class="headerlink" title="语句换行 书写换行，实际一行"></a>语句换行 书写换行，实际一行</h6><p><em><strong>反斜杠后面没有跟任何字符，因此它被视为一个续行符</strong></em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=<span class="string">&quot; 窗前明月光\</span></span><br><span class="line"><span class="string">  dsadasdas\</span></span><br><span class="line"><span class="string"> dsadasdas&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment">#结果是</span></span><br><span class="line"><span class="comment">#  窗前明月光  dsadasdas dsadasdas</span></span><br></pre></td></tr></table></figure><h6 id="同一行写多个语句用分号隔开"><a href="#同一行写多个语句用分号隔开" class="headerlink" title="同一行写多个语句用分号隔开"></a>同一行写多个语句用分号隔开</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m=<span class="number">10</span>;n=<span class="number">11</span></span><br><span class="line"><span class="comment"># 但可读性大大降低</span></span><br></pre></td></tr></table></figure><h6 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h6><h6 id="import-模块名"><a href="#import-模块名" class="headerlink" title="import 模块名"></a>import 模块名</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(math.PI)</span><br></pre></td></tr></table></figure><h3 id="2-2标准输入-输出"><a href="#2-2标准输入-输出" class="headerlink" title="2.2标准输入&#x2F;输出"></a><strong>2.2标准输入&#x2F;输出</strong></h3><h6 id="标准输入函数"><a href="#标准输入函数" class="headerlink" title="标准输入函数"></a>标准输入函数</h6><p>返回的是字符出类型</p><p>注意类型转换</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">input</span>([prompt])</span><br><span class="line"><span class="comment">#prompt可选参数</span></span><br><span class="line"><span class="comment">#返回一个字符串对象</span></span><br><span class="line">name=<span class="built_in">input</span>(<span class="string">&quot;请输入你的大名&quot;</span>)</span><br><span class="line"><span class="comment">#如果需要其他类型的数据就需要强制转换</span></span><br></pre></td></tr></table></figure><h6 id="标准输出函数"><a href="#标准输出函数" class="headerlink" title="标准输出函数"></a>标准输出函数</h6><p>&#x3D;&#x3D;默认自动换行&#x3D;&#x3D;</p><p>&#x3D;&#x3D;print(“%dx%d&#x3D;%d”%(i,j,sum),end&#x3D;’\t’)&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print(value,……,sep=;&#x27;&#x27;,end=&#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># value代表输出对象，可以有多个，用逗号隔开</span></span><br><span class="line"><span class="comment"># sep用于设置输出信息的分隔符 默认为一个空格</span></span><br><span class="line"><span class="comment"># end表示print语句的结束负号，默认为换行符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;你&quot;</span>,<span class="string">&quot;好&quot;</span>,<span class="string">&quot;啊&quot;</span>,sep=<span class="string">&quot;-&quot;</span>,end=<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment"># 你-好-啊a</span></span><br></pre></td></tr></table></figure><h5 id="如何格式化表达式"><a href="#如何格式化表达式" class="headerlink" title="如何格式化表达式?"></a><em><strong>如何格式化表达式?</strong></em></h5><p><em><strong>●f”{表达式}”</strong></em><br><em><strong>●”%s%d%f” % (表达式、表达式、表达式)</strong></em></p><h3 id="2-3变量和常量"><a href="#2-3变量和常量" class="headerlink" title="2.3变量和常量"></a><strong>2.3变量和常量</strong></h3><h6 id="在python中可以直接声明变量，不必声明变量的类型，也就是弱语言类型"><a href="#在python中可以直接声明变量，不必声明变量的类型，也就是弱语言类型" class="headerlink" title="在python中可以直接声明变量，不必声明变量的类型，也就是弱语言类型."></a>在python中可以直接声明变量，不必声明变量的类型，也就是弱语言类型.</h6><h6 id="虽然不需要声明但是在使用前一定要赋值"><a href="#虽然不需要声明但是在使用前一定要赋值" class="headerlink" title="虽然不需要声明但是在使用前一定要赋值"></a>虽然不需要声明但是在使用前一定要赋值</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b=<span class="number">0</span></span><br><span class="line">c=<span class="string">&quot;你好&quot;</span></span><br><span class="line"><span class="comment"># 允许同时为多个变量赋值</span></span><br><span class="line">p=l=k=<span class="number">5</span></span><br><span class="line"><span class="comment"># 可以变量之间相互赋值</span></span><br><span class="line"><span class="comment"># 同一个变量可以反复赋值</span></span><br><span class="line">d=<span class="string">&quot;12.3&quot;</span></span><br><span class="line"><span class="comment"># 弱语言类型，根据赋予的值来决定具体的数据类型</span></span><br></pre></td></tr></table></figure><h6 id="常量就是值不改变的，通常用全部大写的变量名表示常量"><a href="#常量就是值不改变的，通常用全部大写的变量名表示常量" class="headerlink" title="常量就是值不改变的，通常用全部大写的变量名表示常量"></a>常量就是值不改变的，通常用全部大写的变量名表示常量</h6><p>python<em>没有机制保护产量不会被改变</em></p><h3 id="2-4标识符和关键字"><a href="#2-4标识符和关键字" class="headerlink" title="2.4标识符和关键字"></a><strong>2.4标识符和关键字</strong></h3><ol><li>可以有&#x3D;&#x3D;大小写字母，数字，下划线&#x3D;&#x3D;</li><li>要求第一个字符不能是数字</li><li>区分大小写就是joke和JOKE不一样</li><li>在python3中汉字也可以出现在标识符里</li></ol><h3 id="2-5简单数据类型"><a href="#2-5简单数据类型" class="headerlink" title="2.5简单数据类型"></a><strong>2.5简单数据类型</strong></h3><h4 id="type-查数据类型"><a href="#type-查数据类型" class="headerlink" title="&#x3D;&#x3D;type()查数据类型&#x3D;&#x3D;"></a>&#x3D;&#x3D;type()查数据类型&#x3D;&#x3D;</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>]</span><br><span class="line">b=<span class="string">&quot;你好&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b))</span><br><span class="line"><span class="comment"># &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p>整形int特点</p><ol><li><p>不带小数点，分正负</p></li><li><p>在python中没有大小限制，只要内存许可就可以无限大</p></li><li><p>二进制0B开头，八进制0O开头，十六进制0X开头</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">0b1010</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">0x81</span>)</span><br><span class="line"><span class="comment"># 结果是10</span></span><br><span class="line"><span class="comment"># 结果是129</span></span><br></pre></td></tr></table></figure></li><li><p>进制之间的转十进制转为二进制bin(十进制数)</p></li><li><p>十进制转为八进制oct(十进制数)</p></li><li><p>十进制转为十六进制hex(十进制数)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="number">21</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">oct</span>(<span class="number">21</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">21</span>))</span><br><span class="line"><span class="comment"># 0b10101</span></span><br><span class="line"><span class="comment"># 0o25</span></span><br><span class="line"><span class="comment"># 0x15</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="浮点类型特点"><a href="#浮点类型特点" class="headerlink" title="浮点类型特点"></a>浮点类型特点</h4><ol><li>整形转为float用float（整数150）&#x3D;&gt;150.0</li><li>1.2e2&#x3D;&gt;1.2*10^2^</li></ol><h4 id="布尔类型特点"><a href="#布尔类型特点" class="headerlink" title="布尔类型特点"></a>布尔类型特点</h4><ol><li>True和False</li><li>为0的数字0 0.0</li><li>空字符串’’ “”</li><li>空集合(){}[]</li><li>false</li><li>None</li><li>以上全为false</li></ol><h4 id="复数类型特点"><a href="#复数类型特点" class="headerlink" title="复数类型特点"></a>复数类型特点</h4><ol><li>数学上是a+bi</li><li>这里是real+imag</li><li>对应a&#x3D;1.5+2j&#x2F;J</li><li>获取实部和虚部，a.real，a.imag</li><li>把两个数转换为一个复数complex(a,b)&#x3D;&gt;a+bj</li></ol><h4 id="字符串类型特点"><a href="#字符串类型特点" class="headerlink" title="字符串类型特点"></a>字符串类型特点</h4><h6 id="标识字符串"><a href="#标识字符串" class="headerlink" title="标识字符串"></a>标识字符串</h6><ol><li>标识字符串用 单引号’’ 双引号”” 三单引号’’’ ‘’’三双””” “””</li><li>‘你好啊’ , ”你好啊“,     “””你好啊””” ,   ‘’’你好啊’’’</li><li>&#x3D;&#x3D;特殊的三引号抱起来，能原封不动的表示字符串，保留换行和缩进。。&#x3D;&#x3D;</li></ol><h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><ol><li><p>用\开头</p></li><li><p>‘let’s go’&#x3D;&gt;’let\‘s go’</p></li><li><p>\n换行</p></li><li><p>\t横向制表符</p></li><li><p>\r是回车符，&#x3D;&#x3D;它的作用是将光标移到当前行的开头&#x3D;&#x3D;，覆盖之前的内容。</p></li><li><p>\b是退格符，&#x3D;&#x3D;它的作用是将光标向左移动一格&#x3D;&#x3D;，可以用来删除之前输入的字符。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dsadasdadsadasd\r我在这&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dasdasdsav\b我&quot;</span>)</span><br><span class="line"><span class="comment"># 我在这</span></span><br><span class="line"><span class="comment"># dasdasdsa我</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="字符串基本操作"><a href="#字符串基本操作" class="headerlink" title="&#x3D;&#x3D;字符串基本操作&#x3D;&#x3D;"></a>&#x3D;&#x3D;字符串基本操作&#x3D;&#x3D;</h4><ol><li><h5 id="正索引-负索引-但不可修改"><a href="#正索引-负索引-但不可修改" class="headerlink" title="正索引&#x2F;负索引(但不可修改)"></a>正索引&#x2F;负索引(但不可修改)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&quot;python&quot;</span></span><br><span class="line"><span class="comment"># a[1]=9???不可以</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(i)!</span><br><span class="line"><span class="comment"># p 0 -6</span></span><br><span class="line"><span class="comment"># y 1 -5</span></span><br><span class="line"><span class="comment"># t 2 -4</span></span><br><span class="line"><span class="comment"># h 3 -3</span></span><br><span class="line"><span class="comment"># o 4 -2</span></span><br><span class="line"><span class="comment"># n 5 -1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>&#x3D;&#x3D;python不允许以任何方式改变字符串对象的值，否则会出错&#x3D;&#x3D;</strong></p></li><li><p>&#x3D;&#x3D;可以用+号连接两个字符串，可以用*生成重复的字符串&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&quot;比你好&quot;</span></span><br><span class="line">b=<span class="string">&quot;比是的&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a*<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(a+b)</span><br><span class="line"><span class="comment"># 比你好比你好比你好比你好比你好比你好</span></span><br><span class="line"><span class="comment"># 比你好比是的</span></span><br></pre></td></tr></table></figure></li><li><h5 id="字符串切片操作"><a href="#字符串切片操作" class="headerlink" title="字符串切片操作"></a>字符串切片操作</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&quot;python&quot;</span></span><br><span class="line"><span class="comment"># [b,c]</span></span><br><span class="line"><span class="comment"># b代表起点，c代表下标加1，左闭右开 [start，end)</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line"><span class="comment"># py</span></span><br><span class="line"><span class="comment"># 左边不写的话默认为0</span></span><br><span class="line"><span class="comment"># 右边不写的话默认为字符串长度</span></span><br></pre></td></tr></table></figure></li><li><p>字符串逆转</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&quot;你好啊&quot;</span></span><br><span class="line">a=a[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li></ol><h5 id="字符串的常用方法："><a href="#字符串的常用方法：" class="headerlink" title="字符串的常用方法："></a>字符串的常用方法：</h5><p>&#x3D;&#x3D;这些操作都没有真正改变原来的字符串，而是返回了一个新的字符串。原来的字符串仍然保持不变。如果要改变原来的字符串，可以将新的字符串赋值给原来的变量。例如：&#x3D;&#x3D;</p><blockquote><ol><li><p>str.capitalize()  把字符串的首字母变成大写</p></li><li><p>str.find(x)   找到字符串中x的下标</p></li><li><p>str.index(x)   找到字符串中x的下标</p></li><li><p>str.lower()   把字符串中的大写变成小写</p></li><li><p>str.upper()  把字符串中的小写变成大写</p></li><li><p>str.split(x),用x把字符串给分割开，&#x3D;&#x3D;得到一个list 列表&#x3D;&#x3D;，<strong>默认是以空格分开。</strong></p></li><li><h5 id="在Python中，字符串对象有一个-strip-方法，用于去除字符串两端的空白字符（包括空格、制表符和换行符）。"><a href="#在Python中，字符串对象有一个-strip-方法，用于去除字符串两端的空白字符（包括空格、制表符和换行符）。" class="headerlink" title="在Python中，字符串对象有一个 strip() 方法，用于去除字符串两端的空白字符（包括空格、制表符和换行符）。"></a>在Python中，字符串对象有一个 <code>strip()</code> 方法，用于去除字符串两端的空白字符（包括空格、制表符和换行符）。</h5><h5 id="strip-方法不会修改原始字符串，而是返回一个新的字符串。如果指定参数-就清除字符串两端的指定字符"><a href="#strip-方法不会修改原始字符串，而是返回一个新的字符串。如果指定参数-就清除字符串两端的指定字符" class="headerlink" title="strip() 方法不会修改原始字符串，而是返回一个新的字符串。如果指定参数,就清除字符串两端的指定字符"></a><code>strip()</code> 方法不会修改原始字符串，而是返回一个新的字符串。如果指定参数,就清除字符串两端的指定字符</h5></li></ol></blockquote><p>a &#x3D; a.replace(“python”,”蟒蛇”)&#x3D;&#x3D;</p><ol><li><pre><code class="python">a=&quot;python&quot;# capitalize(a)print(a.capitalize())print(a.find(&#39;o&#39;))print(a.lower())print(a.upper())print(a.count(&#39;p&#39;))print(a.split(&#39;p&#39;))#得到一个列表对象# 默认是[&#39;python&#39;]# [&#39;&#39;, &#39;ython&#39;]print(a)print(a.replace(&quot;python&quot;,&quot;蟒蛇&quot;))print(a)# Python# 4# python# PYTHON# 1# [&#39;&#39;, &#39;ython&#39;]# python# 蟒蛇# python<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### 字符串拼接</span><br><span class="line"></span><br><span class="line">&gt; 1==printf(&quot;%d+%d=%d&quot;%(a,b,c))==</span><br><span class="line">&gt;</span><br><span class="line">&gt; ----------------------------------------------------------------</span><br><span class="line">&gt;</span><br><span class="line">&gt; 2 ***==f&quot;内容&#123;变量&#125;&quot;==***</span><br><span class="line">&gt;</span><br><span class="line">&gt; 注意里面只能是变量，表达式不可以sum-=1000</span><br><span class="line">&gt;</span><br><span class="line">&gt; ---</span><br><span class="line">&gt;</span><br><span class="line">&gt; Traceback (most recent call last):</span><br><span class="line">&gt; File &quot;e:\Bluecode\python\learn\learn\review.py&quot;, line 7, in &lt;module&gt;</span><br><span class="line">&gt;  print(f&quot;&#123;aa1&#125;+&#123;bb1+1&#125;=&#123;aa1+bb1&#125;&quot;)</span><br><span class="line">&gt;                 ~~~^~</span><br><span class="line">&gt; TypeError: can only concatenate str (not &quot;int&quot;) to str</span><br><span class="line">&gt;                 ~~~</span><br><span class="line">&gt;</span><br><span class="line">&gt; ```python</span><br><span class="line">&gt; aa=int(input(&quot;请输入aa&quot;))</span><br><span class="line">&gt; bb=int(input(&quot;请输入bb&quot;))</span><br><span class="line">&gt; print(f&quot;&#123;aa&#125;+&#123;bb&#125;=&#123;aa+bb&#125;&quot;)</span><br><span class="line">&gt; aa1=(input(&quot;请输入aa1&quot;))</span><br><span class="line">&gt; bb1=(input(&quot;请输入bb1&quot;))</span><br><span class="line">&gt; print(f&quot;&#123;aa1&#125;+&#123;bb1&#125;=&#123;aa1+bb1&#125;&quot;)</span><br><span class="line">&gt; # 请输入aa7</span><br><span class="line">&gt; # 请输入bb8</span><br><span class="line">&gt; # 7+8=15</span><br><span class="line">&gt; # 请输入aa17</span><br><span class="line">&gt; # 请输入bb18</span><br><span class="line">&gt; # 7+8=78</span><br></pre></td></tr></table></figure>&gt;&gt; `input默认得到的是字符串对象`</code></pre></li></ol><h5 id="格式化的精度控制"><a href="#格式化的精度控制" class="headerlink" title="格式化的精度控制"></a><strong>格式化的精度控制</strong></h5><p>特殊在设置宽度后&#x3D;&#x3D;，是补空格&#x3D;&#x3D;，&#x3D;&#x3D;而且还是四舍五入&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c=<span class="number">11.39</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%d&quot;</span>%c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%.2f&quot;</span>%c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%5.1f&quot;</span>%c)</span><br><span class="line"><span class="comment"># 11</span></span><br><span class="line"><span class="comment"># 11.39</span></span><br><span class="line"><span class="comment">#  11.4</span></span><br></pre></td></tr></table></figure><h6 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&quot;it it dsasdasd it&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a.count(<span class="string">&#x27;it&#x27;</span>))</span><br><span class="line">a=a.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a=a.split(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># it|it|dsasdasd|it</span></span><br><span class="line"><span class="comment"># [&#x27;it&#x27;, &#x27;it&#x27;, &#x27;dsasdasd&#x27;, &#x27;it&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="2-6-类型转换"><a href="#2-6-类型转换" class="headerlink" title="2.6&#x3D;&#x3D;类型转换&#x3D;&#x3D;"></a>2.6&#x3D;&#x3D;类型转换&#x3D;&#x3D;</h3><h5 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h5><ol><li><h5 id="int-x-得到整肃"><a href="#int-x-得到整肃" class="headerlink" title="int(x) 得到整肃"></a>int(x) 得到整肃</h5></li><li><h5 id="float-x-得到浮点数"><a href="#float-x-得到浮点数" class="headerlink" title="float(x) 得到浮点数"></a>float(x) 得到浮点数</h5></li><li><h5 id="complex-a-b-得到对应的复数"><a href="#complex-a-b-得到对应的复数" class="headerlink" title="complex(a,b) 得到对应的复数"></a>complex(a,b) 得到对应的复数</h5></li><li><h5 id="str-x-将对象转化为人容读取的字符串"><a href="#str-x-将对象转化为人容读取的字符串" class="headerlink" title="&#x3D;&#x3D;str(x) 将对象转化为人容读取的字符串&#x3D;&#x3D;"></a>&#x3D;&#x3D;str(x) 将对象转化为人容读取的字符串&#x3D;&#x3D;</h5></li><li><h5 id="repr-x-将对象转化为编辑器容读取的字符串"><a href="#repr-x-将对象转化为编辑器容读取的字符串" class="headerlink" title="repr(x) 将对象转化为编辑器容读取的字符串"></a>repr(x) 将对象转化为编辑器容读取的字符串</h5></li><li><h5 id="eval-str"><a href="#eval-str" class="headerlink" title="eval(str)"></a>eval(str)</h5></li><li><h5 id="chr-x-得到ancil对应的字符"><a href="#chr-x-得到ancil对应的字符" class="headerlink" title="chr(x) 得到ancil对应的字符"></a>chr(x) 得到ancil对应的字符</h5></li><li><h5 id="ord-x-得到l对应的ancil马"><a href="#ord-x-得到l对应的ancil马" class="headerlink" title="ord(x) 得到l对应的ancil马"></a>ord(x) 得到l对应的ancil马</h5></li><li><h5 id="bin-oct-hex"><a href="#bin-oct-hex" class="headerlink" title="bin(),oct(),hex()"></a>bin(),oct(),hex()</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="number">1.2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">complex</span>(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="comment"># str,repr</span></span><br><span class="line"><span class="comment"># print(eval(&quot;sdasd&quot;+&quot;xrb&quot;))</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">77</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="number">18</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">oct</span>(<span class="number">18</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">18</span>))</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 1.0</span></span><br><span class="line"><span class="comment"># (1+2j)</span></span><br><span class="line"><span class="comment"># M</span></span><br><span class="line"><span class="comment"># 0b10010</span></span><br><span class="line"><span class="comment"># 0o22</span></span><br><span class="line"><span class="comment"># 0x12</span></span><br></pre></td></tr></table></figure></li><li><p>各种进制转换为10进制</p></li></ol><p>   使用int的强制转换的第二个参数</p>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_two=<span class="built_in">int</span>(<span class="built_in">bin</span>(<span class="number">16</span>),<span class="number">2</span>)</span><br><span class="line">num_eight=<span class="built_in">int</span>(<span class="built_in">oct</span>(<span class="number">16</span>),<span class="number">8</span>)</span><br><span class="line">num_16=<span class="built_in">int</span>(<span class="string">&quot;aB234&quot;</span>,<span class="number">16</span>);</span><br><span class="line"><span class="comment">#int 的第二个参数代表前面字符串的进制数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;num_two&#125;</span>+++++++<span class="subst">&#123;num_eight&#125;</span>++++<span class="subst">&#123;num_16&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment">#16+++++++16++++700980</span></span><br></pre></td></tr></table></figure><h5 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="&#x3D;&#x3D;运算符和表达式&#x3D;&#x3D;"></a>&#x3D;&#x3D;运算符和表达式&#x3D;&#x3D;</h5><p>对数据进行加工处理的过程叫运算</p><p>表示运算的符号成为运算符</p><p>参加运算的数据叫做操作数</p><h6 id="2-71算数运算符"><a href="#2-71算数运算符" class="headerlink" title="2.71算数运算符"></a>2.71算数运算符</h6><ol><li><ul><li></li></ul></li><li><ul><li></li></ul></li><li><ul><li></li></ul></li><li>&#x2F;</li><li>%</li><li>**</li><li>&#x2F;&#x2F;</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">5</span>;b=<span class="number">2</span>;c=<span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(a+b)</span><br><span class="line"><span class="built_in">print</span>(a**b)</span><br><span class="line"><span class="comment">#a的b次方</span></span><br><span class="line"><span class="built_in">print</span>(c//b)</span><br><span class="line"><span class="comment">#c整除b，商的整数部分</span></span><br></pre></td></tr></table></figure><h6 id="2-72比较运算符"><a href="#2-72比较运算符" class="headerlink" title="2.72比较运算符"></a>2.72比较运算符</h6><ol><li>&#x3D;&#x3D;</li><li>!&#x3D;</li><li>&lt;&gt;类似!&#x3D; &#x3D;&#x3D;在Python中，<code>&lt;&gt;</code> 运算符已经被弃用，因此不再被支持。&#x3D;&#x3D;</li><li>&gt;</li><li>&lt;</li><li>&gt;&#x3D;</li><li>&lt;&#x3D;</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">2</span>;b=<span class="number">2</span>;c=<span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(a&gt;b)</span><br><span class="line"><span class="built_in">print</span>(a==b)</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure><h6 id="2-73逻辑运算符-与或非"><a href="#2-73逻辑运算符-与或非" class="headerlink" title="2.73逻辑运算符-与或非-"></a>2.73逻辑运算符-与或非-</h6><p>&#x3D;&#x3D;默认从左到右&#x3D;&#x3D;</p><ol><li><p>与and   <strong>&#x3D;&#x3D;第一个为0就返回0，第一个为1就返回第二个操作数&#x3D;&#x3D;</strong></p></li><li><h6 id="或or-第一个为1就返回1，第一个为0就返回第二个操作数"><a href="#或or-第一个为1就返回1，第一个为0就返回第二个操作数" class="headerlink" title="或or   &#x3D;&#x3D;第一个为1就返回1，第一个为0就返回第二个操作数&#x3D;&#x3D;"></a>或or   &#x3D;&#x3D;第一个为1就返回1，第一个为0就返回第二个操作数&#x3D;&#x3D;</h6></li><li><p>根据第一个操作数的真假来确定是否返回第二个操作数</p></li><li><p>非not</p></li><li><p>&#x3D;&#x3D;注意逻辑运算符左右不能直接与操作数直接接触&#x3D;&#x3D;</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">1</span></span><br><span class="line">b=<span class="number">1</span></span><br><span class="line">c=<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> a==b <span class="keyword">and</span> b==c:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;asddassd&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="2-74赋值运算符"><a href="#2-74赋值运算符" class="headerlink" title="2.74赋值运算符"></a>2.74赋值运算符</h6><p>&#x3D;</p><p>x&#x3D;x+1</p><blockquote><ol><li>+&#x3D;</li><li>-&#x3D;</li><li>&#x2F;&#x3D;</li><li>*&#x3D;</li><li>%&#x3D;</li><li>**&#x3D;</li><li>&#x2F;&#x2F;&#x3D;</li></ol></blockquote><p>&#x3D;&#x3D;计算后并且赋值&#x3D;&#x3D;</p><h6 id="2-75位运算符（5）"><a href="#2-75位运算符（5）" class="headerlink" title="2.75位运算符（5）"></a>2.75位运算符（5）</h6><p>Python里面没有&amp;&amp;&#x2F;&#x2F;||</p><p>对八位二进制数进行运算，&amp;有假就0，|有真就1,异或&#x3D;&#x3D;同1异0&#x3D;&#x3D;</p><p>~1变-，0变1</p><p>左移整体左移，超出去的保留符号（1代表负，0代表正）右边补0</p><p>​</p><blockquote><ol><li>按位与&amp;</li><li>按位或|</li><li>按位异位~</li><li>左移&lt;&lt;</li><li>右移&gt;&gt;</li></ol></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a=3</span></span><br><span class="line"><span class="comment"># 0 0 0 0 0 0 1 1</span></span><br><span class="line"><span class="comment"># a&lt;&lt;2</span></span><br><span class="line"><span class="comment"># 0 0 0 0 1 1 0 0</span></span><br><span class="line"><span class="comment"># 12=3*2的2次方</span></span><br></pre></td></tr></table></figure><h6 id="2-76成员运算符"><a href="#2-76成员运算符" class="headerlink" title="2.76成员运算符"></a>2.76成员运算符</h6><p>&#x3D;&#x3D;用来判断序列中是否存在某个成员&#x3D;&#x3D;</p><blockquote><ol><li>in</li><li>not in</li></ol></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arry=[<span class="string">&quot;电视&quot;</span>,<span class="string">&quot;冰箱&quot;</span>,<span class="string">&quot;电脑&quot;</span>,<span class="string">&quot;女盆友&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;电视&quot;</span><span class="keyword">in</span> arry)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;电视&#x27;</span><span class="keyword">in</span> arry)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;男朋友&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> arry)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h6 id="2-77标识运算符"><a href="#2-77标识运算符" class="headerlink" title="2.77标识运算符"></a>2.77标识运算符</h6><p>&#x3D;&#x3D;判断两个变量是否引用同一个对象&#x3D;&#x3D;</p><blockquote><ol><li>is</li><li>is not</li></ol></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&quot;电视&quot;</span></span><br><span class="line">b=<span class="string">&quot;冰箱&quot;</span></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> b:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a和b引用同一个对象&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a和b引用不同的对象&quot;</span>)</span><br><span class="line">    a=b</span><br><span class="line">    <span class="keyword">if</span> a <span class="keyword">is</span> b:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;a和b引用同一个对象&quot;</span>)</span><br><span class="line"><span class="comment"># a和b引用不同的对象</span></span><br><span class="line"><span class="comment"># a和b引用同一个对象</span></span><br></pre></td></tr></table></figure><h5 id="2-8运算符优先级"><a href="#2-8运算符优先级" class="headerlink" title="2.8运算符优先级"></a>2.8运算符优先级</h5><blockquote><ol><li>括号：()</li><li>幂运算：**</li><li>正负号：+x, -x</li><li>乘除取模运算：*, &#x2F;, %</li><li>加减运算：+, -</li><li>比较运算：&lt;, &gt;, &lt;&#x3D;, &gt;&#x3D;, &#x3D;&#x3D;, !&#x3D;</li><li>逻辑运算：not, and, or</li><li>赋值运算：&#x3D;, +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D;, %&#x3D;, **&#x3D;, &#x2F;&#x2F;&#x3D;</li></ol></blockquote><p>&#x3D;&#x3D;使用括号：如果有任何疑问，可以使用括号明确指定运算的顺序。&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">3</span></span><br><span class="line">b=<span class="number">0</span></span><br><span class="line">d=a <span class="keyword">and</span> b</span><br><span class="line">e=a <span class="keyword">or</span> b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">and</span> b)</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">or</span> b)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"><span class="comment">#0</span></span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="comment">#0</span></span><br><span class="line"><span class="comment">#3</span></span><br></pre></td></tr></table></figure><h3 id="3-1python控制语句"><a href="#3-1python控制语句" class="headerlink" title="3.1python控制语句"></a>3.1python控制语句</h3><p>&#x3D;&#x3D;不成文结论 ：相当于()&#x3D;&#x3D;</p><h5 id="3-123选择语句"><a href="#3-123选择语句" class="headerlink" title="3.123选择语句"></a>3.123选择语句</h5><ol><li>简单if语句</li><li>if-else语句</li><li>if-elif-else语句</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aa=<span class="number">10</span>;bb=<span class="number">7</span></span><br><span class="line"><span class="keyword">if</span> aa&lt;bb:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我好啊&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span>&lt;=aa&lt;=<span class="number">4</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">5</span>&lt;=aa&lt;=<span class="number">7</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello1&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello3&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>注意形式</strong></p><p>python中是这样写的不同于C&#x2F;C++</p><p>&#x3D;&#x3D;5&lt;&#x3D;aa&lt;&#x3D;7:&#x3D;&#x3D;</p><h5 id="3-14if嵌套语句"><a href="#3-14if嵌套语句" class="headerlink" title="3.14if嵌套语句"></a>3.14if嵌套语句</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> aa&gt;bb:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;helo&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> aa&gt;<span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;heloowos&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;阿三大苏打&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;十大大苏打实打实&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-2循环语句"><a href="#3-2循环语句" class="headerlink" title="3.2循环语句"></a>3.2循环语句</h3><h5 id="For循环语句"><a href="#For循环语句" class="headerlink" title="For循环语句"></a>For循环语句</h5><blockquote><p>for 循环变量 in 循环对象（可迭代对象）</p><p>循环体</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(k)</span><br><span class="line"><span class="comment"># a</span></span><br><span class="line"><span class="comment"># b</span></span><br><span class="line"><span class="comment"># c</span></span><br></pre></td></tr></table></figure><h6 id="整数序列range"><a href="#整数序列range" class="headerlink" title="&#x3D;&#x3D;整数序列range&#x3D;&#x3D;"></a>&#x3D;&#x3D;整数序列range&#x3D;&#x3D;</h6><p>range（start，end）</p><p>[start,end-1]</p><h6 id="for循环嵌套"><a href="#for循环嵌套" class="headerlink" title="for循环嵌套"></a>for循环嵌套</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line">a1=<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">b1=<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a1:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> b1:</span><br><span class="line">        <span class="keyword">if</span> i&gt;=j:</span><br><span class="line">            <span class="built_in">sum</span>=i*j</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%dx%d=%d&quot;</span>%(i,j,<span class="built_in">sum</span>),end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>1x1&#x3D;1</p><p>2x1&#x3D;22x2&#x3D;4</p><p>3x1&#x3D;33x2&#x3D;63x3&#x3D;9</p><p>4x1&#x3D;44x2&#x3D;84x3&#x3D;124x4&#x3D;16</p><p>5x1&#x3D;55x2&#x3D;105x3&#x3D;155x4&#x3D;205x5&#x3D;25</p><p>6x1&#x3D;66x2&#x3D;126x3&#x3D;186x4&#x3D;246x5&#x3D;306x6&#x3D;36</p><p>7x1&#x3D;77x2&#x3D;147x3&#x3D;217x4&#x3D;287x5&#x3D;357x6&#x3D;427x7&#x3D;49</p><p>8x1&#x3D;88x2&#x3D;168x3&#x3D;248x4&#x3D;328x5&#x3D;408x6&#x3D;488x7&#x3D;568x8&#x3D;64</p><p>9x1&#x3D;99x2&#x3D;189x3&#x3D;279x4&#x3D;369x5&#x3D;459x6&#x3D;549x7&#x3D;639x8&#x3D;729x9&#x3D;81</p></blockquote><p>&#x3D;&#x3D;print(“%dx%d&#x3D;%d”%(i,j,sum),end&#x3D;’\t’)&#x3D;&#x3D;</p><h5 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h5><blockquote><h6 id="while-条件表达式："><a href="#while-条件表达式：" class="headerlink" title="while 条件表达式："></a>while 条件表达式：</h6><p>循环体</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> k&lt;=<span class="number">10</span>:</span><br><span class="line">    sum1+=k</span><br><span class="line">    k+=<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(sum1)</span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># 10</span></span><br><span class="line"><span class="comment"># 15</span></span><br><span class="line"><span class="comment"># 21</span></span><br><span class="line"><span class="comment"># 28</span></span><br><span class="line"><span class="comment"># 36</span></span><br><span class="line"><span class="comment"># 45</span></span><br><span class="line"><span class="comment"># 55</span></span><br></pre></td></tr></table></figure><h6 id="while-for混合嵌套-while-while-互相嵌套"><a href="#while-for混合嵌套-while-while-互相嵌套" class="headerlink" title="while for混合嵌套 while while 互相嵌套"></a>while for混合嵌套 while while 互相嵌套</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pp=<span class="number">0</span></span><br><span class="line">sum2=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> pp&lt;=<span class="number">10</span>:</span><br><span class="line">    pp+=<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(pp)</span><br><span class="line">    <span class="keyword">for</span> o <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">        sum2=pp+o</span><br><span class="line">        <span class="comment"># print(o)</span></span><br><span class="line">        <span class="keyword">if</span> pp&gt;=o:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%d+%d=%d&quot;</span>%(pp,o,sum2),end=<span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>运行结果:</p><p>1<br>1+1&#x3D;2\2<br>2+1&#x3D;3\2+2&#x3D;4\3<br>3+1&#x3D;4\3+2&#x3D;5\3+3&#x3D;6\4<br>4+1&#x3D;5\4+2&#x3D;6\4+3&#x3D;7\4+4&#x3D;8\5<br>5+1&#x3D;6\5+2&#x3D;7\5+3&#x3D;8\5+4&#x3D;9\5+5&#x3D;10\6<br>6+1&#x3D;7\6+2&#x3D;8\6+3&#x3D;9\6+4&#x3D;10\6+5&#x3D;11\6+6&#x3D;12\7<br>7+1&#x3D;8\7+2&#x3D;9\7+3&#x3D;10\7+4&#x3D;11\7+5&#x3D;12\7+6&#x3D;13\7+7&#x3D;14\8<br>8+1&#x3D;9\8+2&#x3D;10\8+3&#x3D;11\8+4&#x3D;12\8+5&#x3D;13\8+6&#x3D;14\8+7&#x3D;15\8+8&#x3D;16\9<br>9+1&#x3D;10\9+2&#x3D;11\9+3&#x3D;12\9+4&#x3D;13\9+5&#x3D;14\9+6&#x3D;15\9+7&#x3D;16\9+8&#x3D;17\9+9&#x3D;18\10<br>10+1&#x3D;11\10+2&#x3D;12\10+3&#x3D;13\10+4&#x3D;14\10+5&#x3D;15\10+6&#x3D;16\10+7&#x3D;17\10+8&#x3D;18\10+9&#x3D;19\10+10&#x3D;20\11<br>11+1&#x3D;12\11+2&#x3D;13\11+3&#x3D;14\11+4&#x3D;15\11+5&#x3D;16\11+6&#x3D;17\11+7&#x3D;18\11+8&#x3D;19\11+9&#x3D;20\11+10&#x3D;21\</p></blockquote><h5 id="while循环和for循环的对比"><a href="#while循环和for循环的对比" class="headerlink" title="while循环和for循环的对比"></a>while循环和for循环的对比</h5><p>while循环和for循环，都是循环语句，但细节不同:<br>在循环控制上:<br>while循环可以<strong>自定循环条件，并自行控制</strong><br>for循环不可以自定循环条件,只可以一个个从容器内取出数据<br>●<br>在无限循环上:<br>while循环可以通过条件控制做到无限循环<br>●<br>for循环理论上不可以,因为被遍历的容器容量不是无限的<br>在使用场景上:<br>while循环适用于任何想要循环的场景<br>for循环适用于，遍历数据容器的场景或简单的固定次数循环场景</p><h3 id="3-3跳转语句"><a href="#3-3跳转语句" class="headerlink" title="3.3跳转语句"></a>3.3跳转语句</h3><h5 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h5><blockquote><p>跳出当前层的循环。****</p></blockquote><h5 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h5><blockquote><p>这次循环到这里结束下面的不要执行了，然后进入下一次循环</p></blockquote><h5 id="pass语句"><a href="#pass语句" class="headerlink" title="&#x3D;&#x3D;pass语句&#x3D;&#x3D;"></a>&#x3D;&#x3D;pass语句&#x3D;&#x3D;</h5><blockquote><p>空代码块，占位符作用。</p></blockquote><h5 id="else但配合循环使用"><a href="#else但配合循环使用" class="headerlink" title="&#x3D;&#x3D;else但配合循环使用&#x3D;&#x3D;"></a>&#x3D;&#x3D;else但配合循环使用&#x3D;&#x3D;</h5><blockquote><p>&#x3D;&#x3D;循环正常结束或者while条件判断为False执行else后面的语句&#x3D;&#x3D;</p><p>如果循环break提前结束了，那么不执行else后面的语句</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    <span class="built_in">print</span>(l)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;循环正常结束捏&quot;</span>)</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># 7</span></span><br><span class="line"><span class="comment"># 8</span></span><br><span class="line"><span class="comment"># 9</span></span><br><span class="line"><span class="comment"># 10</span></span><br><span class="line"><span class="comment"># 循环正常结束捏</span></span><br></pre></td></tr></table></figure><h4 id="循环综合案例"><a href="#循环综合案例" class="headerlink" title="循环综合案例"></a>循环综合案例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span>=<span class="number">10000</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">21</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">sum</span>!=<span class="number">0</span>:</span><br><span class="line">        num = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;员工<span class="subst">&#123;i&#125;</span>,绩效分<span class="subst">&#123;num&#125;</span>,不发工资，下一位&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">sum</span>=<span class="built_in">sum</span>-<span class="number">1000</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;向员工<span class="subst">&#123;i&#125;</span>发放工资1000元，账户余额还剩<span class="subst">&#123;<span class="built_in">sum</span>&#125;</span>元&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;工资发完了醉了&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 向员工1发放工资1000元，账户余额还剩9000元</span></span><br><span class="line"><span class="comment"># 向员工2发放工资1000元，账户余额还剩8000元</span></span><br><span class="line"><span class="comment"># 员工3,绩效分4,不发工资，下一位</span></span><br><span class="line"><span class="comment"># 向员工4发放工资1000元，账户余额还剩7000元</span></span><br><span class="line"><span class="comment"># 向员工5发放工资1000元，账户余额还剩6000元</span></span><br><span class="line"><span class="comment"># 员工6,绩效分2,不发工资，下一位</span></span><br><span class="line"><span class="comment"># 员工7,绩效分4,不发工资，下一位</span></span><br><span class="line"><span class="comment"># 员工8,绩效分1,不发工资，下一位</span></span><br><span class="line"><span class="comment"># 向员工9发放工资1000元，账户余额还剩5000元</span></span><br><span class="line"><span class="comment"># 向员工10发放工资1000元，账户余额还剩4000元</span></span><br><span class="line"><span class="comment"># 向员工11发放工资1000元，账户余额还剩3000元</span></span><br><span class="line"><span class="comment"># 向员工12发放工资1000元，账户余额还剩2000元</span></span><br><span class="line"><span class="comment"># 向员工13发放工资1000元，账户余额还剩1000元</span></span><br><span class="line"><span class="comment"># 员工14,绩效分3,不发工资，下一位</span></span><br><span class="line"><span class="comment"># 员工15,绩效分4,不发工资，下一位</span></span><br><span class="line"><span class="comment"># 向员工16发放工资1000元，账户余额还剩0元</span></span><br><span class="line"><span class="comment"># 工资发完了醉了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="4-0数据结构"><a href="#4-0数据结构" class="headerlink" title="4.0数据结构"></a>4.0数据结构</h3><h4 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h4><table><thead><tr><th align="center">类型</th><th>描述</th><th>说明</th></tr></thead><tbody><tr><td align="center">整数</td><td>整数(int)，如: 10、-10</td><td>整数(int)，如: 10、-10</td></tr><tr><td align="center">浮点数(float)</td><td>浮点数(float)</td><td>,如: 13.14、 -13.14</td></tr><tr><td align="center">复数(complex)</td><td>复数(complex)，</td><td>如: 4+3j,以j结尾表示复数</td></tr><tr><td align="center">布尔(bool)</td><td>布尔(bool) 表达现实生活中的逻辑，即真和假，True表示真,False表示假</td><td>True本质上是一个数字记作1,  False记作0</td></tr><tr><td align="center">字符串(String)</td><td>描述文本的一种数据类型</td><td>字符串(string) 由任意数量的字符组成</td></tr><tr><td align="center">列表(List)</td><td><strong>有序的可变序列</strong></td><td>Python中使用最频繁的数据类型，可有序记录一堆数据</td></tr><tr><td align="center">元组(Tuple)</td><td><strong>有序的不可变序列.</strong></td><td>可有序记录一堆不可变的Python数据集合</td></tr><tr><td align="center">集合(Set)</td><td><strong>无序不重复集合</strong></td><td>可无序记录一堆不重复的Python数据集合</td></tr><tr><td align="center">字典(Dictionary)</td><td>无序Key-Value集合</td><td>可无序记录-堆Key-Value型的Python数据集合</td></tr></tbody></table><h4 id="4-1列表-有序可变序列"><a href="#4-1列表-有序可变序列" class="headerlink" title="4.1列表(有序可变序列)"></a>4.1列表(有序可变序列)</h4><h5 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h5><blockquote><p>列表用来存储任意大小的数据集合，可以有任意个数据，可以是不同的数据类型，也可以是列表（嵌套）</p></blockquote><ol><li><p>使用方括号创建列表</p></li><li><p>使用构造函数创建列表</p></li><li><p>使用列表推导式创建</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>=<span class="built_in">list</span>(<span class="string">&quot;我喜欢你&quot;</span>)</span><br><span class="line">list1=[<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>,<span class="string">&quot;我&quot;</span>,<span class="string">&quot;喜欢&quot;</span>,<span class="literal">True</span>]</span><br><span class="line">list2=[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>) <span class="keyword">if</span> x&gt;<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"><span class="built_in">print</span>(list2)</span><br><span class="line"><span class="comment"># &lt;class &#x27;list&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>在Python中，可以使用构造函数来创建列表。构造函数是一种特殊的方法，用于在创建对象时进行初始化操作。</p><p>使用构造函数创建列表的方式是通过调用list()函数，并将一个可迭代对象作为参数传递给它。可迭代对象可以是一个字符串、元组、集合、字典等。</p><p>下面是一些使用构造函数创建列表的示例：</p><ol><li>使用字符串创建列表：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;my_list = <span class="built_in">list</span>(<span class="string">&quot;abc&quot;</span>) </span><br><span class="line">&gt;<span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用元组创建列表：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;my_list = <span class="built_in">list</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) </span><br><span class="line">&gt;<span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用集合创建列表：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;my_list = <span class="built_in">list</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;) </span><br><span class="line">&gt;<span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></table></figure><ol start="4"><li>使用字典创建列表（只包含键）：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;my_list = <span class="built_in">list</span>(&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;)  </span><br><span class="line">&gt;<span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p>需要注意的是，&#x3D;&#x3D;构造函数创建的列表是一个新的对象，与原始的可迭代对象是独立的。修改原始的可迭代对象不会影响到使用构造函数创建的列表。&#x3D;&#x3D;</p><p>此外，还可以使用列表推导式来创建列表，它提供了一种更简洁的语法。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;my_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]  </span><br><span class="line">&gt;<span class="comment"># [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></blockquote><p><em><strong>还可以加一些判断条件</strong></em></p><blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ddd=<span class="built_in">list</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>) <span class="keyword">if</span>(x&gt;<span class="number">5</span>))</span><br><span class="line"><span class="comment"># [6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="列表的访问"><a href="#列表的访问" class="headerlink" title="列表的访问"></a><strong>列表的访问</strong></h5><p><strong>下标[0，len-1]</strong></p><h5 id="列表的遍历"><a href="#列表的遍历" class="headerlink" title="列表的遍历"></a>列表的遍历</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># [1, 2, 4]</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure><h5 id="列表的操作和常见的方法"><a href="#列表的操作和常见的方法" class="headerlink" title="列表的操作和常见的方法"></a>列表的操作和常见的方法</h5><table><thead><tr><th align="center">编号</th><th align="left">使用方式</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">1</td><td align="left">列表.append(元素)</td><td align="center">向列表中追加一个元素</td></tr><tr><td align="center">2</td><td align="left">列表.extend(容器)</td><td align="center">将数据容器的内容依次取出，追加到列表尾部</td></tr><tr><td align="center">3</td><td align="left">列表.insert(下标，元素)</td><td align="center">在指定下标处，插入指定的元素</td></tr><tr><td align="center"><strong>4</strong></td><td align="left"><strong>del列表[下标]</strong></td><td align="center"><strong>删除列表指定下标元素</strong></td></tr><tr><td align="center">5</td><td align="left">列表.pop(下标)</td><td align="center">删除列表指定下标元素并且返回,如果指定了index就把他给删除了默认是-1下标</td></tr><tr><td align="center">6</td><td align="left">列表.remove(元素)</td><td align="center">从前向后，删除此元素第一个匹配项</td></tr><tr><td align="center"><strong>7</strong></td><td align="left"><strong>列表.clear()</strong></td><td align="center"><strong>清空列表</strong></td></tr><tr><td align="center">8</td><td align="left">列表.count(元素)</td><td align="center">统计此元素在列表中出现的次数</td></tr><tr><td align="center">9</td><td align="left">列表.index(元素)</td><td align="center">查找指定元素在列表的下标  找不到报错ValueError</td></tr><tr><td align="center">10</td><td align="left">len(列表)</td><td align="center">统计容器内有多少元素</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ddd=<span class="built_in">list</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>) <span class="keyword">if</span>(x&gt;<span class="number">5</span>))</span><br><span class="line"><span class="comment"># [6, 7, 8, 9, 10]</span></span><br><span class="line"><span class="built_in">print</span>(ddd)</span><br><span class="line"><span class="keyword">for</span> ppp <span class="keyword">in</span> ddd:</span><br><span class="line">    <span class="built_in">print</span>(ppp)</span><br><span class="line">    <span class="comment"># 6</span></span><br><span class="line">    <span class="comment"># 7</span></span><br><span class="line">    <span class="comment"># 8</span></span><br><span class="line">    <span class="comment"># 9</span></span><br><span class="line">    <span class="comment"># 10</span></span><br></pre></td></tr></table></figure><ol><li><p><strong>列表名.append在列表的&#x3D;&#x3D;屁股&#x3D;&#x3D;加新成员</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="built_in">list</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line">a.append(<span class="number">11</span>)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</span></span><br></pre></td></tr></table></figure></li><li><p>列表名.<strong>inset(i,x)在下标为i的地方加入一个新的x,也就是说新来的在a[i]，其他的往后去</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="built_in">list</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line">a.insert(<span class="number">1</span>,<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># [1, &#x27;x&#x27;, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</span></span><br></pre></td></tr></table></figure></li><li><p>列表名.<strong>extend（新的 列表）把新的列表&#x3D;&#x3D;续&#x3D;&#x3D;在操作对象的后面</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="built_in">list</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line">b=<span class="built_in">list</span>(t <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>,<span class="number">15</span>))</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line">a.extend(b)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>列表名.remove(x)移除列表里的x</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="built_in">list</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line">b=<span class="built_in">list</span>(t <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>,<span class="number">15</span>))</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line">a.remove(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># [2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>列表名.pop（obj）&#x3D;&#x3D;删除obj指定的下标&#x3D;&#x3D;</strong>***&#x3D;&#x3D;并返回删除的对象&#x3D;&#x3D;**</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="built_in">list</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line">b=<span class="built_in">list</span>(t <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>,<span class="number">15</span>))</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line">c=a.pop(<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 9</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 10]</span></span><br></pre></td></tr></table></figure></li><li><p>del 列表名[下标]</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> a[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment"># [1, 2, 4]</span></span><br></pre></td></tr></table></figure></li><li><p>列表名.clear() 清空列表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.clear()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># [1, 2, 4]</span></span><br><span class="line"><span class="comment"># []</span></span><br></pre></td></tr></table></figure></li><li><p>列表名.index(x)方法，查x在列表中的下标</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="built_in">list</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line">b=<span class="built_in">list</span>(t <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>,<span class="number">15</span>))</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.index(<span class="number">8</span>))</span><br><span class="line"><span class="comment">#7</span></span><br></pre></td></tr></table></figure></li><li><p>列表名.count(x)，查x在列表中出现的次数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="built_in">list</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line">b=<span class="built_in">list</span>(t <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>,<span class="number">15</span>))</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line">a.append(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 6]</span></span><br><span class="line"><span class="built_in">print</span>(a.count(<span class="number">6</span>))</span><br><span class="line"><span class="comment">#2</span></span><br></pre></td></tr></table></figure></li><li><p>列表名.reverse()将列表顺序反转———————&#x3D;&#x3D;不需要传入任何参数&#x3D;&#x3D;而且也没有返回值相当于返回none</p></li></ol>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="built_in">list</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line">b=<span class="built_in">list</span>(t <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>,<span class="number">15</span>))</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line">a.reverse()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure><ol start="11"><li><p>len(列表名)得到列表的元素个数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a))</span><br><span class="line"><span class="comment"># [1, 2, 4]</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure></li><li><p><strong>列表名.sort（key,reverse）三个参数，key比较时的关键字，reverse比较完是否逆序</strong> </p><blockquote><ol><li><h6 id="在Python-3中，cmp参数已被移除，所以无法直接使用cmp函数进行排序。-取而代之的是使用key参数来指定一个函数"><a href="#在Python-3中，cmp参数已被移除，所以无法直接使用cmp函数进行排序。-取而代之的是使用key参数来指定一个函数" class="headerlink" title="在Python 3中，cmp参数已被移除，所以无法直接使用cmp函数进行排序。&#x3D;&#x3D;取而代之的是使用key参数来指定一个函数&#x3D;&#x3D;"></a>在Python 3中，cmp参数已被移除，所以无法直接使用cmp函数进行排序。&#x3D;&#x3D;取而代之的是使用key参数来指定一个函数&#x3D;&#x3D;</h6></li><li><h6 id="默认是排序后不进行逆序的，默认升序》"><a href="#默认是排序后不进行逆序的，默认升序》" class="headerlink" title="&#x3D;&#x3D;默认是排序后不进行逆序的，默认升序》&#x3D;&#x3D;"></a>&#x3D;&#x3D;默认是排序后不进行逆序的，默认升序》&#x3D;&#x3D;</h6></li><li><h6 id="可以单独使用并排序真身，返回值是个none，可以自定义key，默认升序》"><a href="#可以单独使用并排序真身，返回值是个none，可以自定义key，默认升序》" class="headerlink" title="可以单独使用并排序真身，返回值是个none，可以自定义key，默认升序》"></a>可以单独使用并排序真身，返回值是个none，可以自定义key，默认升序》</h6><p>k.sort(<em>key</em><strong>&#x3D;lambda</strong> <em>a</em>:a[1])有三个参数，不能默认指定，要指定对应的参数&#x3D;&#x3D;k.sort(<em>key</em><strong>&#x3D;lambda</strong> <em>a</em>:a[1])&#x3D;&#x3D;注意使用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l=[<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(l))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(l,reverse=<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">sorted</span>(l)))</span><br><span class="line">   <span class="comment"># [1, 2, 2, 3, 4, 5, 9]</span></span><br><span class="line"><span class="comment"># [9, 5, 4, 3, 2, 2, 1]</span></span><br><span class="line">      </span><br><span class="line">l.sort()</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line">l.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"><span class="built_in">print</span>(l.sort())</span><br><span class="line"><span class="comment"># None</span></span><br><span class="line">   <span class="comment"># [1, 2, 2, 3, 4, 5, 9]</span></span><br><span class="line"><span class="comment"># [9, 5, 4, 3, 2, 2, 1]</span></span><br><span class="line">      </span><br><span class="line">k=[[<span class="string">&quot;a&quot;</span>,<span class="number">15</span>],[<span class="string">&quot;b&quot;</span>,<span class="number">12</span>],[<span class="string">&quot;c&quot;</span>,<span class="number">13</span>]]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmp</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">1</span>]</span><br><span class="line">k.sort(key=cmp)</span><br><span class="line"><span class="built_in">print</span>(k)</span><br><span class="line"><span class="comment"># [[&#x27;b&#x27;, 12], [&#x27;c&#x27;, 13], [&#x27;a&#x27;, 15]]</span></span><br><span class="line">   k=[[<span class="string">&quot;a&quot;</span>,<span class="number">15</span>],[<span class="string">&quot;b&quot;</span>,<span class="number">12</span>],[<span class="string">&quot;c&quot;</span>,<span class="number">13</span>]]</span><br><span class="line">      </span><br><span class="line">      k.sort(key=<span class="keyword">lambda</span> y :y[<span class="number">1</span>])</span><br><span class="line">   <span class="built_in">print</span>(k)</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># [[&#x27;b&#x27;, 12], [&#x27;c&#x27;, 13], [&#x27;a&#x27;, 15]]</span></span><br></pre></td></tr></table></figure></li></ol></blockquote></li></ol><p><strong>python内置的len作为关键字（函数）使用</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b=[<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;dasdasdas&#x27;</span>,<span class="string">&#x27;h1&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># [1, 4, 9, 3, 6, 7, 2]</span></span><br><span class="line">b.sort(key=<span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># [&#x27;h1&#x27;, &#x27;apple&#x27;, &#x27;dasdasdas&#x27;]</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;在Python中，默认的排序函数<code>sort()</code>需要接受一个返回值为布尔类型的比较函数作为参数，而不是返回值为整数类型的比较函数。&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">k=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(k)</span><br><span class="line">k.sort(key=<span class="keyword">lambda</span> x:x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;默认升序的排序<span class="subst">&#123;k&#125;</span>&quot;</span>)</span><br><span class="line">k.sort(key=<span class="keyword">lambda</span> x:-x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;稍微修改降序的排序<span class="subst">&#123;k&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 默认升序的排序[1, 2, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment"># 稍微修改降序的排序[5, 4, 3, 2, 2, 1]</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最简单的降序排列—–因为默认是升序，&#x3D;&#x3D;排序再逆转&#x3D;&#x3D;一下就🆗了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;原状态&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a.sort()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;默认升序&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;逆转后的降序&quot;</span>)</span><br><span class="line">a.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 原状态</span></span><br><span class="line"><span class="comment"># [1, 4, 9, 3, 6, 7, 2]</span></span><br><span class="line"><span class="comment"># 默认升序</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 6, 7, 9]</span></span><br><span class="line"><span class="comment"># 逆转后的降序</span></span><br><span class="line"><span class="comment"># [9, 7, 6, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure><hr><h4 id="4-2元组（有序的不可变序列）"><a href="#4-2元组（有序的不可变序列）" class="headerlink" title="4.2元组（有序的不可变序列）"></a>4.2元组（有序的不可变序列）</h4><h5 id="元组的创建-有两个带turple的"><a href="#元组的创建-有两个带turple的" class="headerlink" title="元组的创建(有两个带turple的)"></a>元组的创建(有两个带turple的)</h5><p><strong>&#x3D;&#x3D;元组用来存储任意大小的数据集合，可以有任意个数据，可以是不同的数据类型，也可以是元组（嵌套）&#x3D;&#x3D;</strong></p><blockquote><ol><li><p>括号创建—-注意区别&#x3D;&#x3D;-创建只含有一个元素的元组要在元素的后面加上,&#x3D;&#x3D;            不加逗号的时候会被理解为优先级的（）而不是元组的括号,就被理解为字符串而非元组</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=(<span class="number">1</span>)</span><br><span class="line">b=(<span class="number">1</span>,)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b))</span><br><span class="line"><span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用构造函数 和列表非常的相似</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;元组的三种创建&quot;</span>)</span><br><span class="line">t1=(<span class="string">&quot;dsadsa&quot;</span>,)</span><br><span class="line"><span class="built_in">print</span>(t1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t1))</span><br><span class="line">/////////</span><br><span class="line"> t1=<span class="built_in">tuple</span>(<span class="string">&quot;dsadsad&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(t1)</span><br><span class="line"> <span class="built_in">print</span>(<span class="built_in">type</span>(t1))</span><br><span class="line">//////////</span><br><span class="line">t1=(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line">//默认是生成器对象</span><br><span class="line">t1=<span class="built_in">tuple</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>) <span class="keyword">if</span> x&gt;<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(t1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t1))</span><br></pre></td></tr></table></figure></li></ol></blockquote><h5 id="元组的访问和遍历"><a href="#元组的访问和遍历" class="headerlink" title="元组的访问和遍历"></a>元组的访问和遍历</h5><blockquote><ol><li><p><strong>下标[0，len-1]</strong></p></li><li><p>&#x3D;&#x3D;可以像列表一样访问但是不可以修改，别说什么删除 了&#x3D;&#x3D;</p></li><li><pre><code class="python">d=tuple(x*2 for x in range(1,6) if x&gt;=3)print(d)(6, 8, 10)for i in d:    print(i)    # 6    # 8    # 10<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 元组与列表的区别</span><br><span class="line"></span><br><span class="line">==唯一就是可修改与不可修改的区别，元组是不可以通过元素的下标修改的，列表是可以的。==</span><br><span class="line"></span><br><span class="line">##### 元组的相关操作</span><br><span class="line"></span><br><span class="line">1. 由于元组的数据不可以被修改</span><br><span class="line"></span><br><span class="line">2. ###### 元组名.count(x),查询x出现的次数</span><br><span class="line"></span><br><span class="line">3. ###### 元组名.index(x)查询x的下标</span><br><span class="line"></span><br><span class="line">4. len(元素名)查询元组的元素个数</span><br><span class="line"></span><br><span class="line">   ```python</span><br><span class="line">   p=tuple(f)</span><br><span class="line">   print(p)</span><br><span class="line">   # (&#x27;张&#x27;, &#x27;三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;, &#x27;李六&#x27;)</span><br><span class="line">   print(p.index(&quot;李四&quot;))</span><br><span class="line">   print(p.count(&quot;王五&quot;))</span><br><span class="line">   # 2</span><br><span class="line">   # 1</span><br></pre></td></tr></table></figure></code></pre></li></ol></blockquote><hr><h5 id="元组的注意事项-总结"><a href="#元组的注意事项-总结" class="headerlink" title="元组的注意事项&#x2F;总结"></a>元组的注意事项&#x2F;总结</h5><p>虽然元组的元素不能修改</p><p>&#x3D;&#x3D;但是如果元组里面放了一个list的时候，可以修改&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="comment"># (1, 2, 3, [4, 5, 6])</span></span><br><span class="line">m[<span class="number">3</span>][<span class="number">0</span>]=<span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(m[<span class="number">3</span>])</span><br><span class="line"><span class="comment"># [5, 5, 6]</span></span><br></pre></td></tr></table></figure><blockquote><p>经过.上述对元组的学习，可以总结出列表有如下特点:</p><ol><li>可以容纳多个数据</li><li>可以容纳不同类型的数据(混装)</li><li>数据是有序存储的(下标索引)</li><li>允许重复数据存在</li><li>不可以修改( 增加或删除元素等)</li><li>支持for循环</li><li>&#x3D;&#x3D;多数特性和list-致，不同点在于不可修改的特性。&#x3D;&#x3D;</li></ol></blockquote><h4 id="4-3序列"><a href="#4-3序列" class="headerlink" title="4.3序列"></a>4.3序列</h4><p><strong>序列是最基本的数据结构，序列中的每一个元素都分配一个下标，[0,n-1],[-n,-1],n是元素个数&#x3D;len(序列)</strong></p><p><em><strong>常见的序列，字符串，元组，列表</strong></em></p><h5 id="序列和通用操作（切片操作）"><a href="#序列和通用操作（切片操作）" class="headerlink" title="序列和通用操作（切片操作）"></a>序列和通用操作（切片操作）</h5><h6 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h6><blockquote><p>序列名[i:j:k]</p><p><code>根据ij索引切除片，并返回对应类型的对象</code></p><p>&#x3D;&#x3D;i表示起始位置，j代表索引结束位置，k代表步长，默认是1。[i,j-1]&#x3D;&#x3D;</p><p>&#x3D;&#x3D;这些操作都没有真正改变原来的序列，而是返回了一个新的序列。原来的序列仍然保持不变。如果要改变原来的字符串，可以将新的字符串赋值给原来的变量。例如：&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&quot;0123456789&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">str</span>[<span class="number">1</span>:<span class="number">3</span>]))</span><br><span class="line"><span class="comment"># 12</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>切片的注意事项</p><ol><li><p>如果切片的索引i&#x3D;0，那么从第一个到j-1的元素</p></li><li><p>如果切片的索引j&#x3D;0，那么会从i切到以后的元素</p></li><li><p>如果开始和结束都为空，那么得到整个序列</p></li><li><p>&#x3D;&#x3D;如果i&gt;j且步长&gt;0，得到一个空的序列&#x3D;&#x3D;’’’’;;如果步长为&lt;0且就理解为反向走</p></li><li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line">d=d[<span class="number">2</span>:<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># (6, 8, 10)</span></span><br><span class="line"><span class="comment"># ()</span></span><br></pre></td></tr></table></figure></li><li><p>如果步长为负数，就逆序获取元素</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d=<span class="built_in">tuple</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># ///////</span></span><br><span class="line">d=d[<span class="number">0</span>:<span class="built_in">len</span>(d)]</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">d=d[::]</span><br><span class="line"><span class="comment"># ///////</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line">      </span><br><span class="line">d=d[<span class="number">4</span>:<span class="number">0</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="comment">#理解为从4到0反向走一次走1</span></span><br><span class="line"><span class="comment"># 而且最终的个数等于绝对值这两个差</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure><hr><p>&#x3D;&#x3D;综合案例，[::-1]常用来倒把序列给倒序&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c=<span class="string">&quot;万过薪月，员序程马牛来，nohtyP学&quot;</span></span><br><span class="line">c=c[::-<span class="number">1</span>][<span class="number">9</span>:<span class="number">14</span>]</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">c=<span class="string">&quot;万过薪月，员序程马牛来，nohtyP学&quot;</span></span><br><span class="line">c=c[<span class="number">5</span>:<span class="number">10</span>][::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">c=<span class="string">&quot;万过薪月，员序程马牛来，nohtyP学&quot;</span></span><br><span class="line">c=c.split(<span class="string">&#x27;，&#x27;</span>)[<span class="number">1</span>][:<span class="number">5</span>][::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># 牛马程序员</span></span><br><span class="line"><span class="comment"># 牛马程序员</span></span><br><span class="line"><span class="comment"># 牛马程序员</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h6 id="连接和复制"><a href="#连接和复制" class="headerlink" title="连接和复制"></a>连接和复制</h6><p><a href="#%E5%AD%97%E5%85%B8">去字典</a></p><blockquote><ol><li><p>连接</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d=<span class="built_in">tuple</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>))</span><br><span class="line">e=<span class="built_in">tuple</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>,<span class="number">11</span>))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line">f=d+e</span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"><span class="comment"># (1, 2, 3, 4, 5)</span></span><br><span class="line"><span class="comment"># (6, 7, 8, 9, 10)</span></span><br><span class="line"><span class="comment"># (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span></span><br></pre></td></tr></table></figure></li><li><p>复制</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d=<span class="built_in">tuple</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(d*<span class="number">3</span>)</span><br><span class="line"><span class="comment"># (1, 2, 3, 4, 5)</span></span><br><span class="line"><span class="comment"># (1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5)</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h6 id="成员检查（成员运算符in-not-in）"><a href="#成员检查（成员运算符in-not-in）" class="headerlink" title="成员检查（成员运算符in not in）"></a>成员检查（成员运算符in not in）</h6><blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d=<span class="built_in">tuple</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># (1, 2, 3, 4, 5)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">in</span> d)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">11</span> <span class="keyword">in</span> d)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure></blockquote><h6 id="内置函数max-min-len"><a href="#内置函数max-min-len" class="headerlink" title="内置函数max,min,len"></a>内置函数max,min,len</h6><blockquote><ol><li><p>len()计算序列的长度，也就是元素&#x2F;字符的个数</p></li><li><p>max()寻找序列中的最大值</p></li><li><p>min()寻找序列中的最小值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d=<span class="built_in">tuple</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">7</span>))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(d))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(d))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(d))</span><br><span class="line"><span class="comment"># (1, 2, 3, 4, 5, 6)</span></span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h5 id="序列的相互转换-（字符串，列表，元组之间的转换）"><a href="#序列的相互转换-（字符串，列表，元组之间的转换）" class="headerlink" title="&#x3D;&#x3D;序列的相互转换&#x3D;&#x3D;（字符串，列表，元组之间的转换）"></a>&#x3D;&#x3D;序列的相互转换&#x3D;&#x3D;（字符串，列表，元组之间的转换）</h5><p><strong>并没有改变真身，但可以赋值给真身</strong></p><blockquote><ol><li><p>字符串转为列表和元组—–list(),tuple()</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d=<span class="string">&#x27;你好啊小盆友&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(d))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(d))</span><br><span class="line"><span class="comment"># 你好啊小盆友</span></span><br><span class="line"><span class="comment"># [&#x27;你&#x27;, &#x27;好&#x27;, &#x27;啊&#x27;, &#x27;小&#x27;, &#x27;盆&#x27;, &#x27;友&#x27;]</span></span><br><span class="line"><span class="comment"># (&#x27;你&#x27;, &#x27;好&#x27;, &#x27;啊&#x27;, &#x27;小&#x27;, &#x27;盆&#x27;, &#x27;友&#x27;)</span></span><br></pre></td></tr></table></figure></li><li><p>列表与元组的相互转换—————–list(),tuple()，只不过里面放的不是字符串了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d=[<span class="number">1</span>,<span class="string">&quot;我&quot;</span>,<span class="number">2</span>,<span class="string">&#x27;取&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(d))</span><br><span class="line"><span class="comment"># [1, &#x27;我&#x27;, 2, &#x27;取&#x27;]</span></span><br><span class="line"><span class="comment"># (1, &#x27;我&#x27;, 2, &#x27;取&#x27;)</span></span><br><span class="line"></span><br><span class="line">e=(<span class="number">3</span>,<span class="string">&quot;你&quot;</span>,<span class="number">5</span>,<span class="string">&#x27;曲&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(e))</span><br><span class="line"><span class="comment"># (3, &#x27;你&#x27;, 5, &#x27;曲&#x27;)</span></span><br><span class="line"><span class="comment"># [3, &#x27;你&#x27;, 5, &#x27;曲&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>&#x3D;&#x3D;列表和元组转换为字符串&#x3D;&#x3D;——–用到了字符串的join方法。需要一个字符串来把新的序列转换为字符串并连接到已有的字符串上面。 ————&#x3D;&#x3D;前提是列表里面都是字符串类型或者字符类型&#x3D;&#x3D;，“ ” ‘ ’，纯数字不可以</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f=[<span class="string">&#x27;张&#x27;</span>,<span class="string">&#x27;三&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;李六&#x27;</span>]</span><br><span class="line">e=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(e))</span><br><span class="line"><span class="built_in">print</span>(e.join(f))</span><br><span class="line"><span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 张三李四王五李六</span></span><br><span class="line"><span class="built_in">str</span>()只是把对象转化为人容易看懂的字符串</span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="Str-函数"><a href="#Str-函数" class="headerlink" title="Str()函数"></a>Str()函数</h4><blockquote><p><code>str()</code>函数是Python内置的一个函数，用于将对象转换为字符串形式。</p><p><code>str()</code>函数的语法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>(<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure><p>其中，<code>object</code>是要转换为字符串的对象。<code>object</code>可以是数字、字符串、列表、元组、字典、集合等等。</p><p><code>str()</code>函数的工作原理如下：</p><ul><li><p>如果<code>object</code>是字符串类型，则返回该字符串本身。</p></li><li><p>如果<code>object</code>是数字类型（整数、浮点数等），则返回对应的字符串表示。</p></li><li><p>如果<code>object</code>是列表、元组、字典、集合等可迭代对象，则返回一个包含各个元素的字符串表示。</p></li><li><p>如果<code>object</code>是自定义的对象，则根据对象的<code>__str__()</code>方法返回字符串表示。</p></li><li><p>以下是一些示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="number">10</span>))  <span class="comment"># 将整数转换为字符串 &#x27;10&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="number">3.14</span>) ) <span class="comment"># 将浮点数转换为字符串 &#x27;3.14&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))  <span class="comment"># 将列表转换为字符串 &#x27;[1, 2, 3]&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>((<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)))  <span class="comment"># 将元组转换为字符串 &quot;(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span>&#125;))  <span class="comment"># 将字典转换为字符串 &quot;&#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 25&#125;&quot;</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><hr><p><a name="字典"></a></p><h4 id="4-4字典（无序Key-Value集合）"><a href="#4-4字典（无序Key-Value集合）" class="headerlink" title="4.4字典（无序Key-Value集合）"></a>4.4字典（无序Key-Value集合）</h4><h5 id="字典的创建"><a href="#字典的创建" class="headerlink" title="字典的创建"></a>字典的创建</h5><blockquote><ol><li><h4 id="使用花括号-创建字典"><a href="#使用花括号-创建字典" class="headerlink" title="使用花括号{}创建字典"></a>使用花括号{}创建字典</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=&#123;<span class="string">&quot;key1&quot;</span>:<span class="number">1</span>,<span class="string">&quot;key2&quot;</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># &#123;&#x27;key1&#x27;: 1, &#x27;key2&#x27;: 2&#125;</span></span><br><span class="line">      </span><br><span class="line">a[<span class="string">&quot;key1&quot;</span>]=<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(a</span><br><span class="line"><span class="comment"># &#123;&#x27;key1&#x27;: 2, &#x27;key2&#x27;: 2&#125;</span></span><br><span class="line">      </span><br><span class="line">b=&#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><h4 id="使用函数创建字典"><a href="#使用函数创建字典" class="headerlink" title="使用函数创建字典"></a>使用函数创建字典</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c=<span class="built_in">dict</span>()</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br><span class="line">c=<span class="built_in">dict</span>(red=<span class="number">1</span>,blue=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># &#123;&#x27;red&#x27;: 1, &#x27;blue&#x27;: 2&#125;</span></span><br><span class="line">l=[(<span class="string">&quot;red&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;green&quot;</span>,<span class="number">3</span>)]</span><br><span class="line">c=<span class="built_in">dict</span>(l)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># &#123;&#x27;red&#x27;: 1, &#x27;green&#x27;: 3&#125;</span></span><br></pre></td></tr></table></figure></li><li><h4 id="使用推导式创建字典—–-p-x-x-for-x-in-range-1-6-严格按照格式，不带dict（）"><a href="#使用推导式创建字典—–-p-x-x-for-x-in-range-1-6-严格按照格式，不带dict（）" class="headerlink" title="使用推导式创建字典—–&#x3D;&#x3D;p&#x3D;{x: x for x in range(1,6)} 严格按照格式，不带dict（）&#x3D;&#x3D;"></a>使用推导式创建字典—–&#x3D;&#x3D;p&#x3D;{x: x for x in range(1,6)} 严格按照格式，不带dict（）&#x3D;&#x3D;</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p=&#123;x: x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="comment"># &#123;1: 2, 2: 4, 3: 6, 4: 8, 5: 10&#125;</span></span><br><span class="line">p=&#123;x: x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>) <span class="keyword">if</span> x&gt;=<span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="comment"># &#123;2: 4, 3: 6, 4: 8, 5: 10&#125;</span></span><br><span class="line"><span class="comment">#=----------------</span></span><br><span class="line">l=[(<span class="string">&quot;red&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;green&quot;</span>,<span class="number">3</span>)]</span><br><span class="line">ll=&#123;x:j <span class="keyword">for</span> x,j <span class="keyword">in</span> l&#125;</span><br><span class="line"><span class="built_in">print</span>(ll)</span><br><span class="line"><span class="comment"># &#123;&#x27;red&#x27;: 1, &#x27;green&#x27;: 3&#125;</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h5 id="字典的使用场景"><a href="#字典的使用场景" class="headerlink" title="字典的使用场景"></a>字典的使用场景</h5><blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">zd=&#123;<span class="string">&quot;王力宏&quot;</span>:&#123;<span class="string">&quot;语文&quot;</span>:<span class="number">60</span>,<span class="string">&quot;数学&quot;</span>:<span class="number">22</span>,<span class="string">&quot;英语&quot;</span>:<span class="number">50</span>&#125;,<span class="string">&quot;周杰伦&quot;</span>:&#123;<span class="string">&quot;语文&quot;</span>:<span class="number">20</span>,<span class="string">&quot;数学&quot;</span>:<span class="number">42</span>,<span class="string">&quot;英语&quot;</span>:<span class="number">60</span>&#125;&#125;</span><br><span class="line"><span class="built_in">print</span>(zd)</span><br><span class="line"><span class="built_in">print</span>(zd[<span class="string">&quot;王力宏&quot;</span>][<span class="string">&quot;语文&quot;</span>])</span><br><span class="line"><span class="comment"># &#123;&#x27;王力宏&#x27;: &#123;&#x27;语文&#x27;: 60, &#x27;数学&#x27;: 22, &#x27;英语&#x27;: 50&#125;, &#x27;周杰伦&#x27;: &#123;&#x27;语文&#x27;: 20, &#x27;数学&#x27;: 42, &#x27;英语&#x27;: 60&#125;&#125;</span></span><br><span class="line"><span class="comment"># 60</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="字典的访问-更新"><a href="#字典的访问-更新" class="headerlink" title="字典的访问&#x2F;更新"></a>字典的访问&#x2F;更新</h5><blockquote><p>字典名[键]&#x3D;新的值</p><ol><li><p>如果新增的key原来字典不存在，那么就新增一个键值对,&#x3D;&#x3D;加在字典的后面&#x3D;&#x3D;</p></li><li><p>如果新增的key原来存在，那么就会覆盖原来的键值对（更新）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">zd=&#123;<span class="string">&quot;王力宏&quot;</span>:&#123;<span class="string">&quot;语文&quot;</span>:<span class="number">60</span>,<span class="string">&quot;数学&quot;</span>:<span class="number">22</span>,<span class="string">&quot;英语&quot;</span>:<span class="number">50</span>&#125;,<span class="string">&quot;周杰伦&quot;</span>:&#123;<span class="string">&quot;语文&quot;</span>:<span class="number">20</span>,<span class="string">&quot;数学&quot;</span>:<span class="number">42</span>,<span class="string">&quot;英语&quot;</span>:<span class="number">60</span>&#125;&#125;</span><br><span class="line">zd[<span class="string">&quot;许闰博&quot;</span>]=&#123;<span class="string">&quot;语文&quot;</span>:<span class="number">100</span>,<span class="string">&quot;数学&quot;</span>:<span class="number">98</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(zd)</span><br><span class="line"><span class="comment"># &#123;&#x27;王力宏&#x27;: &#123;&#x27;语文&#x27;: 60, &#x27;数学&#x27;: 22, &#x27;英语&#x27;: 50&#125;, &#x27;周杰伦&#x27;: &#123;&#x27;语文&#x27;: 20, &#x27;数学&#x27;: 42, &#x27;英语&#x27;: 60&#125;, &#x27;许闰博&#x27;: &#123;&#x27;语文&#x27;: 100, &#x27;数学&#x27;: 98&#125;&#125;</span></span><br><span class="line">zd[<span class="string">&quot;王力宏&quot;</span>][<span class="string">&quot;语文&quot;</span>]=<span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(zd[<span class="string">&quot;王力宏&quot;</span>][<span class="string">&quot;语文&quot;</span>])</span><br><span class="line"><span class="comment"># 0</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h5 id="字典的遍历"><a href="#字典的遍历" class="headerlink" title="字典的遍历"></a>字典的遍历</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">zd=&#123;<span class="string">&#x27;王力宏&#x27;</span>: &#123;<span class="string">&#x27;语文&#x27;</span>: <span class="number">60</span>, <span class="string">&#x27;数学&#x27;</span>: <span class="number">22</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">50</span>&#125;, <span class="string">&#x27;周杰伦&#x27;</span>: &#123;<span class="string">&#x27;语文&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;数学&#x27;</span>: <span class="number">42</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">60</span>&#125;, <span class="string">&#x27;许闰博&#x27;</span>: &#123;<span class="string">&#x27;语文&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;数学&#x27;</span>: <span class="number">98</span>&#125;&#125;</span><br><span class="line">key=zd.keys()</span><br><span class="line">value=zd.values()</span><br><span class="line"><span class="built_in">print</span>(key)</span><br><span class="line"><span class="built_in">print</span>(value)</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> key:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;键是<span class="subst">&#123;k&#125;</span>,对应的值是<span class="subst">&#123;zd[k]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># dict_keys([&#x27;王力宏&#x27;, &#x27;周杰伦&#x27;, &#x27;许闰博&#x27;])</span></span><br><span class="line"><span class="comment"># dict_values([&#123;&#x27;语文&#x27;: 60, &#x27;数学&#x27;: 22, &#x27;英语&#x27;: 50&#125;, &#123;&#x27;语文&#x27;: 20, &#x27;数学&#x27;: 42, &#x27;英语&#x27;: 60&#125;, &#123;&#x27;语文&#x27;: 100, &#x27;数学&#x27;: 98&#125;])</span></span><br><span class="line"><span class="comment"># 键是王力宏, 对应的值是</span></span><br><span class="line"><span class="comment"># &#123;&#x27;语文&#x27;: 60, &#x27;数学&#x27;: 22, &#x27;英语&#x27;: 50&#125;</span></span><br><span class="line"><span class="comment"># 键是周杰伦, 对应的值是</span></span><br><span class="line"><span class="comment"># &#123;&#x27;语文&#x27;: 20, &#x27;数学&#x27;: 42, &#x27;英语&#x27;: 60&#125;</span></span><br><span class="line"><span class="comment"># 键是许闰博, 对应的值是</span></span><br><span class="line"><span class="comment"># &#123;&#x27;语文&#x27;: 100, &#x27;数学&#x27;: 98&#125;</span></span><br></pre></td></tr></table></figure><hr><blockquote><h5 id="其实是等价的"><a href="#其实是等价的" class="headerlink" title="其实是等价的"></a>其实是等价的</h5></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">j=&#123;x:x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>) <span class="keyword">if</span> x&gt;=<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;2: 4, 3: 6, 4: 8, 5: 10&#125;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> j:</span><br><span class="line">    <span class="built_in">print</span>(i,j[i])</span><br><span class="line"><span class="comment"># 2 4</span></span><br><span class="line"><span class="comment"># 3 6</span></span><br><span class="line"><span class="comment"># 4 8</span></span><br><span class="line"><span class="comment"># 5 10</span></span><br></pre></td></tr></table></figure><h5 id="删除字典元素和删除字典和清空字典"><a href="#删除字典元素和删除字典和清空字典" class="headerlink" title="删除字典元素和删除字典和清空字典"></a>删除字典元素和删除字典和清空字典</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pop(key[, default])</span></span><br><span class="line">d=&#123;<span class="string">&quot;key1&quot;</span>:<span class="number">1</span>,<span class="string">&quot;key2&quot;</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line">d.pop(<span class="string">&quot;key1&quot;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line">d.pop(<span class="string">&quot;key3&quot;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&quot;key2&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure><h5 id="字典的常用方法"><a href="#字典的常用方法" class="headerlink" title="字典的常用方法"></a>字典的常用方法</h5><table><thead><tr><th>编号</th><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>字典[Key]</td><td>获取指定Key对应的Value值</td></tr><tr><td>2</td><td>字典[Key]&#x3D; Value</td><td>添加或更新键值对  ，原来有的就覆盖，原来没有就添加</td></tr><tr><td>3</td><td>字典.pop(Key)</td><td># pop(key[, default])取出Key对应的Value并在字典内删除此Key的键值对</td></tr><tr><td>4</td><td>字典.clear()</td><td>清空字典,主要看第一个参数就算第二个喝第一个对应不住也是ok的</td></tr><tr><td>5</td><td>字典.keys()</td><td>获取字典的全部Key,可用于for循环遍历字典</td></tr><tr><td>6</td><td>len(字典)</td><td>计算字典内的元素数量</td></tr></tbody></table><blockquote><ol><li><h4 id="keys（）方法-以列表的形式-返回字典的所有键"><a href="#keys（）方法-以列表的形式-返回字典的所有键" class="headerlink" title="keys（）方法||&#x3D;&#x3D;以列表的形式&#x3D;&#x3D;返回字典的所有键"></a>keys（）方法||&#x3D;&#x3D;以列表的形式&#x3D;&#x3D;返回字典的所有键</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aaa=&#123;<span class="string">&quot;k1&quot;</span>:<span class="number">1</span>,<span class="string">&quot;k2&quot;</span>:<span class="number">9</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(aaa)</span><br><span class="line"><span class="built_in">print</span>(aaa.keys())</span><br><span class="line"><span class="comment"># &#123;&#x27;k1&#x27;: 1, &#x27;k2&#x27;: 9&#125;</span></span><br><span class="line"><span class="comment"># dict_keys([&#x27;k1&#x27;, &#x27;k2&#x27;])</span></span><br></pre></td></tr></table></figure></li><li><h4 id="values-方法-以列表的形式-返回字典的所有值"><a href="#values-方法-以列表的形式-返回字典的所有值" class="headerlink" title="values()方法||&#x3D;&#x3D;以列表的形式&#x3D;&#x3D;返回字典的所有值"></a>values()方法||&#x3D;&#x3D;以列表的形式&#x3D;&#x3D;返回字典的所有值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aaa=&#123;<span class="string">&quot;k1&quot;</span>:<span class="number">1</span>,<span class="string">&quot;k2&quot;</span>:<span class="number">9</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(aaa)</span><br><span class="line"><span class="built_in">print</span>(aaa.values())</span><br><span class="line"><span class="comment"># &#123;&#x27;k1&#x27;: 1, &#x27;k2&#x27;: 9&#125;</span></span><br><span class="line"><span class="comment"># dict_values([1, 9])</span></span><br></pre></td></tr></table></figure></li><li><h4 id="items-方法-以列表的形式-返回字典键值对-对应的元组的可视对象"><a href="#items-方法-以列表的形式-返回字典键值对-对应的元组的可视对象" class="headerlink" title="items()方法||&#x3D;&#x3D;以列表的形式&#x3D;&#x3D;返回字典键值对&#x3D;&#x3D;对应的元组的可视对象&#x3D;&#x3D;"></a>items()方法||&#x3D;&#x3D;以列表的形式&#x3D;&#x3D;返回字典键值对&#x3D;&#x3D;对应的元组的可视对象&#x3D;&#x3D;</h4><p>使用下标运算符<code>[]</code>来访问一个<code>dict_items</code>对象。<code>dict_items</code>对象是由字典的<code>items()</code>方法返回的一个视图对象，&#x3D;&#x3D;它不支持下标运算符。&#x3D;&#x3D;</p><p>要访问<code>dict_items</code>对象中的元素，您可以使用&#x3D;&#x3D;迭代器&#x3D;&#x3D;或将其&#x3D;&#x3D;转换为列表&#x3D;&#x3D;后再进行访问。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aaa=&#123;<span class="string">&quot;k1&quot;</span>:<span class="number">1</span>,<span class="string">&quot;k2&quot;</span>:<span class="number">9</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(aaa)</span><br><span class="line"><span class="built_in">print</span>(aaa.items())</span><br><span class="line"><span class="comment"># &#123;&#x27;k1&#x27;: 1, &#x27;k2&#x27;: 9&#125;</span></span><br><span class="line"><span class="comment"># dict_items([(&#x27;k1&#x27;, 1), (&#x27;k2&#x27;, 9)])</span></span><br><span class="line">一般强制转换为<span class="built_in">list</span>使用</span><br></pre></td></tr></table></figure></li><li><h4 id="get-键-default-方法-返回指定键对应的值，如果没有就返回default，默认是none"><a href="#get-键-default-方法-返回指定键对应的值，如果没有就返回default，默认是none" class="headerlink" title="&#x3D;&#x3D;get(键,default)方法&#x3D;&#x3D;||返回指定键对应的值，如果没有就返回default，默认是none"></a>&#x3D;&#x3D;get(键,default)方法&#x3D;&#x3D;||返回指定键对应的值，如果没有就返回default，默认是none</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aaa=&#123;<span class="string">&quot;k1&quot;</span>:<span class="number">1</span>,<span class="string">&quot;k2&quot;</span>:<span class="number">9</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(aaa)</span><br><span class="line"><span class="built_in">print</span>(aaa.get(<span class="string">&quot;k1&quot;</span>,<span class="string">&quot;该键不存在啊&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(aaa.get(<span class="string">&quot;k3&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(aaa.get(<span class="string">&quot;k3&quot;</span>,<span class="string">&quot;该键不存在啊&quot;</span>))</span><br><span class="line"><span class="comment"># &#123;&#x27;k1&#x27;: 1, &#x27;k2&#x27;: 9&#125;</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"><span class="comment"># 该键不存在啊</span></span><br></pre></td></tr></table></figure></li><li><h4 id="copy-方法-返回一个新的字典，新开辟的"><a href="#copy-方法-返回一个新的字典，新开辟的" class="headerlink" title="copy()方法||返回一个新的字典，新开辟的"></a>copy()方法||返回一个新的字典，新开辟的</h4><ol><li><h6 id="copy与直接赋值一份字典的区别-–二者公用同一份。也就是后者指向前者。"><a href="#copy与直接赋值一份字典的区别-–二者公用同一份。也就是后者指向前者。" class="headerlink" title="copy与直接赋值一份字典的区别  –二者公用同一份。也就是后者指向前者。"></a>copy与直接赋值一份字典的区别  –二者公用同一份。也就是后者指向前者。</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aaa=&#123;<span class="string">&quot;k1&quot;</span>:<span class="number">1</span>,<span class="string">&quot;k2&quot;</span>:<span class="number">9</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(aaa)</span><br><span class="line">bbb=aaa</span><br><span class="line"><span class="built_in">print</span>(bbb)</span><br><span class="line">aaa[<span class="string">&quot;k1&quot;</span>]=<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(aaa)</span><br><span class="line"><span class="built_in">print</span>(bbb)</span><br><span class="line"><span class="comment"># &#123;&#x27;k1&#x27;: 1, &#x27;k2&#x27;: 9&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;k1&#x27;: 1, &#x27;k2&#x27;: 9&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;k1&#x27;: 2, &#x27;k2&#x27;: 9&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;k1&#x27;: 2, &#x27;k2&#x27;: 9&#125;</span></span><br></pre></td></tr></table></figure></li><li><h6 id="copy就不一样了，直接开辟一个新的字典"><a href="#copy就不一样了，直接开辟一个新的字典" class="headerlink" title="copy就不一样了，直接开辟一个新的字典"></a>copy就不一样了，直接开辟一个新的字典</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aaa=&#123;<span class="string">&quot;k1&quot;</span>:<span class="number">1</span>,<span class="string">&quot;k2&quot;</span>:<span class="number">9</span>&#125;</span><br><span class="line">bbb=aaa.copy();</span><br><span class="line"><span class="built_in">print</span>(aaa)</span><br><span class="line"><span class="built_in">print</span>(bbb)</span><br><span class="line">aaa[<span class="string">&quot;k1&quot;</span>]=<span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(aaa)</span><br><span class="line"><span class="built_in">print</span>(bbb)</span><br><span class="line"><span class="comment"># &#123;&#x27;k1&#x27;: 1, &#x27;k2&#x27;: 9&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;k1&#x27;: 1, &#x27;k2&#x27;: 9&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;k1&#x27;: 100, &#x27;k2&#x27;: 9&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;k1&#x27;: 1, &#x27;k2&#x27;: 9&#125;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><h4 id="clear-方-清空字典，删除字典的全部元素，得到空字典-与del-字典名不同，区别在于是否完全删除字典"><a href="#clear-方-清空字典，删除字典的全部元素，得到空字典-与del-字典名不同，区别在于是否完全删除字典" class="headerlink" title="clear()方||清空字典，删除字典的全部元素，得到空字典 与del 字典名不同，区别在于是否完全删除字典"></a>clear()方||清空字典，删除字典的全部元素，得到空字典 与del 字典名不同，区别在于是否完全删除字典</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aaa=&#123;<span class="string">&quot;k1&quot;</span>:<span class="number">1</span>,<span class="string">&quot;k2&quot;</span>:<span class="number">9</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(aaa)</span><br><span class="line">aaa.clear()</span><br><span class="line"><span class="built_in">print</span>(aaa)</span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><h4 id="pop（键，default）-方法-返回指定的-键对应的值，并在字典中将其移除-如果没有就直接报错或者default对应的值"><a href="#pop（键，default）-方法-返回指定的-键对应的值，并在字典中将其移除-如果没有就直接报错或者default对应的值" class="headerlink" title="&#x3D;&#x3D;pop（键，default）&#x3D;&#x3D;方法||返回指定的 键对应的值，并在字典中将其移除. 如果没有就直接报错或者default对应的值"></a>&#x3D;&#x3D;pop（键，default）&#x3D;&#x3D;方法||返回指定的 键对应的值，并在字典中将其移除. 如果没有就直接报错或者default对应的值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aaa=&#123;<span class="string">&quot;k1&quot;</span>:<span class="number">1</span>,<span class="string">&quot;k2&quot;</span>:<span class="number">9</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(aaa)</span><br><span class="line"><span class="built_in">print</span>(aaa.pop(<span class="string">&quot;k1&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(aaa)</span><br><span class="line"><span class="built_in">print</span>(aaa.pop(<span class="string">&quot;k4&quot;</span>,<span class="number">101</span>))</span><br><span class="line"><span class="comment"># &#123;&#x27;k1&#x27;: 1, &#x27;k2&#x27;: 9&#125;</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># &#123;&#x27;k2&#x27;: 9&#125;</span></span><br><span class="line"><span class="comment"># 101</span></span><br></pre></td></tr></table></figure></li><li><h5 id="popitem-方法，随机删除字典中的一组键值对，默认是最后一对，-并且以元组的形式返回这一对"><a href="#popitem-方法，随机删除字典中的一组键值对，默认是最后一对，-并且以元组的形式返回这一对" class="headerlink" title="popitem()方法，随机删除字典中的一组键值对，默认是最后一对，&#x3D;&#x3D;并且以元组的形式返回这一对&#x3D;&#x3D;"></a>popitem()方法，随机删除字典中的一组键值对，默认是最后一对，&#x3D;&#x3D;并且以元组的形式返回这一对&#x3D;&#x3D;</h5></li></ol></blockquote><h5 id="字典的注意事项"><a href="#字典的注意事项" class="headerlink" title="字典的注意事项"></a>字典的注意事项</h5><blockquote><h5 id="key不可以重复，类比生活中的字典"><a href="#key不可以重复，类比生活中的字典" class="headerlink" title="&#x3D;&#x3D;key不可以重复，类比生活中的字典&#x3D;&#x3D;"></a>&#x3D;&#x3D;key不可以重复，类比生活中的字典&#x3D;&#x3D;</h5><h5 id="没有下标索引，但可以使用key来查找对应的value"><a href="#没有下标索引，但可以使用key来查找对应的value" class="headerlink" title="没有下标索引，但可以使用key来查找对应的value"></a>没有下标索引，但可以使用key来查找对应的value</h5></blockquote><h4 id="4-5-集合（无序不重复集合）"><a href="#4-5-集合（无序不重复集合）" class="headerlink" title="4.5&#x3D;&#x3D;集合（无序不重复集合）&#x3D;&#x3D;"></a>4.5&#x3D;&#x3D;集合（<strong>无序不重复集合</strong>）&#x3D;&#x3D;</h4><blockquote><p>集合与列表相似，可以放多个数据，并且元素的存放是无序的，—-&#x3D;&#x3D;集合元素不可以是列表，字典，集合等可变对象不能有重复数据&#x3D;&#x3D;，</p></blockquote><h5 id="集合的创建"><a href="#集合的创建" class="headerlink" title="集合的创建"></a>集合的创建</h5><p><em><strong>集合的创建与字典的创建类似，但是又有区别。无序，元素的位置跟集合创建的位置无关，每次打印的顺序也不同,不能出现重复的元素，可以用来消除重复元素</strong></em></p><ol><li><h5 id="使用花括号创建集合"><a href="#使用花括号创建集合" class="headerlink" title="使用花括号创建集合"></a>使用花括号创建集合</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-s---------------------------------------&quot;</span>)</span><br><span class="line">s1=&#123;<span class="string">&#x27;黑色&#x27;</span>,<span class="string">&quot;白色&quot;</span>,<span class="string">&quot;蓝色&quot;</span>,<span class="string">&quot;蓝色&quot;</span>,<span class="string">&#x27;1&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(s1))</span><br><span class="line"><span class="comment"># &#123;&#x27;白色&#x27;, &#x27;蓝色&#x27;, &#x27;黑色&#x27;, &#x27;1&#x27;&#125;</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;set&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li><li><h5 id="使用set（）函数创建"><a href="#使用set（）函数创建" class="headerlink" title="使用set（）函数创建"></a>使用set（）函数创建</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=<span class="built_in">set</span>(<span class="string">&quot;hellword&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line">m1=[<span class="string">&#x27;1&#x27;</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">m2=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(m1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(m2))</span><br><span class="line">s1=<span class="built_in">set</span>(m1)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line">s1=<span class="built_in">set</span>(m2)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line">s1=<span class="built_in">set</span>()</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="comment"># &#123;&#x27;r&#x27;, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;o&#x27;, &#x27;w&#x27;, &#x27;d&#x27;, &#x27;l&#x27;&#125;</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;1&#x27;, 2, 3, 4&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;2&#x27;, 1, 2, 3&#125;</span></span><br><span class="line"><span class="comment"># set()</span></span><br></pre></td></tr></table></figure></li><li><h5 id="使用推导式创建"><a href="#使用推导式创建" class="headerlink" title="使用推导式创建"></a>使用推导式创建</h5><blockquote><p>与列表的推导式相同只不过用的是{}</p><p>s1&#x3D;{x for x in 可迭代对象 判断语句}</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line">s=<span class="built_in">set</span>(<span class="string">&quot;dasdsadddddd&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line">s=&#123;i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure></blockquote></li></ol><h5 id="访问集合-的元素"><a href="#访问集合-的元素" class="headerlink" title="访问集合 的元素"></a>访问集合 的元素</h5><blockquote><h5 id="因为集合是无序的，所以无法使用下标来操作"><a href="#因为集合是无序的，所以无法使用下标来操作" class="headerlink" title="因为集合是无序的，所以无法使用下标来操作"></a>因为集合是无序的，所以无法使用下标来操作</h5><h5 id="但可以通过for循环来访问集合的元素"><a href="#但可以通过for循环来访问集合的元素" class="headerlink" title="但可以通过for循环来访问集合的元素"></a>但可以通过for循环来访问集合的元素</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=&#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>) <span class="keyword">if</span> x&gt;=<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> s1:</span><br><span class="line"> <span class="built_in">print</span>(x)</span><br><span class="line"> <span class="comment"># </span></span><br><span class="line"> <span class="comment"># 3</span></span><br><span class="line"> <span class="comment"># 4</span></span><br><span class="line"> <span class="comment"># 5</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="集合添加元素"><a href="#集合添加元素" class="headerlink" title="集合添加元素"></a>集合添加元素</h5><blockquote><h5 id="使用add（）方法，因为集合是无序的，只把新的元素添加进去。不考虑位置，"><a href="#使用add（）方法，因为集合是无序的，只把新的元素添加进去。不考虑位置，" class="headerlink" title="使用add（）方法，因为集合是无序的，只把新的元素添加进去。不考虑位置，"></a>使用add（）方法，因为集合是无序的，只把新的元素添加进去。不考虑位置，</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=&#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>) <span class="keyword">if</span> x&gt;=<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="comment"># &#123;3, 4, 5&#125;</span></span><br><span class="line">s1.add(<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="comment"># &#123;3, 4, 5&#125;</span></span><br><span class="line"><span class="comment"># &#123;8, 3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="集合中常用的方法"><a href="#集合中常用的方法" class="headerlink" title="集合中常用的方法"></a>集合中常用的方法</h5><table><thead><tr><th align="center">编号</th><th>操作</th><th>说明</th></tr></thead><tbody><tr><td align="center">1</td><td>集合.add(元素)</td><td>集合内添加一个元素  不管位置，只管添加进去</td></tr><tr><td align="center">2</td><td>集合.remove(元素)</td><td>移除集合内指定的元素  没有的话就报错</td></tr><tr><td align="center">3</td><td>集合.pop()</td><td>&#x3D;&#x3D;从集合中随机取出一个元素,并且返回她&#x3D;&#x3D;</td></tr><tr><td align="center">4</td><td>集合.clear()</td><td>将集合清空</td></tr><tr><td align="center">5</td><td>集合1.difference(集合2)   集合1&gt;集合2</td><td>&#x3D;&#x3D;得到一个新集合&#x3D;&#x3D;，集合的差集   原有的2个集合内容不变,,,1-2</td></tr><tr><td align="center">6</td><td>集合1.difference_update(集合2)  对称</td><td>在集合1中，求差集 不反悔新的集合而是把结果保存再集合1中,,,1-2</td></tr><tr><td align="center">7</td><td>集合1.union(集合2)   并集</td><td>&#x3D;&#x3D;得到1个新集合，内含2个集合的全部元素&#x3D;&#x3D;   原有的2个集合内容不变,,,1+2</td></tr><tr><td align="center">8</td><td>len(集合)</td><td>得到一个整数，记录了集合的元素数量</td></tr></tbody></table><blockquote><ol><li><h5 id="remove-x-删除集合中的x元素，2-如果不存在就报错"><a href="#remove-x-删除集合中的x元素，2-如果不存在就报错" class="headerlink" title="remove(x),删除集合中的x元素，2.如果不存在就报错"></a>remove(x),删除集合中的x元素，2.如果不存在就报错</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=&#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>) <span class="keyword">if</span> x&gt;=<span class="number">3</span>&#125;</span><br><span class="line">      </span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="comment"># &#123;3, 4, 5&#125;</span></span><br><span class="line">s1.remove(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="comment"># &#123;3, 4, 5&#125;</span></span><br><span class="line"><span class="comment"># &#123;3, 5&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=&#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>) <span class="keyword">if</span> x&gt;=<span class="number">3</span>&#125;</span><br><span class="line">      </span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="comment"># &#123;3, 4, 5&#125;</span></span><br><span class="line">s1.remove(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;E:\PYTHON\字典.py&quot;, line 247, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#     s1.remove(6)</span></span><br><span class="line"><span class="comment"># KeyError: 6</span></span><br></pre></td></tr></table></figure></li><li><h5 id="discard（x），删除集合中的x元素，如果不存在，程序不做任何操作-★★★★★★★★推荐且默认返回none"><a href="#discard（x），删除集合中的x元素，如果不存在，程序不做任何操作-★★★★★★★★推荐且默认返回none" class="headerlink" title="discard（x），删除集合中的x元素，如果不存在，程序不做任何操作-★★★★★★★★推荐且默认返回none"></a>discard（x），删除集合中的x元素，如果不存在，程序不做任何操作-★★★★★★★★推荐且默认返回none</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=&#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>) <span class="keyword">if</span> x&gt;=<span class="number">3</span>&#125;</span><br><span class="line">      </span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line">s1.discard(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="comment"># &#123;3, 4, 5&#125;</span></span><br><span class="line"><span class="comment"># &#123;4, 5&#125;</span></span><br></pre></td></tr></table></figure></li><li><h5 id="pop（）方法，删除集合中的-任意一个元-素，并且返回该元素的值。因为集合没有下标操作，所以随机删"><a href="#pop（）方法，删除集合中的-任意一个元-素，并且返回该元素的值。因为集合没有下标操作，所以随机删" class="headerlink" title="pop（）方法，删除集合中的&#x3D;&#x3D;任意一个元&#x3D;&#x3D;素，并且返回该元素的值。因为集合没有下标操作，所以随机删"></a>pop（）方法，删除集合中的&#x3D;&#x3D;任意一个元&#x3D;&#x3D;素，并且返回该元素的值。因为集合没有下标操作，所以随机删</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=&#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>) <span class="keyword">if</span> x&gt;=<span class="number">3</span>&#125;</span><br><span class="line">      </span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="built_in">print</span>(s1.pop())</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="comment"># &#123;3, 4, 5&#125;</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># &#123;4, 5&#125;</span></span><br></pre></td></tr></table></figure></li><li><h5 id="clear（）方法，清空集合，删除集合中的所有元素。"><a href="#clear（）方法，清空集合，删除集合中的所有元素。" class="headerlink" title="clear（）方法，清空集合，删除集合中的所有元素。"></a>clear（）方法，清空集合，删除集合中的所有元素。</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=&#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>) <span class="keyword">if</span> x&gt;=<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line">s1.clear()</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="comment"># &#123;3, 4, 5&#125;</span></span><br><span class="line"><span class="comment"># set()</span></span><br></pre></td></tr></table></figure></li><li><h5 id="union-方法-联合起来，相当于并集"><a href="#union-方法-联合起来，相当于并集" class="headerlink" title="union()方法  联合起来，相当于并集"></a>union()方法  联合起来，相当于并集</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.union((s2)))</span><br><span class="line"><span class="comment"># &#123;1, 2, 3, 4, 5, 6&#125;</span></span><br></pre></td></tr></table></figure></li><li><h5 id="difference-方法-得到差集，注意顺序"><a href="#difference-方法-得到差集，注意顺序" class="headerlink" title="difference()方法 得到差集，注意顺序"></a>difference()方法 得到差集，注意顺序</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s2.difference(s1))</span><br><span class="line"><span class="built_in">print</span>(s1.difference(s2))</span><br><span class="line"><span class="comment"># &#123;4, 5, 6, 7&#125;</span></span><br><span class="line"><span class="comment"># set()</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h5 id="删除集合本身del"><a href="#删除集合本身del" class="headerlink" title="删除集合本身del"></a><strong>删除集合本身del</strong></h5><blockquote><h4 id="直接不存在整个数据结构了"><a href="#直接不存在整个数据结构了" class="headerlink" title="直接不存在整个数据结构了"></a>直接不存在整个数据结构了</h4></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=&#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>) <span class="keyword">if</span> x&gt;=<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="keyword">del</span> s1</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;E:\PYTHON\字典.py&quot;, line 272, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#     print(s1)</span></span><br><span class="line"><span class="comment">#           ^^</span></span><br><span class="line"><span class="comment"># NameError: name &#x27;s1&#x27; is not defined. Did you mean: &#x27;m1&#x27;?</span></span><br></pre></td></tr></table></figure><h5 id="成员操作同于序列"><a href="#成员操作同于序列" class="headerlink" title="成员操作同于序列"></a>成员操作同于序列</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=&#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>) <span class="keyword">if</span> x&gt;=<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">in</span> s1)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">in</span> s1)</span><br><span class="line"><span class="comment"># &#123;3, 4, 5&#125;</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure><h5 id="集合比较运算"><a href="#集合比较运算" class="headerlink" title="集合比较运算"></a>集合比较运算</h5><table><thead><tr><th>比较运算符</th><th>相关描述</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>比较两个集合是否相等，相等返回True</td></tr><tr><td>！&#x3D;</td><td>比较两个集合是否不相等，不相等返回True</td></tr><tr><td>&lt;</td><td>判断一个集合是否是另一个集合的严格子集</td></tr><tr><td>&lt;&#x3D;</td><td>判断一个集合是否是另一个集合的子集</td></tr><tr><td>&gt;</td><td>判断一个集合是否是另一个集合的严格超集</td></tr><tr><td>&gt;&#x3D;</td><td>判断一个集合是否是另一个集合的超集</td></tr></tbody></table><blockquote><ol><li><h5 id="a是b的子集-》a"><a href="#a是b的子集-》a" class="headerlink" title="a是b的子集&#x3D;》a&lt;&#x3D;b    意思就是a的元素b都有，且b的元素个数大于a的元素个数，但b没有a没有的"></a>a是b的子集&#x3D;》a&lt;&#x3D;b    意思就是a的元素b都有，且b的元素个数大于a的元素个数，但b没有a没有的</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1&lt;s2)</span><br><span class="line"><span class="built_in">print</span>(s1&lt;=s2)</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure></li><li><h5 id="a是b的严格子集，a"><a href="#a是b的严格子集，a" class="headerlink" title="a是b的严格子集，a&lt;b.意思就是a的元素b都有，且b的元素个数大于a的元素个数，但b有a没有的"></a>a是b的严格子集，a&lt;b.意思就是a的元素b都有，且b的元素个数大于a的元素个数，但b有a没有的</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1&lt;s2)</span><br><span class="line"><span class="built_in">print</span>(s1&lt;=s2)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h5 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h5><blockquote><ol><li><h5 id="交集运算-得到-两个集合共有的部分-，类型还是集合"><a href="#交集运算-得到-两个集合共有的部分-，类型还是集合" class="headerlink" title="交集运算 &amp; 得到&#x3D;&#x3D;两个集合共有的部分&#x3D;&#x3D;，类型还是集合"></a>交集运算 &amp; 得到&#x3D;&#x3D;两个集合共有的部分&#x3D;&#x3D;，类型还是集合</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">s3=s1 &amp; s2</span><br><span class="line"><span class="built_in">print</span>(s1 &amp; s2)</span><br><span class="line"><span class="built_in">print</span>(s3)</span><br><span class="line"><span class="comment"># &#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="comment"># &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure></li><li><h5 id="并集运算-得到两个集合并起来的整体，类型还是集合"><a href="#并集运算-得到两个集合并起来的整体，类型还是集合" class="headerlink" title="并集运算 | 得到两个集合并起来的整体，类型还是集合"></a>并集运算 | 得到两个集合并起来的整体，类型还是集合</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1 | s2)</span><br><span class="line"><span class="comment"># &#123;1, 2, 3, 4, 5, 6&#125;</span></span><br></pre></td></tr></table></figure></li><li><h5 id="差集运算-得到两个集合元素的减法，类型还是集合"><a href="#差集运算-得到两个集合元素的减法，类型还是集合" class="headerlink" title="差集运算 - 得到两个集合元素的减法，类型还是集合"></a>差集运算 - 得到两个集合元素的减法，类型还是集合</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s2-s1)</span><br><span class="line"><span class="comment"># &#123;4, 5, 6&#125;</span></span><br></pre></td></tr></table></figure></li><li><h5 id="对称差集运算-得到两个集合的并集挖去交集，类型还是集合"><a href="#对称差集运算-得到两个集合的并集挖去交集，类型还是集合" class="headerlink" title="&#x3D;&#x3D;对称差集运算&#x3D;&#x3D; ^ 得到两个集合的并集挖去交集，类型还是集合"></a>&#x3D;&#x3D;对称差集运算&#x3D;&#x3D; ^ 得到两个集合的并集挖去交集，类型还是集合</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1|s2)</span><br><span class="line"><span class="built_in">print</span>(s1&amp;s2)</span><br><span class="line"><span class="built_in">print</span>((s1|s2)-(s1&amp;s2))</span><br><span class="line"><span class="built_in">print</span>(s1^s2)</span><br><span class="line"><span class="comment"># &#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line"><span class="comment"># &#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="comment"># &#123;4, 5, 6&#125;</span></span><br><span class="line"><span class="comment"># &#123;4, 5, 6&#125;</span></span><br></pre></td></tr></table></figure></li><li><h5 id="union运算，-相当于并集"><a href="#union运算，-相当于并集" class="headerlink" title="union运算，&#x3D;&#x3D;相当于并集&#x3D;&#x3D;"></a>union运算，&#x3D;&#x3D;相当于并集&#x3D;&#x3D;</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.union((s2)))</span><br><span class="line"><span class="comment"># &#123;1, 2, 3, 4, 5, 6&#125;</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><hr><p><strong>经过.上述对集合的学习，可以总结出集合有如下特点:</strong><br><strong>可以容纳多个数据</strong><br><strong>●</strong><br><strong>可以容纳不同类型的数据(混装)</strong><br><strong>●</strong><br><strong>数据是无序存储的(不支持下标索引)</strong><br><strong>不允许重复数据存在</strong><br><strong>●</strong><br><strong>可以修改(增加或删除元素等)</strong><br><strong>●</strong><br><strong>支持for循环</strong></p><p><strong>不可以用while循环，因为不支持下标索引</strong></p><hr><hr><hr><h4 id="综合回顾"><a href="#综合回顾" class="headerlink" title="综合回顾"></a>综合回顾</h4><h6 id="数据容器分类"><a href="#数据容器分类" class="headerlink" title="数据容器分类"></a>数据容器分类</h6><blockquote><h6 id="数据容器可以从以下视角进行简单的分类"><a href="#数据容器可以从以下视角进行简单的分类" class="headerlink" title="数据容器可以从以下视角进行简单的分类:"></a>数据容器可以从以下视角进行简单的分类:</h6><hr><h6 id="是否支持下标索引"><a href="#是否支持下标索引" class="headerlink" title="是否支持下标索引"></a>是否支持下标索引</h6><h6 id="支持-列表、元组、字符串一序列类型"><a href="#支持-列表、元组、字符串一序列类型" class="headerlink" title="支持:列表、元组、字符串一序列类型"></a>支持:列表、元组、字符串一序列类型</h6><h6 id="不支持-集合、字典-非序列类型"><a href="#不支持-集合、字典-非序列类型" class="headerlink" title="不支持:集合、字典-非序列类型"></a>不支持:集合、字典-非序列类型</h6><hr><h6 id="是否支持重复元素"><a href="#是否支持重复元素" class="headerlink" title="是否支持重复元素:"></a>是否支持重复元素:</h6><h6 id="支持-列表、元组、字符串-序列类型"><a href="#支持-列表、元组、字符串-序列类型" class="headerlink" title="支持:列表、元组、字符串-序列类型,"></a>支持:列表、元组、字符串-序列类型,</h6><h6 id="不支持-集合、字典-非序列类型-1"><a href="#不支持-集合、字典-非序列类型-1" class="headerlink" title="不支持:集合、字典-非序列类型"></a>不支持:集合、字典-非序列类型</h6><hr><h6 id="是否可以修改"><a href="#是否可以修改" class="headerlink" title="是否可以修改"></a>是否可以修改</h6><h6 id="支持-列表、集合、字典"><a href="#支持-列表、集合、字典" class="headerlink" title="支持:列表、集合、字典"></a>支持:列表、集合、字典</h6><h6 id="不支持-元组、字符串"><a href="#不支持-元组、字符串" class="headerlink" title="不支持:元组、字符串"></a>不支持:元组、字符串</h6></blockquote><h6 id="数据特点对比"><a href="#数据特点对比" class="headerlink" title="数据特点对比"></a>数据特点对比</h6><table><thead><tr><th></th><th>列表</th><th>元组</th><th>字符串</th><th>集合</th><th>字典</th></tr></thead><tbody><tr><td>元素数量</td><td>支持多个</td><td>支持多个</td><td>支持多个</td><td>支持多个</td><td>支持多个</td></tr><tr><td>元素类型</td><td>任意</td><td>任意</td><td>仅字符</td><td>任意</td><td>Key: Value  Key:除字典外任意类型  Value:任意类型</td></tr><tr><td>下标索引</td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>重复元素</td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>可修改性</td><td>支持</td><td>不支持</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>数据有序</td><td>是</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td>使用场景</td><td>可修改、可重复的一批数据</td><td>不可修改、可重复的一批数据记</td><td>一串字符的记录</td><td>不可重复的数据</td><td>以Key检索Value</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="built_in">list</span>(<span class="string">&quot;dasdasd&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment">#[&#x27;d&#x27;, &#x27;a&#x27;, &#x27;s&#x27;, &#x27;d&#x27;, &#x27;a&#x27;, &#x27;s&#x27;, &#x27;d&#x27;]</span></span><br><span class="line">a=[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment">#[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))<span class="comment">#&lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment">#[1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------&quot;</span>)</span><br><span class="line">b=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(b)<span class="comment">#(1, 2, 3, 5)</span></span><br><span class="line">b=<span class="built_in">tuple</span>(<span class="string">&quot;sdadasd&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)<span class="comment">#(&#x27;s&#x27;, &#x27;d&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;a&#x27;, &#x27;s&#x27;, &#x27;d&#x27;)</span></span><br><span class="line">b=(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>))<span class="comment">#</span></span><br><span class="line"><span class="comment">#生成器对象默认是</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b))<span class="comment">#&lt;class &#x27;generator&#x27;&gt;</span></span><br><span class="line">b=<span class="built_in">tuple</span>(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line"><span class="built_in">print</span>(b)<span class="comment">#(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------&quot;</span>)</span><br><span class="line">c=<span class="built_in">dict</span>(a=<span class="number">1</span>,b=<span class="number">3</span>,c=<span class="number">2</span>)<span class="comment">#&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 3, &#x27;c&#x27;: 2&#125;</span></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">c=&#123;<span class="string">&quot;1&quot;</span>:<span class="number">1</span>,<span class="string">&quot;key2&quot;</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">l=[(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">4</span>)];</span><br><span class="line">c=&#123;x:j <span class="keyword">for</span> x,j <span class="keyword">in</span> l&#125;</span><br><span class="line"><span class="built_in">print</span>(c)<span class="comment">#&#123;&#x27;1&#x27;: 1, &#x27;key2&#x27;: 2&#125;</span></span><br><span class="line"></span><br><span class="line">c=&#123;x:y <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>) <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>,<span class="number">11</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(c)<span class="comment">#&#123;1: 10, 2: 10, 3: 10, 4: 10, 5: 10&#125;</span></span><br></pre></td></tr></table></figure><h4 id="数据结构的通用操作"><a href="#数据结构的通用操作" class="headerlink" title="数据结构的通用操作"></a>数据结构的通用操作</h4><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>通用for循环</td><td>遍历容器( 字典是遍历key)</td></tr><tr><td>max</td><td>容器内最大元素</td></tr><tr><td>min()</td><td>容器内最小元素</td></tr><tr><td>len()</td><td>容器元素个数</td></tr><tr><td>list()</td><td>转换为列表</td></tr><tr><td>tuple()</td><td>转换为元组</td></tr><tr><td>str()</td><td>转换为字符串</td></tr><tr><td>set()</td><td>转换为集合</td></tr><tr><td>排序，reverse&#x3D;True表示降序</td><td>sorted(序列，[reverse&#x3D;True])  得到一个排好序的列表  默认是从小到大  没有改变真身</td></tr></tbody></table><hr><blockquote><ol><li><h6 id="都支持遍历操作"><a href="#都支持遍历操作" class="headerlink" title="都支持遍历操作"></a>都支持遍历操作</h6><blockquote><p>首先，在遍历上:<br>●<br>5类数据容器都支持for循环遍历<br>●<br>&#x3D;&#x3D;列表、元组、字符串支持while循环，集合、字典不支持(无法下标索引)&#x3D;&#x3D;<br>尽管遍历的形式各有不同，但是，它们都支持遍历操作。</p></blockquote></li><li><h6 id="通用内置函数"><a href="#通用内置函数" class="headerlink" title="通用内置函数"></a>通用内置函数</h6><blockquote><ol><li><p><strong>len()计算数据容器的长度，也就是元素&#x2F;字符的个数</strong></p></li><li><p><strong>max()寻找数据容器中的最大值</strong></p></li><li><p><strong>min()寻找数据容器中的最小值</strong></p></li><li><h5 id="特殊的字典-返回的是键而不是值"><a href="#特殊的字典-返回的是键而不是值" class="headerlink" title="特殊的字典,返回的是键而不是值"></a>特殊的字典,返回的是键而不是值</h5></li><li><pre><code>b=(1,2,4,6)l=[1,3,5,7,9]k=&#123;&quot;key1&quot;:1,&quot;key2&quot;:3&#125;e=&#123;1,23,4,5,6&#125;print(max(b),max(l),max(k),max(e))# 6 9 key2 23<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 通用转换</span><br><span class="line"></span><br><span class="line">##### list(容器)</span><br><span class="line"></span><br><span class="line">##### 将给定容器转换为列表</span><br><span class="line"></span><br><span class="line">##### str(容器)</span><br><span class="line"></span><br><span class="line">##### 将给定容器转换为字符串</span><br><span class="line"></span><br><span class="line">##### tuple(容器)</span><br><span class="line"></span><br><span class="line">##### 将给定容器转换为元组</span><br><span class="line"></span><br><span class="line">##### set(容器)</span><br><span class="line"></span><br><span class="line">##### 将给定容器转换为集合</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">字典转化为列表，元组，集合都会忽略掉他的value,转为字符串的时候不省略</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">p=&#123;&quot;k1&quot;:1,&quot;k2&quot;:2,&quot;k3&quot;:3&#125;</span><br><span class="line">print(list(p))</span><br><span class="line">print(tuple(p))</span><br><span class="line">print(set(p))</span><br><span class="line">print(f&quot;转为人容易读的字符串&#123;str(p)&#125;&quot;)</span><br><span class="line">print(&quot;转为真正的字符串&quot;,&quot;&quot;.join(p))</span><br><span class="line"># [&#x27;k1&#x27;, &#x27;k2&#x27;, &#x27;k3&#x27;]</span><br><span class="line"># (&#x27;k1&#x27;, &#x27;k2&#x27;, &#x27;k3&#x27;)</span><br><span class="line"># &#123;&#x27;k3&#x27;, &#x27;k1&#x27;, &#x27;k2&#x27;&#125;</span><br><span class="line"># 转为人容易读的字符串&#123;&#x27;k1&#x27;: 1, &#x27;k2&#x27;: 2, &#x27;k3&#x27;: 3&#125;</span><br><span class="line"># 转为真正的字符串 k1k2k3</span><br></pre></td></tr></table></figure></code></pre></li></ol><h5 id="但是将他们转换为真正的字符串的时候要用一个空串的join函数哦"><a href="#但是将他们转换为真正的字符串的时候要用一个空串的join函数哦" class="headerlink" title="但是将他们转换为真正的字符串的时候要用一个空串的join函数哦"></a>但是将他们转换为真正的字符串的时候要用一个空串的join函数哦</h5><h6 id="转化成集合的时候，1去重操作，2顺序打乱"><a href="#转化成集合的时候，1去重操作，2顺序打乱" class="headerlink" title="转化成集合的时候，1去重操作，2顺序打乱"></a>转化成集合的时候，1去重操作，2顺序打乱</h6></blockquote></li><li><h6 id="通用排序功能"><a href="#通用排序功能" class="headerlink" title="通用排序功能"></a>通用排序功能</h6><blockquote><p>sorted(容器，reverse&#x3D;false)</p><p>默认是从小到大,&#x3D;&#x3D;但没有真正改变原本的数据&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p=[<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(p))</span><br><span class="line"><span class="comment"># [1, 2, 5, 7]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(p,reverse=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1, 2, 5, 7]</span></span><br><span class="line"><span class="comment"># [7, 5, 2, 1]</span></span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="comment"># [5, 2, 7, 1]</span></span><br></pre></td></tr></table></figure></blockquote></li></ol></blockquote><h5 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h5><hr><p>按位比较，一位一位的比较，例如ab&gt;aa,ab&gt;a,比较对应的ancii码</p><p>从头到尾一位一位的比较，其中一位大，后面就不用比较了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;abc&quot;</span>&gt;<span class="string">&quot;abd&quot;</span>)</span><br></pre></td></tr></table></figure><hr><hr><h3 id="Python函数"><a href="#Python函数" class="headerlink" title="Python函数"></a>Python函数</h3><h4 id="函数和方法的区别"><a href="#函数和方法的区别" class="headerlink" title="函数和方法的区别"></a>函数和方法的区别</h4><blockquote><p>函数直接传入参数就可以使用</p><p>方法需要用.来引用，例如num&#x3D;student.pop(1)</p></blockquote><h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><p><strong>&#x3D;&#x3D;<code>random.randint(x, y)</code>函数返回一个在闭区间<code>[x, y]</code>内的随机整数，包括<code>x</code>和<code>y</code>在内。&#x3D;&#x3D;</strong></p><blockquote><ol><li><p>提前写好的</p></li><li><p>可以重复使用的</p></li><li><p>把重复性的工作给封装起来 了</p></li><li><p>针对特定功能</p></li><li><p><strong>len()计算数据容器的长度，也就是元素&#x2F;字符的个数</strong></p></li><li><p><strong>max()寻找数据容器中的最大值</strong></p></li><li><p><strong>min()寻找数据容器中的最小值</strong></p></li></ol></blockquote><p>自定义函数</p><h4 id="函数的基础定义语法"><a href="#函数的基础定义语法" class="headerlink" title="函数的基础定义语法"></a>函数的基础定义语法</h4><blockquote><p>def 函数名字(参数1，参数…..):</p><p>​函数体</p><p>return 返回值</p><p>函数定义里面的x，y是&#x3D;&#x3D;形参&#x3D;&#x3D;，函数调用时候传入的为&#x3D;&#x3D;实参&#x3D;&#x3D;</p><p>多个参数用，隔开</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myf1</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x*<span class="number">2</span>+y*<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(myf1(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="comment"># 8</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myf</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是大帅逼&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    myf()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 我是大帅逼</span></span><br><span class="line"><span class="comment"># 我是大帅逼</span></span><br><span class="line"><span class="comment"># 我是大帅逼</span></span><br><span class="line"><span class="comment"># 我是大帅逼</span></span><br><span class="line"><span class="comment"># 我是大帅逼</span></span><br><span class="line"><span class="comment"># 我是大帅逼</span></span><br><span class="line"><span class="comment"># 我是大帅逼</span></span><br><span class="line"><span class="comment"># 我是大帅逼</span></span><br><span class="line"><span class="comment"># 我是大帅逼</span></span><br><span class="line"><span class="comment"># 我是大帅逼</span></span><br></pre></td></tr></table></figure><blockquote><h6 id="注意事项"><a href="#注意事项" class="headerlink" title="&#x3D;&#x3D;注意事项&#x3D;&#x3D;"></a>&#x3D;&#x3D;注意事项&#x3D;&#x3D;</h6><ol><li>如果没有参数就省略</li><li>返回值不需要也可以省略</li><li>函数必须先定义再使用</li></ol></blockquote><h4 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h4><p><em><strong>没有返回值的函数实际上返回了NONE</strong></em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result=myf()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line">result=myf1(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"><span class="comment"># 8</span></span><br></pre></td></tr></table></figure><blockquote><ol><li><h6 id="函数可以返回一个值或多个值。在函数中使用return语句后，-函数将会立即停止执行-，并将指定的值返回给调用者。如果没有使用return语句，函数将默认返回None。"><a href="#函数可以返回一个值或多个值。在函数中使用return语句后，-函数将会立即停止执行-，并将指定的值返回给调用者。如果没有使用return语句，函数将默认返回None。" class="headerlink" title="函数可以返回一个值或多个值。在函数中使用return语句后，&#x3D;&#x3D;函数将会立即停止执行&#x3D;&#x3D;，并将指定的值返回给调用者。如果没有使用return语句，函数将默认返回None。"></a>函数可以返回一个值或多个值。在函数中使用<code>return</code>语句后，&#x3D;&#x3D;函数将会立即停止执行&#x3D;&#x3D;，并将指定的值返回给调用者。如果没有使用<code>return</code>语句，函数将默认返回<code>None</code>。</h6></li><li><p><strong>函数&#x3D;&#x3D;可以返回任意类型的值&#x3D;&#x3D;，包括整数、浮点数、字符串、列表、字典、元组等。</strong></p></li><li><p>如果函数返回多个值，可以使用元组、列表或字典等数据结构来存储这些值，并一起返回。</p></li><li><p>可以使用函数的返回值来赋值给一个变量，或者作为另一个函数的参数。</p></li><li><p>如果函数没有返回值，即没有使用<code>return</code>语句，或者<code>return</code>语句没有指定返回值，则函数默认返回<code>None</code>。</p></li><li><p>可以使用<code>return</code>语句提前结束函数的执行，并返回指定的值。</p></li><li><p>如果函数没有返回值，可以省略<code>return</code>语句。</p></li></ol></blockquote><h4 id="函数的说明文档（帮助理解自己的函数）"><a href="#函数的说明文档（帮助理解自己的函数）" class="headerlink" title="函数的说明文档（帮助理解自己的函数）"></a>函数的说明文档（帮助理解自己的函数）</h4><blockquote><ol><li><p>‘’‘回车自动弹出</p></li><li><p>用于解释函数</p></li><li><p>鼠标放在函数上的时候会现实相关的说明</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myf1</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    第一个参数*2+第二个参数*3 的和</span></span><br><span class="line"><span class="string">    :param x:第一额加的数</span></span><br><span class="line"><span class="string">    :param y:第二个加的数</span></span><br><span class="line"><span class="string">    :return:返回值是运算结果</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> x*<span class="number">2</span>+y*<span class="number">3</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="函数的嵌套"><a href="#函数的嵌套" class="headerlink" title="函数的嵌套"></a>函数的嵌套</h4><p>一个函数里用另一个函数的方法</p><p>直接运用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;------1------&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------2-------&quot;</span>)</span><br><span class="line">    fun1()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------3---------&quot;</span>)</span><br><span class="line">fun2()</span><br><span class="line"><span class="comment"># --------2-------</span></span><br><span class="line"><span class="comment"># ------1------</span></span><br><span class="line"><span class="comment"># --------3---------</span></span><br></pre></td></tr></table></figure><h4 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="&#x3D;&#x3D;变量的作用域&#x3D;&#x3D;"></a>&#x3D;&#x3D;变量的作用域&#x3D;&#x3D;</h4><blockquote><h6 id="python中并不是所有的语句块都会产生作用域，只有在函数，类中定义的语句块，才会产生作用域。"><a href="#python中并不是所有的语句块都会产生作用域，只有在函数，类中定义的语句块，才会产生作用域。" class="headerlink" title="&#x3D;&#x3D;python中并不是所有的语句块都会产生作用域，只有在函数，类中定义的语句块，才会产生作用域。&#x3D;&#x3D;"></a>&#x3D;&#x3D;python中并不是所有的语句块都会产生作用域，只有在函数，类中定义的语句块，才会产生作用域。&#x3D;&#x3D;</h6><h6 id="在if-else，for，while，等关键字里面定义的语句块并不会擦还是你哼作用域，仍然创建的是全局变量"><a href="#在if-else，for，while，等关键字里面定义的语句块并不会擦还是你哼作用域，仍然创建的是全局变量" class="headerlink" title="&#x3D;&#x3D;在if-else，for，while，等关键字里面定义的语句块并不会擦还是你哼作用域，仍然创建的是全局变量&#x3D;&#x3D;"></a>&#x3D;&#x3D;在if-else，for，while，等关键字里面定义的语句块并不会擦还是你哼作用域，仍然创建的是全局变量&#x3D;&#x3D;</h6></blockquote><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>在函数内部定义的，只能在函数返回内使用</p><p>函数执行完毕后局部变量就被销毁了</p><p>全局变量，在函数体内体外都可以使用的变量</p><p>就算同名也不一样</p><h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><p>***&#x3D;&#x3D;global关键字把在函数内部声明的变量变成全局变量&#x3D;&#x3D;***，外面没有的话就创建一个全局变量，外边有的话，二者就为同一个全局变量。</p><p>在Python中，&#x3D;&#x3D;函数内部默认情况下只能访问局部范围内的变量&#x3D;&#x3D;。要在函数内部使用外部变量，需要使用<code>global</code>关键字将其声明为全局变量。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=100</span><br><span class="line">def fun3():</span><br><span class="line">    a+=100</span><br><span class="line">    print(f&quot;我现在是&#123;a&#125;&quot;)</span><br><span class="line"></span><br><span class="line">fun3()</span><br><span class="line">#直接报错</span><br><span class="line"># Traceback (most recent call last):</span><br><span class="line">#   File &quot;E:\PYTHON\函数.py&quot;, line 62, in &lt;module&gt;</span><br><span class="line">#     fun3()</span><br><span class="line">#   File &quot;E:\PYTHON\函数.py&quot;, line 59, in fun3</span><br><span class="line">#     a+=100</span><br><span class="line">#     ^</span><br><span class="line"># UnboundLocalError: cannot access local variable &#x27;a&#x27; where it is not associated with a value</span><br></pre></td></tr></table></figure><p>用了global关键字后</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun3</span>():</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    <span class="comment">#==global使用的时候不能初始化，也就是说只能声明==</span></span><br><span class="line">    a+=<span class="number">100</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;我现在是<span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">fun3()</span><br><span class="line"><span class="comment"># 我现在是200</span></span><br></pre></td></tr></table></figure><blockquote><p>注意事项</p><ol><li>&#x3D;&#x3D;global使用的时候不能初始化，也就是说只能声明&#x3D;&#x3D;</li><li>定义：定义是指在程序中为变量分配内存空间，并为其分配一个唯一的标识符（即变量名）。定义变量时，编译器会为其分配内存空间，以便在程序执行期间存储和操作数据。</li><li>声明：声明是指在程序中引入变量的标识符，以便在后续的代码中使用该变量。声明变量时，编译器会告诉程序变量的数据类型和名称，但不会为其分配内存空间。因此，在声明变量之后，变量是不可用的。</li><li>初始化：初始化是指在声明变量的同时为其赋予一个初始值。初始化变量时，编译器会为其分配内存空间，并将初始值存储在该内存空间中。初始化变量可以在声明时进行，也可以在稍后的代码中进行。</li></ol></blockquote><h4 id="综合案例-1"><a href="#综合案例-1" class="headerlink" title="综合案例"></a>综合案例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">money=<span class="number">120</span></span><br><span class="line">name=<span class="string">&quot;猫饼&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1\t查询余额函数\n&quot;</span><span class="string">&quot;2\t存款函数\n&quot;</span><span class="string">&quot;3\t取款函数\n&quot;</span><span class="string">&quot;4\t主菜单函数&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcsearch</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;您现在的余额为<span class="subst">&#123;money&#125;</span>元&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funccunkuan</span>():</span><br><span class="line">    <span class="keyword">global</span> money</span><br><span class="line">    a=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;你要存多少？&quot;</span>))</span><br><span class="line">    money+=a</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcqukuan</span>():</span><br><span class="line">    <span class="keyword">global</span> money</span><br><span class="line">    a=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;你要取多少？&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> a&lt;=money:</span><br><span class="line">        money-=a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>你特么有多少你没点b数？&quot;</span>)</span><br><span class="line">name=<span class="built_in">input</span>(<span class="string">&quot;请输入你姓名&quot;</span>)</span><br><span class="line"><span class="comment"># menu()</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    menu()</span><br><span class="line">    p=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;您要干神马？&quot;</span>))</span><br><span class="line">    <span class="comment"># print(p)</span></span><br><span class="line">    <span class="keyword">if</span> p==<span class="number">1</span>:</span><br><span class="line">        funcsearch()</span><br><span class="line">    <span class="keyword">elif</span> p==<span class="number">2</span>:</span><br><span class="line">        funccunkuan()</span><br><span class="line">        funcsearch()</span><br><span class="line">    <span class="keyword">elif</span> p==<span class="number">3</span>:</span><br><span class="line">        funcqukuan()</span><br><span class="line">        funcsearch()</span><br><span class="line">    <span class="keyword">elif</span> p==<span class="number">4</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; 1 查询余额函数\n&quot;</span>, <span class="string">&quot;2 存款函数\n&quot;</span>, <span class="string">&quot;3 取款函数\n&quot;</span>, <span class="string">&quot;4 主菜单函数&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> p==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;谢谢你使用牛马ATM自助存取一体机&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="python函数进阶"><a href="#python函数进阶" class="headerlink" title="python函数进阶"></a>python函数进阶</h3><h5 id="函数有多个返回值"><a href="#函数有多个返回值" class="headerlink" title="函数有多个返回值,"></a>函数有多个返回值,</h5><blockquote><h5 id="函数有多个返回值-—对应多个变量来接受它。变量之间用，隔开，而且可以是不同的数据类型-。如果直接返回的话，得到对应的元组"><a href="#函数有多个返回值-—对应多个变量来接受它。变量之间用，隔开，而且可以是不同的数据类型-。如果直接返回的话，得到对应的元组" class="headerlink" title="函数有多个返回值,—对应多个变量来接受它。变量之间用，隔开，而且可以是不同的数据类型.。如果直接返回的话，得到对应的元组"></a>函数有多个返回值,—对应多个变量来接受它。变量之间用，隔开，而且可以是不同的数据类型.。如果直接返回的话，得到对应的元组</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">x,y=func()</span><br><span class="line"><span class="built_in">print</span>(x,y)</span><br><span class="line"><span class="comment"># 1 2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>,<span class="string">&quot;hello&quot;</span>,<span class="literal">True</span></span><br><span class="line">a,b,c=func1()</span><br><span class="line"><span class="built_in">print</span>(a,b,c)</span><br><span class="line"><span class="built_in">print</span>(func1())</span><br><span class="line"><span class="comment"># 1 hello True</span></span><br><span class="line"><span class="comment"># (1, &#x27;hello&#x27;, True)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(func1()))</span><br><span class="line"><span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="位置参数和关键字参数"><a href="#位置参数和关键字参数" class="headerlink" title="位置参数和关键字参数"></a>位置参数和关键字参数</h5><p><strong>位置参数就默认的，需要严格的对应。</strong></p><p><strong>关键字参数键值对的形式，更加清晰。原始的情况需要严格对应。混合使用的时候，位置参数必须在前面。</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------位置参数----------------&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func3</span>(<span class="params">x,y,z</span>):</span><br><span class="line">    <span class="keyword">return</span> x+y+z</span><br><span class="line"><span class="built_in">print</span>(func3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------关键字参数----------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(func3(x=<span class="number">1</span>,y=<span class="number">2</span>,z=<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># 6</span></span><br></pre></td></tr></table></figure><h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><blockquote><h5 id="在函数定义的时候就给形参一个默认的赋值，以后调用函数的时候，如果不给默认参数对应的实参，就用默认参数，如果给了就用实参。"><a href="#在函数定义的时候就给形参一个默认的赋值，以后调用函数的时候，如果不给默认参数对应的实参，就用默认参数，如果给了就用实参。" class="headerlink" title="在函数定义的时候就给形参一个默认的赋值，以后调用函数的时候，如果不给默认参数对应的实参，就用默认参数，如果给了就用实参。"></a>在函数定义的时候就给形参一个默认的赋值，以后调用函数的时候，如果不给默认参数对应的实参，就用默认参数，如果给了就用实参。</h5><hr><h5 id="默认参数需要写在形参的最后"><a href="#默认参数需要写在形参的最后" class="headerlink" title="默认参数需要写在形参的最后"></a>默认参数需要写在形参的最后</h5><h6 id="否则就会报错"><a href="#否则就会报错" class="headerlink" title="否则就会报错"></a>否则就会报错</h6><h5 id="SyntaxError-non-default-argument-follows-default-argument"><a href="#SyntaxError-non-default-argument-follows-default-argument" class="headerlink" title="SyntaxError: non-default argument follows default argument"></a>SyntaxError: non-default argument follows default argument</h5></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func3</span>(<span class="params">x,y,z=<span class="number">9</span></span>):</span><br><span class="line">    <span class="keyword">return</span> x+y+z</span><br><span class="line"><span class="built_in">print</span>(func3(x=<span class="number">1</span>,y=<span class="number">2</span>,z=<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(func3(x=<span class="number">1</span>,y=<span class="number">2</span>))</span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># 12</span></span><br></pre></td></tr></table></figure><h5 id="位置不定长—元组"><a href="#位置不定长—元组" class="headerlink" title="位置不定长—元组"></a>位置不定长—元组</h5><p>传入时候的参数数量是不受限制的</p><p>*<strong>标记一个形参， 以元组的形式接受实参</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">funcc</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;args的类型是<span class="subst">&#123;<span class="built_in">type</span>(args)&#125;</span>,值是<span class="subst">&#123;args&#125;</span>&quot;</span>)</span><br><span class="line">funcc(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line"><span class="comment"># args的类型是&lt;class &#x27;tuple&#x27;&gt;,值是(1, 2, 3, &#x27;小明&#x27;)</span></span><br></pre></td></tr></table></figure><h5 id="关键字不定长—字典"><a href="#关键字不定长—字典" class="headerlink" title="关键字不定长—字典"></a>关键字不定长—字典</h5><p>传入时候的参数数量是不受限制的</p><p><strong>标记一个形参，以字典的形式接受实参</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">funccc</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;kwargs的类型是<span class="subst">&#123;<span class="built_in">type</span>(kwargs)&#125;</span>,值是<span class="subst">&#123;kwargs&#125;</span>&quot;</span>)</span><br><span class="line">funccc(key1=<span class="number">1</span>,key2=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># kwargs的类型是&lt;class &#x27;dict&#x27;&gt;,值是&#123;&#x27;key1&#x27;: 1, &#x27;key2&#x27;: 2&#125;</span></span><br></pre></td></tr></table></figure><h5 id="函数作为参数传递（计算逻辑的传递）"><a href="#函数作为参数传递（计算逻辑的传递）" class="headerlink" title="函数作为参数传递（计算逻辑的传递）"></a>函数作为参数传递（计算逻辑的传递）</h5><p><strong>函数名作为传递的方式</strong></p><p><strong>形参和实参没有强制一致</strong></p><p><em>数据是确定的，计算逻辑是可变的。</em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line">a=<span class="number">19</span>;b=<span class="number">20</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">text</span>(<span class="params">computee</span>):</span><br><span class="line">    result=compute(a,b)+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="built_in">print</span>(compute(a,b))</span><br><span class="line"><span class="built_in">print</span>(text(compute(<span class="number">9</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="comment"># 39</span></span><br><span class="line"><span class="comment"># 40</span></span><br></pre></td></tr></table></figure><p>二者的区别</p><blockquote><h5 id="普通的函数def-add-x-y"><a href="#普通的函数def-add-x-y" class="headerlink" title="普通的函数def add(x,y):"></a>普通的函数def add(x,y):</h5><h5 id="return-x-y"><a href="#return-x-y" class="headerlink" title="return x+y"></a>return x+y</h5><h5 id="传入的是数据，确定的是代码的执行逻辑，不确定的是数据"><a href="#传入的是数据，确定的是代码的执行逻辑，不确定的是数据" class="headerlink" title="传入的是数据，确定的是代码的执行逻辑，不确定的是数据"></a>传入的是数据，确定的是代码的执行逻辑，不确定的是数据</h5><h5 id="函数作为函数的参数-def-func-add"><a href="#函数作为函数的参数-def-func-add" class="headerlink" title="函数作为函数的参数  def func(add):"></a>函数作为函数的参数  def func(add):</h5><h5 id="result-add-1-2"><a href="#result-add-1-2" class="headerlink" title="result&#x3D;add(1,2)"></a>result&#x3D;add(1,2)</h5><h5 id="return-result"><a href="#return-result" class="headerlink" title="return result"></a>return result</h5><h5 id="传入的是函数的代码执行-逻辑，确定的是数据，不确定的是代码的执行逻辑"><a href="#传入的是函数的代码执行-逻辑，确定的是数据，不确定的是代码的执行逻辑" class="headerlink" title="传入的是函数的代码执行 逻辑，确定的是数据，不确定的是代码的执行逻辑"></a>传入的是函数的代码执行 逻辑，确定的是数据，不确定的是代码的执行逻辑</h5></blockquote><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>def定义带有名称的函数</p><p>lambda定义匿名函数</p><p><strong>lambda x,y:x+y</strong></p><p><strong>有名称的可以基于名称重复使用</strong></p><p><strong>匿名函数，只可以临时使用一次</strong></p><p>&#x3D;&#x3D;<strong>自带返回return功能</strong>&#x3D;&#x3D;</p><p><strong>匿名函数的函数体只能写一行，无法写多行代码，且参数不带括号</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line">a=<span class="number">19</span>;b=<span class="number">20</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">text</span>(<span class="params">computee</span>):</span><br><span class="line">    result=compute(a,b)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="built_in">print</span>(text(<span class="keyword">lambda</span> x,y:x+y))</span><br><span class="line"><span class="comment"># 39</span></span><br></pre></td></tr></table></figure><h3 id="文件的操作"><a href="#文件的操作" class="headerlink" title="文件的操作"></a>文件的操作</h3><h5 id="文件的编码"><a href="#文件的编码" class="headerlink" title="文件的编码"></a>文件的编码</h5><blockquote><h5 id="翻译的规则，如何将内容翻译为二进制，然后电脑使用的时候再翻译为文本就ok了"><a href="#翻译的规则，如何将内容翻译为二进制，然后电脑使用的时候再翻译为文本就ok了" class="headerlink" title="翻译的规则，如何将内容翻译为二进制，然后电脑使用的时候再翻译为文本就ok了"></a>翻译的规则，如何将内容翻译为二进制，然后电脑使用的时候再翻译为文本就ok了</h5><h6 id="utf-8-逐渐通用"><a href="#utf-8-逐渐通用" class="headerlink" title="utf-8,逐渐通用"></a>utf-8,逐渐通用</h6><p>gbk</p><p>big5等等</p><p>不同的编码格式会翻译不同的结果</p><h5 id="我喜欢你-我讨厌你……"><a href="#我喜欢你-我讨厌你……" class="headerlink" title="我喜欢你-&gt;我讨厌你……."></a>我喜欢你-&gt;我讨厌你…….</h5></blockquote><hr><h5 id="文件的打开-读取操作"><a href="#文件的打开-读取操作" class="headerlink" title="文件的打开-读取操作"></a>文件的打开-读取操作</h5><p>默认都把\n也读进来了</p><p><strong>没有这个文件的时候就报错</strong></p><p>&#x3D;&#x3D;如果没有这个文件在异常捕获的时候会返回一个none，if语句会把none当作false看作&#x3D;&#x3D;★★★★★★★★</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_file_info</span>(<span class="params">file_name</span>):</span><br><span class="line">    f=<span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f=<span class="built_in">open</span>(file_name,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> reason:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;文件tm打不开啊&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(f.read())</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># print(f)</span></span><br><span class="line">        <span class="keyword">if</span> f:</span><br><span class="line">            f.close()</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打开文件&quot;</span>)</span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&quot;./1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f))</span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;_io.TextIOWrapper&#x27;&gt;</span></span><br></pre></td></tr></table></figure><blockquote><ol><li><h5 id="文件对象-read（num）方法-num代表的是要读取的长度单位是字节-没有传入就默认读取全部数据，-以字符串返回"><a href="#文件对象-read（num）方法-num代表的是要读取的长度单位是字节-没有传入就默认读取全部数据，-以字符串返回" class="headerlink" title="文件对象.read（num）方法,num代表的是要读取的长度单位是字节,没有传入就默认读取全部数据，&#x3D;&#x3D;以字符串返回&#x3D;&#x3D;"></a>文件对象.read（num）方法,num代表的是要读取的长度单位是字节,没有传入就默认读取全部数据，&#x3D;&#x3D;以字符串返回&#x3D;&#x3D;</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打开文件&quot;</span>)</span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&quot;./1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f))</span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;_io.TextIOWrapper&#x27;&gt;</span></span><br><span class="line"><span class="comment"># print(f.read())</span></span><br><span class="line"><span class="built_in">print</span>(f.read(<span class="number">10</span>))</span><br><span class="line"><span class="comment"># 哈利大苏打阿达阿松大 |第一次读到这里，第二次继续读</span></span><br><span class="line"><span class="comment"># 啊啊</span></span><br><span class="line"><span class="built_in">print</span>(f.read())</span><br></pre></td></tr></table></figure></li><li><h6 id="文件对象-readlines（）方法，读取全部行并且封装到列表中返回-以列表返回"><a href="#文件对象-readlines（）方法，读取全部行并且封装到列表中返回-以列表返回" class="headerlink" title="文件对象.readlines（）方法，读取全部行并且封装到列表中返回  &#x3D;&#x3D;以列表返回&#x3D;&#x3D;"></a>文件对象.readlines（）方法，读取全部行并且封装到列表中返回  &#x3D;&#x3D;以列表返回&#x3D;&#x3D;</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;打开文件&quot;)</span><br><span class="line">f=open(&quot;./1.txt&quot;,&quot;r&quot;,encoding=&quot;UTF-8&quot;)</span><br><span class="line">print(type(f))</span><br><span class="line"># 打开文件</span><br><span class="line"># &lt;class &#x27;_io.TextIOWrapper&#x27;&gt;</span><br><span class="line">print(f.readlines())</span><br><span class="line"># [&#x27;哈利大苏打阿达阿松大啊啊\n&#x27;, &#x27;dadasdasdasdsad&#x27;]</span><br></pre></td></tr></table></figure></li><li><h6 id="文件对象-readline（num）方法，读取一行的内容，返回字符串-以字符串返回"><a href="#文件对象-readline（num）方法，读取一行的内容，返回字符串-以字符串返回" class="headerlink" title="文件对象.readline（num）方法，读取一行的内容，返回字符串   &#x3D;&#x3D;以字符串返回&#x3D;&#x3D;"></a>文件对象.readline（num）方法，读取一行的内容，返回字符串   &#x3D;&#x3D;以字符串返回&#x3D;&#x3D;</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打开文件&quot;</span>)</span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&quot;./1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f))</span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;_io.TextIOWrapper&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(f.readline())</span><br><span class="line"><span class="comment"># 哈利大苏打阿达阿松大啊啊</span></span><br></pre></td></tr></table></figure></li><li><h5 id="for循环方法读取-以字符串返回"><a href="#for循环方法读取-以字符串返回" class="headerlink" title="for循环方法读取   &#x3D;&#x3D;以字符串返回&#x3D;&#x3D;"></a>for循环方法读取   &#x3D;&#x3D;以字符串返回&#x3D;&#x3D;</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打开文件&quot;</span>)</span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&quot;./1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f))</span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;_io.TextIOWrapper&#x27;&gt;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># 哈利大苏打阿达阿松大啊啊</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># dadasdasdasdsad</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><hr><blockquote><h5 id="文件对象-close-关闭文件，取消对文件的占用。"><a href="#文件对象-close-关闭文件，取消对文件的占用。" class="headerlink" title="文件对象.close(),关闭文件，取消对文件的占用。"></a>文件对象.close(),关闭文件，取消对文件的占用。</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f.close()</span><br></pre></td></tr></table></figure></blockquote><h5 id="with-open语法★★★★★"><a href="#with-open语法★★★★★" class="headerlink" title="with-open语法★★★★★"></a>with-open语法★★★★★</h5><blockquote><h5 id="对文件的操作完成后，会自动的把文件给close掉"><a href="#对文件的操作完成后，会自动的把文件给close掉" class="headerlink" title="对文件的操作完成后，会自动的把文件给close掉"></a>对文件的操作完成后，会自动的把文件给close掉</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打开文件&quot;</span>)</span><br><span class="line"><span class="comment"># f=open(&quot;./1.txt&quot;,&quot;r&quot;,encoding=&quot;UTF-8&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span> (<span class="string">&quot;./1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf=8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"> <span class="built_in">print</span>(f.readlines())</span><br><span class="line"><span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="comment">#关闭后的文件是不能再读取的</span></span><br><span class="line"><span class="comment"># [&#x27;哈利大苏打阿达阿松大啊啊\n&#x27;, &#x27;dadasdasdasdsad&#x27;]</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;e:\Bluecode\code\python\code\文件的操作.py&quot;, line 6, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#     print(f.read())</span></span><br><span class="line"><span class="comment">#           ^^^^^^^^</span></span><br><span class="line"><span class="comment"># ValueError: I/O operation on closed file.</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="文件的写操作"><a href="#文件的写操作" class="headerlink" title="文件的写操作"></a>文件的写操作</h5><blockquote><p>write()方法，文件写入，并没有真正的写入硬盘上，仅写在内存的某一个区域中，也就是缓冲区。</p><h6 id="直到调用flush或者close方法文件，才会把缓冲区的内容真正写到硬盘中"><a href="#直到调用flush或者close方法文件，才会把缓冲区的内容真正写到硬盘中" class="headerlink" title="直到调用flush或者close方法文件，才会把缓冲区的内容真正写到硬盘中"></a>直到调用flush或者close方法文件，才会把缓冲区的内容真正写到硬盘中</h6><h6 id="避免频繁的操作硬盘"><a href="#避免频繁的操作硬盘" class="headerlink" title="避免频繁的操作硬盘"></a>避免频繁的操作硬盘</h6><p>flush（）方法，内容刷新，</p><hr><h6 id="使用w操作，如果这个文件存在，就覆盖原来的内容，如果文件不存在，就创建一个"><a href="#使用w操作，如果这个文件存在，就覆盖原来的内容，如果文件不存在，就创建一个" class="headerlink" title="使用w操作，如果这个文件存在，就覆盖原来的内容，如果文件不存在，就创建一个"></a>使用w操作，如果这个文件存在，就覆盖原来的内容，如果文件不存在，就创建一个</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f=<span class="built_in">open</span>(<span class="string">&quot;./2.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">f.write(<span class="string">&quot;我去&quot;</span>)</span><br><span class="line">f.flush()</span><br><span class="line"><span class="comment"># 我去</span></span><br></pre></td></tr></table></figure><h6 id="直到调用flush或者close方法文件，才会把缓冲区的内容真正写到硬盘中-1"><a href="#直到调用flush或者close方法文件，才会把缓冲区的内容真正写到硬盘中-1" class="headerlink" title="直到调用flush或者close方法文件，才会把缓冲区的内容真正写到硬盘中"></a>直到调用flush或者close方法文件，才会把缓冲区的内容真正写到硬盘中</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./2.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"> f.write(<span class="string">&quot;你好啊&quot;</span>)</span><br><span class="line"><span class="comment"># 你好啊</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="文件的追加"><a href="#文件的追加" class="headerlink" title="文件的追加"></a>文件的追加</h5><p>和文件的w操作类似，&#x3D;&#x3D;只不过如果文件存在的话会在后面追加内容，不会覆盖。&#x3D;&#x3D;</p><p><strong>直到调用flush或者close方法文件，才会把缓冲区的内容真正写到硬盘中</strong></p><p>&#x3D;&#x3D;如果要换行加\n&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#运行三次后</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./3.txt&quot;</span>,<span class="string">&quot;a&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;这是追加模式&quot;</span>)</span><br><span class="line"><span class="comment"># 这是追加模式这是追加模式这是追加模式</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h5 id="文件操作综合案例"><a href="#文件操作综合案例" class="headerlink" title="文件操作综合案例"></a>文件操作综合案例</h5><blockquote><h5 id="1读取文件并查单词个数"><a href="#1读取文件并查单词个数" class="headerlink" title="1读取文件并查单词个数"></a>1读取文件并查单词个数</h5></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count=<span class="number">0</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        k=line.strip()</span><br><span class="line">        w=k.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(w)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(k,end=&quot; &quot;)</span></span><br><span class="line">        <span class="comment"># print(w)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> w:</span><br><span class="line">            <span class="keyword">if</span> i==<span class="string">&quot;the&quot;</span>:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;the出现的次数是<span class="subst">&#123;count&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># print(f.readlines())</span></span><br><span class="line">    k=f.read()</span><br><span class="line"><span class="comment"># print(k)</span></span><br><span class="line">p=k.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="comment"># print(p)</span></span><br><span class="line"><span class="comment"># print(type(k))    </span></span><br><span class="line"><span class="built_in">print</span>(p.count(<span class="string">&quot;the&quot;</span>))</span><br></pre></td></tr></table></figure><blockquote><h5 id="2-读取文件，筛选部分写入文件"><a href="#2-读取文件，筛选部分写入文件" class="headerlink" title="2 读取文件，筛选部分写入文件"></a>2 读取文件，筛选部分写入文件</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./bill.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">  <span class="comment"># print(line)</span></span><br><span class="line">  line.strip()</span><br><span class="line">  <span class="comment"># print(line,end=&quot;&quot;)</span></span><br><span class="line">  <span class="keyword">if</span> <span class="string">&quot;测试&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> line:</span><br><span class="line">      g=<span class="built_in">open</span>(<span class="string">&quot;./bill副本.txt&quot;</span>,<span class="string">&quot;a&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">      g.write(<span class="string">f&quot;<span class="subst">&#123;line&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># name,date,money,type,remarks</span></span><br><span class="line"><span class="comment"># 周杰轮,2022-01-01,100000,消费,正式</span></span><br><span class="line"><span class="comment"># 周杰轮,2022-01-02,300000,收入,正式</span></span><br><span class="line"><span class="comment"># 林俊节,2022-01-01,300000,收入,正式</span></span><br><span class="line"><span class="comment"># 林俊节,2022-01-03,100000,消费,正式</span></span><br><span class="line"><span class="comment"># 林俊节,2022-01-05,500000,收入,正式</span></span><br><span class="line"><span class="comment"># 张学油,2022-01-01,100000,消费,正式</span></span><br><span class="line"><span class="comment"># 张学油,2022-01-02,500000,收入,正式</span></span><br><span class="line"><span class="comment"># 王力鸿,2022-01-01,500000,消费,正式</span></span><br><span class="line"><span class="comment"># 王力鸿,2022-01-03,950000,收入,正式</span></span><br><span class="line"><span class="comment"># 刘德滑,2022-01-02,100000,消费,正式</span></span><br><span class="line"><span class="comment"># 刘德滑,2022-01-03,300000,消费,正式</span></span><br></pre></td></tr></table></figure><h6 id="3删除目标数据，切片操作"><a href="#3删除目标数据，切片操作" class="headerlink" title="3删除目标数据，切片操作"></a>3删除目标数据，切片操作</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f=<span class="built_in">open</span>(<span class="string">&quot;E:\PYTHON\code\啊.tax&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">data=f.read()</span><br><span class="line">data=data.replace(<span class="string">&quot;删掉我，&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">data=data[:-<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="comment"># 删掉我，</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 大撒大撒</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># dsadasdasdasdasdasd)&#125;</span></span><br><span class="line"><span class="comment"># 大撒大撒</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># dsadasdasdasdasdasd</span></span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="异常BUG"><a href="#异常BUG" class="headerlink" title="异常BUG"></a>异常BUG</h3><h4 id="了解异常"><a href="#了解异常" class="headerlink" title="了解异常"></a>了解异常</h4><blockquote><h6 id="python解释器遇到一个错误，就会停止程序的执行，并演示一些错误信息。通过了解常见的异常类型，方便检查错误。"><a href="#python解释器遇到一个错误，就会停止程序的执行，并演示一些错误信息。通过了解常见的异常类型，方便检查错误。" class="headerlink" title="python解释器遇到一个错误，就会停止程序的执行，并演示一些错误信息。通过了解常见的异常类型，方便检查错误。"></a>python解释器遇到一个错误，就会停止程序的执行，并演示一些错误信息。通过了解常见的异常类型，方便检查错误。</h6></blockquote><h4 id="为什么要捕获异常"><a href="#为什么要捕获异常" class="headerlink" title="为什么要捕获异常"></a>为什么要捕获异常</h4><p><strong>当程序遇到了bug，有两种选择</strong>，后者才是想要的 </p><blockquote><ol><li><h6 id="整个程序直接停止运行"><a href="#整个程序直接停止运行" class="headerlink" title="整个程序直接停止运行"></a>整个程序直接停止运行</h6></li><li><h6 id="对bug进行提醒，整个程序继续运行"><a href="#对bug进行提醒，整个程序继续运行" class="headerlink" title="&#x3D;&#x3D;对bug进行提醒，整个程序继续运行&#x3D;&#x3D;"></a>&#x3D;&#x3D;对bug进行提醒，整个程序继续运行&#x3D;&#x3D;</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个数&quot;</span>))</span><br><span class="line">    result=<span class="number">8</span>/a</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> reason:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;出错了草&quot;</span>,<span class="built_in">str</span>(reason))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> reason:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未知错误%s&quot;</span>%<span class="built_in">str</span>(reason))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;哎嘿&quot;</span>)</span><br><span class="line"><span class="comment"># 请输入一个数0</span></span><br><span class="line"><span class="comment"># 未知错误division by zero</span></span><br><span class="line"><span class="comment"># 哎嘿</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a>常见的异常</h4><blockquote><ol><li>assertionError assert后面的条件为假的时候就会抛出异常</li><li>attributeError 尝试访问未知的对象属性</li><li>indexError 索引超出序列范围</li><li>keyError 字典中找一个不存在的关键字</li><li>osError 操作系统产生的异常</li><li>nameError 尝试访问一个不存在的变量</li><li>syntaxError python语法错误</li><li>typeError 不同类型之间的无效操作</li><li>zerodivisionError 除数为0的时候</li></ol></blockquote><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><h6 id="捕获指定的异常"><a href="#捕获指定的异常" class="headerlink" title="捕获指定的异常"></a><em><strong>捕获指定的异常</strong></em></h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">检测范围</span><br><span class="line">except Exception[as reason]</span><br><span class="line">出现异常后的处理代码</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./4.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> reason:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;出错了草&quot;</span>,<span class="built_in">str</span>(reason))</span><br><span class="line">    </span><br><span class="line"><span class="comment">#出错了草 [Errno 2] No such file or directory: &#x27;./4.txt&#x27;</span></span><br></pre></td></tr></table></figure><h6 id="捕获多种类型异常"><a href="#捕获多种类型异常" class="headerlink" title="捕获多种类型异常"></a>捕获多种类型异常</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">检测范围</span><br><span class="line">except Exception1[as reason]</span><br><span class="line">出现异常后的处理代码</span><br><span class="line">except Exception2[as reason]</span><br><span class="line">出现异常后的处理代码</span><br><span class="line">except Exception3[as reason]</span><br><span class="line">出现异常后的处理代码</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">except (NameError,zerodivisionerroe) as e:</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./4.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> reason:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;出错了草&quot;</span>,<span class="built_in">str</span>(reason))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#顶级的捕获方式-----1</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个数&quot;</span>))</span><br><span class="line">    result=<span class="number">8</span>/a</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;好像出错了啊&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;哎嘿&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#等价于------捕获全部的异常------2  顶级异常</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未知错误%s&quot;</span>%result)</span><br><span class="line"><span class="comment"># 请输入一个数0</span></span><br><span class="line"><span class="comment"># 好像出错了啊</span></span><br><span class="line"><span class="comment"># 哎嘿</span></span><br></pre></td></tr></table></figure><h4 id="配合else使用–-可选"><a href="#配合else使用–-可选" class="headerlink" title="配合else使用–(可选)"></a>配合else使用–(可选)</h4><p><strong>也就是没有异常就执行else后面的语句</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个数&quot;</span>))</span><br><span class="line">    result=<span class="number">8</span>/a</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;好像出错了啊&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;没有异常啊&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;哎嘿&quot;</span>)</span><br><span class="line"><span class="comment"># 请输入一个数9</span></span><br><span class="line"><span class="comment"># 0.8888888888888888</span></span><br><span class="line"><span class="comment"># 没有异常啊</span></span><br><span class="line"><span class="comment"># 哎嘿</span></span><br></pre></td></tr></table></figure><h4 id="异常的finally–-可选"><a href="#异常的finally–-可选" class="headerlink" title="异常的finally–(可选)"></a>异常的finally–(可选)</h4><p><strong>就是有没有异常，都要执行这句话了。</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个数&quot;</span>))</span><br><span class="line">    result=<span class="number">8</span>/a</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;好像出错了啊&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;没有异常啊&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无所谓，有没有异常我都要执行&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;哎嘿&quot;</span>)</span><br><span class="line"><span class="comment"># 请输入一个数0</span></span><br><span class="line"><span class="comment"># 好像出错了啊</span></span><br><span class="line"><span class="comment"># 无所谓，有没有异常我都要执行</span></span><br><span class="line"><span class="comment"># 哎嘿</span></span><br></pre></td></tr></table></figure><h4 id="异常的传递"><a href="#异常的传递" class="headerlink" title="异常的传递"></a>异常的传递</h4><p>一层一层的向上传递，如果最高层级调用了异常就抛出。</p><blockquote><h5 id="没有捕获的时候，从出现异常的位置开始往外冒"><a href="#没有捕获的时候，从出现异常的位置开始往外冒" class="headerlink" title="没有捕获的时候，从出现异常的位置开始往外冒"></a>没有捕获的时候，从出现异常的位置开始往外冒</h5></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func1开始&quot;</span>)</span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func1结束&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func2开始&quot;</span>)</span><br><span class="line">    func1()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func2结束&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">     func2()</span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># func2开始</span></span><br><span class="line"><span class="comment"># func1开始</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;e:\Bluecode\code\python\code\异常的传递.py&quot;, line 13, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#     func2()</span></span><br><span class="line"><span class="comment">#   File &quot;e:\Bluecode\code\python\code\异常的传递.py&quot;, line 7, in func2</span></span><br><span class="line"><span class="comment">#     func1()</span></span><br><span class="line"><span class="comment">#   File &quot;e:\Bluecode\code\python\code\异常的传递.py&quot;, line 3, in func1</span></span><br><span class="line"><span class="comment">#     1/0</span></span><br><span class="line"><span class="comment">#     ~^~</span></span><br><span class="line"><span class="comment"># ZeroDivisionError: division by zero</span></span><br></pre></td></tr></table></figure><blockquote><h5 id="当最高级有捕获的时候"><a href="#当最高级有捕获的时候" class="headerlink" title="当最高级有捕获的时候"></a>当最高级有捕获的时候</h5></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func1开始&quot;</span>)</span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func1结束&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func2开始&quot;</span>)</span><br><span class="line">    func1()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func2结束&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        func2()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> op:</span><br><span class="line">        <span class="built_in">print</span>(op)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># func2开始</span></span><br><span class="line"><span class="comment"># func1开始</span></span><br><span class="line"><span class="comment"># division by zero</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;在最顶级就可以捕获到低级出发生的异常&#x3D;&#x3D;</p><h3 id="Python模块和包"><a href="#Python模块和包" class="headerlink" title="Python模块和包"></a>Python模块和包</h3><h4 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h4><blockquote><h6 id="python文件"><a href="#python文件" class="headerlink" title="python文件"></a>python文件</h6><h6 id="提供的现成的变量，函数，来使用"><a href="#提供的现成的变量，函数，来使用" class="headerlink" title="提供的现成的变量，函数，来使用"></a>提供的现成的变量，函数，来使用</h6></blockquote><h4 id="如何导入模块"><a href="#如何导入模块" class="headerlink" title="如何导入模块"></a>如何导入模块</h4><p><em><strong>写在开头</strong></em></p><blockquote><ol><li><h6 id="from-模块名-import-模块-类-变量-函数-as-别名"><a href="#from-模块名-import-模块-类-变量-函数-as-别名" class="headerlink" title="[from 模块名]  import [模块 |类|变量|函数|*] [as 别名]"></a>[from 模块名]  import [模块 |类|变量|函数|*] [as 别名]</h6><hr><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法:"></a>基本语法:</h5><p>import 模块名</p><p>import 模块1，模块2</p><h5 id="用法-通过-就可以使用模块的全部功能了。确定层级关系"><a href="#用法-通过-就可以使用模块的全部功能了。确定层级关系" class="headerlink" title="用法,&#x3D;&#x3D;通过.&#x3D;&#x3D;就可以使用模块的全部功能了。确定层级关系"></a>用法,&#x3D;&#x3D;通过.&#x3D;&#x3D;就可以使用模块的全部功能了。确定层级关系</h5><p>模块.功能名()</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>)</span><br><span class="line"><span class="comment"># 开始</span></span><br><span class="line">10s后</span><br><span class="line"><span class="comment"># 结束</span></span><br></pre></td></tr></table></figure><h5 id="直接引入模块对应的功能-只需要模块的部分功能"><a href="#直接引入模块对应的功能-只需要模块的部分功能" class="headerlink" title="直接引入模块对应的功能,只需要模块的部分功能"></a>直接引入模块对应的功能,只需要模块的部分功能</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>)</span><br><span class="line"><span class="comment"># 开始</span></span><br><span class="line"><span class="comment"># 3s后</span></span><br><span class="line"><span class="comment"># 结束</span></span><br></pre></td></tr></table></figure><h6 id="引入模块全部的功能，直接使用"><a href="#引入模块全部的功能，直接使用" class="headerlink" title="引入模块全部的功能，直接使用"></a>引入模块全部的功能，直接使用</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>)</span><br><span class="line"><span class="comment"># 开始</span></span><br><span class="line"><span class="comment"># 3s后</span></span><br><span class="line"><span class="comment"># 结束</span></span><br></pre></td></tr></table></figure><h6 id="用别名来代替对应的功能-相当于改名，对于那些难听的，臭长臭长的功能"><a href="#用别名来代替对应的功能-相当于改名，对于那些难听的，臭长臭长的功能" class="headerlink" title="用别名来代替对应的功能,相当于改名，对于那些难听的，臭长臭长的功能"></a>用别名来代替对应的功能,相当于改名，对于那些难听的，臭长臭长的功能</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep <span class="keyword">as</span> op</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line">op(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>)</span><br><span class="line"><span class="comment"># 开始</span></span><br><span class="line"><span class="comment"># 3s后</span></span><br><span class="line"><span class="comment"># 结束</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time <span class="keyword">as</span> t</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line">t.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>)</span><br><span class="line"><span class="comment"># 开始</span></span><br><span class="line"><span class="comment"># 3s后</span></span><br><span class="line"><span class="comment"># 结束</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="自定义模块-main-all"><a href="#自定义模块-main-all" class="headerlink" title="自定义模块(__main__ __all__)"></a>自定义模块(__main__ __all__)</h4><blockquote><h5 id="import-自定义模块的python文件名字"><a href="#import-自定义模块的python文件名字" class="headerlink" title="import 自定义模块的python文件名字"></a>import 自定义模块的python文件名字</h5><hr><h5 id="自定义模块-mymodul"><a href="#自定义模块-mymodul" class="headerlink" title="自定义模块 mymodul"></a>自定义模块 mymodul</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line"> <span class="keyword">return</span> x+y</span><br></pre></td></tr></table></figure><h5 id="导入自定义模块"><a href="#导入自定义模块" class="headerlink" title="导入自定义模块"></a>导入自定义模块</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mymolul <span class="keyword">as</span> a</span><br><span class="line"><span class="built_in">print</span>(a.add(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment">#4</span></span><br></pre></td></tr></table></figure><hr><h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><h5 id="自定义模块mymodul1"><a href="#自定义模块mymodul1" class="headerlink" title="自定义模块mymodul1"></a>自定义模块mymodul1</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line"> <span class="keyword">return</span> x-y</span><br></pre></td></tr></table></figure><h5 id="引用两个具有相同名字但不同功能的模块"><a href="#引用两个具有相同名字但不同功能的模块" class="headerlink" title="引用两个具有相同名字但不同功能的模块"></a>引用两个具有相同名字但不同功能的模块</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mymolul <span class="keyword">import</span> add</span><br><span class="line"><span class="keyword">from</span> mymolul1 <span class="keyword">import</span> add</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># -2</span></span><br></pre></td></tr></table></figure><h5 id="后者会覆盖前者"><a href="#后者会覆盖前者" class="headerlink" title="后者会覆盖前者"></a>后者会覆盖前者</h5><hr><h5 id="自定义模块-main"><a href="#自定义模块-main" class="headerlink" title="自定义模块(__main__)"></a>自定义模块(__main__)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line"> <span class="built_in">print</span>(x-y)</span><br><span class="line"> <span class="keyword">return</span> x-y</span><br><span class="line">add(<span class="number">1</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h5 id="导入自定义模块-但没有任何操作"><a href="#导入自定义模块-但没有任何操作" class="headerlink" title="导入自定义模块 但没有任何操作"></a>导入自定义模块 但没有任何操作</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mymolul1 <span class="keyword">import</span> add</span><br><span class="line"><span class="comment">#-4</span></span><br></pre></td></tr></table></figure><p>from 模块的时候就直接把模块给执行了</p><h6 id="在模块中用-main-实现在模块中可以测试，import引入模块的时候不立刻执行测试的语句"><a href="#在模块中用-main-实现在模块中可以测试，import引入模块的时候不立刻执行测试的语句" class="headerlink" title="在模块中用__main__实现在模块中可以测试，import引入模块的时候不立刻执行测试的语句"></a>在模块中用__main__实现在模块中可以测试，import引入模块的时候不立刻执行测试的语句</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line"> <span class="built_in">print</span>(x-y)</span><br><span class="line"> <span class="keyword">return</span> x-y</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"> add(<span class="number">1</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h6 id="就实现导入模块的时候不执行模块的测试语句"><a href="#就实现导入模块的时候不执行模块的测试语句" class="headerlink" title="就实现导入模块的时候不执行模块的测试语句"></a>就实现导入模块的时候不执行模块的测试语句</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mymolul1 <span class="keyword">import</span> add</span><br></pre></td></tr></table></figure><hr><p>自定义模块的__all__</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line"> <span class="built_in">print</span>(x-y)</span><br><span class="line"> <span class="keyword">return</span> x-y</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add1</span>(<span class="params">x,y</span>):</span><br><span class="line"> <span class="built_in">print</span>(x+y)</span><br><span class="line"> <span class="keyword">return</span> x-y</span><br><span class="line">__all__=[<span class="string">&#x27;add&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mymolul1 <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(add1(<span class="number">1</span>,<span class="number">2</span>)) add1为被定义。手动导入是可以的，仅限制导入*的时候</span><br></pre></td></tr></table></figure><h6 id="这样导入模块的时候尽管使用from-模块名-import-也只能限制all里面的可使用功能"><a href="#这样导入模块的时候尽管使用from-模块名-import-也只能限制all里面的可使用功能" class="headerlink" title="这样导入模块的时候尽管使用from 模块名 import *也只能限制all里面的可使用功能"></a>这样导入模块的时候尽管使用from 模块名 import *也只能限制all里面的可使用功能</h6></blockquote><hr><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><blockquote><h5 id="1-如何自定义模块并导入"><a href="#1-如何自定义模块并导入" class="headerlink" title="1.如何自定义模块并导入?"></a>1.如何自定义模块并导入?</h5><p>在Python代码文件中正常写代码即可,通过import、from关键字和导<br>入Python内置模块一样导入即可使用。</p><ol start="2"><li>main_ 变量的功能是?<br>if__ main__ &#x3D;&#x3D; “_ __main____“</li></ol><p> &#x3D;&#x3D;测试语句里面的相对路径是对包的文件夹而言的不是模块文件&#x3D;&#x3D;</p><h6 id="4-txt是在包的外面的文件"><a href="#4-txt是在包的外面的文件" class="headerlink" title="4.txt是在包的外面的文件"></a>4.txt是在包的外面的文件</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">append_to_file</span>(<span class="params">file_name,data</span>):</span><br><span class="line">    p=<span class="built_in">open</span>(file_name,<span class="string">&quot;a&quot;</span>,encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">    p.write(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    append_to_file(<span class="string">&quot;./4.txt&quot;</span>,<span class="string">&quot;卧槽&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="表示，只有当程序是直接执行的才会进入"><a href="#表示，只有当程序是直接执行的才会进入" class="headerlink" title="表示，只有当程序是直接执行的才会进入"></a>表示，只有当程序是直接执行的才会进入</h6><h6 id="if内部，如果是被导入的，则if无法进入"><a href="#if内部，如果是被导入的，则if无法进入" class="headerlink" title="&#x3D;&#x3D;if内部，如果是被导入的，则if无法进入&#x3D;&#x3D;"></a>&#x3D;&#x3D;if内部，如果是被导入的，则if无法进入&#x3D;&#x3D;</h6><ol start="3"><li>注意事项<br>●<br>不同模块，同名的功能，如果都被导入，那么后导入的会覆盖先导<br>入的<br>●<br><em>all</em> 变量可以控制import *的时候哪些功能可以被导入</li></ol></blockquote><h4 id="自定义Python包"><a href="#自定义Python包" class="headerlink" title="自定义Python包"></a>自定义Python包</h4><blockquote><p>如果导入的模块太多，就需要一个包来管理大部分模块。相当于一个文件夹，文件夹里面一大堆模块.py</p><p>还有一个额外的 __init__.py</p><h5 id="和普通的文件夹区分主要是看有无-init-py文件"><a href="#和普通的文件夹区分主要是看有无-init-py文件" class="headerlink" title="&#x3D;&#x3D;和普通的文件夹区分主要是看有无 __init__.py文件&#x3D;&#x3D;"></a>&#x3D;&#x3D;和普通的文件夹区分主要是看有无 __init__.py文件&#x3D;&#x3D;</h5></blockquote><h5 id="自定义包"><a href="#自定义包" class="headerlink" title="自定义包"></a>自定义包</h5><h5 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h5><blockquote><p>import 包名.模块名字<br>使用相关的功能<br>包.模块.功能</p><p>导入包里的具体模块，导入具体模块的时候，用对应功能的时候，模块名字.功能</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mypython包.mk</span><br><span class="line"><span class="built_in">print</span>(mypython包.mk.add(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment">#4</span></span><br></pre></td></tr></table></figure><p>导入包里的具体模块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mypython包 <span class="keyword">import</span> mk</span><br><span class="line"><span class="built_in">print</span>(mk.add(<span class="number">2</span>,<span class="number">5</span>))</span><br><span class="line"><span class="comment">#7</span></span><br></pre></td></tr></table></figure><p>导入具体包模块的功能</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mypython包.mk <span class="keyword">import</span> add <span class="keyword">as</span> a</span><br><span class="line"><span class="built_in">print</span>(a(<span class="number">1</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>__all__写在init文件里可以控制*导入的范围</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from mypython包 import *</span><br><span class="line">把包里所有模块都导入了，直接用模块的名和对应的功能</span><br><span class="line">mk1不存在</span><br></pre></td></tr></table></figure><hr><blockquote><p>1.什么是Python的包?<br>包就是一个文件夹，里面可以存放许多Python的模块(代码文件)，通<br>过包，在逻辑上将一批模块归为一类，方便使用。</p><ol start="2"><li>_ init_ .py文件的作用 ?<br>创建包会默认自动创建的文件，通过这个文件来表示一-个文件夹是;<br>Python的包，而非普通的文件夹。</li><li>__all__ 变量的作用?<br>同模块中学习到的是一个作用，控制import *能够导入的内容</li></ol></blockquote></blockquote><h4 id="第三方包"><a href="#第三方包" class="headerlink" title="第三方包"></a>第三方包</h4><p><strong>安装第三方python包</strong></p><p><strong>一个包就是一堆同类型功能的集合体</strong></p><h6 id="如何安装第三方包"><a href="#如何安装第三方包" class="headerlink" title="如何安装第三方包"></a>如何安装第三方包</h6><blockquote><h6 id="利用python内置的pipi程序"><a href="#利用python内置的pipi程序" class="headerlink" title="利用python内置的pipi程序"></a>利用python内置的pipi程序</h6><h6 id="win-r-cmd-输入命令"><a href="#win-r-cmd-输入命令" class="headerlink" title="win+r cmd 输入命令"></a>win+r cmd 输入命令</h6><h6 id="pip-install-第三方包名-国外"><a href="#pip-install-第三方包名-国外" class="headerlink" title="pip install 第三方包名 国外"></a>pip install 第三方包名 国外</h6><h6 id="pip-install-i-https-pypi-tuna-tsinghua-edu-cn-simple-包名-国内"><a href="#pip-install-i-https-pypi-tuna-tsinghua-edu-cn-simple-包名-国内" class="headerlink" title="pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 包名  国内"></a>pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> 包名  国内</h6><h5 id="在pychrm里去解释器的设置安装"><a href="#在pychrm里去解释器的设置安装" class="headerlink" title="在pychrm里去解释器的设置安装"></a>在pychrm里去解释器的设置安装</h5></blockquote><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="json文件"><a href="#json文件" class="headerlink" title="json文件"></a>json<strong>文件</strong></h5><blockquote><h6 id="轻量级的数据交互格式"><a href="#轻量级的数据交互格式" class="headerlink" title="轻量级的数据交互格式"></a>轻量级的数据交互格式</h6><h6 id="相当于字符串"><a href="#相当于字符串" class="headerlink" title="&#x3D;&#x3D;相当于字符串&#x3D;&#x3D;"></a>&#x3D;&#x3D;相当于字符串&#x3D;&#x3D;</h6><h6 id="带有特定格式的字符串"><a href="#带有特定格式的字符串" class="headerlink" title="带有特定格式的字符串"></a>带有特定格式的字符串</h6><h6 id="按照json指定的格式去组织和封装数据"><a href="#按照json指定的格式去组织和封装数据" class="headerlink" title="按照json指定的格式去组织和封装数据"></a>按照json指定的格式去组织和封装数据</h6><h6 id="json相当于国际语言，在各个编程语言中流通的数据格式，负责不同编程语言中的数据传递和交互"><a href="#json相当于国际语言，在各个编程语言中流通的数据格式，负责不同编程语言中的数据传递和交互" class="headerlink" title="json相当于国际语言，在各个编程语言中流通的数据格式，负责不同编程语言中的数据传递和交互"></a>json相当于国际语言，在各个编程语言中流通的数据格式，负责不同编程语言中的数据传递和交互</h6><h6 id="普通话，英语"><a href="#普通话，英语" class="headerlink" title="普通话，英语"></a>普通话，英语</h6><hr><p>python格式数据——json格式数据—–C语言接受json格式数据并转换为python格式数据继续使用</p><ul><li><code>json.loads()</code>: 该方法用于将JSON格式的字符串转换为Python对象。它接受一个JSON字符串作为参数，并返回一个对应的Python对象。</li><li><code>json.dumps()</code>: 该方法用于将Python对象&#x3D;&#x3D;转换为JSON格式的字符串&#x3D;&#x3D;。它接受一个Python对象作为参数，并返回一个对应的JSON字符串。</li></ul><h6 id="json格式数据化-、、、字典"><a href="#json格式数据化-、、、字典" class="headerlink" title="json格式数据化 、、、字典"></a>json格式数据化 、、、字典</h6><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">data = &#x27;<span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span><span class="punctuation">,</span> <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;New York&quot;</span><span class="punctuation">&#125;</span>&#x27;</span><br><span class="line">obj = json.loads(data)</span><br><span class="line"></span><br><span class="line">print(obj)  # 输出：<span class="punctuation">&#123;</span>&#x27;name&#x27;<span class="punctuation">:</span> &#x27;John&#x27;<span class="punctuation">,</span> &#x27;age&#x27;<span class="punctuation">:</span> <span class="number">30</span><span class="punctuation">,</span> &#x27;city&#x27;<span class="punctuation">:</span> &#x27;New York&#x27;<span class="punctuation">&#125;</span></span><br><span class="line">print(type(obj))  # 输出：dict</span><br></pre></td></tr></table></figure><p>python-&gt;json</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">obj = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">30</span>, <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;New York&#x27;</span>&#125;</span><br><span class="line">data = json.dumps(obj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data)  <span class="comment"># 输出：&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(data))  <span class="comment"># 输出：str</span></span><br></pre></td></tr></table></figure><p><code>json.dumps()</code>方法默认使用ASCII编码来生成JSON字符串，如果需要使用其他编码，可以通过<code>ensure_ascii</code>参数进行设置。此外，还可以通过<code>indent</code>参数设置缩进空格数，以使生成的JSON字符串更易读。</p></blockquote><p><code>json.dump()</code>和<code>json.dumps()</code>都是Python中用于将数据对象转换为JSON格式的方法，但它们之间有一些区别。</p><ul><li><p><code>json.dump()</code>: 这个方法用于将数据对象转换为JSON格式，并将其写入文件对象中。它接受两个参数：第一个参数是要转换为JSON的数据对象，第二个参数是要写入的文件对象。示例代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>&#125;</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    json.dump(data, file)</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>data</code>是一个字典对象，我们使用<code>json.dump()</code>方法将其转换为JSON格式，并将结果写入名为”data.json”的文件中。</p></li><li><p><code>json.dumps()</code>: 这个方法用于将数据对象转换为JSON格式，并返回一个字符串。它只接受一个参数，即要转换为JSON的数据对象。示例代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>&#125;</span><br><span class="line">json_str = json.dumps(data)</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>data</code>是一个字典对象，我们使用<code>json.dumps()</code>方法将其转换为JSON格式，并将结果赋值给<code>json_str</code>变量。</p></li></ul><p>总结来说，<code>json.dump()</code>用于将数据对象转换为JSON格式，并将其写入文件对象中，而<code>json.dumps()</code>用于将数据对象转换为JSON格式，并返回一个字符串。你可以根据具体的需求选择使用哪个方法。</p><hr><h5 id="python内置的json模块，数据相互转换"><a href="#python内置的json模块，数据相互转换" class="headerlink" title="python内置的json模块，数据相互转换"></a>python内置的json模块，数据相互转换</h5><h6 id="把json的数据转为python的形式，不一定是json文件"><a href="#把json的数据转为python的形式，不一定是json文件" class="headerlink" title="&#x3D;&#x3D;把json的数据转为python的形式，不一定是json文件&#x3D;&#x3D;"></a>&#x3D;&#x3D;把json的数据转为python的形式，不一定是json文件&#x3D;&#x3D;</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">data=&#123;<span class="string">&quot;key1&quot;</span>:<span class="number">2</span>,<span class="string">&quot;key2&quot;</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;python数据转为json&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(json.dumps(data))</span><br><span class="line">data=json.dumps(data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;json数据转为python&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(json.loads(data))</span><br><span class="line"><span class="comment"># python数据转为json</span></span><br><span class="line"><span class="comment"># &#123;&quot;key1&quot;: 2, &quot;key2&quot;: 2&#125;</span></span><br><span class="line"><span class="comment"># json数据转为python</span></span><br><span class="line"><span class="comment"># &#123;&#x27;key1&#x27;: 2, &#x27;key2&#x27;: 2&#125;</span></span><br><span class="line"></span><br><span class="line">data1=[&#123;<span class="string">&quot;key1&quot;</span>:<span class="number">2</span>,<span class="string">&quot;key2&quot;</span>:<span class="number">2</span>&#125;,&#123;<span class="string">&quot;key11&quot;</span>:<span class="number">2</span>,<span class="string">&quot;key2&quot;</span>:<span class="number">2</span>&#125;,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;王大锤&quot;</span>,<span class="string">&quot;key22&quot;</span>:<span class="number">2</span>&#125;]</span><br><span class="line">data1_json=json.dumps(data1,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(data1_json))</span><br><span class="line"><span class="built_in">print</span>(data1_json)</span><br><span class="line"><span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="comment"># [&#123;&quot;key1&quot;: 2, &quot;key2&quot;: 2&#125;, &#123;&quot;key11&quot;: 2, &quot;key2&quot;: 2&#125;, &#123;&quot;name&quot;: &quot;\u738b\u5927\u9524&quot;, &quot;key22&quot;: 2&#125;]</span></span><br><span class="line"><span class="comment"># 不用ancii码转换，原样输出</span></span><br><span class="line"><span class="comment"># [&#123;&quot;key1&quot;: 2, &quot;key2&quot;: 2&#125;, &#123;&quot;key11&quot;: 2, &quot;key2&quot;: 2&#125;, &#123;&quot;name&quot;: &quot;王大锤&quot;, &quot;key22&quot;: 2&#125;]</span></span><br></pre></td></tr></table></figure><blockquote><p>1.json: 是一种轻量级的数据交互格式,采用完全独立于编程语言的文本<br>格式来存储和表示数据( 就是字符串)<br>Python语言使用JSON有很大优势，因为: JSON无非就是-个单独的字典或-个内部元素都<br>是字典的列表<br>所以JSON可以直接和Python的字典或列表进行无缝转换。</p><ol start="2"><li>json格式数据转化</li></ol><h5 id="通过json-dumps-data-方法把python数据转化为了json数-据data-json-dumps-data"><a href="#通过json-dumps-data-方法把python数据转化为了json数-据data-json-dumps-data" class="headerlink" title="通过json. dumps (data)方法把python数据转化为了json数 据data &#x3D; json. dumps (data)"></a>通过json. dumps (data)方法把python数据转化为了json数 据data &#x3D; json. dumps (data)</h5><p>  如果有中文可以带上: ensure_ _ascii&#x3D;Fal se参数来确保中<br>  文正常转换.</p><h5 id="通过json-loads-data-方法把josn数据转化为了python列表或字典"><a href="#通过json-loads-data-方法把josn数据转化为了python列表或字典" class="headerlink" title="通过json. loads (data)方法把josn数据转化为了python列表或字典."></a>通过json. loads (data)方法把josn数据转化为了python列表或字典.</h5><p>data &#x3D; json. loads (data) </p></blockquote><h5 id="pyecharts模块—-利用鼠标放上去的提示写"><a href="#pyecharts模块—-利用鼠标放上去的提示写" class="headerlink" title="pyecharts模块—-利用鼠标放上去的提示写"></a>pyecharts模块—-利用鼠标放上去的提示写</h5><p>&#x3D;&#x3D;<em><strong>bar.reversal_axis()</strong></em>&#x3D;&#x3D;</p><h5 id="1折线图2基础可视化地图map"><a href="#1折线图2基础可视化地图map" class="headerlink" title="1折线图2基础可视化地图map"></a>1折线图2基础可视化地图map</h5><blockquote><ol><li><h5 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Line</span><br><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./数据/日本.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    data=file.read().replace(<span class="string">&quot;jsonp_1629350871167_29498(&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    data=data[:-<span class="number">2</span>]</span><br><span class="line">    <span class="comment"># print(data)</span></span><br><span class="line">    data=json.loads(data)</span><br><span class="line">    <span class="comment"># print(data)</span></span><br><span class="line">    data=data[<span class="string">&quot;data&quot;</span>][<span class="number">0</span>][<span class="string">&quot;trend&quot;</span>]</span><br><span class="line">    xdata=data[<span class="string">&quot;updateDate&quot;</span>][:<span class="number">315</span>]</span><br><span class="line">    ydata=data[<span class="string">&quot;list&quot;</span>][<span class="number">0</span>][<span class="string">&quot;data&quot;</span>][:<span class="number">315</span>]</span><br><span class="line">    <span class="comment"># print(xdata)</span></span><br><span class="line">    <span class="comment"># print(ydata)</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./数据/美国.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data=f.read()</span><br><span class="line">    data=data.replace(<span class="string">&quot;jsonp_1629344292311_69436(&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    data=data[:-<span class="number">2</span>]</span><br></pre></td></tr></table></figure><pre><code>pydata=json.loads(data)# x轴数据timedata=pydata[&quot;data&quot;][0][&quot;trend&quot;][&quot;updateDate&quot;][:314]# print(timedata)# y轴数据listdata=pydata[&quot;data&quot;][0][&quot;trend&quot;][&quot;list&quot;][0][&quot;data&quot;][:314]line=Line()     line.add_xaxis(xdata)     line.add_yaxis(&quot;日本疫情数据&quot;,ydata,label_opts=LabelOpts(is_show=False))line.add_yaxis(&quot;美国疫情数据&quot;,listdata,label_opts=LabelOpts(is_show=False))line.set_global_opts(    toolbox_opts=ToolboxOpts(is_show=True),    tooltip_opts=TooltipOpts(is_show=True),    legend_opts=LegendOpts(is_show=True),    visualmap_opts=VisualMapOpts(is_show=True),    title_opts=TitleOpts(title=&quot;疫情数据&quot;,pos_left=&quot;center&quot;,pos_top=&quot;5%&quot;),    datazoom_opts=DataZoomOpts(is_show=True)     )     line.render(&quot;./两国数据.html&quot;)</code></pre><ol start="2"><li><h5 id="基础可视化地图"><a href="#基础可视化地图" class="headerlink" title="基础可视化地图"></a><strong>基础可视化地图</strong></h5></li></ol></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Map</span><br><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./数据/疫情.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    data=file.read()</span><br><span class="line">    data=json.loads(data)</span><br><span class="line"></span><br><span class="line">    fordata=data[<span class="string">&quot;areaTree&quot;</span>][<span class="number">0</span>][<span class="string">&quot;children&quot;</span>]</span><br><span class="line">    <span class="comment"># print(fordata)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    listdata=[]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> fordata:</span><br><span class="line">        <span class="comment"># print(k)</span></span><br><span class="line">        address=k[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">        peoples=k[<span class="string">&quot;total&quot;</span>][<span class="string">&quot;confirm&quot;</span>]</span><br><span class="line">        <span class="comment"># print(address,peoples)</span></span><br><span class="line">        listdata.append((address,peoples))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(listdata),listdata)</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>=Map()</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.add(<span class="string">&quot;各省疫情总览&quot;</span>,listdata,<span class="string">&quot;china&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.set_global_opts(</span><br><span class="line">    visualmap_opts=VisualMapOpts(</span><br><span class="line">        is_show=<span class="literal">True</span>,</span><br><span class="line">        is_piecewise=<span class="literal">True</span>,</span><br><span class="line">        pieces=[</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>:<span class="number">1</span>,<span class="string">&quot;max&quot;</span>:<span class="number">1000</span>,<span class="string">&quot;color&quot;</span>:<span class="string">&quot;#87ceeb&quot;</span>,<span class="string">&quot;label&quot;</span>:<span class="string">&quot;1-1000人&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>:<span class="number">10</span>,<span class="string">&quot;max&quot;</span>:<span class="number">20</span>,<span class="string">&quot;color&quot;</span>:<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;label&quot;</span>:<span class="string">&quot;10-20人&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>:<span class="number">20</span>,<span class="string">&quot;max&quot;</span>:<span class="number">100</span>,<span class="string">&quot;color&quot;</span>:<span class="string">&quot;yellow&quot;</span>,<span class="string">&quot;label&quot;</span>:<span class="string">&quot;20-100人&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>:<span class="number">2000</span>,<span class="string">&quot;max&quot;</span>:<span class="number">3000</span>,<span class="string">&quot;color&quot;</span>:<span class="string">&quot;red&quot;</span>,<span class="string">&quot;label&quot;</span>:<span class="string">&quot;2000-3000人&quot;</span>&#125;,</span><br><span class="line">        ]</span><br><span class="line">    ),</span><br><span class="line">    title_opts=TitleOpts(title=<span class="string">&quot;全国疫情&quot;</span>)</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.render(<span class="string">&quot;./疫情大地图.html&quot;</span>)</span><br></pre></td></tr></table></figure></blockquote><hr><h5 id="柱状图，时间柱状图-动态柱状图"><a href="#柱状图，时间柱状图-动态柱状图" class="headerlink" title="柱状图，时间柱状图,动态柱状图"></a>柱状图，时间柱状图,动态柱状图</h5><p><strong>基础柱状图—————————————————————————————————————————————————————-</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bar.add_yaxis(<span class="string">&quot;gdp&quot;</span>,[<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>],label_opts=LabelOpts(position=<span class="string">&quot;right&quot;</span>))</span><br></pre></td></tr></table></figure><p><em><strong>实现数值标签的位置</strong></em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Bar</span><br><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bar=Bar()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bar.add_yaxis(<span class="string">&quot;gdp&quot;</span>,[<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>])</span><br><span class="line">bar.add_xaxis([<span class="string">&quot;中国&quot;</span>,<span class="string">&quot;美国&quot;</span>,<span class="string">&quot;日本&quot;</span>])</span><br><span class="line">bar.set_global_opts(</span><br><span class="line">    legend_opts=LegendOpts(is_show=<span class="literal">True</span>),</span><br><span class="line">    toolbox_opts=ToolboxOpts(is_show=<span class="literal">True</span>),</span><br><span class="line">    tooltip_opts=TooltipOpts(is_show=<span class="literal">True</span>),</span><br><span class="line">    visualmap_opts=VisualMapOpts(is_show=<span class="literal">True</span>),</span><br><span class="line">    datazoom_opts=DataZoomOpts(is_show=<span class="literal">True</span>)</span><br><span class="line">)</span><br><span class="line">bar.reversal_axis() </span><br><span class="line">bar.render(<span class="string">&quot;./基础柱状图.html&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><h5 id="1-通过Bar-构建一个柱状图对象"><a href="#1-通过Bar-构建一个柱状图对象" class="headerlink" title="1.通过Bar()构建一个柱状图对象"></a>1.通过Bar()构建一个柱状图对象</h5><h5 id="2-和折线图一样，通过add-xaxis-和add-yaxis-添加"><a href="#2-和折线图一样，通过add-xaxis-和add-yaxis-添加" class="headerlink" title="2.和折线图一样，通过add xaxis()和add_yaxis()添加"></a>2.和折线图一样，通过add xaxis()和add_yaxis()添加</h5><h5 id="x和y轴数据"><a href="#x和y轴数据" class="headerlink" title="x和y轴数据"></a>x和y轴数据</h5><h5 id="3-通过柱状图对象的-reversal-axis-，反转x和y轴"><a href="#3-通过柱状图对象的-reversal-axis-，反转x和y轴" class="headerlink" title="3.通过柱状图对象的:reversal axis()，反转x和y轴"></a>3.通过柱状图对象的:reversal axis()，反转x和y轴</h5><h5 id="4-通过label-opts-LabelOpts-position-”right”-设置"><a href="#4-通过label-opts-LabelOpts-position-”right”-设置" class="headerlink" title="4.通过label opts&#x3D;LabelOpts(position&#x3D;”right”)设置"></a>4.通过label opts&#x3D;LabelOpts(position&#x3D;”right”)设置</h5><h5 id="数值标签在右侧显示"><a href="#数值标签在右侧显示" class="headerlink" title="数值标签在右侧显示"></a>数值标签在右侧显示</h5></blockquote><hr><p><strong>时间柱状图——————————————————————————————————————————————————————</strong></p><p><strong>在有多个柱状图bar对象的前提下，创建一个时间线timeline对象，然后给时间线对象的add方法添加多个bar对象和标题</strong></p><p><strong>from</strong> pyecharts.charts <strong>import</strong> Timeline</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Bar</span><br><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Timeline</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bar=Bar()</span><br><span class="line">bar1=Bar()</span><br><span class="line">bar2=Bar()</span><br><span class="line">bar3=Bar()</span><br><span class="line">bar4=Bar()</span><br><span class="line">bar5=Bar()</span><br><span class="line">bar6=Bar()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bar.add_yaxis(<span class="string">&quot;gdp&quot;</span>,[<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>],label_opts=LabelOpts(position=<span class="string">&quot;right&quot;</span>))</span><br><span class="line">bar.add_xaxis([<span class="string">&quot;中国&quot;</span>,<span class="string">&quot;美国&quot;</span>,<span class="string">&quot;日本&quot;</span>])</span><br><span class="line"></span><br><span class="line">bar1.add_yaxis(<span class="string">&quot;gdp&quot;</span>,[<span class="number">35</span>,<span class="number">45</span>,<span class="number">45</span>],label_opts=LabelOpts(position=<span class="string">&quot;right&quot;</span>))</span><br><span class="line">bar1.add_xaxis([<span class="string">&quot;中国&quot;</span>,<span class="string">&quot;美国&quot;</span>,<span class="string">&quot;日本&quot;</span>])</span><br><span class="line"></span><br><span class="line">bar2.add_yaxis(<span class="string">&quot;gdp&quot;</span>,[<span class="number">40</span>,<span class="number">60</span>,<span class="number">40</span>],label_opts=LabelOpts(position=<span class="string">&quot;right&quot;</span>))</span><br><span class="line">bar2.add_xaxis([<span class="string">&quot;中国&quot;</span>,<span class="string">&quot;美国&quot;</span>,<span class="string">&quot;日本&quot;</span>])</span><br><span class="line"></span><br><span class="line">bar3.add_yaxis(<span class="string">&quot;gdp&quot;</span>,[<span class="number">45</span>,<span class="number">30</span>,<span class="number">50</span>],label_opts=LabelOpts(position=<span class="string">&quot;right&quot;</span>,font_size=<span class="string">&quot;30px&quot;</span>))</span><br><span class="line">bar3.add_xaxis([<span class="string">&quot;中国&quot;</span>,<span class="string">&quot;美国&quot;</span>,<span class="string">&quot;日本&quot;</span>])</span><br><span class="line"></span><br><span class="line">bar4.add_yaxis(<span class="string">&quot;gdp&quot;</span>,[<span class="number">205</span>,<span class="number">30</span>,<span class="number">50</span>],label_opts=LabelOpts(position=<span class="string">&quot;right&quot;</span>,font_size=<span class="string">&quot;30px&quot;</span>))</span><br><span class="line">bar4.add_xaxis([<span class="string">&quot;中国&quot;</span>,<span class="string">&quot;美国&quot;</span>,<span class="string">&quot;日本&quot;</span>])</span><br><span class="line"></span><br><span class="line">bar5.add_yaxis(<span class="string">&quot;gdp&quot;</span>,[<span class="number">100</span>,<span class="number">30</span>,<span class="number">50</span>],label_opts=LabelOpts(position=<span class="string">&quot;right&quot;</span>,font_size=<span class="string">&quot;30px&quot;</span>))</span><br><span class="line">bar5.add_xaxis([<span class="string">&quot;中国&quot;</span>,<span class="string">&quot;美国&quot;</span>,<span class="string">&quot;日本&quot;</span>])</span><br><span class="line"></span><br><span class="line">bar6.add_yaxis(<span class="string">&quot;gdp&quot;</span>,[<span class="number">205</span>,<span class="number">30</span>,<span class="number">50</span>],label_opts=LabelOpts(position=<span class="string">&quot;right&quot;</span>,font_size=<span class="string">&quot;30px&quot;</span>))</span><br><span class="line">bar6.add_xaxis([<span class="string">&quot;中国&quot;</span>,<span class="string">&quot;美国&quot;</span>,<span class="string">&quot;日本&quot;</span>])</span><br><span class="line"></span><br><span class="line">bar.set_global_opts(</span><br><span class="line">    title_opts=TitleOpts(title=<span class="string">&quot;时间线柱状图666666&quot;</span> ),</span><br><span class="line">    legend_opts=LegendOpts(is_show=<span class="literal">True</span>),</span><br><span class="line">    toolbox_opts=ToolboxOpts(is_show=<span class="literal">True</span>),</span><br><span class="line">    tooltip_opts=TooltipOpts(is_show=<span class="literal">True</span>),</span><br><span class="line">    visualmap_opts=VisualMapOpts(is_show=<span class="literal">True</span>),</span><br><span class="line">    datazoom_opts=DataZoomOpts(is_show=<span class="literal">True</span>,pos_top=<span class="string">&quot;20px&quot;</span>)</span><br><span class="line">)</span><br><span class="line">time=Timeline()</span><br><span class="line"></span><br><span class="line">time.add(bar,<span class="string">&quot;2001&quot;</span>)</span><br><span class="line">time.add(bar1,<span class="string">&quot;2002&quot;</span>)</span><br><span class="line">time.add(bar2,<span class="string">&quot;2003&quot;</span>)</span><br><span class="line">time.add(bar3,<span class="string">&quot;2004&quot;</span>)</span><br><span class="line">time.add(bar4,<span class="string">&quot;2010&quot;</span>)</span><br><span class="line">time.add(bar5,<span class="string">&quot;2024&quot;</span>)</span><br><span class="line">time.add(bar6,<span class="string">&quot;2034&quot;</span>)</span><br><span class="line"></span><br><span class="line">time.add_schema(</span><br><span class="line">    play_interval=<span class="number">700</span>,</span><br><span class="line">    is_auto_play=<span class="literal">True</span>,</span><br><span class="line">    is_loop_play=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># bar.reversal_axis()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">time.render(<span class="string">&quot;./时间线柱状图.html&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>&#x3D;&#x3D;控制时间线的属性&#x3D;&#x3D;</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time.add_schema(</span><br><span class="line">    play_interval=<span class="number">700</span>,</span><br><span class="line">    is_auto_play=<span class="literal">True</span>,</span><br><span class="line">    is_loop_play=<span class="literal">True</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h6 id="主题类型模块"><a href="#主题类型模块" class="headerlink" title="&#x3D;&#x3D;主题类型模块&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;主题类型模块&#x3D;&#x3D;</strong></h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.<span class="built_in">globals</span> <span class="keyword">import</span> ThemeType</span><br><span class="line">time=Timeline(</span><br><span class="line">    &#123;<span class="string">&quot;theme&quot;</span>:ThemeType.BUILTIN_THEMES&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="综合案例-2"><a href="#综合案例-2" class="headerlink" title="综合案例"></a>综合案例</h5><p><em><strong>循环中每创建一个bar就add到时间线里面，是不会有问题的</strong></em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Timeline</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Bar</span><br><span class="line"><span class="keyword">from</span> pyecharts.<span class="built_in">globals</span> <span class="keyword">import</span> ThemeType</span><br><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./数据/1960-2019全球GDP数据.csv&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;GB2312&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    data=file.readlines()</span><br><span class="line">    data.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># print(data)</span></span><br><span class="line"></span><br><span class="line">zd=&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">    <span class="comment"># print(line)</span></span><br><span class="line">    <span class="built_in">list</span>=line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    <span class="comment"># print(list)</span></span><br><span class="line">    year=<span class="built_in">int</span>(<span class="built_in">list</span>[<span class="number">0</span>])</span><br><span class="line">    country=<span class="built_in">list</span>[<span class="number">1</span>]</span><br><span class="line">    gdp=<span class="built_in">float</span>(<span class="built_in">list</span>[<span class="number">2</span>])</span><br><span class="line">    <span class="comment"># print(year,country,gdp)</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        zd[year].append([country,gdp])</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        zd[year]=[]</span><br><span class="line">        zd[year].append([country,gdp])</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(zd)</span></span><br><span class="line">timeline=Timeline(</span><br><span class="line">    &#123;<span class="string">&quot;theme&quot;</span>:ThemeType.WALDEN&#125;</span><br><span class="line">)</span><br><span class="line">timedata=zd.keys()</span><br><span class="line"><span class="comment"># print(type(timedata))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> year <span class="keyword">in</span> timedata:</span><br><span class="line">    zd[year].sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line">    yeardata=zd[year][<span class="number">0</span>:<span class="number">8</span>]</span><br><span class="line">    x_data=[]</span><br><span class="line">    y_data=[]</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> yeardata:</span><br><span class="line">        x_data.append(data[<span class="number">0</span>])</span><br><span class="line">        y_data.append(<span class="built_in">int</span>(data[<span class="number">1</span>]/<span class="number">100000000</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        bar=Bar()</span><br><span class="line">        <span class="comment"># x_data.reverse()</span></span><br><span class="line">        <span class="comment"># y_data.reverse()</span></span><br><span class="line"></span><br><span class="line">        bar.add_xaxis(x_data)</span><br><span class="line">        bar.add_yaxis(<span class="string">&quot;GDP/亿&quot;</span>,y_data,label_opts=LabelOpts(position=<span class="string">&quot;right&quot;</span>,font_size=<span class="string">&quot;20px&quot;</span>))</span><br><span class="line"></span><br><span class="line">        bar.set_global_opts(</span><br><span class="line">            <span class="comment"># visualmap_opts=VisualMapOpts(is_show=True),</span></span><br><span class="line">            <span class="comment"># toolbox_opts=ToolboxOpts(is_show=True),</span></span><br><span class="line">            <span class="comment"># tooltip_opts=TooltipOpts(is_show=True),</span></span><br><span class="line">            <span class="comment"># datazoom_opts=DataZoomOpts(is_show=True),</span></span><br><span class="line">            <span class="comment"># legend_opts=LegendOpts(is_show=True)</span></span><br><span class="line">            title_opts=TitleOpts(title=<span class="string">f&quot;gdp<span class="subst">&#123;year&#125;</span>前八争霸&quot;</span>)</span><br><span class="line">        )</span><br><span class="line">        bar.reversal_axis()</span><br><span class="line">        timeline.add(bar,<span class="built_in">str</span>(year))</span><br><span class="line"></span><br><span class="line">timeline.add_schema(</span><br><span class="line">    is_auto_play=<span class="literal">True</span>,</span><br><span class="line">    is_loop_play=<span class="literal">True</span>,</span><br><span class="line">    play_interval=<span class="number">300</span>,</span><br><span class="line">    is_timeline_show=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">timeline.render(<span class="string">&quot;./动态gdp.html&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><blockquote><ol><li><h5 id="创建一个类，-》设计表格"><a href="#创建一个类，-》设计表格" class="headerlink" title="创建一个类，-》设计表格"></a>创建一个类，-》设计表格</h5></li><li><h5 id="创建具体的对象，-》打印出来"><a href="#创建具体的对象，-》打印出来" class="headerlink" title="创建具体的对象，-》打印出来"></a>创建具体的对象，-》打印出来</h5></li><li><h5 id="设置对象的属性值，-》学生填写"><a href="#设置对象的属性值，-》学生填写" class="headerlink" title="设置对象的属性值，-》学生填写"></a>设置对象的属性值，-》学生填写</h5></li></ol></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设计类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    name=<span class="literal">None</span></span><br><span class="line">    number=<span class="literal">None</span></span><br><span class="line">    address=<span class="literal">None</span></span><br><span class="line">    age=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化对象</span></span><br><span class="line">student1=student()</span><br><span class="line"></span><br><span class="line">student1.age=<span class="number">11</span></span><br><span class="line">student1.name=<span class="string">&quot;林军姐&quot;</span></span><br><span class="line">student1.address=<span class="string">&quot;日本&quot;</span></span><br><span class="line">student1.number=<span class="number">1982830095</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(student1.address,student1.age,student1.name,student1.number)</span><br><span class="line"><span class="comment"># 日本 11 林军姐 1982830095</span></span><br></pre></td></tr></table></figure><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><h5 id="类的定义和使用"><a href="#类的定义和使用" class="headerlink" title="类的定义和使用"></a>类的定义和使用</h5><hr><p><strong>在类内定义和变量叫成员变量</strong></p><p><strong>在类内定义和函数叫成员方法</strong></p><p>&#x3D;&#x3D;<strong>类的属性和行为都是类的成员</strong>&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>:</span><br><span class="line">类的属性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">类的行为</span><br></pre></td></tr></table></figure><h5 id="创建类对象的语法"><a href="#创建类对象的语法" class="headerlink" title="创建类对象的语法"></a>创建类对象的语法</h5><h6 id="对象名-类名字"><a href="#对象名-类名字" class="headerlink" title="&#x3D;&#x3D;对象名&#x3D;类名字()&#x3D;&#x3D;"></a>&#x3D;&#x3D;对象名&#x3D;类名字()&#x3D;&#x3D;</h6><hr><h5 id="类的成员方法的创建"><a href="#类的成员方法的创建" class="headerlink" title="类的成员方法的创建"></a>类的成员方法的创建</h5><blockquote><h5 id="1，和普通函数构造没太大区别，2，-只不过必须有一个形参是self，必须要有-3，self形参不需要给对应的实参。"><a href="#1，和普通函数构造没太大区别，2，-只不过必须有一个形参是self，必须要有-3，self形参不需要给对应的实参。" class="headerlink" title="1，和普通函数构造没太大区别，2，&#x3D;&#x3D;只不过必须有一个形参是self，必须要有&#x3D;&#x3D;,3，self形参不需要给对应的实参。"></a>1，和普通函数构造没太大区别，2，&#x3D;&#x3D;只不过必须有一个形参是self，必须要有&#x3D;&#x3D;,3，self形参不需要给对应的实参。</h5><p>​     <strong>&#x3D;&#x3D;实例方法需要通过类的实例来调用，而不是直接通过类来调用。&#x3D;&#x3D;</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>:</span><br><span class="line"> name=<span class="string">&quot;黑马&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">a5g</span>(<span class="params">self</span>):</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;5g&quot;</span>)</span><br><span class="line">father.a5g()</span><br></pre></td></tr></table></figure><h5 id="2-访问成员变量的时候也要用到self"><a href="#2-访问成员变量的时候也要用到self" class="headerlink" title="2. 访问成员变量的时候也要用到self"></a>2. 访问成员变量的时候也要用到self</h5></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设计类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    name=<span class="literal">None</span></span><br><span class="line">    number=<span class="literal">None</span></span><br><span class="line">    address=<span class="literal">None</span></span><br><span class="line">    age=<span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sayhi</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;你好,我叫<span class="subst">&#123;self.name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化对象</span></span><br><span class="line">student1=student()</span><br><span class="line"></span><br><span class="line">student1.age=<span class="number">11</span></span><br><span class="line">student1.name=<span class="string">&quot;林军姐&quot;</span></span><br><span class="line">student1.address=<span class="string">&quot;日本&quot;</span></span><br><span class="line">student1.number=<span class="number">1982830095</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(student1.address,student1.age,student1.name,student1.number)</span><br><span class="line"><span class="comment"># 日本 11 林军姐 1982830095</span></span><br><span class="line">student1.sayhi()</span><br><span class="line"><span class="comment"># 你好,我叫林军姐</span></span><br></pre></td></tr></table></figure><h5 id="面向对象编程-属性和行为"><a href="#面向对象编程-属性和行为" class="headerlink" title="面向对象编程(属性和行为)"></a>面向对象编程(属性和行为)</h5><blockquote><h5 id="类-设计图纸"><a href="#类-设计图纸" class="headerlink" title="类&#x3D;&#x3D;设计图纸"></a>类&#x3D;&#x3D;设计图纸</h5><h5 id="对象-基于图纸生产的实体"><a href="#对象-基于图纸生产的实体" class="headerlink" title="对象&#x3D;&#x3D;基于图纸生产的实体"></a>对象&#x3D;&#x3D;基于图纸生产的实体</h5></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">clock</span>:</span><br><span class="line">    <span class="built_in">id</span>=<span class="literal">None</span></span><br><span class="line">    price=<span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ring</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">import</span> winsound</span><br><span class="line">        winsound.Beep(<span class="number">2000</span>,<span class="number">3000</span>)</span><br><span class="line">类==设计图纸</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对象==基于图纸生产的实体</span><br><span class="line">clock1=clock()</span><br><span class="line">clock2=clock()</span><br><span class="line"></span><br><span class="line">clock1.<span class="built_in">id</span>=<span class="string">&quot;0001&quot;</span></span><br><span class="line">clock1.price=<span class="number">100</span></span><br><span class="line"></span><br><span class="line">clock2.<span class="built_in">id</span>=<span class="string">&quot;0002&quot;</span></span><br><span class="line">clock2.price=<span class="number">200</span></span><br><span class="line">clock1.ring()</span><br><span class="line">clock2.ring()</span><br></pre></td></tr></table></figure><h4 id="类内置的方法—-魔术方法"><a href="#类内置的方法—-魔术方法" class="headerlink" title="类内置的方法—-魔术方法"></a>类内置的方法—-魔术方法</h4><p>魔术方法__魔术名字__</p><p>很多很多，常用的</p><blockquote><ol><li><h4 id="init-—构造方法"><a href="#init-—构造方法" class="headerlink" title="__init__—构造方法"></a>__init__—构造方法</h4><h5 id="特点：对象实例化的时候自动执行，把参数自动传递-inie-方法使用"><a href="#特点：对象实例化的时候自动执行，把参数自动传递-inie-方法使用" class="headerlink" title="&#x3D;&#x3D;特点：对象实例化的时候自动执行，把参数自动传递__inie__方法使用&#x3D;&#x3D;"></a>&#x3D;&#x3D;特点：对象实例化的时候自动执行，把参数自动传递__inie__方法使用&#x3D;&#x3D;</h5><p>与最基本的声明变量相比</p><p><strong>定义—》定义加赋值，二合一</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name:<span class="literal">None</span></span><br><span class="line">address=<span class="literal">None</span></span><br><span class="line">number=<span class="literal">None</span></span><br><span class="line">age=<span class="literal">None</span></span><br><span class="line">这一步可以被构造方法来代替</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    name:<span class="literal">None</span></span><br><span class="line">    address=<span class="literal">None</span></span><br><span class="line">    number=<span class="literal">None</span></span><br><span class="line">    age=<span class="literal">None</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,address,number,age</span>):</span><br><span class="line">      </span><br><span class="line">        self.name= name</span><br><span class="line">        self.age=age</span><br><span class="line">        self.number=number</span><br><span class="line">        self.address=address</span><br><span class="line">      </span><br><span class="line">xrb=student(<span class="string">&quot;王大山&quot;</span>,<span class="string">&quot;日本&quot;</span>,<span class="number">198283095</span>,<span class="number">17</span>)</span><br><span class="line"><span class="built_in">print</span>(xrb.address)</span><br><span class="line"><span class="built_in">print</span>(xrb.age)</span><br><span class="line"><span class="built_in">print</span>(xrb.name)</span><br><span class="line"><span class="built_in">print</span>(xrb.number)</span><br><span class="line">   <span class="comment"># 日本</span></span><br><span class="line">      </span><br><span class="line">   <span class="comment"># 17</span></span><br><span class="line">      </span><br><span class="line">   <span class="comment"># 王大山</span></span><br><span class="line">      </span><br><span class="line">   <span class="comment"># 198283095</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="str-方法—字符串方法"><a href="#str-方法—字符串方法" class="headerlink" title="__str__方法—字符串方法"></a>__str__方法—字符串方法</h4><blockquote><p>问题引入</p></blockquote>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    name:<span class="literal">None</span></span><br><span class="line">    address=<span class="literal">None</span></span><br><span class="line">    number=<span class="literal">None</span></span><br><span class="line">    age=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,address,number,age</span>):</span><br><span class="line"></span><br><span class="line">        self.name= name</span><br><span class="line">        self.age=age</span><br><span class="line">        self.number=number</span><br><span class="line">        self.address=address</span><br><span class="line"></span><br><span class="line">xrb=student(<span class="string">&quot;王大山&quot;</span>,<span class="string">&quot;日本&quot;</span>,<span class="number">198283095</span>,<span class="number">17</span>)</span><br><span class="line"><span class="built_in">print</span>(xrb)</span><br><span class="line"><span class="comment"># &lt;__main__.student object at 0x0000024AD5537450&gt;</span></span><br></pre></td></tr></table></figure><h5 id="使用str魔术方法，可以直接输出对象的属性"><a href="#使用str魔术方法，可以直接输出对象的属性" class="headerlink" title="使用str魔术方法，可以直接输出对象的属性"></a>使用str魔术方法，可以直接输出对象的属性</h5><h5 id="替换了原来的str方法-原来的str（对象）是内存地址-也替换了对象的打印方式"><a href="#替换了原来的str方法-原来的str（对象）是内存地址-也替换了对象的打印方式" class="headerlink" title="&#x3D;&#x3D;替换了原来的str方法 ,原来的str（对象）是内存地址,也替换了对象的打印方式&#x3D;&#x3D;"></a>&#x3D;&#x3D;替换了原来的str方法 ,原来的str（对象）是内存地址,也替换了对象的打印方式&#x3D;&#x3D;</h5>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    name:<span class="literal">None</span></span><br><span class="line">    address=<span class="literal">None</span></span><br><span class="line">    number=<span class="literal">None</span></span><br><span class="line">    age=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,address,number,age</span>):</span><br><span class="line"></span><br><span class="line">        self.name= name</span><br><span class="line">        self.age=age</span><br><span class="line">        self.number=number</span><br><span class="line">        self.address=address</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>,<span class="subst">&#123;self.age&#125;</span>,<span class="subst">&#123;self.address&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">xrb=student(<span class="string">&quot;王大山&quot;</span>,<span class="string">&quot;日本&quot;</span>,<span class="number">198283095</span>,<span class="number">17</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(xrb))</span><br><span class="line"><span class="comment"># 王大山,17,日本</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h5 id="lt-方法"><a href="#lt-方法" class="headerlink" title="__lt__方法"></a>__lt__方法</h5><blockquote><h5 id="操控原来的"><a href="#操控原来的" class="headerlink" title="操控原来的&lt;,原来是比较内存位置的大小"></a>操控原来的&lt;,原来是比较内存位置的大小</h5></blockquote>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line"></span><br><span class="line">        self.name= name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>,<span class="subst">&#123;self.age&#125;</span>,<span class="subst">&#123;self.address&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self,other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.age&gt;other.age</span><br><span class="line"></span><br><span class="line">xrb=student(<span class="string">&quot;王大山&quot;</span>,<span class="number">17</span>)</span><br><span class="line">xrb1=student(<span class="string">&quot;周杰伦&quot;</span>,<span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span>(xrb.age,xrb1.age)</span><br><span class="line"><span class="built_in">print</span>(xrb&gt;xrb1)</span><br><span class="line"><span class="built_in">print</span>(xrb.__lt__(xrb1))</span><br><span class="line"><span class="number">17</span>,<span class="number">32</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对于给定的代码，输出结果应该是不同的。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 在 `<span class="built_in">print</span>(xrb&gt;xrb1)` 中，使用了 `&gt;` 操作符进行比较。`&gt;` 操作符实际上调用了对象的 `__gt__` 方法。由于 `student` 类中没有定义 `__gt__` 方法，Python 会使用默认的比较规则进行比较。默认的比较规则是基于对象的内存地址进行比较，而不是基于对象的属性。</span><br><span class="line"><span class="number">2.</span> 在 `<span class="built_in">print</span>(xrb.__lt__(xrb1))` 中，使用了 `__lt__` 方法进行比较。`__lt__` 方法定义了对象之间的比较规则。根据 `__lt__` 方法中的逻辑，如果 `self` 对象的 `age` 属性大于 `other` 对象的 `age` 属性，它将返回 `<span class="literal">True</span>`，否则返回 `<span class="literal">False</span>`。</span><br><span class="line">在这种情况下，`xrb` 对象的 `age` 是 <span class="number">17</span>，`xrb1` 对象的 `age` 是 <span class="number">32</span>。因此，`xrb.__lt__(xrb1)` 返回 `<span class="literal">False</span>`，而不是 `<span class="literal">True</span>`。</span><br><span class="line">所以，根据提供的代码，`<span class="built_in">print</span>(xrb&gt;xrb1)` 的输出结果应该是 `<span class="literal">False</span>`，而 `<span class="built_in">print</span>(xrb.__lt__(xrb1))` 的输出结果应该是 `<span class="literal">False</span>`。</span><br></pre></td></tr></table></figure><p>   &#x3D;&#x3D;最好使用具体的方法，因为&gt;,&lt;都需要定义，默认是比较内存地址的大小，现在之定义了&lt;号，而&gt;还默认是比较内存地址&#x3D;&#x3D;</p><h5 id="print-xrb-lt-xrb1-，或者"><a href="#print-xrb-lt-xrb1-，或者" class="headerlink" title="print(xrb.lt(xrb1))，或者&lt;，才是自己定义的方法，如果符合return后面的式子就返回true"></a>print(xrb.<strong>lt</strong>(xrb1))，或者&lt;，才是自己定义的方法，如果符合return后面的式子就返回true</h5><hr><ol start="3"><li>__lt__方法</li></ol><blockquote><h5 id="操控原来-的"><a href="#操控原来-的" class="headerlink" title="操控原来 的&lt;&#x3D; ，原来是比较内存位置的大小"></a>操控原来 的&lt;&#x3D; ，原来是比较内存位置的大小</h5></blockquote>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line"></span><br><span class="line">         self.name= name</span><br><span class="line">         self.age=age</span><br><span class="line"></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">         <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>,<span class="subst">&#123;self.age&#125;</span>,<span class="subst">&#123;self.address&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self,other</span>):</span><br><span class="line">         <span class="keyword">return</span> self.age&lt;other.age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__le__</span>(<span class="params">self,other</span>):</span><br><span class="line">         <span class="keyword">return</span> self.age&lt;=other.age</span><br><span class="line"></span><br><span class="line"> xrb=student(<span class="string">&quot;王大山&quot;</span>,<span class="number">32</span>)</span><br><span class="line"> xrb1=student(<span class="string">&quot;周杰伦&quot;</span>,<span class="number">32</span>)</span><br><span class="line">xrb2=student(<span class="string">&quot;林俊杰&quot;</span>,<span class="number">11</span>)</span><br><span class="line"> <span class="comment"># print(xrb.age,xrb1.age)</span></span><br><span class="line"> <span class="built_in">print</span>(xrb2&lt;=xrb1)</span><br><span class="line"> <span class="built_in">print</span>(xrb.__le__(xrb1))</span><br><span class="line"> <span class="comment"># True</span></span><br><span class="line"> <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h4 id="在-Python-中，-操作符和-操作符的默认行为是比较对象的内存位置，"><a href="#在-Python-中，-操作符和-操作符的默认行为是比较对象的内存位置，" class="headerlink" title="&#x3D;&#x3D;在 Python 中，&gt; 操作符和 &gt;= 操作符的默认行为是比较对象的内存位置，&#x3D;&#x3D;"></a>&#x3D;&#x3D;在 Python 中，<code>&gt;</code> 操作符和 <code>&gt;=</code> 操作符的默认行为是比较对象的内存位置，&#x3D;&#x3D;</h4><p>  lt le,gt ge   &lt; &lt;&#x3D; &gt; &gt;&#x3D;</p><ol start="4"><li>__eq__方法</li></ol><blockquote><h5 id="操控-原来的-是比较内存位置是否相同的"><a href="#操控-原来的-是比较内存位置是否相同的" class="headerlink" title="操控=&#x3D;,原来的&#x3D;&#x3D;是比较内存位置是否相同的"></a>操控=&#x3D;,原来的&#x3D;&#x3D;是比较内存位置是否相同的</h5></blockquote>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line"></span><br><span class="line">        self.name= name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>,<span class="subst">&#123;self.age&#125;</span>,<span class="subst">&#123;self.address&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self,other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.age&lt;other.age</span><br><span class="line">       <span class="keyword">def</span> <span class="title function_">__le__</span>(<span class="params">self,other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.age&lt;=other.age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.age==other.age</span><br><span class="line"></span><br><span class="line">xrb=student(<span class="string">&quot;王大山&quot;</span>,<span class="number">98</span>)</span><br><span class="line">xrb1=student(<span class="string">&quot;周杰伦&quot;</span>,<span class="number">98</span>)</span><br><span class="line">   xrb2=student(<span class="string">&quot;林俊杰&quot;</span>,<span class="number">11</span>)</span><br><span class="line"><span class="built_in">print</span>(xrb==xrb1)</span><br><span class="line"><span class="built_in">print</span>(xrb==xrb2)</span><br></pre></td></tr></table></figure></blockquote><hr><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p><strong>把现实世界的，属性，行为，封装道类中，描述为成员变量，成员方法，从而完成程序对现实世界事物的描述</strong></p><blockquote><p>苹果越狱，安卓root</p><p>就是突破权限</p><hr><h4 id="私有成员变量，私有成员方法"><a href="#私有成员变量，私有成员方法" class="headerlink" title="私有成员变量，私有成员方法"></a>私有成员变量，私有成员方法</h4><p>如何私有？</p><hr><h5 id="1-如果一个属性或方法的名称以两个下划线开头，并且不以两个下划线结尾，那么它将被视为私有的。"><a href="#1-如果一个属性或方法的名称以两个下划线开头，并且不以两个下划线结尾，那么它将被视为私有的。" class="headerlink" title="1. &#x3D;&#x3D;如果一个属性或方法的名称以两个下划线开头，并且不以两个下划线结尾，那么它将被视为私有的。&#x3D;&#x3D;"></a>1. &#x3D;&#x3D;如果一个属性或方法的名称以两个下划线开头，并且不以两个下划线结尾，那么它将被视为私有的。&#x3D;&#x3D;</h5><h5 id="2-私有成员变量和私有成员方法在类的外部是无法直接访问的。"><a href="#2-私有成员变量和私有成员方法在类的外部是无法直接访问的。" class="headerlink" title="2. &#x3D;&#x3D;私有成员变量和私有成员方法在类的外部是无法直接访问的。&#x3D;&#x3D;"></a>2. &#x3D;&#x3D;私有成员变量和私有成员方法在类的外部是无法直接访问的。&#x3D;&#x3D;</h5><p>3&#x3D;&#x3D;<strong>私有成员通过公共的成员函数去调用和操作</strong>&#x3D;&#x3D;</p><p>类对象无法使用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sb</span>:</span><br><span class="line"> __name=<span class="string">&quot;王大山&quot;</span></span><br><span class="line"> age=<span class="literal">None</span></span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">__getage</span>(<span class="params">self</span>):</span><br><span class="line">     <span class="keyword">return</span> self.age</span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">public</span>(<span class="params">self</span>):</span><br><span class="line">     <span class="built_in">print</span>(self.__getage())</span><br><span class="line">     <span class="keyword">return</span> self.__name</span><br><span class="line">sbson=sb()</span><br><span class="line">sbson.age=<span class="number">18</span></span><br><span class="line"><span class="comment"># print(sbson.__getage())</span></span><br><span class="line"></span><br><span class="line">sbson.__name=<span class="string">&quot;周杰伦&quot;</span></span><br><span class="line"><span class="built_in">print</span>(sbson.__name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;公共方法可以访问私有成员变量和私有成员方法,<span class="subst">&#123;sbson.public()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># __name 是私有成员变量，但是在 sbson 对象上赋值 sbson.__name = &quot;周杰伦&quot; 并不会修改类中的私有成员变量 __name。相反，它会创建一个新的公有成员变量 __name 并将其赋值为 &quot;周杰伦&quot;。因此，当你打印 sbson.__name 时，它将输出 &quot;周杰伦&quot;。</span></span><br><span class="line"><span class="comment"># 周杰伦</span></span><br><span class="line"><span class="comment"># 18</span></span><br><span class="line"><span class="comment"># 公共方法可以访问私有成员变量和私有成员方法,王大山</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h5 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a><strong>单继承</strong></h5><blockquote><h5 id="class-类名（父类名）"><a href="#class-类名（父类名）" class="headerlink" title="class 类名（父类名）"></a>class 类名（父类名）</h5><h5 id="类内容体"><a href="#类内容体" class="headerlink" title="类内容体"></a>类内容体</h5><h6 id="就把父亲的成员都继承过来了。"><a href="#就把父亲的成员都继承过来了。" class="headerlink" title="&#x3D;&#x3D;就把父亲的成员都继承过来了。&#x3D;&#x3D;"></a>&#x3D;&#x3D;就把父亲的成员都继承过来了。&#x3D;&#x3D;</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">phone</span>:</span><br><span class="line"> name=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">a5g</span>(<span class="params">self</span>):</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;5g&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">phone2022</span>(<span class="title class_ inherited__">phone</span>):</span><br><span class="line"> age=<span class="literal">None</span></span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">a6g</span>(<span class="params">self</span>):</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;6g&quot;</span>)</span><br><span class="line">a=phone2022()</span><br><span class="line">a.a5g()</span><br><span class="line">a.a6g()</span><br><span class="line">5g</span><br><span class="line">6g</span><br></pre></td></tr></table></figure></blockquote><h5 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a><strong>多继承</strong></h5><blockquote><h5 id="class-类名-父类1，父类2，父类3-。。。"><a href="#class-类名-父类1，父类2，父类3-。。。" class="headerlink" title="class 类名(父类1，父类2，父类3.。。。)"></a>class 类名(父类1，父类2，父类3.。。。)</h5><h5 id="类内容提体"><a href="#类内容提体" class="headerlink" title="类内容提体"></a>类内容提体</h5><p>就把所有父亲的成员继承下来了。</p></blockquote><p>&#x3D;&#x3D;<em><strong>如果有同名的成员，从左到右，最左边继承的优先级最高</strong></em>&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">phone</span>:</span><br><span class="line">    name=<span class="string">&quot;黑马&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">a5g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;5g&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">phone1</span>:</span><br><span class="line">    name=<span class="string">&quot;牛马&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">a5g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;5g&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">phone2022</span>(phone1,phone):</span><br><span class="line">    age=<span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">a6g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;6g&quot;</span>)</span><br><span class="line">a=phone2022()</span><br><span class="line"><span class="built_in">print</span>(a.name)</span><br><span class="line">牛马</span><br></pre></td></tr></table></figure><h4 id="复写"><a href="#复写" class="headerlink" title="复写"></a>复写</h4><p><strong>&#x3D;&#x3D;子类对父亲的成员不满意，就在子类重新定义父亲继承下来的那个，名字相同，就是复写&#x3D;&#x3D;</strong></p><p><strong>复写后。子类调用类实体对象的成员是复写后 的成员</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>:</span><br><span class="line">    name=<span class="string">&quot;黑马&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">a5g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;5g&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span>(<span class="title class_ inherited__">father</span>):</span><br><span class="line">    age=<span class="literal">None</span></span><br><span class="line">    name=<span class="string">&quot;牛马&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">a6g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;6g&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">a5g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;555555g&quot;</span>)</span><br><span class="line">a=son()</span><br><span class="line"><span class="built_in">print</span>(a.name)</span><br><span class="line">a.a5g()</span><br><span class="line"><span class="comment"># 牛马</span></span><br><span class="line"><span class="comment"># 555555g</span></span><br></pre></td></tr></table></figure><p><strong>但复写后，还想使用父类原来的成员，也就是复写前的父类成员</strong></p><blockquote><ol><li><h4 id="用父类名-成员-类外-，子类内都可以使用"><a href="#用父类名-成员-类外-，子类内都可以使用" class="headerlink" title="用父类名.成员   类外&#x3D;&#x3D;，子类内都可以使用&#x3D;&#x3D;"></a>用父类名.成员   类外&#x3D;&#x3D;，子类内都可以使用&#x3D;&#x3D;</h4><p><strong>在类外调用成员行为需要实例化一个对象先</strong></p><p><strong>在子类里面调用父类的行为需要加（self）参数</strong></p></li><li><h4 id="super-父类成员-只能在子类的类体内使用-★★★★★★★★"><a href="#super-父类成员-只能在子类的类体内使用-★★★★★★★★" class="headerlink" title="super().父类成员  &#x3D;&#x3D;只能在子类的类体内使用&#x3D;&#x3D; ★★★★★★★★"></a>super().父类成员  &#x3D;&#x3D;只能在子类的类体内使用&#x3D;&#x3D; ★★★★★★★★</h4></li></ol></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>:</span><br><span class="line">    name=<span class="string">&quot;黑马&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">a5g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;5g&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span>(<span class="title class_ inherited__">father</span>):</span><br><span class="line">    age=<span class="literal">None</span></span><br><span class="line">    name=<span class="string">&quot;牛马&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">a6g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">super</span>().name)</span><br><span class="line">        <span class="built_in">print</span>(father.name)</span><br><span class="line"></span><br><span class="line">        father.a5g(self)</span><br><span class="line">        <span class="built_in">super</span>().a5g()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">a=son()</span><br><span class="line"><span class="built_in">print</span>(a.name)</span><br><span class="line">a.a6g()</span><br><span class="line"><span class="built_in">print</span>(father.name)</span><br><span class="line"><span class="comment"># 牛马</span></span><br><span class="line"><span class="comment"># 黑马</span></span><br><span class="line"><span class="comment"># 黑马</span></span><br><span class="line"><span class="comment"># 黑马</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h4><p><strong>方便开发者看</strong></p><p><strong>帮助ide代码提示</strong></p><p><strong>标记错了也不影响运行</strong></p><p><strong>变量:类型</strong></p><p><strong>数据容器:类型[类型注解挨个，如果统一写一个就ok]</strong></p><p><strong>数据容器都用[]</strong></p><h5 id="变量，数据容器的类型注解"><a href="#变量，数据容器的类型注解" class="headerlink" title="变量，数据容器的类型注解"></a>变量，数据容器的类型注解</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a:<span class="built_in">int</span>=<span class="number">10</span></span><br><span class="line">b=<span class="number">10</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sb</span>:</span><br><span class="line">    name:<span class="built_in">str</span>=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line">xrb:sb=sb()</span><br><span class="line">mylist:<span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">mylist1:<span class="built_in">list</span>[<span class="built_in">int</span>]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">mytuple:<span class="built_in">tuple</span>=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">mytuple1:<span class="built_in">tuple</span>[<span class="built_in">int</span>,<span class="built_in">str</span>]=(<span class="number">1</span>,<span class="string">&quot;adsad&quot;</span>)</span><br><span class="line"></span><br><span class="line">myset:<span class="built_in">set</span>=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">myset1:<span class="built_in">set</span>[<span class="built_in">int</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mydict:<span class="built_in">dict</span>=&#123;<span class="string">&quot;ky1&quot;</span>:<span class="number">1</span>,<span class="string">&quot;ky2&quot;</span>:<span class="number">2</span>&#125;</span><br><span class="line">mydict1:<span class="built_in">dict</span>[<span class="built_in">str</span>,<span class="built_in">int</span>]</span><br></pre></td></tr></table></figure><blockquote><h5 id="给无法直接看出变量类型的变量添加类型注解"><a href="#给无法直接看出变量类型的变量添加类型注解" class="headerlink" title="给无法直接看出变量类型的变量添加类型注解"></a><strong>给无法直接看出变量类型的变量添加类型注解</strong></h5></blockquote><hr><h5 id="函数参数的类型注解"><a href="#函数参数的类型注解" class="headerlink" title="函数参数的类型注解"></a><strong>函数参数的类型注解</strong></h5><p><em><strong>就会有类型提示了，ide知道了</strong></em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a:<span class="built_in">int</span>,b:<span class="built_in">str</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(a,b)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>,<span class="string">&quot;你好&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="函数返回值的类型注解"><a href="#函数返回值的类型注解" class="headerlink" title="函数返回值的类型注解"></a>函数返回值的类型注解</h5><p><em><strong>-&gt;就会帮函数的返回值给予提示</strong></em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a:<span class="built_in">int</span>,b:<span class="built_in">str</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">    <span class="built_in">print</span>(a,b)</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><h5 id="Union类型注解"><a href="#Union类型注解" class="headerlink" title="Union类型注解"></a>Union类型注解</h5><ol><li><h5 id="导入Union模块"><a href="#导入Union模块" class="headerlink" title="导入Union模块"></a>导入Union模块</h5></li><li><h5 id="注释的时候如果里面的数据多，且是混合的，之前的挨个注释就不太方便了"><a href="#注释的时候如果里面的数据多，且是混合的，之前的挨个注释就不太方便了" class="headerlink" title="注释的时候如果里面的数据多，且是混合的，之前的挨个注释就不太方便了"></a>注释的时候如果里面的数据多，且是混合的，之前的挨个注释就不太方便了</h5></li><li><h5 id="union-数据类型1，数据类型2"><a href="#union-数据类型1，数据类型2" class="headerlink" title="union[数据类型1，数据类型2]"></a>union[数据类型1，数据类型2]</h5></li><li><h5 id="表示要么是数据类型1，要么是数据类型2"><a href="#表示要么是数据类型1，要么是数据类型2" class="headerlink" title="表示要么是数据类型1，要么是数据类型2"></a>表示要么是数据类型1，要么是数据类型2</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line"></span><br><span class="line">mylist:<span class="built_in">list</span>[<span class="type">Union</span>[<span class="built_in">int</span>,<span class="built_in">str</span>]]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="string">&quot;s&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>]</span><br><span class="line">mydict=&#123;<span class="number">1</span>:<span class="number">2</span>,<span class="number">2</span>:<span class="number">3</span>,<span class="string">&quot;1&quot;</span>:<span class="string">&quot;你好&quot;</span>,<span class="string">&quot;2&quot;</span>:<span class="string">&quot;我去&quot;</span>&#125;</span><br><span class="line">mydict:<span class="built_in">dict</span>[<span class="type">Union</span>[<span class="built_in">int</span>,<span class="built_in">str</span>],<span class="type">Union</span>[<span class="built_in">int</span>,<span class="built_in">str</span>]]=&#123;<span class="number">1</span>:<span class="number">2</span>,<span class="number">2</span>:<span class="number">3</span>,<span class="string">&quot;1&quot;</span>:<span class="string">&quot;你好&quot;</span>,<span class="string">&quot;2&quot;</span>:<span class="string">&quot;我去&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>(<span class="params">data:<span class="type">Union</span>[<span class="built_in">int</span>,<span class="built_in">str</span>]</span>)-&gt;<span class="type">Union</span>[<span class="built_in">int</span>,<span class="built_in">str</span>]:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">a()提示</span><br><span class="line">(variable) <span class="keyword">def</span> <span class="title function_">a</span>(<span class="params">data: <span class="built_in">int</span> | <span class="built_in">str</span></span>) -&gt; (<span class="built_in">int</span> | <span class="built_in">str</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li></ol><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p><strong>多种状态，完成某个行为的时候，使用不同的对象得到不同的结果</strong></p><p><strong>animal；相当于顶层设计，设计一个标准</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;汪汪汪&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;喵喵喵&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">jiao</span>(<span class="params">a:animal</span>):</span><br><span class="line">    a.speak()</span><br><span class="line"></span><br><span class="line">dog=dog()</span><br><span class="line">cat=cat()</span><br><span class="line"></span><br><span class="line">jiao(dog)</span><br><span class="line">jiao(cat)</span><br><span class="line">汪汪汪</span><br><span class="line">喵喵喵</span><br></pre></td></tr></table></figure><p><strong>抽象类（接口）：含有抽象方法的类</strong></p><p><strong>抽象方法：方法体的实现是空的PASS</strong></p><p><strong>顶层设计有多少个抽象方法，以后就要有对应几个函数。</strong></p><p><strong>顶层设计标准，子类来实现具体的功能</strong></p><p><strong>要求子类必须复写实现具体的功能</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">airconditioner</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_cool</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_hot</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swing</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">geli</span>(<span class="title class_ inherited__">airconditioner</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_cool</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;格力的制冷&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_hot</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;格力的制热&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swing</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;格力的左右摇摆&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">meidi</span>(<span class="title class_ inherited__">airconditioner</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_cool</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;美的的制冷&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_hot</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;美的的制热&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swing</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;美的的左右摇摆&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mc</span>(<span class="params"><span class="built_in">object</span>:airconditioner</span>):</span><br><span class="line">    <span class="built_in">object</span>.make_cool()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mh</span>(<span class="params"><span class="built_in">object</span>:airconditioner</span>):</span><br><span class="line">    <span class="built_in">object</span>.make_hot()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swing</span>(<span class="params"><span class="built_in">object</span>:airconditioner</span>):</span><br><span class="line">    <span class="built_in">object</span>.swing()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">airmeidi=meidi()</span><br><span class="line">airgeli=geli()</span><br><span class="line"></span><br><span class="line">mc(airgeli)</span><br><span class="line">mc(airmeidi)</span><br><span class="line"><span class="comment"># 格力的制冷</span></span><br><span class="line"><span class="comment"># 美的的制冷</span></span><br><span class="line">mh(airgeli)</span><br><span class="line">mh(airmeidi)</span><br><span class="line"><span class="comment"># 格力的制热</span></span><br><span class="line"><span class="comment"># 美的的制热</span></span><br><span class="line">swing(airgeli)</span><br><span class="line">swing(airmeidi)</span><br><span class="line"><span class="comment"># 格力的左右摇摆</span></span><br><span class="line"><span class="comment"># 美的的左右摇摆</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SQL数据库（简单入门）"><a href="#SQL数据库（简单入门）" class="headerlink" title="SQL数据库（简单入门）"></a>SQL数据库（简单入门）</h3><p><strong>&#x3D;&#x3D;字符串的值，出现在sql语句中，必须用单引号包起来&#x3D;&#x3D;</strong></p><p><strong>后端&#x3D;sql+编程语言</strong></p><p><strong>SQL开发人员必备技能</strong></p><p><strong>SQL{pyspark，pyflink,BI可视化}</strong></p><p><em><strong>数据的存储，数据库管理系统</strong></em></p><hr><p><strong>&#x3D;&#x3D;数据库是对数据库数据的操作管理查询&#x3D;&#x3D;</strong></p><p><em><strong>而操控数据库需要用到SQL语言</strong></em></p><p>组织数据：库-&gt;表-&gt;数据</p><blockquote><ol><li><p>进入mysql开发环境</p><p>mysql -uroot -p</p><blockquote><p> 在命令行环境中</p><ol><li>show databases;查看有哪些数据库</li><li>use 数据库名  使用某个数据库</li><li>show tables 查看数据库内有哪些表</li><li>exit 退出数据库</li></ol></blockquote></li></ol></blockquote><p><strong>mysql图形化工具DBeaver免费开源</strong></p><p>SQL语言的分类</p><blockquote><ol><li><p>数据定义</p><ol><li>数据定义D D L   -define</li><li>数据操纵D M L   -manipulate</li><li>数据控制D C L   - control</li><li>数据查询D Q L   quer</li></ol></li><li><p>简单语法</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"><span class="keyword">SHOW</span> databases;</span><br><span class="line"><span class="keyword">show</span></span><br><span class="line">databases;</span><br><span class="line"># dsadsadasd</span><br><span class="line"><span class="comment">-- dasdadasd</span></span><br><span class="line"><span class="comment">/*三大</span></span><br><span class="line"><span class="comment"> * 大撒大撒</span></span><br><span class="line"><span class="comment"> * 撒大苏打</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span><span class="operator">*</span><span class="operator">/</span></span><br></pre></td></tr></table></figure><h5 id="对大小写不敏感"><a href="#对大小写不敏感" class="headerlink" title="对大小写不敏感"></a>对大小写不敏感</h5><h5 id="可以换行写，但必须以-结尾"><a href="#可以换行写，但必须以-结尾" class="headerlink" title="可以换行写，但必须以;结尾"></a>可以换行写，但必须以;结尾</h5><h5 id="三种注释方法-单行-空格-空格"><a href="#三种注释方法-单行-空格-空格" class="headerlink" title="三种注释方法:单行:#(空格),-空格,"></a>三种注释方法:单行:#(空格),-空格,</h5><h5 id="多行"><a href="#多行" class="headerlink" title="多行:&#x2F;**&#x2F;"></a>多行:&#x2F;**&#x2F;</h5></li></ol></blockquote><h4 id="数据定义D-D-L"><a href="#数据定义D-D-L" class="headerlink" title="数据定义D D L"></a>数据定义D D L</h4><p><strong>库管理</strong></p><blockquote><ol><li><p>查看数据库</p><h5 id="show-databases"><a href="#show-databases" class="headerlink" title="show databases;"></a>show databases;</h5></li><li><p>使用数据库</p><h5 id="use-库名"><a href="#use-库名" class="headerlink" title="use 库名;"></a>use 库名;</h5></li><li><p>创建数据库</p><h5 id="create-database-库名-charset-utf-8"><a href="#create-database-库名-charset-utf-8" class="headerlink" title="create database 库名 [charset utf-8];"></a>create database 库名 [charset utf-8];</h5></li><li><p>删除数据库</p><h5 id="drop-database-库名"><a href="#drop-database-库名" class="headerlink" title="drop database 库名;"></a>drop database 库名;</h5></li><li><p>查看当前使用的数据库</p><h5 id="select-database"><a href="#select-database" class="headerlink" title="select database();"></a>select database();</h5></li></ol></blockquote><p>**表管理**</p><blockquote><ol><li><p>查看表</p><h5 id="先选择数据库"><a href="#先选择数据库" class="headerlink" title="先选择数据库"></a>先选择数据库</h5><h5 id="show-tables"><a href="#show-tables" class="headerlink" title="show tables;"></a>show tables;</h5></li><li><p>添加表</p><h5 id="creat-table-表（"><a href="#creat-table-表（" class="headerlink" title="creat table 表（"></a>creat table 表（</h5><h5 id="列名-列类型"><a href="#列名-列类型" class="headerlink" title="列名 列类型,"></a>列名 列类型,</h5><h5 id="列名-列类型-1"><a href="#列名-列类型-1" class="headerlink" title="列名 列类型,"></a>列名 列类型,</h5><h5 id="列名-列类型-2"><a href="#列名-列类型-2" class="headerlink" title="列名 列类型"></a>列名 列类型</h5><h5 id="）"><a href="#）" class="headerlink" title="）;"></a>）;</h5><p><strong>最后一个表的添加不需要,</strong></p></li><li><p>删除表</p><h5 id="drop-table-表名"><a href="#drop-table-表名" class="headerlink" title="drop table 表名;"></a>drop table 表名;</h5><h5 id="drop-table-if-exits-表名"><a href="#drop-table-if-exits-表名" class="headerlink" title="drop table if exits 表名;"></a>drop table if exits 表名;</h5></li></ol><p>&#x3D;&#x3D;<strong>选中要运行的语句然后执行</strong>&#x3D;&#x3D;</p></blockquote><hr><h4 id="数据操作D-M-L"><a href="#数据操作D-M-L" class="headerlink" title="数据操作D M L"></a>数据操作D M L</h4><p>对表的数据操作</p><blockquote><ol><li><p>数据插入insert</p><p>insert into 表名([列],,,,,) values (对应的值,,,,,,,,,)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(id) <span class="keyword">values</span> (<span class="number">1001</span>),(<span class="number">1002</span>),(<span class="number">1003</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> student(id,name,age) <span class="keyword">values</span> (<span class="number">001</span>,&quot;林俊杰&quot;,<span class="number">18</span>),(<span class="number">002</span>,&quot;张杰&quot;,<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span>  student <span class="keyword">values</span> (<span class="number">001</span>,&quot;林俊杰&quot;,<span class="number">18</span>),(<span class="number">002</span>,&quot;张杰&quot;,<span class="number">23</span>);</span><br></pre></td></tr></table></figure></li><li><p>数据的删除delete</p><h5 id="delete-from-表名-where-条件判断"><a href="#delete-from-表名-where-条件判断" class="headerlink" title="delete from 表名 [where 条件判断];"></a>delete from 表名 [where 条件判断];</h5><h5 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断:&gt; &lt; &#x3D; &gt;&#x3D; &lt;&#x3D; !&#x3D;"></a>条件判断:&gt; &lt; &#x3D; &gt;&#x3D; &lt;&#x3D; !&#x3D;</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">删除具体的</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student;</span><br><span class="line">删除整张表</span><br></pre></td></tr></table></figure></li><li><p>数据的更新update</p><h5 id="update-表-set-列-值-where-条件判断"><a href="#update-表-set-列-值-where-条件判断" class="headerlink" title="update 表 set 列&#x3D;值 [where 条件判断];"></a>update 表 set 列&#x3D;值 [where 条件判断];</h5><h5 id="条件判断-1"><a href="#条件判断-1" class="headerlink" title="条件判断:&gt; &lt; &#x3D; &gt;&#x3D; &lt;&#x3D; !&#x3D;"></a>条件判断:&gt; &lt; &#x3D; &gt;&#x3D; &lt;&#x3D; !&#x3D;</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> name<span class="operator">=</span>&quot;牛马程序员&quot; <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="数据查找-D-Q-L"><a href="#数据查找-D-Q-L" class="headerlink" title="数据查找 D Q L"></a>数据查找 D Q L</h4><blockquote><ol><li><h5 id="最基础的数据查找"><a href="#最基础的数据查找" class="headerlink" title="最基础的数据查找"></a>最基础的数据查找</h5><p>select  列表 from 表</p><p>*代表该表的所有列</p><p>where 条件判断</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,age,gender <span class="keyword">from</span> students;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students age<span class="operator">&gt;=</span><span class="number">18</span>;</span><br></pre></td></tr></table></figure></li><li><p>分组聚合</p><p>基础语法: group by 列，按照列分组</p><h6 id="SELECT-字段-聚合函数-FROM-表-WHERE条件-GROUP-BY列"><a href="#SELECT-字段-聚合函数-FROM-表-WHERE条件-GROUP-BY列" class="headerlink" title="SELECT&#x3D;&#x3D;字段&#x3D;&#x3D;|聚合函数 FROM 表[WHERE条件] &#x3D;&#x3D;GROUP BY列&#x3D;&#x3D;"></a>SELECT&#x3D;&#x3D;字段&#x3D;&#x3D;|聚合函数 FROM 表[WHERE条件] &#x3D;&#x3D;GROUP BY列&#x3D;&#x3D;</h6><p><strong>&#x3D;&#x3D;GROUP BY中出现了哪个列，哪个列才能出现在SELECT中的非聚合中。&#x3D;&#x3D;</strong></p><p>聚合函数有:<br>SUM(列)求和<br>AVG(列)求平均值<br>MIN(列)求最小值<br>MAX(列)求最大值<br>COUNT(列| *）:求数量</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sex,<span class="built_in">avg</span>(age) <span class="keyword">from</span> student <span class="keyword">group</span> <span class="keyword">by</span> sex;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="数据排序-D-C-L"><a href="#数据排序-D-C-L" class="headerlink" title="数据排序 D C L"></a>数据排序 D C L</h4><blockquote><h5 id="select-列-from-student-where-条件判断-order-by-字段-asc-desc"><a href="#select-列-from-student-where-条件判断-order-by-字段-asc-desc" class="headerlink" title="select 列|* from student [where 条件判断] order by 字段 [asc|desc] ;"></a><strong>select</strong> 列|* <strong>from</strong> student [<strong>where</strong> 条件判断] <strong>order</strong> <strong>by</strong> 字段 [asc|desc] ;</h5><p>默认是asc，也就是升序。</p><p>按照字段排序</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> age<span class="operator">&gt;=</span><span class="number">18</span> <span class="keyword">order</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure><p>加个限制条件</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> age<span class="operator">&gt;=</span><span class="number">18</span> <span class="keyword">order</span> <span class="keyword">by</span> age limit n[,m];</span><br></pre></td></tr></table></figure><p>只有n的时候就取前n条数据</p><p>既有n又有m的时候是取n（不包含第n条)之后的m条数据</p></blockquote><p>where,group by ,order by,limit 都可以省略，按照需求</p><hr><p>执行顺序:<br>FROM -&gt; WHERE -&gt; GROUP BY和聚合函数-&gt; SELECT -&gt; ORDER BY -&gt;LIMIT</p><h4 id="PYTHON-mysql"><a href="#PYTHON-mysql" class="headerlink" title="PYTHON&amp;mysql"></a>PYTHON&amp;mysql</h4><p><strong>获取链接对象</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#导入模块</span><br><span class="line"><span class="keyword">from</span> pymysql import <span class="keyword">Connect</span></span><br><span class="line"></span><br><span class="line">#connection(主机，端口，用户，密码)得到链接对象</span><br><span class="line"><span class="keyword">sql</span><span class="operator">=</span><span class="keyword">Connect</span>(</span><br><span class="line">    host<span class="operator">=</span>&quot;localhost&quot;,</span><br><span class="line">    port<span class="operator">=</span><span class="number">3306</span>,</span><br><span class="line">    <span class="keyword">user</span><span class="operator">=</span>&quot;root&quot;,</span><br><span class="line">    passwd<span class="operator">=</span>&quot;zzuli4514&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#关闭链接</span><br><span class="line">sql.close()</span><br></pre></td></tr></table></figure><p><strong>sql执行语句创建表单</strong></p><p>创建</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#导入模块</span><br><span class="line"><span class="keyword">from</span> pymysql import <span class="keyword">Connect</span></span><br><span class="line">#创建链接对象</span><br><span class="line"><span class="keyword">sql</span><span class="operator">=</span><span class="keyword">Connect</span>(</span><br><span class="line">    host<span class="operator">=</span>&quot;localhost&quot;,</span><br><span class="line">    port<span class="operator">=</span><span class="number">3306</span>,</span><br><span class="line">    <span class="keyword">user</span><span class="operator">=</span>&quot;root&quot;,</span><br><span class="line">    passwd<span class="operator">=</span>&quot;zzuli4514&quot;</span><br><span class="line">)</span><br><span class="line">print(sql.get_server_info())</span><br><span class="line">#链接数据库</span><br><span class="line">sql.select_db(&quot;text001&quot;)</span><br><span class="line">#创建对应的游标对象</span><br><span class="line"><span class="keyword">cursor</span><span class="operator">=</span>sql.cursor()</span><br><span class="line">#执行<span class="keyword">sql</span></span><br><span class="line">cursor.execute(&quot;create table sb2(id int)&quot;)</span><br><span class="line">#关闭链接</span><br><span class="line"></span><br><span class="line">sql.close()</span><br></pre></td></tr></table></figure><p>查询相关功能</p><p>利用游标对象执行不同的excute语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#导入模块</span><br><span class="line"><span class="keyword">from</span> pymysql import <span class="keyword">Connect</span></span><br><span class="line">#创建链接对象</span><br><span class="line"><span class="keyword">sql</span><span class="operator">=</span><span class="keyword">Connect</span>(</span><br><span class="line">    host<span class="operator">=</span>&quot;localhost&quot;,</span><br><span class="line">    port<span class="operator">=</span><span class="number">3306</span>,</span><br><span class="line">    <span class="keyword">user</span><span class="operator">=</span>&quot;root&quot;,</span><br><span class="line">    passwd<span class="operator">=</span>&quot;zzuli4514&quot;</span><br><span class="line">)</span><br><span class="line">print(sql.get_server_info())</span><br><span class="line">#链接数据库</span><br><span class="line">sql.select_db(&quot;text001&quot;)</span><br><span class="line">#创建对应的游标对象</span><br><span class="line"><span class="keyword">cursor</span><span class="operator">=</span>sql.cursor()</span><br><span class="line"></span><br><span class="line">#执行<span class="keyword">sql</span></span><br><span class="line">cursor.execute(&quot;select * from student&quot;)</span><br><span class="line">data:tuple<span class="operator">=</span>cursor.fetchall()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    print(i)</span><br><span class="line"># (<span class="number">4</span>, <span class="string">&#x27;尼干吗&#x27;</span>, <span class="number">13</span>, <span class="number">4</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"># (<span class="number">1</span>, <span class="string">&#x27;周杰伦&#x27;</span>, <span class="number">33</span>, <span class="number">1</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"># (<span class="number">2</span>, <span class="string">&#x27;王大山&#x27;</span>, <span class="number">43</span>, <span class="number">2</span>, <span class="string">&#x27;女&#x27;</span>)</span><br><span class="line"># (<span class="number">3</span>, <span class="string">&#x27;周星驰&#x27;</span>, <span class="number">23</span>, <span class="number">3</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"># (<span class="number">4</span>, <span class="string">&#x27;尼干吗&#x27;</span>, <span class="number">13</span>, <span class="number">4</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"># (<span class="number">1</span>, <span class="string">&#x27;周杰伦&#x27;</span>, <span class="number">33</span>, <span class="number">1</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"># (<span class="number">2</span>, <span class="string">&#x27;王大山&#x27;</span>, <span class="number">43</span>, <span class="number">2</span>, <span class="string">&#x27;女&#x27;</span>)</span><br><span class="line"># (<span class="number">3</span>, <span class="string">&#x27;周星驰&#x27;</span>, <span class="number">23</span>, <span class="number">3</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"># (<span class="number">4</span>, <span class="string">&#x27;尼干吗&#x27;</span>, <span class="number">13</span>, <span class="number">4</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#关闭链接</span><br><span class="line">sql.close()</span><br></pre></td></tr></table></figure><p>对数据的更改，需要使用connection对象的commit方法来确认</p><p><strong>1,直接在创建connection对象的时候直接设置自动确认属性</strong></p><p><strong>2，在执行mysql语句后手动确认</strong></p><p><strong>只有确认的修改才能生效</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">connect=connect(</span><br><span class="line">    host=<span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">    autocommit=<span class="literal">True</span>,</span><br><span class="line">    password=<span class="string">&quot;zzuli4514&quot;</span>,</span><br><span class="line">    user=<span class="string">&quot;root&quot;</span>,</span><br><span class="line">    port=<span class="number">3306</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">connect.select_db(<span class="string">&quot;text001&quot;</span>)</span><br><span class="line"></span><br><span class="line">cursor=connect.cursor()</span><br><span class="line"></span><br><span class="line">cursor.execute(<span class="string">&quot;insert into student values (9,&#x27;林俊杰&#x27;,20,3,&#x27;男&#x27;);&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># connect.commit()</span></span><br><span class="line">connect.close()</span><br></pre></td></tr></table></figure><h3 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h3><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><blockquote><p><strong>不定义全局变量，让函数持续的访问和修改一个外部的变量</strong></p></blockquote><p><strong><code>nonlocal</code>是一个关键字，用于在嵌套函数中声明一个变量为非局部变量。当在一个函数内部定义了另一个函数时，内部函数可以访问外部函数的变量。然而，&#x3D;&#x3D;默认情况下，内部函数只能读取外部函数的变量，而不能修改它们。&#x3D;&#x3D;</strong></p><p><strong>在内部函数中使用<code>nonlocal</code>关键字声明一个变量时，Python会沿着作用域链向上查找，找到最近的外部函数中具有相同名称的变量，并将其标记为非局部变量。</strong></p><p><strong>&#x3D;&#x3D;<code>nonlocal</code>关键字只能在嵌套函数中使用，而不能在全局作用域或单独的函数中使用。&#x3D;&#x3D;</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">account_mount</span>(<span class="params">total=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">atm</span>(<span class="params">money,choose=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> total</span><br><span class="line">        <span class="keyword">if</span> choose:</span><br><span class="line">            total+=money</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;取款:+<span class="subst">&#123;money&#125;</span>,账户余额:<span class="subst">&#123;total&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            total-=money</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;取款:-<span class="subst">&#123;money&#125;</span>,账户余额:<span class="subst">&#123;total&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> atm</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;无需通过定义全局变量，就可以通过函数实现持续访问，操作某个值&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;闭包使用的变量在函数内，很难被错误的误改&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;缺点，由于一直持续的引用外部函数的变量，会占用内存&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">atm=account_mount()</span><br><span class="line">atm(<span class="number">100</span>)</span><br><span class="line">atm(<span class="number">100</span>)</span><br><span class="line">atm(<span class="number">100</span>,choose=<span class="literal">False</span>)</span><br><span class="line">无需通过定义全局变量，就可以通过函数实现持续访问，操作某个值</span><br><span class="line">闭包使用的变量在函数内，很难被错误的误改</span><br><span class="line">缺点，由于一直持续的引用外部函数的变量，会占用内存</span><br><span class="line">取款:+<span class="number">100</span>,账户余额:<span class="number">100</span></span><br><span class="line">取款:+<span class="number">100</span>,账户余额:<span class="number">200</span></span><br><span class="line">取款:-<span class="number">100</span>,账户余额:<span class="number">100</span></span><br></pre></td></tr></table></figure><hr><h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><p><strong>在不修改原函数的内容的情况下</strong></p><p>实现给原函数添加新的功能</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;睡眠中。。。&quot;</span>)</span><br><span class="line">    time.sleep(random.randint(<span class="number">0</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">sleep</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我要汤姆睡觉了&quot;</span>)</span><br><span class="line">        sleep()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我要汤姆起床了&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">sheep=outer(sleep)</span><br><span class="line">sheep()</span><br><span class="line"><span class="comment"># 我要汤姆睡觉了</span></span><br><span class="line"><span class="comment"># 睡眠中。。。</span></span><br><span class="line"><span class="comment"># 我要汤姆起床了</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>改进后的写法，@**outer **</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">sleep</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我要汤姆睡觉了&quot;</span>)</span><br><span class="line">        sleep()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我要汤姆起床了&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;睡眠中。。。&quot;</span>)</span><br><span class="line">    time.sleep(random.randint(<span class="number">0</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep()</span><br><span class="line"><span class="comment"># 我要汤姆睡觉了</span></span><br><span class="line"><span class="comment"># 睡眠中。。。</span></span><br><span class="line"><span class="comment"># 我要汤姆起床了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p><strong>编程套路</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sb</span>:</span><br><span class="line">    name=<span class="literal">None</span></span><br><span class="line">SB=sb()</span><br></pre></td></tr></table></figure><p>​<strong>减少内存损耗，提供多个接口，只实例一个对象，导包传入一个对象。</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> 包 <span class="keyword">import</span> sb,SB</span><br><span class="line"></span><br><span class="line">s1=SB</span><br><span class="line">s2=SB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="built_in">print</span>(s2)</span><br><span class="line"><span class="comment"># &lt;包.sb object at 0x00000247FA22B590&gt;</span></span><br><span class="line"><span class="comment"># &lt;包.sb object at 0x00000247FA22B590&gt;</span></span><br></pre></td></tr></table></figure><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>当要创建很多很多对象的时候</p><p>有统一的getperson（）入口  易于维护</p><p>当发生修改的时候只修改工厂的方法就可以了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">worker</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">factory</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getperson</span>(<span class="params">self,<span class="built_in">type</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>==<span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> worker()</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">type</span>==<span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> teacher()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> student()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person=factory()</span><br><span class="line">worker=person.getperson(<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">teacher=person.getperson(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">student=person.getperson(<span class="string">&#x27;s&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="进程，线程-并行执行"><a href="#进程，线程-并行执行" class="headerlink" title="进程，线程, 并行执行"></a>进程，线程, 并行执行</h4><p><strong>一个操作系统中可以有多个进程，多任务运行</strong></p><p><strong>一个进程可以运行多个线程，多线程运行</strong></p><img src="/post/a378bd8e/image-20230717134650413.png" class="" title="image-20230717134650413"><p><strong>一个进程可以有多个线程，线程之间内存是共享的。</strong></p><p><strong>不同线程之间的内存是隔离的</strong></p><p><strong>并行执行</strong></p><p>同一时间做多个事情。</p><h4 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h4><p><strong>调用threading模块，创造一个线程对象就是一个线程</strong></p><p><strong>线程一般都持久干活</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我在唱歌啦啦啦啦啦&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dance</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我在跳舞嘎嘎&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sing=threading.Thread(target=sing)</span><br><span class="line">dance=threading.Thread(target=dance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sing.start()</span><br><span class="line">dance.start()</span><br><span class="line"></span><br><span class="line">一边唱歌一边跳舞</span><br></pre></td></tr></table></figure><p>参数</p><p>​    group: <em>None</em> <strong>&#x3D;</strong> None,<strong>忽略</strong><br>​    target: ((…) -&gt; <strong>object</strong>) <strong>|</strong> <em>None</em> <strong>&#x3D;</strong> None, <strong>执行任务名称</strong><br>​    name: <strong>str</strong> <strong>|</strong> <em>None</em> <strong>&#x3D;</strong> None, <strong>线程名一般不设置</strong><br>​    args: Iterable[Any] <strong>&#x3D;</strong> (), <strong>以元组的形式传参</strong><br>​    kwargs: Mapping[<strong>str</strong>, Any] <strong>|</strong> <em>None</em> <strong>&#x3D;</strong> None,  <strong>以字典的形式传参</strong></p><p>因为target&#x3D;任务名字，没有直接调用函数,所以要另一种方式传参</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>(<span class="params">msg</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dance</span>(<span class="params">msg</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sing=threading.Thread(target=sing,args=(<span class="string">&quot;我在唱歌啊啊啊啊啊&quot;</span>,))</span><br><span class="line">dance=threading.Thread(target=dance,kwargs=&#123;<span class="string">&quot;msg&quot;</span>:<span class="string">&quot;我在跳舞蹬蹬咚咚&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sing.start()</span><br><span class="line">dance.start()</span><br></pre></td></tr></table></figure><h4 id="网络编程Socket"><a href="#网络编程Socket" class="headerlink" title="网络编程Socket"></a>网络编程Socket</h4><p>进程之间的网路通信需要<strong>socket</strong>,数据的搬运工</p><hr><p><strong>两个进程之间要想进行通讯,就必须有服务端和客户端</strong></p><p><strong>socket服务端</strong></p><blockquote><h4 id="等待其他进程的连接-可以收发信息"><a href="#等待其他进程的连接-可以收发信息" class="headerlink" title="等待其他进程的连接,可以收发信息."></a>等待其他进程的连接,可以收发信息.</h4><ol><li><p>导入内置的socket对象</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment">#创建一个socket对象</span></span><br><span class="line">socket_severe=socket.socket()</span><br><span class="line">      </span><br><span class="line"><span class="comment">#服务端绑定在本机和端口</span></span><br><span class="line">socket_severe.bind((<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>))</span><br><span class="line">      </span><br><span class="line"><span class="comment">#设置服务端允许连接的数量</span></span><br><span class="line">socket_severe.listen(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#等待客户端连接，这是一个阻塞语句，只有成功链接了才会执行下一句,返回一个二元元组.</span></span><br><span class="line">client_socket,client_address=socket_severe.accept()</span><br><span class="line"><span class="comment">#表示连接的socket对象，以及客户端的地址信息。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;蛙趣，客户端连接成功!,并且客户端的地址信息是<span class="subst">&#123;client_address&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    client_msg=client_socket.recv(<span class="number">1024</span>).decode(<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">    <span class="comment">#这是一个阻塞语句，只有成功链接了才会执行下一句</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;客户端发送来的信息是:<span class="subst">&#123;client_msg&#125;</span>&quot;</span>)</span><br><span class="line">      </span><br><span class="line">    severe_sentmsg=<span class="built_in">input</span>(<span class="string">&quot;要给客户端回应的信息是:&quot;</span>)</span><br><span class="line">    client_socket.send(severe_sentmsg.encode(<span class="string">&quot;UTF-8&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> severe_sentmsg==<span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      </span><br><span class="line">   client_socket.close()</span><br><span class="line">socket_severe.close()</span><br></pre></td></tr></table></figure></li></ol></blockquote><p><strong>socket客户端</strong></p><blockquote><h4 id="主动连接服务端-可以收发信息"><a href="#主动连接服务端-可以收发信息" class="headerlink" title="主动连接服务端,可以收发信息."></a>主动连接服务端,可以收发信息.</h4><p><strong>全程使用client__socket对象</strong>,<strong>先发送后接受</strong></p><ol><li><p>导入socket模块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment">#创建一个socket对象</span></span><br><span class="line">client_socket=socket.socket()</span><br><span class="line"><span class="comment">#客户端连接具体的服务端</span></span><br><span class="line">      </span><br><span class="line">client_socket.connect((<span class="string">&quot;localhost&quot;</span>,<span class="number">8888</span>))</span><br><span class="line">      </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sent_data=<span class="built_in">input</span>(<span class="string">&quot;要给服务端发送的信息是:&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> sent_data==<span class="string">&quot;exit&quot;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    client_socket.send(sent_data.encode(<span class="string">&quot;UTF-8&quot;</span>))</span><br><span class="line">      </span><br><span class="line">    recv_data=client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">      </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;服务端返回来的信息是:<span class="subst">&#123;recv_data.decode(<span class="string">&#x27;UTF-8&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">      <span class="comment">#关闭链接</span></span><br><span class="line">client_socket.close()</span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p><strong>正则表达式,又称规则表达式( Regular Expression),是使用单个字符串来描述、匹配某个句法规则的字符串,常被用</strong><br><strong>来检索、替换那些符合某个模式(规则)的文本。</strong></p><blockquote><ol><li><strong>match,search,findall方法</strong></li><li><strong>span得到的是对应的(起始下标，末下标+1)</strong></li><li>match是从头到尾开始匹配，如果刚开始都没有，后面又也没用。</li><li>search也从头开始找，但只找第一个。</li><li>findall，全部找，不管在哪能找到，并以列表的形式返回</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#导入正则表达式的RE模块</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------------------match-------------------    &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;python itniuma python itniuma&quot;</span></span><br><span class="line"><span class="comment">#目标字符串</span></span><br><span class="line">result=re.<span class="keyword">match</span>(<span class="string">&quot;python&quot;</span>,<span class="built_in">str</span>)</span><br><span class="line"><span class="comment">#re模块的match对象实例化</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result.span())</span><br><span class="line"><span class="built_in">print</span>(result.group())</span><br><span class="line"><span class="comment"># &lt;re.Match object; span=(0, 6), match=&#x27;python&#x27;&gt;</span></span><br><span class="line"><span class="comment"># (0, 6)</span></span><br><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="comment">#从前到后开始找，如果刚开始就匹配不到，就算后面又有也没用</span></span><br><span class="line"><span class="comment"># 如果没有就返回none</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------------------search---------------------    &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;1python itniuma python itniuma&quot;</span></span><br><span class="line"></span><br><span class="line">result=re.search(<span class="string">&quot;python&quot;</span>,<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result.span())</span><br><span class="line"><span class="built_in">print</span>(result.group())</span><br><span class="line"><span class="comment">#  &lt;re.Match object; span=(1, 7), match=&#x27;python&#x27;&gt;</span></span><br><span class="line"><span class="comment"># (1, 7)</span></span><br><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="comment">#有的话只找一个！</span></span><br><span class="line"><span class="comment"># 如果没有就返回none</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------findall-----------------------    &quot;</span>)</span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;1python itniuma python itniuma&quot;</span></span><br><span class="line">result=re.findall(<span class="string">&quot;python&quot;</span>,<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># print(result.count(&quot;python&quot;))</span></span><br><span class="line"><span class="comment"># [&#x27;python&#x27;, &#x27;python&#x27;]</span></span><br></pre></td></tr></table></figure></blockquote><hr><h4 id="正则表达式——元字符匹配"><a href="#正则表达式——元字符匹配" class="headerlink" title="正则表达式——元字符匹配"></a>正则表达式——元字符匹配</h4><table><thead><tr><th align="center">字符</th><th>功能</th></tr></thead><tbody><tr><td align="center">.</td><td>匹配任意1个字符(除了\n) ，.匹配点本身</td></tr><tr><td align="center">[]</td><td>匹配[ ]中列举的字符</td></tr><tr><td align="center">\d</td><td>匹配数字，即0-9</td></tr><tr><td align="center">\D</td><td>匹配非数字</td></tr><tr><td align="center">\s</td><td>匹配空白，即空格、tab键 .</td></tr><tr><td align="center">\S</td><td>匹配非空白</td></tr><tr><td align="center">\w</td><td>匹配单词字符，即a-Z、A-Z、  日-9、 _</td></tr><tr><td align="center">\W</td><td>匹配非单词字符</td></tr></tbody></table><p>r标记是查找原始的字符串，转义字符无效</p><p><strong>数量匹配</strong></p><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>*</td><td>匹配前一个规则的字符出现0至无数次  [0,+∞)</td></tr><tr><td>+</td><td>匹配前一个规则的字符出现1至无数次   [1,+∞)</td></tr><tr><td>？</td><td>匹配前一个规则的字符出现0次或1次     o||1</td></tr><tr><td>{m}</td><td>匹配前一个规则的字符出现m次    &#x3D;&#x3D;m</td></tr><tr><td>{m,}</td><td>匹配前一个规则的字符出现最少m次  &gt;&#x3D;m</td></tr><tr><td>{m,n}</td><td>匹配前一个规则的字符出现m到n次   [m,n]</td></tr></tbody></table><p><strong>边界匹配</strong></p><p>^$匹配整体需要加这个</p><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>^</td><td>匹配字符串开头</td></tr><tr><td>$</td><td>匹配字符串结尾</td></tr><tr><td>\b</td><td>匹配一个单词的边界</td></tr><tr><td>\B</td><td>匹配非单词边界</td></tr></tbody></table><p>分组匹配</p><table><thead><tr><th align="center">字符</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">|</td><td align="left">匹配左右任意一个表达式</td></tr><tr><td align="center">（）</td><td align="left">将括号中字符作为一个分组</td></tr></tbody></table><img src="/post/a378bd8e/image-20230720182736642.png" class="" title="image-20230720182736642"><p>如果正则表达式里面有（），会把每一个（）都列出来，findall，每一个组的匹配返回，可以外加一个大括号.</p>]]></content>
      
      
      <categories>
          
          <category> python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp2.0</title>
      <link href="/post/a77e947a.html"/>
      <url>/post/a77e947a.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h1><p>本阶段主要针对C++&#x3D;&#x3D;面向对象&#x3D;&#x3D;编程技术做详细讲解，探讨C++中的核心和精髓。</p><h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p><ul><li>代码区：存放<strong>函数体</strong>的<strong>二进制代码</strong>，由<strong>操作系统</strong>进行管理的</li><li>注释不在代码区</li><li>全局区：存放<strong>全局变量和静态变量以及常量</strong></li><li>栈区：由<strong>编译器自动分配释放</strong>, 存放<strong>函数的参数值</strong>,<strong>局部变量</strong>等</li><li>堆区：由**程序员分配和释放,**<strong><strong>若程序员不释放,程序结束时由操作系统回收</strong></strong></li></ul><p><strong>内存四区意义：</strong></p><p>不同区域存放的数据，<strong>赋予不同的生命周期</strong>, 给我们更大的<strong>灵活编程</strong></p><h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>​<strong>在程序编译后，生成了exe可执行程序</strong>，<strong>未执行该程序前</strong>分为两个区域</p><p>​<strong>代码区：</strong></p><p>​存放 CPU 执行的机器指令</p><p>​代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，<strong>只需要在内存中有一份代码即可</strong></p><p>​代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令,<strong>金币变点券</strong></p><p>​<strong>全局区：</strong></p><p>​<strong>全局变量 和 静态变量</strong>存放在此.</p><p>​全局区还包含了<strong>常量区</strong>, <strong>字符串常量和全局常量</strong>存放在此.</p><p>&#x3D;&#x3D;<strong>局部常量也局部变量都在栈区</strong>&#x3D;&#x3D;</p><p>​&#x3D;&#x3D;该区域的数据在程序结束后由操作系统释放&#x3D;&#x3D;.</p><img src="/post/a77e947a/image-20230725153630117.png" class="" title="image-20230725153630117"><hr><p>(int)指针的地址，是不被定义的行为.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">10</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;a)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;b)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;g_a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;g_b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;s_a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;s_b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;<span class="string">&quot;hello world&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;c_g_a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;c_g_b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;c_l_a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;c_l_b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印结果：</p><p><strong>局部变量</strong>a地址为： 6422044<br><strong>局部变量</strong>b地址为： 6422040<br>全局变量g_a地址为： 4206608<br>全局变量g_b地址为： 4206612<br>静态变量s_a地址为： 4206616<br>静态变量s_b地址为： 4206620<br>字符串常量地址为： 4210842<br>全局常量c_g_a地址为： 4210692<br>全局常量c_g_b地址为： 4210696<br><strong>局部常量</strong>c_l_a地址为： 6422036<br><strong>局部常量</strong>c_l_b地址为： 6422032<br>请按任意键继续. . .</p><img src="/post/a77e947a/1545017602518.png" class="" width="1545017602518"><p>总结：</p><ul><li>C++中在<strong>程序运行前</strong>分为全局区和代码区</li><li>代码区特点是<strong>共享和只读</strong></li><li>全局区中存放&#x3D;&#x3D;全局变量、静态变量、常量&#x3D;&#x3D;,<strong>不包括局部常量和局部变量</strong></li><li>常量区中存放 const修饰的<strong>全局常量  和 字符串常量</strong></li></ul><h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p>​<strong>栈区：</strong><strong><strong>编译器的天下.</strong></strong></p><p>​由<strong>编译器</strong>自动分配释放, 存放<strong>函数的参数值,局部变量</strong>等</p><p>​注意事项：<strong>不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;<span class="comment">//理论上第一次打印10</span></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;<span class="comment">//第二次打印乱码，就是因为编译器帮你做了一次保留，栈区的数据由编译器主宰。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>堆区：</strong></p><p>​由<strong>程序员分配释放,若程序员不释放,程序结束时由操作系统回收</strong></p><p>​在C++中<strong>主要利用new在堆区开辟内存</strong></p><p>​&#x3D;&#x3D;并且返回new出来内存的地址，也就是指针！&#x3D;&#x3D;</p><img src="/post/a77e947a/image-20230725160019240.png" class="" title="image-20230725160019240"><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;<span class="comment">//都是10，因为堆区的数据只有点击了x才被释放。在此之前一直存在。不像堆区离开了局部（函数）就被释放了，虽然编译器会帮你保留一次，但第二次就要出问题了。</span></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>堆区数据由程序员管理开辟和释放</p><p>堆区数据利用new关键字进行开辟内存</p><h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>​C++中利用&#x3D;&#x3D;new&#x3D;&#x3D;操作符在堆区开辟数据</p><p>​堆区开辟的数据，<strong>由程序员手动开辟，手动释放</strong>，释放利用操作符 &#x3D;&#x3D;delete&#x3D;&#x3D;</p><p>​语法：<code> new 数据类型</code>(初始值)</p><p>​利用new创建的数据，<strong>会返回该数据对应的类型的指针(地址)</strong></p><p>int *a&#x3D;new int(10)</p><p>​&#x3D;&#x3D;最后需要delete对应的指针！&#x3D;&#x3D;加new返回的 指针！</p><blockquote><img src="/post/a77e947a/image-20230725160534499.png" class="" title="image-20230725160534499"></blockquote><p>​&#x3D;&#x3D;<strong>释放的空间不可访问</strong>&#x3D;&#x3D;</p><p><strong>示例1： 基本语法</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用delete释放堆区数据</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//15735568</span></span><br></pre></td></tr></table></figure><p><strong>示例2：开辟数组</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//开辟字符串,开辟字符串数组的时候换成[]再加个数</span></span><br><span class="line">    string* str=<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    cout&lt;&lt;*str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = i + <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []  arr;</span><br><span class="line">    <span class="keyword">delete</span> str;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p><strong>作用： <strong>给</strong>变量</strong>起别名</p><p>土豆，马铃薯都是。。</p><p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p><p>类型得相同</p><img src="/post/a77e947a/image-20230725170131910.png" class="" title="image-20230725170131910"><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h3><ul><li><strong>引用必须初始化</strong></li><li>引用在初始化后，不可以改变也就是</li><li>一旦引用被初始化绑定到一个对象上，它将一直引用该对象，无法改变引用所绑定的对象。</li></ul><p>示例：</p><img src="/post/a77e947a/image-20230725170414023.png" class="" title="image-20230725170414023"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line"><span class="type">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line">    <span class="comment">//实际上是操作a的值。。</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利<strong>用引用的技术让形参修饰实参</strong></p><p><strong>优点：</strong>可以简化指针修改实参</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sp1</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sp2</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=*a;</span><br><span class="line">    *a=*b;</span><br><span class="line">    *b=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sp3</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入两个数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;值传递，不可以修改实参的本身&quot;</span>&lt;&lt;endl;</span><br><span class="line">      <span class="built_in">sp1</span>(a,b);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;地址传递--指针，可以修改实参的本身&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">sp2</span>(&amp;a,&amp;b);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;地址传递--引用，可以修改实参的本身&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">sp3</span>(a,b);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>总结：<strong>通过引用参数产生的效果同按地址传递是一样的</strong>。引用的语法更清楚简单</p><h5 id="当引用作为一个函数形参时，它所引用的变量的生命周期必须保证在函数的执行期间内是有效的。在函数执行期间内，对于引用所指向的变量所进行的任何修改都将影响到函数调用方式中的原始变量。"><a href="#当引用作为一个函数形参时，它所引用的变量的生命周期必须保证在函数的执行期间内是有效的。在函数执行期间内，对于引用所指向的变量所进行的任何修改都将影响到函数调用方式中的原始变量。" class="headerlink" title="当引用作为一个函数形参时，它所引用的变量的生命周期必须保证在函数的执行期间内是有效的。在函数执行期间内，对于引用所指向的变量所进行的任何修改都将影响到函数调用方式中的原始变量。"></a>当引用作为一个函数形参时，它所引用的变量的生命周期必须保证在函数的执行期间内是有效的。在函数执行期间内，对于引用所指向的变量所进行的任何修改都将影响到函数调用方式中的原始变量。</h5><p>引用和指针操作最大的区别在于，指<strong>针的方式借助的形参会占用栈区空间</strong>，而用引用则不会，<strong>因此引用节省了栈区空间！</strong></p></blockquote><hr><h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>作用：引用是可以<strong>作为函数的返回值</strong>存在的</p><p>注意：**&#x3D;&#x3D;不要返回局部变量引用和地址&#x3D;&#x3D;**</p><p><strong>也要用引用的形式去接受</strong></p><p><strong>变量有可以同时存在多个别名，别名与别名与变量之间的操作是共通的</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;b=a;</span><br><span class="line">    <span class="type">int</span> &amp;c=a;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;c=&quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用法：<em>函数调用作为左值</em></p><hr><p>在 C++ 中，<strong>不建议返回指向局部变量的引用，因为局部变量在函数执行完毕后会被销毁，而引用仍然指向该变量的内存地址。</strong>这样会导致返回的引用指向一个无效的内存位置，访问该引用可能会导致未定义行为。</p><p><strong>而静态变量是在程序运行期间一直存在的，不会在函数执行完毕后被销毁。</strong>因此，返回静态变量的引用是安全的，因为静态变量的生命周期超出了函数的作用域。</p><hr><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回a的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span><span class="comment">//全局区，在整个程序运行完才释放</span></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">    <span class="comment">//返回的a是以类型“int&amp;”返回的，所以必须要以类型“int&amp;”去接收，这里用ref去接收，即int&amp; ref = a  ，即ref为a的别名</span></span><br><span class="line"><span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果函数做左值，那么必须返回引用,ref2也是a的别名</span></span><br><span class="line"><span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">////</span></span><br><span class="line">    <span class="comment">//int &amp;别名=1000 也相当于是a的别名只不过是函数</span></span><br><span class="line"><span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">////</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>int * const 变量名字&#x3D;</p><p>费曼学习法，先学面向过程C，在学面向对象CSharp，然后又滚来学C++面向对象过程（滑稽）</p><h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p><blockquote><p>常量指针是指 指针指向的数据不可更改</p><p>const指针常量是值 指针的指向不可更改</p></blockquote><p>讲解示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line"><span class="type">int</span>&amp; ref = a; </span><br><span class="line">ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">func</span>(a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p><h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p><strong>作用：</strong>常量引用<strong>主要用来修饰形参，防止误操作</strong></p><p>在函数形参列表中，可以加改变实参</p><p>引用必须引用一块合法的内存空间</p><p>int&amp; a&#x3D;10;  不可以</p><p>const int&amp; a&#x3D;10  可以</p><p>相当于，编译器帮助这样处理.</p><p>{</p><p>int temp&#x3D;10;</p><p>const int&amp; a&#x3D;temp;</p><p>}</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="comment">//v += 10;</span></span><br><span class="line">cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="comment">//void showValue(const int* const name) &#123;</span></span><br><span class="line"><span class="comment">//v += 10;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; v &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line"><span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p><p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p><p>&#x3D;&#x3D;如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值&#x3D;&#x3D;</p><h6 id="如果函数声明有默认值，函数实现的时候就不能有默认参数"><a href="#如果函数声明有默认值，函数实现的时候就不能有默认参数" class="headerlink" title="&#x3D;&#x3D;如果函数声明有默认值，函数实现的时候就不能有默认参数&#x3D;&#x3D;"></a>&#x3D;&#x3D;如果函数<strong>声明有默认值</strong>，函数实现的时候就不能有默认参数&#x3D;&#x3D;</h6><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p><p>占一个位置，可以接受实参。</p><p><strong>占位参数必须填补</strong></p><p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> =<span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h4 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p><p><strong>函数重载满足条件：</strong></p><ul><li><p>同一个作用域下</p></li><li><p>函数名称相同</p></li><li><p>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong>（前提是参数类型不同！！！）</p></li><li><blockquote><p>函数的返回值类型不可以重载！！！</p></blockquote></li></ul><p><strong>注意:</strong>  <strong>函数的返回值不可以作为函数重载的条件</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h4><ul><li><strong>引用作为重载条件</strong></li><li>函数重载碰到<strong>函数默认参数</strong></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">func</span>(a); <span class="comment">//调用无const</span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const</span></span><br><span class="line">    相当于弄了一个临时变量</span><br><span class="line">      <span class="comment">//  int &amp;a=10 不可以</span></span><br><span class="line">      <span class="comment">//  const int &amp;a=10;可以</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免 二义性！~！！</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="&#x3D;&#x3D;4 类和对象&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>4</strong> 类和对象&#x3D;&#x3D;</h2><p>C++面向对象的三大特性为：&#x3D;&#x3D;封装、继承、多态&#x3D;&#x3D;</p><p>C++认为&#x3D;&#x3D;万事万物都皆为对象&#x3D;&#x3D;，对象上有其属性和行为</p><blockquote><p><strong>类里面的属性和行为都是成员！</strong></p><p><strong>创建具体的对象的过程叫做类的实例化！</strong></p></blockquote><p><strong>例如：</strong></p><p>​人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p><p>​车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、开空调…</p><p>​具有相同性质的&#x3D;&#x3D;对象&#x3D;&#x3D;，我们可以抽象称为&#x3D;&#x3D;类&#x3D;&#x3D;，人属于人类，车属于车类</p><h3 id="4-1-封装–1"><a href="#4-1-封装–1" class="headerlink" title="4.1 封装–1"></a>4.1 封装–1</h3><h4 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1  封装的意义"></a>4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p><p>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为<strong>加以权限控制</strong></li></ul><p><strong>封装意义一：</strong></p><p>​在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p><p><strong>示例1：</strong>设计一个圆类，求圆的周长</p><p><strong>示例代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="type">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//行为</span></span><br><span class="line"><span class="comment">//获取到圆的周长</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//2 * pi  * r</span></span><br><span class="line"><span class="comment">//获取圆的周长</span></span><br><span class="line"><span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过圆类，创建圆的对象</span></span><br><span class="line"><span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">Circle c1;</span><br><span class="line">c1.m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p><p><strong>示例2代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setname</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setid</span><span class="params">(string number)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;number=number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showmessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="keyword">this</span>-&gt;name&lt;&lt;<span class="string">&quot;----&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;number&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    string number;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    student xrb;</span><br><span class="line">    xrb.<span class="built_in">setname</span>(<span class="string">&quot;徐润波&quot;</span>);</span><br><span class="line">    xrb.<span class="built_in">setid</span>(<span class="string">&quot;542207230725&quot;</span>);</span><br><span class="line">    xrb.<span class="built_in">showmessage</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>封装意义二：</strong></p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ol><li>public        公共权限  </li><li>protected 保护权限</li><li>private      私有权限</li></ol><blockquote><p>在C++中，类的成员可以不同的访问权限，包括私有（private）、保护（protected）和公共（public）权限。这些权限决定了类的成员对于<strong>类内部和类外部</strong>的<strong>可见性和可访问性。</strong></p><p><strong>私有权限（private）是最严格的权限</strong>，它表示<strong>只有类内部的成员函数可以访问该成员，</strong>类外部的代码无法直接访问私有成员。私有成员对于类外部的用户是隐藏的，只有类内部的函数可以直接访问和操作私有成员。私有成员常用于封装类的实现细节，以确保数据的安全性和一致性。</p><p>保护权限（protected）<strong>介于私有权限和公共权限之间。</strong>保护成员<strong>可以被类内部的成员函数和派生类的成员函数访问</strong>，但对于类外部的代码是不可见的。<strong>保护成员常用于实现继承中的数据共享和派生类的访问控制。</strong></p><p>区别总结如下：</p><ul><li><strong>私有权限（private）：只有类内部的成员函数可以访问，类外部的代码无法直接访问。</strong></li><li>*<em>保护权限（protected）：类内部的成员函数和派生类的成员函数可以访问，类外部的代码无法直接访问。</em></li><li><strong>公共权限（public）：类内部的成员函数和类外部的代码都可以访问。</strong></li></ul><p>需要注意的是，这些<strong>访问权限只是在编译时进行的静态检查</strong>，<em><strong>而不是运行时的限制</strong></em>。因此，通过类的<strong>公共成员函数可以间接地访问私有和保护成员</strong>。</p></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string m_Car;</span><br><span class="line"></span><br><span class="line"><span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">m_Password = <span class="number">123456</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line"><span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line"><span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p><p>区别：</p><blockquote><ul><li><h4 id="struct-默认权限为公共"><a href="#struct-默认权限为公共" class="headerlink" title="struct 默认权限为公共"></a>struct 默认权限为公共</h4></li><li><h4 id="class-默认权限为私有"><a href="#class-默认权限为私有" class="headerlink" title="class   默认权限为私有"></a>class   默认权限为私有</h4></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">C1 c1;</span><br><span class="line">c1.m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">C2 c2;</span><br><span class="line">c2.m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 &#x3D;&#x3D;成员属性设置为私有&#x3D;&#x3D;"></a>4.1.3 &#x3D;&#x3D;成员属性设置为私有&#x3D;&#x3D;</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以<strong>自己控制读写权限</strong></p><p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p><hr><p><em>在 C++ 中，私有成员是类的成员，<strong>只有类的成员函数可以直接访问和修改私有成员。</strong>其他函数或代码块无法直接访问和修改私有成员。</em></p><p><em>然而，<strong>可以通过指针间接访问和修改私有成员</strong>。如果你有一个指向类对象的指针，你可以使用指针来访问和修改私有成员。这是因为<strong>指针可以具有与类成员函数相同的访问权限。</strong></em></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateMember;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPrivateMember</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        privateMember = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getPrivateMember</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateMember;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    MyClass* ptr = &amp;obj;</span><br><span class="line"></span><br><span class="line">    ptr-&gt;<span class="built_in">setPrivateMember</span>(<span class="number">200</span>);</span><br><span class="line">    <span class="type">int</span> value = ptr-&gt;<span class="built_in">getPrivateMember</span>();</span><br><span class="line">    cout&lt;&lt;value&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//姓名设置可读可写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取年龄</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置年龄</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情人设置为只写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">        m_Lover = lover;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">    string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Person p;</span><br><span class="line">    <span class="comment">//姓名设置</span></span><br><span class="line">    p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//年龄设置</span></span><br><span class="line">    p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情人设置</span></span><br><span class="line">    p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习案例1：设计立方体类</strong></p><p>设计立方体类(Cube)</p><p>求出立方体的面积和体积</p><p>分别用全局函数和成员函数判断两个立方体是否相等。</p><img src="/post/a77e947a/1545533548532.png" class="" width="1545533548532"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cubic</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getwidth</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setwidth</span><span class="params">(<span class="type">int</span> width)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;width=width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getlength</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setlength</span><span class="params">(<span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;length=length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getheight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setheight</span><span class="params">(<span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;height=height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">caculateV</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;length*<span class="keyword">this</span>-&gt;height*<span class="keyword">this</span>-&gt;width;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cubic abc;</span><br><span class="line">    abc.<span class="built_in">setwidth</span>(<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;得到立方体的宽度&quot;</span>&lt;&lt;abc.<span class="built_in">getwidth</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    abc.<span class="built_in">setlength</span>(<span class="number">4</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;得到立方体的长度&quot;</span>&lt;&lt;abc.<span class="built_in">getlength</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    abc.<span class="built_in">setheight</span>(<span class="number">5</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;得到立方体的高度&quot;</span>&lt;&lt;abc.<span class="built_in">getheight</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;得到立方体的体积V=&quot;</span>&lt;&lt;abc.<span class="built_in">caculateV</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到立方体的宽度3</span></span><br><span class="line"><span class="comment">//得到立方体的长度4</span></span><br><span class="line"><span class="comment">//得到立方体的高度5</span></span><br><span class="line"><span class="comment">//得到立方体的体积V=60</span></span><br><span class="line"><span class="comment">//请按任意键继续. .</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习案例2：点和圆的关系</strong></p><p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p><img src="/post/a77e947a/1545533829184.png" class="" width="1545533829184"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getx</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setx</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gety</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sety</span><span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y=y;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setx</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;c_x=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sety</span><span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;c_y=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setr</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;c_r=r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;c_r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">CaculateTheRelationshipBetweenCircleAndPoint</span><span class="params">(point abc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> p_x=abc.<span class="built_in">getx</span>();</span><br><span class="line">        <span class="type">int</span> p_y=abc.<span class="built_in">gety</span>();</span><br><span class="line">        <span class="type">int</span> distance=<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">sqrt</span>((p_x-<span class="keyword">this</span>-&gt;c_x)*(p_x-<span class="keyword">this</span>-&gt;c_x)-(p_y-<span class="keyword">this</span>-&gt;c_y)*(p_y-<span class="keyword">this</span>-&gt;c_y)));</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> c_x;</span><br><span class="line">    <span class="type">int</span> c_y;</span><br><span class="line">    <span class="type">int</span> c_r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    circle circle;</span><br><span class="line">    circle.<span class="built_in">setx</span>(<span class="number">0</span>);</span><br><span class="line">    circle.<span class="built_in">sety</span>(<span class="number">1</span>);</span><br><span class="line">    circle.<span class="built_in">setr</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    point point;</span><br><span class="line"></span><br><span class="line">    point.<span class="built_in">setx</span>(<span class="number">2</span>);</span><br><span class="line">    point.<span class="built_in">sety</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result=circle.<span class="built_in">CaculateTheRelationshipBetweenCircleAndPoint</span>(point);</span><br><span class="line">    <span class="keyword">if</span>(result==circle.<span class="built_in">getr</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;点在圆上！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(result&gt;circle.<span class="built_in">getr</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;点在园外!!!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;点在园内！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//点在园外!!!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="static-cast和reinterpret-cast"><a href="#static-cast和reinterpret-cast" class="headerlink" title="static_cast&lt;&gt;和reinterpret_cast&lt;&gt;"></a><em><strong>static_cast&lt;&gt;和reinterpret_cast&lt;&gt;</strong></em></h4><blockquote><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast&lt;&gt;"></a>static_cast&lt;&gt;</h2><p><code>static_cast&lt;&gt;</code> 是 C++ 中的一种<strong>类型转换运算符</strong>，用于在编译时进行类型转换。它可以用于将一种类型转换为另一种类型，包括基本类型、类类型和指针类型。</p><p><code>static_cast&lt;&gt;</code> 的语法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;目标类型&gt;(表达式)</span><br></pre></td></tr></table></figure><p>其中，<code>目标类型</code> 是你希望将表达式转换为的类型，而 <code>表达式</code> 则是要进行转换的值或<strong>变量</strong>。</p><p>下面是一些示例用法：</p><ol><li>将整数转换为浮点数：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> result = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(num);</span><br></pre></td></tr></table></figure><ol start="2"><li>将浮点数转换为整数：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> num = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(num);</span><br></pre></td></tr></table></figure><ol start="3"><li><em>将指针类型转换为另一种指针类型</em>：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">char</span>* result = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(ptr);</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>static_cast&lt;&gt;</code> <strong>不会执行运行时的类型检查</strong>，因此转换的安全性需要由开发者自行保证。如果转换是不安全的，建议使用更加安全的类型转换运算符，如 <code>dynamic_cast&lt;&gt;</code> 或 <code>reinterpret_cast&lt;&gt;</code>。</p><p>总结起来，<code>static_cast&lt;&gt;</code> 是 C++ 中一种常用的类型转换运算符，<strong>用于在编译时进行类型转换</strong>。它可以将一种类型转换为另一种类型，但需要开发者自行确保转换的安全性。</p><hr><hr><hr><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast&lt;&gt;"></a>reinterpret_cast&lt;&gt;</h2><p><code>reinterpret_cast&lt;&gt;</code> 是 C++ 中的一种类型转换运算符，用<strong>于执行底层的强制类型转换</strong>。它可以将一个指针或引用转换为另一种指针或引用类型，甚至可以将指针或引用转换为整数类型。</p><p><code>reinterpret_cast&lt;&gt;</code> 的语法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reinterpret_cast</span>&lt;目标类型&gt;(表达式)</span><br></pre></td></tr></table></figure><p>其中，<code>目标类型</code> 是你希望将表达式转换为的类型，而 <code>表达式</code> 则是要进行转换的值或变量。</p><p>下面是一些示例用法：</p><ol><li>将指针类型转换为另一种指针类型：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">char</span>* result = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ptr);</span><br></pre></td></tr></table></figure><ol start="2"><li>将指针类型转换为整数类型：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">uintptr_t</span> result = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(ptr);</span><br></pre></td></tr></table></figure><ol start="3"><li>将整数类型转换为指针类型：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">uintptr_t</span> num = <span class="number">12345</span>;</span><br><span class="line"><span class="type">int</span>* result = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(num);</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>reinterpret_cast&lt;&gt;</code> 执行的是一种底层的强制类型转换，<strong>它可以绕过编译器的类型检查</strong>，因此需要开发者自行确保转换的安全性。使用 <code>reinterpret_cast&lt;&gt;</code> 进行类型转换时应该非常小心，确保转换的结果在语义上是合理的。</p><p>总结起来，<code>reinterpret_cast&lt;&gt;</code> 是 C++ 中一种类型转换运算符，用于执行底层的强制类型转换。它可以将指针或引用转换为另一种指针或引用类型，甚至可以将指针或引用转换为整数类型。使用 <code>reinterpret_cast&lt;&gt;</code> 进行类型转换时需要非常小心，确保转换的安全性和语义正确性。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">10</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;a)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;b)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><ul><li>生活中我们买的电子产品都基本会有<strong>出厂设置</strong>，在某一天我们不用时候也会删除一些自己信息数据保证安全</li><li>C++中的<strong>面向对象来源于生活，</strong>每个对象也都会有<strong>初始设置</strong>以及 对象销毁前的<strong>清理数据</strong>的设置。</li></ul><h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p><p><strong>多个对象的时候，先构造的后析构！！</strong></p><p><strong>在类外调用类的成员</strong></p><p><strong>类名::成员</strong></p><blockquote><p>​一个对象或者变量没有初始状态，对其使用后果是未知</p><p>​同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p></blockquote><p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这<strong>两个函数将会被编译器自动调用</strong>，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译<strong>器强制要我们做的事情</strong>，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p><p><strong>编译器提供的构造函数和析构函数是-&#x3D;空实现-&#x3D;。</strong></p><ul><li>构造函数：主要作用在于创建对象时<strong>为对象的成员属性赋值</strong>，<strong>构造函数由编译器自动调用</strong>，无须手动调用。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong><em>系统自动调用</em>，执行一些<strong>清理工作</strong>。</li></ul><p>可以写在类内</p><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><blockquote><ol><li><strong>构造函数，没有返回值也写void</strong></li><li><strong>函数名称与类名相同</strong></li><li><strong>构造函数可以有参数，因此可以发生重载</strong></li><li>程序在<strong>调用对象时候会自动调用构造</strong>，无须手动调用**,而且只会调用一次**</li></ol></blockquote><p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p><blockquote><ol><li><h5 id="析构函数，没有返回值也写void"><a href="#析构函数，没有返回值也写void" class="headerlink" title="析构函数，没有返回值也写void"></a>析构函数，没有返回值也写void</h5></li><li><h5 id="函数名称是类名，但前面要加个"><a href="#函数名称是类名，但前面要加个" class="headerlink" title="函数名称是类名，但前面要加个~"></a>函数名称是类名，但前面要加个~</h5></li><li><h5 id="函数不可以有参数，不能发生重载"><a href="#函数不可以有参数，不能发生重载" class="headerlink" title="函数不可以有参数，不能发生重载"></a>函数不可以有参数，不能发生重载</h5></li><li><h5 id="程序在对象销毁前对自动调用析构函数，无需手动调用，且只会调用一次"><a href="#程序在对象销毁前对自动调用析构函数，无需手动调用，且只会调用一次" class="headerlink" title="程序在对象销毁前对自动调用析构函数，无需手动调用，且只会调用一次"></a>程序在<em>对象销毁前</em>对自动调用析构函数，无需手动调用，且只会调用一次</h5></li></ol></blockquote><hr><p>C++ 类的构造函数和析构函数可以在类的定义外部进行定义和实现。这样做的目的是将类的声明和实现分离，使代码更加清晰和可维护。</p><p><strong>构造函数和析构函数的定义和实现可以放在类的定义之后的任何地方，通常会放在类的定义之后的源文件中。</strong></p><p>以下是一个示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyClass.h 头文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateMember;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(); <span class="comment">// 构造函数的声明</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>(); <span class="comment">// 析构函数的声明</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyClass.cpp 源文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">    <span class="comment">// 构造函数的实现</span></span><br><span class="line">    privateMember = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass::~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">    <span class="comment">// 析构函数的实现</span></span><br><span class="line">    <span class="comment">// 可以进行资源的释放等清理工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>MyClass</code> 类的构造函数和析构函数的声明放在了头文件 <code>MyClass.h</code> 中，而定义和实现则放在了源文件 <code>MyClass.cpp</code> 中。这样可以使类的接口和实现分离，提高代码的可读性和可维护性。</p><p><strong>如果构造函数和析构函数的定义和实现在类的定义内部，编译器会隐式地将它们声明为内联函数。</strong>而将它们定义在类的定义外部时，不会自动成为内联函数，需要显式地在定义中加上 <code>inline</code> 关键字来指示编译器将其作为内联函数处理。</p><blockquote><p><strong>当编译器将函数的定义插入到调用它的地方时，这被称为内联展开</strong>。相比于生成函数调用，内联展开具有以下优点和缺点：</p><p>优点：</p><ol><li><strong>减少函数调用的开销</strong>：函数调用涉及到保存和恢复寄存器、跳转到函数代码、返回地址等操作，这些操作会消耗一定的时间和空间。通过内联展开，可以避免这些开销，从而提高程序的执行效率。</li><li><strong>优化循环和递归</strong>：内联展开可以优化循环和递归函数的性能。将循环或递归函数内联展开，可以减少函数调用的次数，避免重复的栈帧创建和销毁，从而加快循环或递归的执行速度。</li><li><strong>提高编译器优化的机会</strong>：内联展开可以<strong>提供更多的代码上下文信息给编译器</strong>，使其有更多的优化机会。例如，编译器可以进行常量折叠、循环展开、代码复制等优化，从而进一步提高程序的执行效率。</li></ol><p>缺点：</p><ol><li><strong>增加代码的体积</strong>：内联展开会将函数的定义插入到调用它的地方，这会增加代码的体积。如果函数体很大，内联展开可能会导致代码膨胀，<strong>增加可执行文件的大小。</strong></li><li>增加编译时间：内联展开会增加编译器的工作量，因为编译器需要将函数的定义插入到每个调用它的地方。<strong>如果程序中有大量的函数调用，内联展开可能会导致编译时间的增加。</strong></li><li>可读性下降：内联展开会使代码变得更加冗长，可读性可能会下降。特别是对于复杂的函数体，将其内联展开可能会使代码难以理解和维护。</li></ol><p>综上所述，<strong>内联展开可以提高程序的执行效率，特别是对于频繁调用的小型函数和循环或递归函数。</strong>然而，内联展开也会增加代码的体积和编译时间，并可能降低代码的可读性。因此，在使用内联展开时需要权衡这些优缺点，并根据具体的情况进行选择。</p></blockquote><hr><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;我是构造函数，调用对象前会自动执行，只执行一次，没有返回值也不写void，可以有参数也就说我一般用于创建对象的同时对其成员进行赋值&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;我是析构函数，对象销毁前会被自动执行，没有返回值也不写void，不可以有参数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;begin&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;end&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//begin</span></span><br><span class="line"><span class="comment">//我是构造函数，调用对象前会自动执行，只执行一次，没有返回值也不写void，可以有参数也就说我一般用于创建对象的同时对其成员进行赋值</span></span><br><span class="line"><span class="comment">//我是析构函数，对象销毁前会被自动执行，没有返回值也不写void，不可以有参数</span></span><br><span class="line"><span class="comment">//end</span></span><br></pre></td></tr></table></figure><h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p><p>​按参数分为： 无参构造和有参构造</p><p>​按类型分为： 普通构造（简单的有参无参）和拷贝构造</p><p>三种调用方式：</p><p>​括号法</p><p>​显示法</p><p>​隐式转换法</p><hr><p><strong>注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</strong></p><hr><blockquote><p>C++ 中的构造函数可以分为以下几种类型：</p><ol><li><p>无参构造(默认构造)（Default Constructor）：没有参数的构造函数。如果一个类没有定义任何构造函数，编译器会自动生成一个默认构造函数。默认构造函数用于创建对象时不需要提供任何参数。</p></li><li><p>有参构造（Parameterized Constructor）：带有参数的构造函数，可以在<strong>创建对象时传递参数来初始化对象的成员变量。</strong></p></li><li><p>拷贝构造函数（Copy Constructor）：*<em>用于创建一个新对象并将其初始化为已有对象的副本。</em>**<em>拷贝构造函数的参数是 &gt; <strong>同类型的对象的引用</strong></em>*。</p></li><li><p>深拷贝构造函数（Move Constructor）：用于将一个对象的资源（如动态分配的内存）转移到另一个对象中，通常用于提高程序的性能。</p></li></ol><p>构造函数的调用方式有以下几种：</p><ol><li><p>直接调用：通过类名和参数列表直接调用构造函数来创建对象。例如：<code>MyClass obj(10);</code></p></li><li><p>隐式调用：在不显式调用构造函数的情况下，使用类的对象声明来创建对象。例如：<code>MyClass obj = 10;</code></p></li><li><p>拷贝初始化：使用一个已存在的对象来初始化新对象，会调用拷贝构造函数。例如：<code>MyClass obj2 = obj1;</code></p></li><li><p>动态创建对象：使用 <code>new</code> 运算符在堆上动态创建对象，会调用构造函数。例如：<code>MyClass* ptr = new MyClass();</code></p></li></ol><p>需要注意的是，<strong>构造函数在对象创建时自动调用，无法手动调用构造函数来重新初始化已经存在的对象</strong>。构造函数的调用顺序是<strong>先调用基类的构造函数，再调用成员对象的构造函数，最后调用派生类的构造函数</strong>。析构函数的调用顺序与构造函数相反，先调用派生类的析构函数，再调用成员对象的析构函数，最后调用基类的析构函数。</p></blockquote><p>推荐使用括号</p><p>了解匿名对象</p><p>有参构造函数直接Person（10）的时候创了一个匿名对象。</p><p>相当于没人接受这个对象。</p><p>要想利用拷贝构造函数，先有一个自己同类型的对象，然后再以引用的形式传入就ok了</p><img src="/post/a77e947a/image-20230726211121976.png" class="" title="image-20230726211121976"><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.1  括号法，常用</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line"><span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.2 显式法</span></span><br><span class="line">Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line"><span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构，直接构造析构然后立马销毁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.3 隐式转换法</span></span><br><span class="line">Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line"><span class="comment">//Person p5(p4);</span></span><br><span class="line">    <span class="comment">///数声明和对象定义的语法非常相似，都可以使用括号来表示。</span></span><br><span class="line">    <span class="comment">//使用额外的括号：可以在匿名对象的括号外面再加一对括号，这样编译器就不会将其解释为函数声明。</span></span><br><span class="line"><span class="comment">//MyClass obj((MyClass())); // 使用括号明确告诉编译器我们要定义一个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = p.mAge;</span><br><span class="line">默认的简单拷贝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li><strong>值传递</strong>的方式给函数参数传值</li><li>以<strong>值方式</strong>返回局部对象</li></ul><blockquote><ol><li><p><code>Person newman3 = man;</code> 和 <code>Person newman3; newman3 = man;</code> 是有区别的。</p><ol><li><code>Person newman3 = man;</code> 使用<strong>拷贝初始化的方式创建了一个新的对象</strong> <code>newman3</code>，并将 <code>man</code> 对象的值复制给 <code>newman3</code>。这里会<strong>调用拷贝构造函数来完成对象的复制初始化。</strong></li><li>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</li><li><code>Person newman3; newman3 = man;</code> 首先创建了一个新的对象 <code>newman3</code>，但它<strong>是通过默认构造函数创建的</strong>，并不包含任何数据。然后，通<strong>过赋值操作符 <code>=</code> 将 <code>man</code> 对象的值赋给了 <code>newman3</code><strong>。这里会调用</strong>赋值运算符重载函数来完成对象的赋值操作。</strong></li></ol><p>总体来说，两种形式都会将 <code>man</code> 对象的值复制到 <code>newman3</code> 对象中，但是在实现细节上有所不同。<strong>拷贝初始化会调用拷贝构造函数</strong>，<strong>而赋值操作会调用赋值运算符重载函数</strong>。在某些情况下，拷贝构造函数和赋值运算符重载函数的实现可能会有差异，因此两种形式可能具有不同的行为。<strong>在一般情况下</strong>，如果需要创建并初始化一个新对象，<strong>建议使用拷贝初始化的方式</strong>，而不是先创建对象再赋值的方式。</p></li><li><p><strong>值传递是指将实参的值</strong>复制一份传递给函数的形参。<strong>在函数调用时，会创建一个新的变量（形参），并将实参的值复制到形参中。</strong>&#x3D;&#x3D;在函数内部，对形参的修改不会影响到实参的值。&#x3D;&#x3D;当函数执行完毕后，形参的生命周期结束<strong>，它所占用的内存会被释放。</strong></p><p>text02()在你的例子中，<code>doWork</code> 函数的形参 <code>p1</code> 是通过值传递的方式进行传递的。当你调用 <code>doWork(p)</code> 时，会创建一个新的 <code>Person</code> 对象 <code>p1</code>，并将 <code>p</code> 对象的值复制给 <code>p1</code>。</p></li><li><p>可以以值方式返回<strong>局部对象</strong>。当函数返回一个对象时，编<strong><em>译器会执行对象的拷贝构造函数来创建一个临时对象，并将其作为返回值</em>。这个临时对象是在函数调用栈上分配的</strong>，<strong>它的生命周期与函数的返回值绑定。</strong></p><p>&#x2F;&#x2F;</p><p><strong>假如说我用a来接受这个局部对象，那么这个临时对象将会在a的销毁的时候同时销毁</strong></p><img src="/post/a77e947a/image-20230727153838243.png" class="" title="image-20230727153838243"></li></ol></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = p.mAge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line"><span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person newman3;</span></span><br><span class="line"><span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p; <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> p1;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//此时return *this;也会拷贝一个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h4><p>默认情况下，创建一个类的时候，c++编译器至少给一个类添加3个函数,</p><p>1．默认构造函数(无参，函数体为空)</p><p>2．默认析构函数(无参，函数体为空)</p><p>3．默认拷贝构造函数，对属性进行值拷贝</p><p>构造函数调用规则如下：</p><ul><li><p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</p></li><li><p>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;<span class="comment">//18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4><p><strong>深浅拷贝是面试经典问题，也是常见的一个坑</strong></p><p>浅拷贝：<strong>简单的赋值拷贝操作</strong>  编译器提供的那个拷贝构造函数，浅拷贝</p><p>深拷贝：<strong>在堆区重新申请空间，进行拷贝操作</strong></p><img src="/post/a77e947a/image-20230727164829489.png" class="" title="image-20230727164829489"><p><strong>这是编译器帮忙写的浅拷贝</strong></p><img src="/post/a77e947a/image-20230727172119889.png" class="" title="image-20230727172119889"><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age, <span class="type">int</span> height) &#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">m_age = age;</span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数  </span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_age = a.m_age;</span><br><span class="line"><span class="comment">//m_height = a.m_height;</span></span><br><span class="line"><span class="comment">//利用拷贝对象的数据来开辟一个新的空间。</span></span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*a.m_height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line"><span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">160</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"><span class="comment">//Person p2 = p1;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：<strong>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</strong></p></blockquote><ol><li><p>自己写拷贝构造函数，用拷贝对象的数据来开辟对应的空间</p></li><li><pre><code class="c++">//拷贝构造函数  Person(const Person&amp; a)&#123;    cout &lt;&lt; &quot;拷贝构造函数&quot; &lt;&lt; endl;    m_age = a.m_age;    //m_height = a.m_height;    //利用拷贝对象的数据来开辟一个新的空间。    m_height = new int(*a.m_height);&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 析构函数PLUS！</span><br><span class="line"></span><br><span class="line">4. ```c++</span><br><span class="line">   //析构函数</span><br><span class="line">   ~Person() &#123;</span><br><span class="line">   cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">   if (m_height != NULL)</span><br><span class="line">   &#123;</span><br><span class="line">   delete m_height;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><p>只有new出来的空间才能用delete，而且只能delete一次！</p><h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p><strong>作用：</strong></p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p><p><code>//初始化列表方式初始化</code></p><p><code>Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c)&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">////传统方式初始化</span></span><br><span class="line"><span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line"><span class="comment">//m_A = a;</span></span><br><span class="line"><span class="comment">//m_B = b;</span></span><br><span class="line"><span class="comment">//m_C = c;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表方式初始化</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="&#x3D;&#x3D;4.2.7 类对象作为类成员&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.2.7 类对象作为类成员&#x3D;&#x3D;</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>B类中有对象A作为成员，A为对象成员</p><p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p><blockquote><p><strong>&#x2F;&#x2F;构造的顺序是 ：先调用<em>对象成员</em>的构造，再调用本类构造</strong><br><strong>&#x2F;&#x2F;析构顺序与构造相反</strong></p></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Phone</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">m_PhoneName = name;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Phone</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line">Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line"><span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line"><span class="comment">//析构顺序与构造相反</span></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>();</span><br><span class="line">~<span class="built_in">Son</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Father</span>();</span><br><span class="line">~<span class="built_in">Father</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Son* a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Father::<span class="built_in">Father</span>()</span><br><span class="line">&#123;</span><br><span class="line">a = <span class="keyword">new</span> Son;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;父亲被构造了&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father::~<span class="built_in">Father</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;父亲被析构了&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son::<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;儿子被构造了&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son::~<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;儿子被析构了&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Father father;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>();</span><br><span class="line">~<span class="built_in">Son</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Father</span>();</span><br><span class="line">~<span class="built_in">Father</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Son a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Father::<span class="built_in">Father</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;父亲被构造了&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father::~<span class="built_in">Father</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;父亲被析构了&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son::<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;儿子被构造了&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son::~<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;儿子被析构了&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Father father;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这两种都是先构造儿子后构造父亲，析构相反</strong></p><p><strong>只有在父亲的构造函数里面再栈区开辟一个儿子对象的时候才是先构造父亲，然后构造儿子，其他相反</strong></p><h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4><p><strong>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</strong></p><p>—————————————-<em>可以通过类名访问静态成员</em>————————————————-</p><p><strong><em>静态成员分为</em>：</strong></p><ul><li><strong>静态成员变量</strong><ul><li><strong>所有对象共享同一份数据</strong></li><li><strong>在编译阶段分配内存</strong>（全局区运行前）</li><li><strong>类内声明，类外初始化</strong>（记得加作用域！！！！）</li></ul></li><li><strong>静态成员函数</strong><ul><li><strong>所有对象共享同一个函数</strong></li><li><strong>静态成员函数只能访问静态成员变量</strong></li></ul></li></ul><blockquote><p><strong>静态成员变量也有私有的时候。外部不能直接访问</strong></p><p><strong>可以通过类名访问静态成员</strong></p><p><strong>普通的成员public变量不可以直接用类名：：变量名访问！！！</strong></p></blockquote><p><strong>示例1 ：</strong>静态成员变量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员变量特点：</span></span><br><span class="line"><span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line"><span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line"><span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过对象</span></span><br><span class="line">Person p1;</span><br><span class="line">p1.m_A = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p2.m_A = <span class="number">200</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong>静态成员函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数特点：</span></span><br><span class="line"><span class="comment">//1 程序共享一个函数</span></span><br><span class="line"><span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//静态static成员函数它只属于类本身不属于每一个对象实例，独立存在。非静态成员，仅当实例化对象之后才存在。静态成员函数产生在前，非静态成员函数产生在后，静态函数无法访问一个不存在的东西。也就是静态成员函数离不能用this指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"><span class="type">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过对象</span></span><br><span class="line">Person p1;</span><br><span class="line">p1.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名</span></span><br><span class="line">Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，<strong>类内的成员变量和成员函数分开存储</strong></p><p>只有<strong>非静态成员变量才属于类的对象上</strong></p><blockquote><h5 id="只有非静态成员变量在真正属于类！！！！！"><a href="#只有非静态成员变量在真正属于类！！！！！" class="headerlink" title="只有非静态成员变量在真正属于类！！！！！"></a>只有非静态成员变量在真正属于类！！！！！</h5><h5 id="空对象占用1字节，为了区分空对象。"><a href="#空对象占用1字节，为了区分空对象。" class="headerlink" title="空对象占用1字节，为了区分空对象。"></a>空对象占用1字节，为了区分空对象。</h5><h5 id="也就是类的大小是根据非静态成员变量的"><a href="#也就是类的大小是根据非静态成员变量的" class="headerlink" title="也就是类的大小是根据非静态成员变量的"></a>也就是类的大小是根据非静态成员变量的</h5></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">mA = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line"><span class="type">int</span> mA;</span><br><span class="line"><span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mB;</span><br><span class="line"><span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4</span></span><br></pre></td></tr></table></figure><h4 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>c++通过提供特殊的对象指针，this指针，解决上述问题。<em><strong>this指针指向被调用的成员函数所属的对象</strong></em></p><blockquote><p><strong>this指针是隐含每一个非静态成员函数内的一种指针</strong></p><p><strong>this指针不需要定义，直接使用即可</strong></p><p><strong>静态成员函数没有this指针</strong></p><p>本质是指针常量！！！，已经指向了a，不可以修改指向，但可以修改值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showperson</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span> = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_a = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Person a;</span><br><span class="line">a.<span class="built_in">showperson</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>this指针的用途：</p><ul><li>当形参和成员变量同名时，可用this指针来区分</li><li>*<em>在类的非静态成员函数中返回对象本身，可使用return <em>this</em></em></li></ul><h5 id="链式编程思想！！！"><a href="#链式编程思想！！！" class="headerlink" title="&#x3D;&#x3D;链式编程思想！！！&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>链式编程思想！！！</strong>&#x3D;&#x3D;</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line"><span class="comment">//返回对象本身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line">p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><blockquote><p>类类型的指针，在成员里this就是指针。</p></blockquote><p>但不能用空指针访问里面的属性，可以用函数。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showperosn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是person类&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showpp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//代码健壮！！！</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sdadasdassdasdasdasdsda&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person* p = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;<span class="built_in">showperosn</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">p-&gt;<span class="built_in">showpp</span>(); <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p><blockquote><ul><li><strong>成员函数后</strong>加const后我们称为这个函数为<strong>常函数</strong></li><li><strong>常函数内不可以修改成员属性</strong></li><li><strong>成员属性声明时加关键字mutable后，在常函数中依然可以修改</strong></li></ul></blockquote><p><strong>常对象：</strong></p><ul><li><strong>声明对象前加const称该对象为常对象</strong></li><li><strong>常对象只能调用常函数</strong></li><li><strong>常对象可以修改静态变量的值</strong></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">m_A = <span class="number">0</span>;</span><br><span class="line">m_B = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line"><span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//const Type* const pointer;</span></span><br><span class="line"><span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line"><span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//mA = 10000;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常对象访问成员函数</span></span><br><span class="line">person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p><p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p><p>但是呢，你也可以允许你的好闺蜜好基友进去。</p><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是<strong>让一个函数或者类 访问另一个类中私有成员</strong></p><p>友元的关键字为  &#x3D;&#x3D;friend&#x3D;&#x3D;</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodgay</span><span class="params">(building* building)</span></span>;<span class="comment">//写在类里面就ok，最好在上面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">building</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_sittingrom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">m_bedroom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_sittingrom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_bedroom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodgay</span><span class="params">(building* building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友 全局函数正在访问:&quot;</span> &lt;&lt;building-&gt;m_sittingrom&lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友 全局函数正在访问:&quot;</span> &lt;&lt; building-&gt;m_bedroom&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">building b;</span><br><span class="line"><span class="built_in">goodgay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">text01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">goodGay</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">goodGay gg;</span><br><span class="line">gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="comment">//你可以在goodGay类的定义之前提供一个Building类的前向声明来解决编译错误。</span></span><br><span class="line"><span class="comment">//但是，在这种情况下，你不能直接在goodGay类的构造函数中使用new来创建Building对象，因为编译器仍然无法识别Building类的具体定义。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">goodGay</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Building* building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">goodGay gg;</span><br><span class="line">gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p><blockquote><p>通过成员函数重载</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public: </span><br><span class="line">person(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_a = a;</span><br><span class="line">this-&gt;m_b = b;</span><br><span class="line">&#125;</span><br><span class="line">person operator+(person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">person p3(0, 0);</span><br><span class="line">p3.m_a = this-&gt;m_a + p.m_a;</span><br><span class="line">p3.m_b = this-&gt;m_b + p.m_b;</span><br><span class="line">return p3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int m_a;</span><br><span class="line">int m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">person p1(10, 10);</span><br><span class="line">person p2(20, 20);</span><br><span class="line">person p3=p1+(p2);</span><br><span class="line">cout &lt;&lt; p3.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;_------------------&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p3.m_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过全局函数重载</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//person fucn(person&amp; p1, person&amp; p2)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//person p3(0,0);</span></span><br><span class="line"><span class="comment">//p3.m_a = p1.m_a + p2.m_a;</span></span><br><span class="line"><span class="comment">//p3.m_b = p3.m_b + p2.m_b;</span></span><br><span class="line"><span class="comment">//return p3;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">person <span class="keyword">operator</span>+(person&amp; p1, person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">person <span class="title">p3</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">p3.m_a = p1.m_a + p2.m_a;</span><br><span class="line">p3.m_b = p1.m_b + p2.m_b;</span><br><span class="line"><span class="keyword">return</span> p3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//person p3 = func(p1, p2);</span></span><br><span class="line">    <span class="comment">//可以简写为这样！</span></span><br><span class="line">person p3 = p1 + p2;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p3.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;_------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p3.m_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>运算符对应的函数重载</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person <span class="keyword">operator</span>+(person&amp; p1, person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">person <span class="title">p3</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">p3.m_a = p1.m_a + p2.m_a;</span><br><span class="line">p3.m_b = p1.m_b + p2.m_b;</span><br><span class="line"><span class="keyword">return</span> p3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person <span class="keyword">operator</span>+(person&amp; p1, <span class="type">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">person <span class="title">p3</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">p3.m_a = p1.m_a + num;</span><br><span class="line">p3.m_b = p1.m_b + num;</span><br><span class="line"><span class="keyword">return</span> p3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//person p3 = operator+(p1, p2);</span></span><br><span class="line">person p3 = p1 + p2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//现在如果</span></span><br><span class="line">person p4 = p1 + <span class="number">100</span>;<span class="comment">//person + int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p3.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p3.m_b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;_------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p4.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p4.m_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>通过成员函数或者全局函数写一个目标重载运算符的作用函数,然后把函数的名字改为operator+就可以说使用+号来重载了</li><li>不把函数名改写为operator+之前的加号还默认是原来的样子!!!!</li><li>熟练之后直接函数名字就是operator+</li><li>如果二者同时存在的时候就会报错</li></ol></blockquote><blockquote><p>总结1：对于<strong>内置的数据类型</strong>的表达式的的运算符是不可能改变的1+1&#x3D;2,变成1+1&#x3D;0?不可以</p></blockquote><blockquote><p>总结2：不要滥用运算符重载,加号运算符重载,实现就不要用减号..</p></blockquote><h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="&#x3D;&#x3D;4.5.2 左移运算符重载&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.5.2 左移运算符重载&#x3D;&#x3D;</h4><p>作用：可以输出自定义数据类型</p><p>加个cosnt最好，引用作为函数参数传递的时候不修改最好加上cosnt！！！！！！！！！</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p) <span class="comment">//本质operator&lt;&lt;(cout,p) 简化cout&lt;&lt;p;</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a ;</span><br><span class="line">cout &lt;&lt; p.m_b;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链式思想,返回cout对应的</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> person&amp; p) <span class="comment">//本质operator&lt;&lt;(cout,p) 简化cout&lt;&lt;p;</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a ;</span><br><span class="line">cout &lt;&lt; p.m_b;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也是ok的因为,引用本来就是起别名,而真正传入的实参确实cout所以</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line"><span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个,所以要用引用的形式修改,否则覆盖不了原来的cout</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结<strong>：重载左移运算符配合友元可以实现输出自定义数据类型</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, person&amp; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>(<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout对象和我的p对象</span></span><br><span class="line"><span class="comment">//void operator&lt;&lt;(cout)  // p.operator&lt;&lt;(cout)  简化为p&lt;&lt;cout</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, person&amp; p) <span class="comment">//本质operator&lt;&lt;(cout,p) 简化cout&lt;&lt;p;</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a ;</span><br><span class="line">cout &lt;&lt; p.m_b;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl &lt;&lt; <span class="string">&quot;helloworld&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p><p>但用引用可以节省空间，而且不怕拷贝函数有错误。</p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>++() &#123;  <span class="comment">// 前置递增运算符重载</span></span><br><span class="line">  <span class="comment">// 执行递增操作</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回递增后的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;  <span class="comment">// 后置递增运算符重载</span></span><br><span class="line">  MyClass temp = *<span class="keyword">this</span>;  <span class="comment">// 创建一个临时对象保存当前对象的值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行递增操作</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> temp;  <span class="comment">// 返回之前的对象</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//class MyClass &#123;</span></span><br><span class="line"><span class="comment">//    // 类定义</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>++(MyClass&amp; obj) &#123;  <span class="comment">// 前置递增运算符重载</span></span><br><span class="line"><span class="comment">// 执行递增操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> obj;  <span class="comment">// 返回递增后的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass <span class="keyword">operator</span>++(MyClass&amp; obj, <span class="type">int</span>) &#123;  <span class="comment">// 后置递增运算符重载</span></span><br><span class="line">MyClass temp = obj;  <span class="comment">// 创建一个临时对象保存当前对象的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行递增操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> temp;  <span class="comment">// 返回之前的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意conse，会有一定的影响，如果引用做函数参数的时候确认是不修改的 话就加上const！！！</span></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>前置++</p><p>返回引用！！可以链式</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, person&amp; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//p.operator++(person&amp; p)</span></span><br><span class="line">person&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数重载的时候</span></span><br><span class="line">person&amp; <span class="keyword">operator</span>++(person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">p.m_a++;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意conse，会有一定的影响，如果引用做函数参数的时候确认是不修改的 话就加上const！！！</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">person p;</span><br><span class="line">cout &lt;&lt; ++(++p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>后置递增！</p><p>返回同类，不可以用链式</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p);</span><br><span class="line"><span class="keyword">friend</span> person <span class="keyword">operator</span>++(person&amp; obj, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person <span class="keyword">operator</span>++(person&amp; obj, <span class="type">int</span>) &#123;  <span class="comment">// 后置递增运算符重载</span></span><br><span class="line">person temp = obj;  <span class="comment">// 创建一个临时对象保存当前对象的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行递增操作</span></span><br><span class="line">obj.m_a++;=</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> temp;  <span class="comment">// 返回之前的对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意conse，会有一定的影响，如果引用做函数参数的时候确认是不修改的 话就加上const！！！</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">person myInt;</span><br><span class="line">cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">person p;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><blockquote><h4 id="总结：-前置递增返回引用，后置递增返回值"><a href="#总结：-前置递增返回引用，后置递增返回值" class="headerlink" title="总结： 前置递增返回引用，后置递增返回值"></a>总结： 前置递增返回引用，后置递增返回值</h4></blockquote><p>递减！！的成员函数 的 写法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person&amp; <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a--;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">person <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">person temp = *<span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a--;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">person myInt;</span><br><span class="line">cout &lt;&lt; --myInt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">person myInt;</span><br><span class="line">cout &lt;&lt; myInt--&lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">person p;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递减的全局函数重载写法！！</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p);</span><br><span class="line"><span class="keyword">friend</span> person&amp; <span class="keyword">operator</span>--(person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> person <span class="keyword">operator</span>--(person&amp; p, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person&amp; <span class="keyword">operator</span>--(person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">p.m_a--;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person <span class="keyword">operator</span>--(person&amp; p,<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">person temp = p;</span><br><span class="line">p.m_a--;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">person myInt;</span><br><span class="line">cout &lt;&lt; --myInt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">person myInt;</span><br><span class="line">cout &lt;&lt; myInt--&lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">person p;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p><blockquote><ol><li><h5 id="默认构造函数-无参，函数体为空"><a href="#默认构造函数-无参，函数体为空" class="headerlink" title="默认构造函数(无参，函数体为空)"></a>默认构造函数(无参，函数体为空)</h5></li><li><h5 id="默认析构函数-无参，函数体为空"><a href="#默认析构函数-无参，函数体为空" class="headerlink" title="默认析构函数(无参，函数体为空)"></a>默认析构函数(无参，函数体为空)</h5></li><li><h5 id="默认拷贝构造函数，对属性进行值拷贝"><a href="#默认拷贝构造函数，对属性进行值拷贝" class="headerlink" title="默认拷贝构造函数，对属性进行值拷贝"></a>默认拷贝构造函数，对属性进行值拷贝</h5></li><li><h5 id="赋值运算符-operator-对属性进行值拷贝"><a href="#赋值运算符-operator-对属性进行值拷贝" class="headerlink" title="赋值运算符 operator&#x3D;, 对属性进行值拷贝"></a>赋值运算符 operator&#x3D;, 对属性进行值拷贝</h5></li></ol></blockquote><ol><li>也是浅拷贝</li></ol><p><strong>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</strong></p><p>类中有属性指向堆区，就要考虑深拷贝了</p><hr><p><strong>思考，指出那里出现了问题????</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>(<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in">int</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;p;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="comment">//此处使用拷贝构造函数的隐式转换</span></span><br><span class="line">    <span class="comment">//person p3=p1</span></span><br><span class="line">    <span class="comment">//由于我们并没有写自己的深拷贝,也就是说还用的是编译器帮我们写的浅拷贝,造成了简单的赋值操作,让我么两个指针都指向了同一块数据,然后释放了两次就鸡; </span></span><br><span class="line">    <span class="comment">//我们只是写了自己的=的重载.</span></span><br><span class="line">    <span class="comment">//避免了重载的时候释放两次同一个位置</span></span><br><span class="line">    <span class="comment">//p2=p1这样的操作不会有问题</span></span><br><span class="line">person p3 = p1;</span><br><span class="line">cout &lt;&lt; *p1.p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p2.p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p3.p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/post/a77e947a/image-20230729143751080.png" class="" title="image-20230729143751080"><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载赋值运算符 </span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line"><span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回自身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄的指针</span></span><br><span class="line"><span class="type">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//int a = 10;</span></span><br><span class="line"><span class="comment">//int b = 20;</span></span><br><span class="line"><span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c = b = a;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="可以是实现这样的操作，从右到左赋值！！！"><a href="#可以是实现这样的操作，从右到左赋值！！！" class="headerlink" title="可以是实现这样的操作，从右到左赋值！！！"></a>可以是实现这样的操作，从右到左赋值！！！</h4></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//test();</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">a = b = c;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a  &lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b  &lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c=&quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>给&#x3D;进行链式思想实连等</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>(<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in">int</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;p;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> person&amp; pp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//需要看原来的堆区是否有数据，如果有需要先释放干净，然后再利用数据开辟空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in">int</span>(*pp.p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">person p3 =(<span class="number">30</span>);</span><br><span class="line">p3 = p2 = p1;</span><br><span class="line">cout &lt;&lt; *p1.p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p2.p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p3.p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="4-5-5-关系运算符重载—返回BOOL"><a href="#4-5-5-关系运算符重载—返回BOOL" class="headerlink" title="4.5.5 关系运算符重载—返回BOOL"></a>4.5.5 关系运算符重载—返回BOOL</h4><p><strong>作用：</strong>重<strong>载关系运算符，可以让两个自定义类型对象进行对比操作</strong></p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;name == p2.name &amp;&amp; <span class="keyword">this</span>-&gt;age == p2.age)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////////</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> == p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;name != p2.name &amp;&amp; <span class="keyword">this</span>-&gt;age != p2.age)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////全局函数重载的时候</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(person&amp; p1, person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p1.name == p2.name &amp;&amp; p1.age == p2.age)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(person&amp; p1, person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p1.name == p2.name &amp;&amp; p1.age == p2.age)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//全局记得加上友元!!!@#@#@#@#@#!#!</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>(string name, <span class="type">int</span> age):<span class="built_in">name</span>(name), <span class="built_in">age</span>(age)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;name == p2.name &amp;&amp; <span class="keyword">this</span>-&gt;age == p2.age)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="string">&quot;tom&quot;</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line"><span class="function">person <span class="title">p2</span><span class="params">(<span class="string">&quot;tom&quot;</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line">person p3 = <span class="built_in">person</span>(<span class="string">&quot;jerry&quot;</span>,<span class="number">20</span>);</span><br><span class="line"><span class="comment">///erson p4 = p2;//浅拷贝！！！危险，如果指针操纵他—+析构释放，就要考虑深拷贝！！！</span></span><br><span class="line"><span class="keyword">if</span> (p1==p2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1和p2是相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1和p2是不相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载()"></a>4.5.6 函数调用运算符重载()</h4><ul><li>函数调用运算符 ()  也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><blockquote><h4 id="刚试了一下，operator（）（）只能在类里面定义，报错说不允许他为全局函数。"><a href="#刚试了一下，operator（）（）只能在类里面定义，报错说不允许他为全局函数。" class="headerlink" title="刚试了一下，operator（）（）只能在类里面定义，报错说不允许他为全局函数。"></a>刚试了一下，operator（）（）只能在类里面定义，报错说不允许他为全局函数。</h4></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line"><span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line"><span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line"><span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myadd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+<span class="number">1</span> + b+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//匿名对象调用  </span></span><br><span class="line"><span class="comment">//有参构造Person(10)单独写就是匿名对象  当前行结束之后，马上析构，直接构造析构然后立马销毁</span></span><br><span class="line"><span class="comment">//Person()单独写就是匿名对象  当前行结束之后，马上析构，直接构造析构然后立马销毁</span></span><br><span class="line">person p;</span><br><span class="line"><span class="built_in">p</span>(<span class="string">&quot;你好啊）OP&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----匿名函数----------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">person</span>()(<span class="string">&quot;你好啊匿名函数&quot;</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">Myadd add;</span><br><span class="line">cout&lt;&lt;<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">30</span>)&lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----匿名函数----------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Myadd</span>()(<span class="number">90</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-继承–2"><a href="#4-6-继承–2" class="headerlink" title="4.6  继承–2"></a>4.6  继承–2</h3><p><strong>继承是面向对象三大特性之一</strong></p><p>有些类与类之间存在特殊的关系，例如下图中：</p><img src="/post/a77e947a/1544861202252.png" class="" width="1544861202252"><p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p>重要但不难</p><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p><strong>普通实现：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.<span class="built_in">header</span>();</span><br><span class="line">cp.<span class="built_in">footer</span>();</span><br><span class="line">cp.<span class="built_in">left</span>();</span><br><span class="line">cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承实现：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.<span class="built_in">header</span>();</span><br><span class="line">cp.<span class="built_in">footer</span>();</span><br><span class="line">cp.<span class="built_in">left</span>();</span><br><span class="line">cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>继承的好处：&#x3D;&#x3D;可以减少重复的代码&#x3D;&#x3D;</p><blockquote><p>class A : public B; </p><p><strong>A 类称为子类 或 派生类</strong></p><p><strong>B 类称为父类 或 基类</strong></p></blockquote><p><strong>派生类中的成员，包含两大部分</strong>：</p><p><strong>一类是从基类继承过来的，一类是自己增加的成员。</strong></p><p>从基类继承过过来的表现其共性，而新增的成员体现了<strong>其个性</strong>。</p><h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p><p><strong>继承方式一共有三种：</strong></p><blockquote><ul><li><h4 id="公共继承-原来是啥还是啥，只不过不可以访问父亲的私有的"><a href="#公共继承-原来是啥还是啥，只不过不可以访问父亲的私有的" class="headerlink" title="公共继承,原来是啥还是啥，只不过不可以访问父亲的私有的"></a>公共继承,原来是啥还是啥，只不过不可以访问父亲的私有的</h4></li><li><h4 id="保护继承-除了private都变成protected"><a href="#保护继承-除了private都变成protected" class="headerlink" title="保护继承  除了private都变成protected"></a>保护继承  除了private都变成protected</h4></li><li><h4 id="私有继承-全变成private；"><a href="#私有继承-全变成private；" class="headerlink" title="私有继承 全变成private；"></a>私有继承 全变成private；</h4></li></ul><p>在C++中，<strong>派生类确实继承了基类的所有成员，包括私有成员。</strong>但是，<strong>私有成员在派生类中是不可访问的。</strong>这<strong>意味着派生类无法直接访问或继承基类的私有成员。</strong></p><p><strong>私有成员只能在基类内部访问</strong>，派生类无法直接访问或继承私有成员。这是因为<strong>私有成员被设计为只能在基类内部使用，对外部是不可见的。****派生类只能通过基类的公有和保护成员来访问和操作私有成员</strong>。</p><p><strong>只是编译器把父类的private给隐藏了，子类不可访问</strong></p></blockquote><img src="/post/a77e947a/clip_image002.png" class="" title="img"><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son1 s1;</span><br><span class="line">s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2 s;</span><br><span class="line"><span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line"><span class="comment">//m_A;</span></span><br><span class="line"><span class="comment">//m_B;</span></span><br><span class="line"><span class="comment">//m_C;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="&#x3D;&#x3D;4.6.3 继承中的对象模型&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.6.3 继承中的对象模型&#x3D;&#x3D;</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p><blockquote><p><strong>在C++中，子类继承了父类的函数，但子类函数和父类函数并不指向同一块地址。</strong></p><p><strong>当子类继承父类的函数时，子类会创建一个新的函数，该函数与父类的函数具有相同的名称和参数列表，但是可以有不同的实现（重写）或相同的实现（继承）。</strong></p><p><strong>子类函数和父类函数是两个独立的函数，它们具有不同的地址。子类对象可以通过子类函数来调用子类的实现，而父类对象可以通过父类函数来调用父类的实现。</strong></p><hr><p><strong>在C++中，子类继承了父类的成员变量，但子类的成员变量和父类的成员变量并不指向同一块地址。子类对象包含了父类对象的所有成员变量，但它们在内存中是独立存储的。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> parentVar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Parent parent;</span><br><span class="line">    Child child;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印父类成员变量地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;父类成员变量地址：&quot;</span> &lt;&lt; &amp;(parent.parentVar) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印子类成员变量地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子类成员变量地址：&quot;</span> &lt;&lt; &amp;(child.parentVar) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//16</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用工具查看：</p><img src="/post/a77e947a/image-20230729223112618.png" class="" title="image-20230729223112618"><p>打开工具窗口后，定位到当前CPP文件的盘符</p><img src="/post/a77e947a/image-20230729222903401.png" class="" title="image-20230729222903401"><p>然后输入： cl &#x2F;d1 reportSingleClassLayout查看的类名   所属文件名</p><p>table</p><p>效果如下图：</p><img src="/post/a77e947a/1545882158050.png" class="" width="1545882158050"><blockquote><p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote><h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><p><strong>因为是继承，肯定要先创建一个父类</strong></p><p><strong>先父亲后儿子，和之前的类里面有别的类的时候，</strong></p><p>4.2.7 类对象作为类成员是有区别的</p><p>类里面有类的时候是先构造里面的然后再构造外面的！！！</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="总结：继承中-先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反"><a href="#总结：继承中-先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反" class="headerlink" title="总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反"></a>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</h4></blockquote><h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><blockquote><ul><li><h4 id="访问子类同名成员-直接访问即可"><a href="#访问子类同名成员-直接访问即可" class="headerlink" title="访问子类同名成员   直接访问即可"></a>访问子类同名成员   直接访问即可</h4></li><li><h4 id="访问父类同名成员-需要加作用域"><a href="#访问父类同名成员-需要加作用域" class="headerlink" title="访问父类同名成员   需要加作用域"></a>访问父类同名成员   需要加作用域</h4></li><li><p>直接调用就是儿子的，</p><p><strong>&#x2F;&#x2F;当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</strong><br><strong>&#x2F;&#x2F;如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</strong></p></li></ul></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这是父类的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Base1</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这是父类的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是父亲！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B ;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是儿子！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Son1</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这是子类的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Son1</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这是子类的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_A=<span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line"><span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son1 s1;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;子类的同名是&quot;</span>&lt;&lt; s1.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;父类的同名是&quot;</span> &lt;&lt; s1.Base1::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">s1.<span class="built_in">func</span>();</span><br><span class="line">s1.Base1::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s1.Base1::<span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Son1) &lt;&lt; endl;</span><br><span class="line"><span class="comment">//16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><blockquote><ol><li><h5 id="子类对象可以直接访问到子类中同名成员"><a href="#子类对象可以直接访问到子类中同名成员" class="headerlink" title="子类对象可以直接访问到子类中同名成员"></a>子类对象可以直接访问到子类中同名成员</h5></li><li><h5 id="子类对象加作用域可以访问到父类同名成员"><a href="#子类对象加作用域可以访问到父类同名成员" class="headerlink" title="子类对象加作用域可以访问到父类同名成员"></a>子类对象加作用域可以访问到父类同名成员</h5></li><li><h5 id="当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数-包括重载的，都没用，加作用域可以访问到父类中同名函数"><a href="#当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数-包括重载的，都没用，加作用域可以访问到父类中同名函数" class="headerlink" title="当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数,包括重载的，都没用，加作用域可以访问到父类中同名函数"></a>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数,包括重载的，都没用，<em>加作用域</em>可以访问到父类中同名函数</h5></li></ol></blockquote><h4 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h4><p><strong>1.静态成员可以通过类名来访问！</strong></p><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p><strong>静态成员和非静态成员出现同名，处理方式一致</strong></p><p>想要使用父亲的就加作用域就欧克了！！！</p><blockquote><h5 id="访问子类同名成员-直接访问即可-1"><a href="#访问子类同名成员-直接访问即可-1" class="headerlink" title="访问子类同名成员   直接访问即可"></a>访问子类同名成员   直接访问即可</h5><h5 id="访问父类同名成员-需要加作用域-1"><a href="#访问父类同名成员-需要加作用域-1" class="headerlink" title="访问父类同名成员   需要加作用域"></a>访问父类同名成员   需要加作用域</h5></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">    <span class="comment">//第一个双冒号：代表通过类名方式访问，第二个双冒号是，代表访问父类的作用域下！！！！</span></span><br><span class="line">Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认是Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;要想用父亲的就加作用域Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Base::m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//想要用子类来访问父类的静态成员变量就得用这种</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认是Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;要想用父亲的就加作用域Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Base::m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//想要用子类来访问父类的静态成员变量就得用这种</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">    <span class="comment">//第一个双冒号：代表通过类名方式访问，第二个双冒号是，代表访问父类的作用域下！！！！</span></span><br><span class="line">Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p></blockquote><h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p><hr><p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><hr><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><p>子类想用自己的 就类名.使用</p><p>子类想用爹爹们的 就用 子类名.父类::对应的数据</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base2</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_C = <span class="number">300</span>;</span><br><span class="line">m_D = <span class="number">400</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line"><span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote><h4 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p><p>​两个派生类继承同一个基类</p><p>​又有某个类同时继承者两个派生类</p><p>​这种继承被称为菱形继承，或者钻石继承</p><p><strong>典型的菱形继承案例：</strong></p><img src="/post/a77e947a/clip_image002.jpg" class="" title="IMG_256"><p><strong>菱形继承问题：</strong></p><ol><li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</code></pre></li><li><pre><code>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</code></pre></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SheepTuo st;</span><br><span class="line">st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul><blockquote><p><strong>解释虚继承（virtual inheritance）的概念</strong></p><p>在C++中，当一个类被继承时，子类会包含父类的成员变量和成员函数。如果一个类被多个子类继承，那么每个子类都会包含一份父类的成员变量和成员函数，这可能会导致冗余和浪费。</p><p>为了解决这个问题，C++引入了虚继承（virtual inheritance）的概念。虚继承可以确保在多继承中，对于公共的基类，只有一份实例存在于继承体系中。通过使用<code>virtual</code>关键字来声明虚继承。</p><p>在您的代码中，<code>Sheep</code>和<code>Tuo</code>类都使用了虚继承，它们都继承自虚基类<code>Animal</code>。而<code>SheepTuo</code>类继承自<code>Sheep</code>和<code>Tuo</code>类。</p><p>在加入虚继承之前，<code>SheepTuo</code>类中会包含两份<code>m_Age</code>成员变量，分别来自于<code>Sheep</code>和<code>Tuo</code>类。而加入虚继承后，<code>SheepTuo</code>类中只会包含一份<code>m_Age</code>成员变量，来自于虚基类<code>Animal</code>。</p><p>因此，加入虚继承后，<code>SheepTuo</code>对象的大小（占用的字节数）会减小。在您的代码中，输出<code>sizeof(st)</code>可以看到<code>SheepTuo</code>对象的大小变为4。</p><p>另外，由于虚继承的特性，通过类名作用域来访问虚基类的成员变量。在您的代码中，使用<code>st.Sheep::m_Age</code>和<code>st.Tuo::m_Age</code>来访问<code>Sheep</code>和<code>Tuo</code>类中的<code>m_Age</code>成员变量。</p><p>最后，注释掉的<code>cout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;</code>语句会导致编译错误，因为在虚继承中，访问虚基类的成员变量需要使用类名作用域。</p><hr><p>在虚继承中，除了会包含虚基类的成员变量，还会包含一些额外的信息来处理虚继承的相关操作，比如虚基类指针或虚基类表。这些额外的信息会导致对象的大小增加。</p><hr><p><strong>确定虚基类的大小？想吧你哈哈</strong></p><p>确定虚基类指针或虚基类表所占字节的具体方法是依赖于编译器和系统的实现细节的。不同的编译器和系统可能会有不同的实现方式。</p><p>一种常见的实现方式是，在虚继承中，编译器会为每个包含虚基类的类生成一个虚基类表（vtable）。虚基类表是一个数据结构，用于存储虚基类的相关信息，比如虚基类的偏移量等。</p><p>虚基类指针是一个指向虚基类表的指针，用于在运行时动态查找虚基类的成员。虚基类指针的大小通常是一个指针的大小，即在32位系统中通常是4个字节，在64位系统中通常是8个字节。</p><p>虚基类表的大小取决于虚基类的数量和虚基类的成员变量和成员函数的数量。每个虚基类在虚基类表中占据一定的空间，用于存储虚基类的相关信息。</p></blockquote><h3 id="4-7-多态–3"><a href="#4-7-多态–3" class="headerlink" title="4.7  多态–3"></a>4.7  多态–3</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li>静态多态: <strong>函数重载 和 运算符重载属于静态多态，复用函数名</strong></li><li>动态多态: <strong>派生类和虚函数实现运行时多态</strong></li></ul><p>静态多态和动态多态区别：</p><ul><li><strong>静态多态的函数地址早绑定  -  编译阶段确定函数地址</strong></li><li><strong>动态多态的函数地址晚绑定</strong>  -  运行阶段确定函数地址</li></ul><hr><p><strong>等号左边编译类型右边运行类型，早绑定看编译类型，晚绑定看运行类型</strong></p><p><strong>Animal&amp; animal与传入的东西</strong></p><hr><p>&#x3D;&#x3D;就相当于重载函数，本来必须在同一作用域下才能重载，vritual允许父子类之间函数重载&#x3D;&#x3D;</p><p>下面通过案例进行讲解多态</p><blockquote><p>&#x2F;函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</p><p>&#x2F;&#x2F;我们希望传入什么对象，那么就调用什么对象的函数<br>&#x2F;&#x2F;如果函数地址在编译阶段就能确定，那么静态联编<br>&#x2F;&#x2F;如果函数地址在运行阶段才能确定，就是动态联编</p><hr><p>&#x2F;&#x2F;多态满足条件：<br>&#x2F;&#x2F;1、有继承关系<br>&#x2F;&#x2F;2、子类重写父类中的虚函数,,此时加不加 virtual都欧克<br>&#x2F;&#x2F;多态使用：<br><strong>———————————————&#x2F;&#x2F;父类指针或引用指向子类对象</strong>—————————————————-</p><p>父亲类 *pointer&#x3D;new 子类名;</p><p>父亲类&amp;p&#x3D;子类具体对象</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建+法计算器</span></span><br><span class="line">addCalculator add;</span><br><span class="line">AbstractCalculator&amp; abc = add;</span><br><span class="line"></span><br><span class="line">abc.a = <span class="number">10</span>;</span><br><span class="line">abc.b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc.<span class="built_in">getresult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">////////////////////////</span></span><br><span class="line"><span class="comment">//创建+法计算器</span></span><br><span class="line">AbstractCalculator* abc = <span class="keyword">new</span> <span class="built_in">addCalculator</span>();</span><br><span class="line"></span><br><span class="line">abc-&gt;a = <span class="number">10</span>;</span><br><span class="line">abc-&gt;b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;<span class="built_in">getresult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//释放对应的数据</span></span><br><span class="line"><span class="keyword">delete</span> abc;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//Speak函数就是虚函数</span></span><br><span class="line"><span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;动物在叫！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;喵喵喵！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//早绑定，编译阶段就把函数地址给绑定了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">(Animal&amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal.<span class="built_in">Speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal am;</span><br><span class="line">Cat cat;</span><br><span class="line"><span class="built_in">speak</span>(am);</span><br><span class="line"><span class="built_in">speak</span>(cat);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>没有重写speak函数的时候，通过继承，把父亲的虚函数也也继承下来了，而且在虚基表里是父类的函数</strong></p><img src="/post/a77e947a/image-20230730140026926.png" class="" title="image-20230730140026926"><p>重写后</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;喵喵喵！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/post/a77e947a/image-20230730140251440.png" class="" title="image-20230730140251440"><p>总结：</p><blockquote><p>C++中的多态是通过<strong>虚函数实现的</strong>。当<strong>基类指针或引用指向派生类对象时</strong>，可以通过<strong>该指针或引用调用虚函数时，会根据对象的实际类型来确定调用哪个类的虚函数。</strong></p><p>在C++中，<strong>每个包含虚函数的类都有一个虚函数表（vtable）</strong>。<strong>虚函数表是一个存储指向虚函数地址的指针数组。****每个对象都有一个指向其类的虚函数表的指针，称为虚函数指针（vptr）。</strong></p><p><strong>当对象被创建时，编译器会在对象的内存布局中添加一个隐藏的虚函数指针。</strong>这个指针指向该类的虚函数表。**&#x3D;&#x3D;如果类没有虚函数，那么它也不会有虚函数表和虚函数指针。&#x3D;&#x3D;**</p><p>当调用一个虚函数时，<strong>编译器会根据对象的虚函数指针找到对应的虚函数表，</strong>然<strong>后根据函数在虚函数表中的索引找到要调用的函数地址。</strong>这个过程是<strong>在运行时动态确定的</strong>，因此可以实现多态。</p><p>继承和重写是多态的基础。<strong>当派生类继承基类时，它会继承基类的虚函数，并可以选择重写这些虚函数。</strong></p><p>.<strong>通过重写，派生类可以为基类的虚函数提供自己的实现</strong>。</p><p>当使用基类指针或引用调用虚函数时，根据对象的实际类型，将调用派生类的虚函数。</p></blockquote><p>多态满足条件</p><ul><li><strong>有继承关系</strong></li><li><strong>子类重写父类中的虚函数</strong></li></ul><p>多态使用条件</p><ul><li><strong>父类指针或引用指向子类对象</strong></li></ul><p>重写：<strong>函数返回值类型  函数名 参数列表 完全一致称为重写</strong></p><h4 id="4-7-2-多态案例一-计算器类"><a href="#4-7-2-多态案例一-计算器类" class="headerlink" title="4.7.2 多态案例一-计算器类"></a>4.7.2 多态案例一-计算器类</h4><p><strong>‘’字符,””字符串</strong></p><p><strong>delete会把指针指向的内存权限释放，让这块内存可以被其他进程使用</strong></p><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getresult</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//+是一个字符串const char*</span></span><br><span class="line"><span class="comment">//或者strcmp(c,&#x27;+&#x27;)==0</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> a * b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Caculator caculator;</span><br><span class="line">caculator.a = <span class="number">10</span>;</span><br><span class="line">caculator.b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; caculator.<span class="built_in">getresult</span>(<span class="string">&#x27;+&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; caculator.<span class="built_in">getresult</span>(<span class="string">&#x27;-&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; caculator.<span class="built_in">getresult</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; caculator.<span class="built_in">getresult</span>(<span class="string">&#x27;/&#x27;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getresult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">addCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getresult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">jianCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getresult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">chengCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getresult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">chuCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getresult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建+法计算器</span></span><br><span class="line">AbstractCalculator* abc = <span class="keyword">new</span> <span class="built_in">addCalculator</span>();</span><br><span class="line"></span><br><span class="line">abc-&gt;a = <span class="number">10</span>;</span><br><span class="line">abc-&gt;b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;<span class="built_in">getresult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//释放对应的数据</span></span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建-法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> <span class="built_in">jianCalculator</span>();</span><br><span class="line">abc-&gt;a = <span class="number">10</span>;</span><br><span class="line">abc-&gt;b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;<span class="built_in">getresult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建*法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> <span class="built_in">chengCalculator</span>();</span><br><span class="line">abc-&gt;a = <span class="number">10</span>;</span><br><span class="line">abc-&gt;b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;<span class="built_in">getresult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line"><span class="comment">//创建/法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> <span class="built_in">chuCalculator</span>();</span><br><span class="line">abc-&gt;a = <span class="number">10</span>;</span><br><span class="line">abc-&gt;b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;<span class="built_in">getresult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line"><span class="comment">//销毁一次后仅仅完成了空间的释放,此时还可以使用,即指向关系依然存在,</span></span><br><span class="line"><span class="comment">//但如果释放了两次以上指向关系将不存在,但一般不建议这样使用,</span></span><br><span class="line"><span class="comment">//既然释放了某空间,紧接着给该空间的指针赋值为NULL或者指向一个地方,养成良好的编程风格</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p><p><strong><strong>&#x2F;&#x2F;销毁一次后仅仅完成了空间的释放,此时还可以使用,即指向关系依然存在,</strong><br>    <strong>&#x2F;&#x2F;但如果释放了两次以上指向关系将不存在,但一般不建议这样使用,</strong><br>    &#x2F;&#x2F;既然释放了某空间,紧接着给该空间的指针赋值为NULL或者指向一个地方,养成良好的编程风格</strong></p></blockquote><h4 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="&#x3D;&#x3D;4.7.3 纯虚函数和抽象类&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.7.3 纯虚函数和抽象类&#x3D;&#x3D;</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><blockquote><p><strong>抽象类不能实例化，但是能定义一个指向该类的指针</strong></p></blockquote><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><hr><p><strong>当类中有了纯虚函数，这个类也称为&#x3D;&#x3D;抽象类&#x3D;&#x3D;</strong></p><p><strong>纯虚函数是在<em>基类</em>中声明为纯虚函数的虚函数，它没有实现，只是用来作为接口的占位符，要求派生类必须实现这个函数。</strong></p><hr><p><strong>抽象类特点</strong>：</p><ul><li><strong>无法实例化对象</strong></li><li><strong>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</strong></li></ul><blockquote><p>纯虚函数来自</p><ol><li><strong>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></strong></li><li><strong>继承抽象类但不重写对应的纯虚函数！！！！！！！</strong></li><li>有虚析构函数或者纯虚析构函数</li></ol></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line"><span class="comment">//抽象类无法实例化对象</span></span><br><span class="line"><span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base * base = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">base = <span class="keyword">new</span> Son;</span><br><span class="line">base-&gt;<span class="built_in">func</span>();</span><br><span class="line"><span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-4-多态案例二-制作饮品"><a href="#4-7-4-多态案例二-制作饮品" class="headerlink" title="4.7.4 多态案例二-制作饮品"></a>4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p><p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><img src="/post/a77e947a/1545985945198.png" class="" width="1545985945198"><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Makedrink</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">zhushui</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">chongru</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">daorubeizhong</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">jiaruzuoliao</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//规定流程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Makeit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">zhushui</span>();</span><br><span class="line"><span class="built_in">chongru</span>();</span><br><span class="line"><span class="built_in">daorubeizhong</span>();</span><br><span class="line"><span class="built_in">jiaruzuoliao</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MakeCha</span> :<span class="keyword">public</span> Makedrink</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zhushui</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;做茶的时候煮水&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chongru</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡茶叶&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">daorubeizhong</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;倒入杯子&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">jiaruzuoliao</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加柠檬&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Makecoffee</span> :<span class="keyword">public</span> Makedrink</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zhushui</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;做咖啡的时候煮水&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chongru</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡咖啡&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">daorubeizhong</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;倒入杯子&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">jiaruzuoliao</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加牛奶和冰糖&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dowork</span><span class="params">(Makedrink* abc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">abc-&gt;<span class="built_in">Makeit</span>();</span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Makedrink* mc = <span class="keyword">new</span> <span class="built_in">MakeCha</span>();</span><br><span class="line"><span class="built_in">Dowork</span>(mc);</span><br><span class="line"><span class="built_in">Dowork</span>(<span class="keyword">new</span> MakeCha);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;现在开始制作咖啡&quot;</span> &lt;&lt; endl;</span><br><span class="line">Makedrink* cf = <span class="keyword">new</span> <span class="built_in">Makecoffee</span>();</span><br><span class="line"><span class="built_in">Dowork</span>(cf);</span><br><span class="line"><span class="built_in">Dowork</span>(<span class="keyword">new</span> MakeCha);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h4><p><strong>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</strong></p><p><strong>也就是说不运行子类的析构函数！！！造成内存泄漏</strong></p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>​<strong>如果改成纯虚析构的话需要在函数外部进行 函数实现</strong></p><p>​<strong>或者就是简单的弄一个虚析构函数就ok了</strong></p><p>虚析构和纯虚析构共性：</p><ul><li><strong>可以解决父类指针释放子类对象</strong></li><li><strong>都需要有具体的函数实现</strong>，纯虚析构函数的实现必须在外部！</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p><strong>虚析构函数通常在希望通过基类指针或引用来删除派生类对象时使用。这样可以确保派生类的析构函数被正确调用，避免内存泄漏。</strong></p><p>虚析构语法：</p><p><code>virtual ~类名()&#123;&#125;</code></p><p>纯虚析构语法：</p><p><code> virtual ~类名() = 0;</code></p><p><strong>必须需要有外部实现！！！</strong></p><p><code>类名::~类名()&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//不加virtual的时候不会走子类的 析构函数 造成内存泄露</span></span><br><span class="line"><span class="comment">//析构函数加上virtual关键字，变成虚析构函数  就会走子类的析构函数了</span></span><br><span class="line"><span class="comment">//virtual ~Animal()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者是纯虚析构函数，但要有函数实现！！且在外部</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cat</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//虚函数的重写</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; *m_Name &lt;&lt; <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Cat</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_Name;</span><br><span class="line">m_Name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string* m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal* animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line"><span class="comment">//怎么解决？给基类增加一个虚析构函数 或者纯虚析构函数，但是明显是虚析构函数简单a Aaaaa</span></span><br><span class="line"><span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line"><span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><blockquote><h4 id="1-虚析构或纯虚析构就是用来解决通过父类指针释放子类对象"><a href="#1-虚析构或纯虚析构就是用来解决通过父类指针释放子类对象" class="headerlink" title="1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象"></a>1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</h4><h4 id="2-如果子类中没有堆区数据，可以不写为虚析构或纯虚析构"><a href="#2-如果子类中没有堆区数据，可以不写为虚析构或纯虚析构" class="headerlink" title="2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构"></a>2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</h4><h4 id="3-拥有纯虚析构函数的类也属于抽象类"><a href="#3-拥有纯虚析构函数的类也属于抽象类" class="headerlink" title="3. 拥有纯虚析构函数的类也属于抽象类"></a>3. 拥有纯虚析构函数的类也属于抽象类</h4></blockquote><h4 id="4-7-6-多态案例三-电脑组装"><a href="#4-7-6-多态案例三-电脑组装" class="headerlink" title="&#x3D;&#x3D;4.7.6 多态案例三-电脑组装&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.7.6 多态案例三-电脑组装&#x3D;&#x3D;</h4><p><strong>案例描述：</strong></p><p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p><p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p><p>测试时组装三台不同的电脑进行工作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的计算函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的存储函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Computer</span>(CPU* cpu, VideoCard* vc, Memory* mem)</span><br><span class="line">&#123;</span><br><span class="line">m_cpu = cpu;</span><br><span class="line">m_vc = vc;</span><br><span class="line">m_mem = mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供工作的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">~<span class="built_in">Computer</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放CPU零件</span></span><br><span class="line"><span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_cpu;</span><br><span class="line">m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放显卡零件</span></span><br><span class="line"><span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_vc;</span><br><span class="line">m_vc = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存条零件</span></span><br><span class="line"><span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_mem;</span><br><span class="line">m_mem = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">CPU* m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">VideoCard* m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">Memory* m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//第一台电脑零件</span></span><br><span class="line">CPU* intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">VideoCard* intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">Memory* intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//创建第一台电脑</span></span><br><span class="line">Computer* computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//第二台电脑组装</span></span><br><span class="line">Computer* computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);</span><br><span class="line">computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer2;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//第三台电脑组装</span></span><br><span class="line">Computer* computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);</span><br><span class="line">computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过<strong>文件可以将数据持久化</strong></p><p>C++中对文件操作需要包含头文件 &#x3D;&#x3D;&lt; fstream &gt;&#x3D;&#x3D;</p><p>文件类型分为两种：</p><ol><li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li><li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li></ol><p>操作文件的三大类:</p><ol><li>ofstream：写操作</li><li>ifstream： 读操作</li><li>fstream ： 读写操作</li></ol><h3 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h3><h4 id="5-1-1写文件"><a href="#5-1-1写文件" class="headerlink" title="5.1.1写文件"></a>5.1.1写文件</h4><p>   写文件步骤如下：</p><ol><li><p>包含头文件   </p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象  </p><p>ofstream ofs;</p></li><li><p>打开文件</p><p>ofs.open(“文件路径”,打开方式);</p></li><li><p>写数据</p><p>ofs &lt;&lt; “写入的数据”;</p></li><li><p>关闭文件</p><p>ofs.close();</p></li></ol><p>文件打开方式：</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p><p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p><blockquote><p>在C++中，<code>|</code> 是位运算符中的按位或运算符。当它用于两个整数时，它将对这两个整数的每个位执行逻辑或操作。</p><p>在文件操作中，<code>|</code> 运算符通常用于将多个标志（flag）组合在一起。在你提供的例子中，<code>ios::binary | ios::out</code> 将 <code>ios::binary</code> 和 <code>ios::out</code> 这两个标志进行按位或运算，以便将它们组合在一起。</p><p><code>ios::binary</code> 是 <code>ios</code> 类中的一个标志，表示以二进制模式打开文件。在二进制模式下，文件将以字节流的形式进行读写，而不会进行任何文本转换。</p><p><code>ios::out</code> 是另一个 <code>ios</code> 类中的标志，表示以写入模式打开文件。在写入模式下，文件将被打开以供写入操作。</p><p>通过将这两个标志使用 <code>|</code> 运算符组合在一起，你可以同时指定二进制模式和写入模式来打开文件。</p></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件操作必须包含头文件 fstream</li><li>读文件可以利用 ofstream  ，或者fstream类</li><li>打开文件时候需要指定操作文件的路径，以及打开方式</li><li>利用&lt;&lt;可以向文件中写数据</li><li>操作完毕，要关闭文件</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.包含fstream头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.测试写操作ooooo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.1创建对象!</span></span><br><span class="line"><span class="comment">//fstream a;</span></span><br><span class="line"><span class="comment">//也是ok的，为了区分，先引入总的头文件fstream，再用其分类ostream创建具体要写的对象</span></span><br><span class="line">ofstream a;</span><br><span class="line"><span class="comment">//1.2打开文件</span></span><br><span class="line">a.<span class="built_in">open</span>(<span class="string">&quot;E:/PROPORECODE/文件的读写操作/12.txt&quot;</span>, ios::out);</span><br><span class="line"><span class="comment">//1.3写入操作</span></span><br><span class="line">a &lt;&lt; <span class="string">&quot;你好啊&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//1.4关闭文件</span></span><br><span class="line">a.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-2读文件"><a href="#5-1-2读文件" class="headerlink" title="5.1.2读文件"></a>5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步骤如下：</p><ol><li><p>包含头文件   </p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象  </p><p>ifstream ifs;</p></li><li><p>打开文件并判断文件是否打开成功</p><p>ifs.open(“文件路径”,打开方式);</p></li><li><p>读数据</p><p>四种方式读取</p></li><li><p>关闭文件</p><p>ifs.close();</p></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//1.包含fstream头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.测试写操作ooooo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.1创建对象!</span></span><br><span class="line"><span class="comment">//fstream a;</span></span><br><span class="line"><span class="comment">//也是ok的，为了区分，先引入总的头文件fstream，再用其分类ostream创建具体要写的对象</span></span><br><span class="line">ofstream a;</span><br><span class="line"><span class="comment">//1.2打开文件</span></span><br><span class="line">a.<span class="built_in">open</span>(<span class="string">&quot;E:/PROPORECODE/文件的读写操作/11.txt&quot;</span>, ios::out | ios::binary);</span><br><span class="line"><span class="comment">//1.3写入操作</span></span><br><span class="line"><span class="comment">//&quot;你好啊&quot; &lt;&lt; endl;都被写进去了</span></span><br><span class="line">a &lt;&lt; <span class="string">&quot;你好啊dasdad &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//1.4关闭文件</span></span><br><span class="line">a.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.测试读文件</span></span><br><span class="line"><span class="comment">//2.1创建读的对象iiii</span></span><br><span class="line">fstream b;</span><br><span class="line">b.<span class="built_in">open</span>(<span class="string">&quot;E:/PROPORECODE/文件的读写操作/11.txt&quot;</span>, ios::in);</span><br><span class="line"><span class="keyword">if</span> (b.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;打开成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;打开失败！，草！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//读取1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//char bufer[1024];</span></span><br><span class="line"><span class="comment">//while (b&gt;&gt;bufer)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; bufer;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//读取2类内的getline</span></span><br><span class="line"><span class="comment">//char bufer[1024] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//while (b.getline(bufer, sizeof(bufer)))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; bufer &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//读取3全局getline</span></span><br><span class="line"><span class="comment">//string str;</span></span><br><span class="line"><span class="comment">//while (getline(b,str))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; str &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> (c=b.<span class="built_in">get</span>()!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从右到左！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><blockquote><ul><li><strong>读文件可以利用 ifstream  ，或者fstream类</strong></li><li><strong>利用is_open函数可以判断文件是否打开成功</strong></li><li><strong>close 关闭文件</strong></li></ul></blockquote><h3 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为 &#x3D;&#x3D;ios::binary&#x3D;&#x3D;</p><h4 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> name[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">fstream <span class="title">a</span><span class="params">(<span class="string">&quot;E:/PROPORECODE/文件的读写操作/21.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">MyStruct xrb = &#123; <span class="number">18</span>,<span class="string">&quot;李四&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//结构体的实例化</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">a.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;xrb, <span class="built_in">sizeof</span>(str));</span><br><span class="line"></span><br><span class="line">a.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件输出流对象 可以通过write函数，以二进制方式写数据</li></ul><h4 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> name[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">fstream <span class="title">a</span><span class="params">(<span class="string">&quot;E:/PROPORECODE/文件的读写操作/21.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">MyStruct xrb = &#123; <span class="number">18</span>,<span class="string">&quot;李四&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//结构体的实例化</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">a.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;xrb, <span class="built_in">sizeof</span>(xrb));</span><br><span class="line"></span><br><span class="line">a.<span class="built_in">close</span>();</span><br><span class="line">fstream b;</span><br><span class="line">b.<span class="built_in">open</span>(<span class="string">&quot;E:/PROPORECODE/文件的读写操作/21.txt&quot;</span>, ios::in | ios::binary);</span><br><span class="line"><span class="keyword">if</span> (b.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;读取成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">MyStruct l;</span><br><span class="line">b.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;l, <span class="built_in">sizeof</span>(l));</span><br><span class="line">cout &lt;&lt; l.age &lt;&lt; l.name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文件输入流对象 可以通过read函数，以二进制方式读数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> c++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++核心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp1.0</title>
      <link href="/post/a5382a23.html"/>
      <url>/post/a5382a23.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-基础入门"><a href="#C-基础入门" class="headerlink" title="C++基础入门"></a>C++基础入门</h1><h2 id="1-C-初识"><a href="#1-C-初识" class="headerlink" title="1 C++初识"></a>1 C++初识</h2><h3 id="1-1-第一个C-程序"><a href="#1-1-第一个C-程序" class="headerlink" title="1.1  第一个C++程序"></a>1.1  第一个C++程序</h3><p>编写一个C++程序总共分为4个步骤</p><ul><li>创建项目</li><li>创建文件</li><li>编写代码</li><li>运行程序</li></ul><h4 id="1-1-1-创建项目"><a href="#1-1-1-创建项目" class="headerlink" title="1.1.1 创建项目"></a>1.1.1 创建项目</h4><p>​Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开</p><img src="/post/a5382a23/1541383178746.png" class="" width="1541383178746"><img src="/post/a5382a23/1541384366413.png" class="" width="1541384366413"><h4 id="1-1-2-创建文件"><a href="#1-1-2-创建文件" class="headerlink" title="1.1.2 创建文件"></a>1.1.2 创建文件</h4><p>右键源文件，选择添加-&gt;新建项</p><img src="/post/a5382a23/1541383817248.png" class="" width="1541383817248"><p>给C++文件起个名称，然后点击添加即可。</p><img src="/post/a5382a23/1541384140042.png" class="" width="1541384140042"><h4 id="1-1-3-编写代码"><a href="#1-1-3-编写代码" class="headerlink" title="1.1.3 编写代码"></a>1.1.3 编写代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-4-运行程序"><a href="#1-1-4-运行程序" class="headerlink" title="1.1.4 运行程序"></a>1.1.4 运行程序</h4><img src="/post/a5382a23/1541384818688.png" class="" width="1541384818688"><h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><p><strong>作用</strong>：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码</p><p><strong>两种格式</strong></p><ol><li><strong>单行注释</strong>：<code>// 描述信息</code> <ul><li>通常放在一行代码的上方，或者一条语句的末尾，&#x3D;&#x3D;对该行代码说明&#x3D;&#x3D;</li></ul></li><li><strong>多行注释</strong>： <code>/* 描述信息 */</code><ul><li>通常放在一段代码的上方，&#x3D;&#x3D;对该段代码做整体说明&#x3D;&#x3D;</li></ul></li></ol><blockquote><p>提示：编译器在编译代码时，会忽略注释的内容</p></blockquote><h3 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h3><p><strong>作用</strong>：给一段指定的内存空间起名，方便操作这段内存</p><p><strong>语法</strong>：<code>数据类型 变量名 = 初始值;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变量的定义</span></span><br><span class="line"><span class="comment">//语法：数据类型  变量名 = 初始值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：C++在创建变量时，必须给变量一个初始值，否则会报错</p></blockquote><h3 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4  常量"></a>1.4  常量</h3><p><strong>作用</strong>：用于记录程序中不可更改的数据</p><p>C++定义常量两种方式</p><ol><li><p><strong>#define</strong> 宏常量： <code>#define 常量名 常量值</code></p><ul><li>&#x3D;&#x3D;通常在文件上方定义&#x3D;&#x3D;，表示一个常量</li></ul></li><li><p><strong>const</strong>修饰的变量 <code>const 数据类型 常量名 = 常量值</code></p><ul><li>&#x3D;&#x3D;通常在变量定义前加关键字const&#x3D;&#x3D;，修饰该变量为常量，不可修改</li></ul></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、宏常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> day 7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;一周里总共有 &quot;</span> &lt;&lt; day &lt;&lt; <span class="string">&quot; 天&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//day = 8;  //报错，宏常量不可以修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、const修饰变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> month = <span class="number">12</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;一年里总共有 &quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot; 个月份&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//month = 24; //报错，常量是不可以修改的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-关键字"><a href="#1-5-关键字" class="headerlink" title="1.5 关键字"></a>1.5 关键字</h3><p><strong>作用：</strong>关键字是C++中预先保留的单词（标识符）</p><ul><li><strong>在定义变量或者常量时候，不要用关键字</strong></li></ul><p>C++关键字如下：</p><table><thead><tr><th>asm</th><th>do</th><th>if</th><th>return</th><th>typedef</th></tr></thead><tbody><tr><td>auto</td><td>double</td><td>inline</td><td>short</td><td>typeid</td></tr><tr><td>bool</td><td>dynamic_cast</td><td>int</td><td>signed</td><td>typename</td></tr><tr><td>break</td><td>else</td><td>long</td><td>sizeof</td><td>union</td></tr><tr><td>case</td><td>enum</td><td>mutable</td><td>static</td><td>unsigned</td></tr><tr><td>catch</td><td>explicit</td><td>namespace</td><td>static_cast</td><td>using</td></tr><tr><td>char</td><td>export</td><td>new</td><td>struct</td><td>virtual</td></tr><tr><td>class</td><td>extern</td><td>operator</td><td>switch</td><td>void</td></tr><tr><td>const</td><td>false</td><td>private</td><td>template</td><td>volatile</td></tr><tr><td>const_cast</td><td>float</td><td>protected</td><td>this</td><td>wchar_t</td></tr><tr><td>continue</td><td>for</td><td>public</td><td>throw</td><td>while</td></tr><tr><td>default</td><td>friend</td><td>register</td><td>true</td><td></td></tr><tr><td>delete</td><td>goto</td><td>reinterpret_cast</td><td>try</td><td></td></tr></tbody></table><p><code>提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。</code></p><h3 id="1-6-标识符命名规则"><a href="#1-6-标识符命名规则" class="headerlink" title="1.6 标识符命名规则"></a>1.6 标识符命名规则</h3><p><strong>作用</strong>：C++规定给标识符（变量、常量）命名时，有一套自己的规则</p><ul><li>标识符不能是关键字</li><li>标识符只能由字母、数字、下划线组成</li><li>第一个字符必须为字母或下划线</li><li>标识符中字母区分大小写</li></ul><blockquote><p>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读</p></blockquote><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2 数据类型"></a>2 数据类型</h2><p>C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存</p><h3 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h3><p><strong>作用</strong>：整型变量表示的是&#x3D;&#x3D;整数类型&#x3D;&#x3D;的数据</p><p>C++中能够表示整型的类型有以下几种方式，<strong>区别在于所占内存空间不同</strong>：</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占用空间</strong></th><th>取值范围</th></tr></thead><tbody><tr><td>short(短整型)</td><td>2字节</td><td>(-2^15 ~ 2^15-1)</td></tr><tr><td>int(整型)</td><td>4字节</td><td>(-2^31 ~ 2^31-1)</td></tr><tr><td>long(长整形)</td><td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td><td>(-2^31 ~ 2^31-1)</td></tr><tr><td>long long(长长整形)</td><td>8字节</td><td>(-2^63 ~ 2^63-1)</td></tr></tbody></table><h3 id="2-2-sizeof关键字"><a href="#2-2-sizeof关键字" class="headerlink" title="2.2 sizeof关键字"></a>2.2 sizeof关键字</h3><p><strong>作用：</strong>利用sizeof关键字可以&#x3D;&#x3D;统计数据类型所占内存大小&#x3D;&#x3D;</p><p><strong>语法：</strong> <code>sizeof( 数据类型 / 变量)</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;short 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;int 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>整型结论</strong>：&#x3D;&#x3D;short &lt; int &lt;&#x3D; long &lt;&#x3D; long long&#x3D;&#x3D;</p></blockquote><h3 id="2-3-实型（浮点型）"><a href="#2-3-实型（浮点型）" class="headerlink" title="2.3 实型（浮点型）"></a>2.3 实型（浮点型）</h3><p><strong>作用</strong>：用于&#x3D;&#x3D;表示小数&#x3D;&#x3D;</p><p>浮点型变量分为两种：</p><ol><li>单精度float </li><li>双精度double</li></ol><p>两者的<strong>区别</strong>在于表示的有效数字范围不同。</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占用空间</strong></th><th><strong>有效数字范围</strong></th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>7位有效数字</td></tr><tr><td>double</td><td>8字节</td><td>15～16位有效数字</td></tr><tr><td>long double</td><td>16字节</td><td></td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> f1 = <span class="number">3.14f</span>;</span><br><span class="line"><span class="type">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> ld=<span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; d1&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;float  sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(f1) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;double sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(d1) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;lone double sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(ld) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//科学计数法</span></span><br><span class="line"><span class="type">float</span> f2 = <span class="number">-3e2</span>; <span class="comment">// 3 * 10 ^ 2 </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;f2 = &quot;</span> &lt;&lt; f2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> f3 = <span class="number">3e-2</span>;  <span class="comment">// 3 * 0.1 ^ 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;f3 = &quot;</span> &lt;&lt; f3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-字符型"><a href="#2-4-字符型" class="headerlink" title="2.4 字符型"></a>2.4 字符型</h3><p><strong>作用：</strong>字符型变量用于显示单个字符</p><p><strong>语法：</strong><code>char ch = &#39;a&#39;;</code></p><blockquote><p>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号</p></blockquote><blockquote><p>注意2：单引号内只能有一个字符，不是字符串</p></blockquote><ul><li>C和C++中字符型变量只占用&#x3D;&#x3D;1个字节&#x3D;&#x3D;。</li><li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ch = &quot;abcde&quot;; //错误，不可以用双引号</span></span><br><span class="line"><span class="comment">//ch = &#x27;abcde&#x27;; //错误，单引号内只能引用一个字符</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (<span class="type">int</span>)ch &lt;&lt; endl;  <span class="comment">//查看字符a对应的ASCII码</span></span><br><span class="line">ch = <span class="number">97</span>; <span class="comment">//可以直接用ASCII给字符型变量赋值</span></span><br><span class="line">cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ASCII码表格：</p><table><thead><tr><th><strong>ASCII</strong>值</th><th><strong>控制字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th></tr></thead><tbody><tr><td>0</td><td>NUT</td><td>32</td><td>(space)</td><td>64</td><td>@</td><td>96</td><td>、</td></tr><tr><td>1</td><td>SOH</td><td>33</td><td>!</td><td>65</td><td>A</td><td>97</td><td>a</td></tr><tr><td>2</td><td>STX</td><td>34</td><td>“</td><td>66</td><td>B</td><td>98</td><td>b</td></tr><tr><td>3</td><td>ETX</td><td>35</td><td>#</td><td>67</td><td>C</td><td>99</td><td>c</td></tr><tr><td>4</td><td>EOT</td><td>36</td><td>$</td><td>68</td><td>D</td><td>100</td><td>d</td></tr><tr><td>5</td><td>ENQ</td><td>37</td><td>%</td><td>69</td><td>E</td><td>101</td><td>e</td></tr><tr><td>6</td><td>ACK</td><td>38</td><td>&amp;</td><td>70</td><td>F</td><td>102</td><td>f</td></tr><tr><td>7</td><td>BEL</td><td>39</td><td>,</td><td>71</td><td>G</td><td>103</td><td>g</td></tr><tr><td>8</td><td>BS</td><td>40</td><td>(</td><td>72</td><td>H</td><td>104</td><td>h</td></tr><tr><td>9</td><td>HT</td><td>41</td><td>)</td><td>73</td><td>I</td><td>105</td><td>i</td></tr><tr><td>10</td><td>LF</td><td>42</td><td>*</td><td>74</td><td>J</td><td>106</td><td>j</td></tr><tr><td>11</td><td>VT</td><td>43</td><td>+</td><td>75</td><td>K</td><td>107</td><td>k</td></tr><tr><td>12</td><td>FF</td><td>44</td><td>,</td><td>76</td><td>L</td><td>108</td><td>l</td></tr><tr><td>13</td><td>CR</td><td>45</td><td>-</td><td>77</td><td>M</td><td>109</td><td>m</td></tr><tr><td>14</td><td>SO</td><td>46</td><td>.</td><td>78</td><td>N</td><td>110</td><td>n</td></tr><tr><td>15</td><td>SI</td><td>47</td><td>&#x2F;</td><td>79</td><td>O</td><td>111</td><td>o</td></tr><tr><td>16</td><td>DLE</td><td>48</td><td>0</td><td>80</td><td>P</td><td>112</td><td>p</td></tr><tr><td>17</td><td>DCI</td><td>49</td><td>1</td><td>81</td><td>Q</td><td>113</td><td>q</td></tr><tr><td>18</td><td>DC2</td><td>50</td><td>2</td><td>82</td><td>R</td><td>114</td><td>r</td></tr><tr><td>19</td><td>DC3</td><td>51</td><td>3</td><td>83</td><td>S</td><td>115</td><td>s</td></tr><tr><td>20</td><td>DC4</td><td>52</td><td>4</td><td>84</td><td>T</td><td>116</td><td>t</td></tr><tr><td>21</td><td>NAK</td><td>53</td><td>5</td><td>85</td><td>U</td><td>117</td><td>u</td></tr><tr><td>22</td><td>SYN</td><td>54</td><td>6</td><td>86</td><td>V</td><td>118</td><td>v</td></tr><tr><td>23</td><td>TB</td><td>55</td><td>7</td><td>87</td><td>W</td><td>119</td><td>w</td></tr><tr><td>24</td><td>CAN</td><td>56</td><td>8</td><td>88</td><td>X</td><td>120</td><td>x</td></tr><tr><td>25</td><td>EM</td><td>57</td><td>9</td><td>89</td><td>Y</td><td>121</td><td>y</td></tr><tr><td>26</td><td>SUB</td><td>58</td><td>:</td><td>90</td><td>Z</td><td>122</td><td>z</td></tr><tr><td>27</td><td>ESC</td><td>59</td><td>;</td><td>91</td><td>[</td><td>123</td><td>{</td></tr><tr><td>28</td><td>FS</td><td>60</td><td>&lt;</td><td>92</td><td>&#x2F;</td><td>124</td><td>|</td></tr><tr><td>29</td><td>GS</td><td>61</td><td>&#x3D;</td><td>93</td><td>]</td><td>125</td><td>}</td></tr><tr><td>30</td><td>RS</td><td>62</td><td>&gt;</td><td>94</td><td>^</td><td>126</td><td>&#96;</td></tr><tr><td>31</td><td>US</td><td>63</td><td>?</td><td>95</td><td>_</td><td>127</td><td>DEL</td></tr></tbody></table><p>ASCII 码大致由以下<strong>两部分组</strong>成：</p><ul><li>ASCII 非打印控制字符： ASCII 表上的数字 <strong>0-31</strong> 分配给了控制字符，用于控制像打印机等一些外围设备。</li><li>ASCII 打印字符：数字 <strong>32-126</strong> 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li></ul><h3 id="2-5-转义字符"><a href="#2-5-转义字符" class="headerlink" title="2.5 转义字符"></a>2.5 转义字符</h3><p><strong>作用：</strong>用于表示一些&#x3D;&#x3D;不能显示出来的ASCII字符&#x3D;&#x3D;</p><p>现阶段我们常用的转义字符有：<code> \n  \\  \t</code></p><table><thead><tr><th><strong>转义字符</strong></th><th><strong>含义</strong></th><th><strong>ASCII</strong>码值（十进制）</th></tr></thead><tbody><tr><td>\a</td><td>警报</td><td>007</td></tr><tr><td>\b</td><td>退格(BS) ，将当前位置移到前一列</td><td>008</td></tr><tr><td>\f</td><td>换页(FF)，将当前位置移到下页开头</td><td>012</td></tr><tr><td><strong>\n</strong></td><td><strong>换行(LF) ，将当前位置移到下一行开头</strong></td><td><strong>010</strong></td></tr><tr><td>\r</td><td>回车(CR) ，将当前位置移到本行开头</td><td>013</td></tr><tr><td><strong>\t</strong></td><td><strong>水平制表(HT)  （跳到下一个TAB位置）</strong></td><td><strong>009</strong></td></tr><tr><td>\v</td><td>垂直制表(VT)</td><td>011</td></tr><tr><td><strong>\\</strong></td><td><strong>代表一个反斜线字符”&quot;</strong></td><td><strong>092</strong></td></tr><tr><td>&#39;</td><td>代表一个单引号（撇号）字符</td><td>039</td></tr><tr><td>&quot;</td><td>代表一个双引号字符</td><td>034</td></tr><tr><td>?</td><td>代表一个问号</td><td>063</td></tr><tr><td>\0</td><td>数字0</td><td>000</td></tr><tr><td>\ddd</td><td>8进制转义字符，d范围0~7</td><td>3位8进制</td></tr><tr><td>\xhh</td><td>16进制转义字符，h范围0<del>9，a</del>f，A~F</td><td>3位16进制</td></tr></tbody></table><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\\&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\tHello&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-字符串型"><a href="#2-6-字符串型" class="headerlink" title="2.6 字符串型"></a>2.6 字符串型</h3><p><strong>作用</strong>：用于表示一串字符</p><p><strong>两种风格</strong></p><ol><li><p><strong>C风格字符串</strong>： <code>char 变量名[] = &quot;字符串值&quot;</code></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意：C风格的字符串要用双引号括起来</p></blockquote><ol><li><p><strong>C++风格字符串</strong>：  <code>string  变量名 = &quot;字符串值&quot;</code></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意：C++风格字符串，需要加入头文件&#x3D;&#x3D;#include&lt;string&gt;&#x3D;&#x3D;</p></blockquote><h3 id="2-7-布尔类型-bool"><a href="#2-7-布尔类型-bool" class="headerlink" title="2.7 布尔类型 bool"></a>2.7 布尔类型 bool</h3><p><strong>作用：</strong>布尔数据类型代表真或假的值 </p><p>bool类型只有两个值：</p><ul><li>true  — 真（本质是1）</li><li>false — 假（本质是0）</li></ul><p><strong>bool类型占&#x3D;&#x3D;1个字节&#x3D;&#x3D;大小</strong></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line">cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size of bool = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">bool</span>) &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8-数据的输入"><a href="#2-8-数据的输入" class="headerlink" title="2.8 数据的输入"></a>2.8 数据的输入</h3><p><strong>作用：用于从键盘获取数据</strong></p><p><strong>关键字：</strong>cin</p><p><strong>语法：</strong> <code>cin &gt;&gt; 变量 </code></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整型输入</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入整型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//浮点型输入</span></span><br><span class="line"><span class="type">double</span> d = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入浮点型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; d;</span><br><span class="line">cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符型输入</span></span><br><span class="line"><span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入字符型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; ch;</span><br><span class="line">cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串型输入</span></span><br><span class="line">string str;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入字符串型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//布尔类型输入</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入布尔型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; flag;</span><br><span class="line">cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3 运算符"></a>3 运算符</h2><p><strong>作用：</strong>用于执行代码的运算</p><p>本章我们主要讲解以下几类运算符：</p><table><thead><tr><th><strong>运算符类型</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>算术运算符</td><td>用于处理四则运算</td></tr><tr><td>赋值运算符</td><td>用于将表达式的值赋给变量</td></tr><tr><td>比较运算符</td><td>用于表达式的比较，并返回一个真值或假值</td></tr><tr><td>逻辑运算符</td><td>用于根据表达式的值返回真值或假值</td></tr></tbody></table><h3 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1 算术运算符"></a>3.1 算术运算符</h3><p><strong>作用</strong>：用于处理四则运算 </p><p>算术运算符包括以下符号：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>+</td><td>正号</td><td>+3</td><td>3</td></tr><tr><td>-</td><td>负号</td><td>-3</td><td>-3</td></tr><tr><td>+</td><td>加</td><td>10 + 5</td><td>15</td></tr><tr><td>-</td><td>减</td><td>10 - 5</td><td>5</td></tr><tr><td>*</td><td>乘</td><td>10 * 5</td><td>50</td></tr><tr><td>&#x2F;</td><td>除</td><td>10 &#x2F; 5</td><td>2</td></tr><tr><td>%</td><td>取模(取余)</td><td>10 % 3</td><td>1</td></tr><tr><td>++c</td><td>前置递增</td><td>a&#x3D;2; b&#x3D;++a;</td><td>a&#x3D;3; b&#x3D;3;</td></tr><tr><td>c++</td><td>后置递增</td><td>a&#x3D;2; b&#x3D;a++;</td><td>a&#x3D;3; b&#x3D;2;</td></tr><tr><td>–</td><td>前置递减</td><td>a&#x3D;2; b&#x3D;–a;</td><td>a&#x3D;1; b&#x3D;1;</td></tr><tr><td>c–</td><td>后置递减</td><td>a&#x3D;2; b&#x3D;a–;</td><td>a&#x3D;1; b&#x3D;2;</td></tr></tbody></table><p><strong>示例1：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加减乘除</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a1 + b1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; a1 - b1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; a1 * b1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; a1 / b1 &lt;&lt; endl;  <span class="comment">//两个整数相除结果依然是整数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b2 = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; a2 / b2 &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b3 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//两个小数可以相除</span></span><br><span class="line"><span class="type">double</span> d1 = <span class="number">0.5</span>;</span><br><span class="line"><span class="type">double</span> d2 = <span class="number">0.25</span>;</span><br><span class="line">cout &lt;&lt; d1 / d2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：在除法运算中，除数不能为0</p></blockquote><p><strong>示例2：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取模</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="number">10</span> % <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a2 % b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两个小数不可以取模</span></span><br><span class="line"><span class="type">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> d2 = <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; d1 % d2 &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>总结：&#x3D;&#x3D;只有整型变量可以进行取模运算&#x3D;&#x3D;</p></blockquote><p><strong>示例3：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递增</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置递增</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a++; <span class="comment">//等价于a = a + 1</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置递增</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">++b;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//区别</span></span><br><span class="line"><span class="comment">//前置递增先对变量进行++，再计算表达式</span></span><br><span class="line"><span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b2 = ++a2 * <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置递增先计算表达式，后对变量进行++</span></span><br><span class="line"><span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b3 = a3++ * <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; b3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>总结：前置递增先对变量进行++，再计算表达式，后置递增相反</p></blockquote><h3 id="3-2-赋值运算符"><a href="#3-2-赋值运算符" class="headerlink" title="3.2 赋值运算符"></a>3.2 赋值运算符</h3><p><strong>作用：</strong>用于将表达式的值赋给变量</p><p>赋值运算符包括以下几个符号：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>&#x3D;</td><td>赋值</td><td>a&#x3D;2; b&#x3D;3;</td><td>a&#x3D;2; b&#x3D;3;</td></tr><tr><td>+&#x3D;</td><td>加等于</td><td>a&#x3D;0; a+&#x3D;2;</td><td>a&#x3D;2;</td></tr><tr><td>-&#x3D;</td><td>减等于</td><td>a&#x3D;5; a-&#x3D;3;</td><td>a&#x3D;2;</td></tr><tr><td>*&#x3D;</td><td>乘等于</td><td>a&#x3D;2; a*&#x3D;2;</td><td>a&#x3D;4;</td></tr><tr><td>&#x2F;&#x3D;</td><td>除等于</td><td>a&#x3D;4; a&#x2F;&#x3D;2;</td><td>a&#x3D;2;</td></tr><tr><td>%&#x3D;</td><td>模等于</td><td>a&#x3D;3; a%2;</td><td>a&#x3D;1;</td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// +=</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a += <span class="number">2</span>; <span class="comment">// a = a + 2;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -=</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a -= <span class="number">2</span>; <span class="comment">// a = a - 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *=</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a *= <span class="number">2</span>; <span class="comment">// a = a * 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /=</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a /= <span class="number">2</span>;  <span class="comment">// a = a / 2;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %=</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a %= <span class="number">2</span>;  <span class="comment">// a = a % 2;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h3><p><strong>作用：</strong>用于表达式的比较，并返回一个真值或假值</p><p>比较运算符有以下符号：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>相等于</td><td>4 &#x3D;&#x3D; 3</td><td>0</td></tr><tr><td>!&#x3D;</td><td>不等于</td><td>4 !&#x3D; 3</td><td>1</td></tr><tr><td>&lt;</td><td>小于</td><td>4 &lt; 3</td><td>0</td></tr><tr><td>&gt;</td><td>大于</td><td>4 &gt; 3</td><td>1</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td><td>4 &lt;&#x3D; 3</td><td>0</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td><td>4 &gt;&#x3D; 1</td><td>1</td></tr></tbody></table><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a == b) &lt;&lt; endl; <span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a != b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &gt; b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &lt; b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：C和C++ 语言的比较运算中， &#x3D;&#x3D;“真”用数字“1”来表示， “假”用数字“0”来表示。&#x3D;&#x3D; </p></blockquote><h3 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h3><p><strong>作用：</strong>用于根据表达式的值返回真值或假值</p><p>逻辑运算符有以下符号：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>!</td><td>非</td><td>!a</td><td>如果a为假，则!a为真；  如果a为真，则!a为假。</td></tr><tr><td>&amp;&amp;</td><td>与</td><td>a &amp;&amp; b</td><td>如果a和b都为真，则结果为真，否则为假。</td></tr><tr><td>||</td><td>或</td><td>a || b</td><td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td></tr></tbody></table><p><strong>示例1：</strong>逻辑非</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 非</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; !a &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; !!a &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 真变假，假变真</p></blockquote><p><strong>示例2：</strong>逻辑与</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 与</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>总结：逻辑&#x3D;&#x3D;与&#x3D;&#x3D;运算符总结： &#x3D;&#x3D;同真为真，其余为假&#x3D;&#x3D;</p></blockquote><p><strong>示例3：</strong>逻辑或</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 或</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1 </span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>逻辑&#x3D;&#x3D;或&#x3D;&#x3D;运算符总结： &#x3D;&#x3D;同假为假，其余为真&#x3D;&#x3D;</p></blockquote><h2 id="4-程序流程结构"><a href="#4-程序流程结构" class="headerlink" title="4 程序流程结构"></a>4 程序流程结构</h2><p>C&#x2F;C++支持最基本的三种程序运行结构：&#x3D;&#x3D;顺序结构、选择结构、循环结构&#x3D;&#x3D;</p><ul><li>顺序结构：程序按顺序执行，不发生跳转</li><li>选择结构：依据条件是否满足，有选择的执行相应功能</li><li>循环结构：依据条件是否满足，循环多次执行某段代码</li></ul><h3 id="4-1-选择结构"><a href="#4-1-选择结构" class="headerlink" title="4.1 选择结构"></a>4.1 选择结构</h3><h4 id="4-1-1-if语句"><a href="#4-1-1-if语句" class="headerlink" title="4.1.1 if语句"></a>4.1.1 if语句</h4><p><strong>作用：</strong>执行满足条件的语句</p><p>if语句的三种形式</p><ul><li><p>单行格式if语句</p></li><li><p>多行格式if语句</p></li><li><p>多条件的if语句</p></li></ul><ol><li><p>单行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;</code></p><img src="/post/a5382a23/clip_image002.png" class="" title="img"><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择结构-单行if语句</span></span><br><span class="line"><span class="comment">//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入一个分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;您输入的分数为： &quot;</span> &lt;&lt; score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if语句</span></span><br><span class="line"><span class="comment">//注意事项，在if判断语句后面，不要加分号</span></span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了一本大学！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意：if条件表达式后不要加分号</p></blockquote><ol start="2"><li>多行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;else&#123; 条件不满足执行的语句 &#125;;</code></li></ol><img src="/post/a5382a23/clip_image002-1541662519170.png" class="" title="img"><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我未考上一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>多条件的if语句：<code>if(条件1)&#123; 条件1满足执行的语句 &#125;else if(条件2)&#123;条件2满足执行的语句&#125;... else&#123; 都不满足执行的语句&#125;</code></li></ol><img src="/post/a5382a23/clip_image002-1541662566808.png" class="" title="img"><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>嵌套if语句</strong>：在if语句中，可以嵌套使用if语句，达到更精确的条件判断</p><p>案例需求：</p><ul><li>提示用户输入一个高考考试分数，根据分数做如下判断</li><li>分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；</li><li>在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">700</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了北大&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">650</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了清华&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了人大&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习案例：</strong> 三只小猪称体重</p><p>有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        t=a;</span><br><span class="line">        a=b;</span><br><span class="line">        b=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        t=a;</span><br><span class="line">        a=c;</span><br><span class="line">        c=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(b&gt;c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        t=b;</span><br><span class="line">        b=c;</span><br><span class="line">        c=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;a&lt;&lt;b&lt;&lt;c;</span></span><br><span class="line">    cout&lt;&lt;c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优雅</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    <span class="type">int</span> max=a;</span><br><span class="line">    <span class="keyword">if</span>(b&gt;max)&#123;</span><br><span class="line">        max=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c&gt;max)&#123;</span><br><span class="line">        max=c;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;max;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-三目运算符"><a href="#4-1-2-三目运算符" class="headerlink" title="4.1.2 三目运算符"></a>4.1.2 三目运算符</h4><p><strong>作用：</strong> 通过三目运算符实现简单的判断</p><p><strong>语法：</strong><code>表达式1 ? 表达式2 ：表达式3</code></p><p><strong>解释：</strong></p><p>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</p><p>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">c = a &gt; b ? a : b;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++中三目运算符返回的是变量,可以继续赋值</span></span><br><span class="line"></span><br><span class="line">(a &gt; b ? a : b) = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰</p></blockquote><h4 id="4-1-3-switch语句"><a href="#4-1-3-switch语句" class="headerlink" title="4.1.3 switch语句"></a>4.1.3 switch语句</h4><p><strong>作用：</strong>执行多条件分支语句</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 结果<span class="number">1</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 结果<span class="number">2</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请给电影评分 </span></span><br><span class="line"><span class="comment">//10 ~ 9   经典   </span></span><br><span class="line"><span class="comment">// 8 ~ 7   非常好</span></span><br><span class="line"><span class="comment">// 6 ~ 5   一般</span></span><br><span class="line"><span class="comment">// 5分以下 烂片</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请给电影打分&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (score)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;经典&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;非常好&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;一般&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;烂片&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意1：switch语句中表达式类型只能是整型或者字符型</p></blockquote><blockquote><p>注意2：case里如果没有break，那么程序会一直向下执行</p></blockquote><blockquote><p>总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间</p></blockquote><h3 id="4-2-循环结构"><a href="#4-2-循环结构" class="headerlink" title="4.2 循环结构"></a>4.2 循环结构</h3><h4 id="4-2-1-while循环语句"><a href="#4-2-1-while循环语句" class="headerlink" title="4.2.1 while循环语句"></a>4.2.1 while循环语句</h4><p><strong>作用：</strong>满足循环条件，执行循环语句</p><p><strong>语法：</strong><code> while(循环条件)&#123; 循环语句 &#125;</code></p><p><strong>解释：</strong>&#x3D;&#x3D;只要循环条件的结果为真，就执行循环语句&#x3D;&#x3D;</p><img src="/post/a5382a23/clip_image002-1541668640382.png" class="" title="img"><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (num &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环</p></blockquote><p><strong>while循环练习案例：</strong>&#x3D;&#x3D;猜数字&#x3D;&#x3D;</p><p><strong>案例描述：</strong>系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">int</span> c=<span class="built_in">rand</span>()%<span class="number">100</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入你猜的数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y)</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;太大了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;y)</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;太小了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;猜对了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>随机数</strong></p><blockquote><ol><li><p>(<code>rand()</code> 是 C++ 的标准库函数，用于生成伪随机数。它生成的数字序列在每次程序运行时都是相同的。<strong>stdlib.h</strong></p><p>用户未设定随机数种子时，系统默认的随机数种子为 1，rand() 产生的是伪随机数字，每次执行时是相同的; 若要不同, 用函数 srand() 初始化它。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">srand</span>(i);</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">rand</span>();</span><br><span class="line">  </span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>srand()</strong> 用来设置 rand() 产生随机数时的随机数种子。<strong>参数 seed 必须是个整数</strong>，如果每次 seed 都设相同值，rand() 所产生的随机数值每次就会一样。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">srand</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="type">int</span> a = <span class="built_in">rand</span>();</span><br><span class="line">   </span><br><span class="line">  cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 45</span></span><br><span class="line">  <span class="comment">// 45</span></span><br><span class="line">  <span class="comment">// 45</span></span><br><span class="line">  <span class="comment">// 45</span></span><br><span class="line">  <span class="comment">// 45</span></span><br><span class="line">  <span class="comment">// 45</span></span><br><span class="line">  <span class="comment">// 45</span></span><br><span class="line">  <span class="comment">// 45</span></span><br><span class="line">  <span class="comment">// 45</span></span><br><span class="line">  <span class="comment">// 45</span></span><br></pre></td></tr></table></figure></li><li><p><code>(unsigned)time(NULL)</code> 表示获取当前时间的秒数，并将其转换为无符号整数。</p><p><code>time(NULL)</code> 函数是 C&#x2F;C++ 标准库中的函数，它返回从 1970 年 1 月 1 日 00:00:00 UTC 起至今的秒数。它的函数原型是 <code>time_t time(time_t* timer)</code>，其中 <code>timer</code> 是一个指向 <code>time_t</code> 类型的指针，用于存储返回的时间值。如果将 <code>timer</code> 参数设置为 <code>NULL</code>，则 <strong><code>time(NULL)</code> 将直接返回当前时间的秒数。</strong></p><p>通过将 <code>time(NULL)</code> 的返回值强制转换为无符号整数 <code>(unsigned)</code>，可以将时间的秒数表示为无符号整数。这样做的目的可能是为了将时间的秒数用作随机数种子或其他需要无符号整数的场景中。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)); </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++ ) </span><br><span class="line">    cout &lt;&lt; <span class="built_in">rand</span>() &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>要取得 [a,b) 的随机整数，使用 (rand() % (b-a))+ a;</strong></p><p><strong>要取得 [a,b] 的随机整数，使用 (rand() % (b-a+1))+ a;</strong></p><p><strong>要取得 (a,b] 的随机整数，使用 (rand() % (b-a))+ a + 1;</strong></p><p><strong>通用公式: a + rand() % n；其中的 a 是起始值，n 是整数的范围。</strong></p><p><strong>要取得 a 到 b 之间的随机整数，另一种表示：a + (int)b * rand() &#x2F; (RAND_MAX + 1)。</strong></p><p><strong>要取得 0～1 之间的浮点数，可以使用 rand() &#x2F; double(RAND_MAX)。</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> y=<span class="built_in">rand</span>()%(<span class="number">4</span>)+<span class="number">1</span>;<span class="comment">//[0,3]+1</span></span><br><span class="line"><span class="comment">//[1,100].[0,99]+1.rand()%100+1</span></span><br><span class="line">cout&lt;&lt;y&lt;&lt;endl;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p><strong>unsigned：无符号 表示抛弃数据类型的负数部分，将更多的存储空间用来存放非负数 例如：int类型原本占用4字节空间，即只能存储[-2^16,2^16 - 1]范围内的数据 加unsigned后存储数据的范围就是[0,2^32 - 1]</strong></p><h4 id="4-2-2-do…while循环语句"><a href="#4-2-2-do…while循环语句" class="headerlink" title="4.2.2 do…while循环语句"></a>4.2.2 do…while循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p><p><strong>语法：</strong> <code>do&#123; 循环语句 &#125; while(循环条件);</code></p><p><strong>注意：</strong>与while的区别在于&#x3D;&#x3D;do…while会先执行一次循环语句&#x3D;&#x3D;，再判断循环条件</p><img src="/post/a5382a23/clip_image002-1541671163478.png" class="" title="img"><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">num++;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (num &lt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件</p></blockquote><p><strong>练习案例：水仙花数</strong></p><p><strong>案例描述：</strong>水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身</p><p>例如：1^3 + 5^3+ 3^3 &#x3D; 153</p><p>请利用do…while语句，求出所有3位数中的水仙花数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>((x%<span class="number">10</span>)*(x%<span class="number">10</span>)*(x%<span class="number">10</span>)+(x/<span class="number">10</span>%<span class="number">10</span>)*(x/<span class="number">10</span>%<span class="number">10</span>)*(x/<span class="number">10</span>%<span class="number">10</span>)+(x/<span class="number">100</span>)*(x/<span class="number">100</span>)*(x/<span class="number">100</span>)==x)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;x&lt;&lt;<span class="string">&quot;--&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0--</span></span><br><span class="line"><span class="comment">// 1--</span></span><br><span class="line"><span class="comment">// 153--</span></span><br><span class="line"><span class="comment">// 370--</span></span><br><span class="line"><span class="comment">// 371--</span></span><br><span class="line"><span class="comment">// 407--</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-for循环语句"><a href="#4-2-3-for循环语句" class="headerlink" title="4.2.3 for循环语句"></a>4.2.3 for循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p><p><strong>语法：</strong><code> for(起始表达式;条件表达式;末尾循环体) &#123; 循环语句; &#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>详解：</strong></p><img src="/post/a5382a23/1541673704101.png" class="" width="1541673704101"><blockquote><p>注意：for循环中的表达式，要用<strong>分号</strong>进行分隔</p></blockquote><blockquote><p>总结：while , do…while, for都是开发中常用的循环语句，<strong>for循环结构比较清晰，比较常用</strong></p></blockquote><p><strong>练习案例：敲桌子</strong></p><p>案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。</p><img src="/post/a5382a23/timg.gif" class="" title="timg"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i%<span class="number">10</span>==<span class="number">7</span>)||(i/<span class="number">10</span>%<span class="number">10</span>==<span class="number">7</span>)||(i%<span class="number">7</span>==<span class="number">0</span>))</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot;过！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 7过！</span></span><br><span class="line"><span class="comment">// 14过！</span></span><br><span class="line"><span class="comment">// 17过！</span></span><br><span class="line"><span class="comment">// 21过！</span></span><br><span class="line"><span class="comment">// 27过！</span></span><br><span class="line"><span class="comment">// 28过！</span></span><br><span class="line"><span class="comment">// 35过！</span></span><br><span class="line"><span class="comment">// 37过！</span></span><br><span class="line"><span class="comment">// 42过！</span></span><br><span class="line"><span class="comment">// 47过！</span></span><br><span class="line"><span class="comment">// 49过！</span></span><br><span class="line"><span class="comment">// 56过！</span></span><br><span class="line"><span class="comment">// 57过！</span></span><br><span class="line"><span class="comment">// 63过！</span></span><br><span class="line"><span class="comment">// 67过！</span></span><br><span class="line"><span class="comment">// 70过！</span></span><br><span class="line"><span class="comment">// 71过！</span></span><br><span class="line"><span class="comment">// 72过！</span></span><br><span class="line"><span class="comment">// 73过！</span></span><br><span class="line"><span class="comment">// 74过！</span></span><br><span class="line"><span class="comment">// 75过！</span></span><br><span class="line"><span class="comment">// 76过！</span></span><br><span class="line"><span class="comment">// 77过！</span></span><br><span class="line"><span class="comment">// 78过！</span></span><br><span class="line"><span class="comment">// 79过！</span></span><br><span class="line"><span class="comment">// 84过！</span></span><br><span class="line"><span class="comment">// 87过！</span></span><br><span class="line"><span class="comment">// 91过！</span></span><br><span class="line"><span class="comment">// 97过！</span></span><br><span class="line"><span class="comment">//98过！</span></span><br></pre></td></tr></table></figure><h4 id="4-2-4-嵌套循环"><a href="#4-2-4-嵌套循环" class="headerlink" title="4.2.4 嵌套循环"></a>4.2.4 嵌套循环</h4><p><strong>作用：</strong> 在循环体中再嵌套一层循环，解决一些实际问题</p><p>例如我们想在屏幕中打印如下图片，就需要利用嵌套循环</p><img src="/post/a5382a23/1541676003486.png" class="" width="1541676003486"><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外层循环执行1次，内层循环执行1轮</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习案例：</strong>乘法口诀表</p><p>案例描述：利用嵌套循环，实现九九乘法表</p><img src="/post/a5382a23/0006018857256120_b.jpg" class="" title="0006018857256120_b"><h3 id="4-3-跳转语句"><a href="#4-3-跳转语句" class="headerlink" title="4.3 跳转语句"></a>4.3 跳转语句</h3><h4 id="4-3-1-break语句"><a href="#4-3-1-break语句" class="headerlink" title="4.3.1 break语句"></a>4.3.1 break语句</h4><p><strong>作用:</strong> 用于跳出&#x3D;&#x3D;选择结构&#x3D;&#x3D;或者&#x3D;&#x3D;循环结构&#x3D;&#x3D;</p><p>break使用的时机：</p><ul><li>出现在switch条件语句中，作用是<strong>终止case并跳出switch</strong></li><li>出现在循环语句中，作用是跳出<strong>当前的循环语句</strong></li><li>出现在嵌套循环中，跳出<strong>最近的内层循环语句</strong></li></ul><p><strong>示例1：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//1、在switch 语句中使用break</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请选择您挑战副本的难度：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;1、普通&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;2、中等&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;3、困难&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;您选择的是普通难度&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;您选择的是中等难度&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;您选择的是困难难度&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//2、在循环语句中用break</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//跳出循环语句</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//在嵌套循环语句中使用break，退出内层循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-2-continue语句"><a href="#4-3-2-continue语句" class="headerlink" title="4.3.2 continue语句"></a>4.3.2 continue语句</h4><p><strong>作用：</strong>在&#x3D;&#x3D;循环语句&#x3D;&#x3D;中，<strong>跳过本次循环中余下尚未执行的语句，继续执行下一次循环</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<strong>continue并没有使整个循环终止，而break会跳出循环</strong></p></blockquote><h4 id="4-3-3-goto语句"><a href="#4-3-3-goto语句" class="headerlink" title="4.3.3 goto语句"></a>4.3.3 goto语句</h4><p><strong>作用：</strong>可以无条件跳转语句</p><p><strong>语法：</strong> <code>goto 标记;</code></p><p><strong>解释：</strong>如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> FLAG;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;3&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;4&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">FLAG:</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;5&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<strong>在程序中不建议使用goto语句，以免造成程序流程混乱</strong></p></blockquote><h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>所谓数组，<strong>就是一个集合，里面存放了&#x3D;&#x3D;相同类型的数据元素&#x3D;&#x3D;</strong></p><p><strong>特点1：</strong>数组中的每个&#x3D;&#x3D;数据元素都是相同的数据类型&#x3D;&#x3D;</p><p><strong>特点2：</strong>数组是由&#x3D;&#x3D;连续的内存&#x3D;&#x3D;位置组成的</p><img src="/post/a5382a23/1541748375356.png" class="" width="1541748375356"><h3 id="5-2-一维数组"><a href="#5-2-一维数组" class="headerlink" title="5.2 一维数组"></a>5.2 一维数组</h3><h4 id="5-2-1-一维数组定义方式"><a href="#5-2-1-一维数组定义方式" class="headerlink" title="5.2.1 一维数组定义方式"></a>5.2.1 一维数组定义方式</h4><p>一维数组定义的三种方式：</p><ol><li><code>数据类型  数组名[ 数组长度 ];</code></li><li><code>数据类型  数组名[ 数组长度 ] = &#123; 值1，值2 ...&#125;;</code></li><li><code>数据类型  数组名[ ] = &#123; 值1，值2 ...&#125;;</code></li></ol><p><strong>&#x3D;&#x3D;当数组作为函数参数传递时，会退化为指针，此时 <code>sizeof</code> 运算符返回的是指针的大小，而不是数组的大小。&#x3D;&#x3D;</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;size&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">20</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> c[]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;sizeof(c)/sizeof(int)&lt;&lt;endl;</span></span><br><span class="line">    <span class="type">int</span> a_size=<span class="built_in">sizeof</span>(a)/<span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> b_size=<span class="built_in">sizeof</span>(b)/<span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> c_size=<span class="built_in">sizeof</span>(c)/<span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(a,a_size);</span><br><span class="line">    <span class="built_in">func</span>(b,b_size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义方式1</span></span><br><span class="line"><span class="comment">//数据类型 数组名[元素个数];</span></span><br><span class="line"><span class="type">int</span> score[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用下标赋值</span></span><br><span class="line">score[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">score[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">score[<span class="number">2</span>] = <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用下标输出</span></span><br><span class="line">cout &lt;&lt; score[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; score[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; score[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种定义方式</span></span><br><span class="line"><span class="comment">//数据类型 数组名[元素个数] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line"><span class="comment">//如果&#123;&#125;内不足10个数据，剩余数据用0补全</span></span><br><span class="line"><span class="type">int</span> score2[<span class="number">10</span>] = &#123; <span class="number">100</span>, <span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逐个输出</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; score2[0] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; score2[1] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个一个输出太麻烦，因此可以利用循环进行输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; score2[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义方式3</span></span><br><span class="line"><span class="comment">//数据类型 数组名[] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line"><span class="type">int</span> score3[] = &#123; <span class="number">100</span>,<span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; score3[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结1：<strong>数组名的命名规范与变量名命名规范一致，不要和变量重名</strong></p></blockquote><blockquote><p>总结2：<strong>数组中下标是从0开始索引</strong></p></blockquote><hr><hr><h4 id="5-2-2-一维数组数组名"><a href="#5-2-2-一维数组数组名" class="headerlink" title="5.2.2 一维数组数组名"></a>5.2.2 一维数组数组名</h4><p>一维数组名称的<strong>用途</strong>：</p><ol><li>可以统计整个数组在内存中的长度</li><li>可以获取数组在内存中的首地址</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组名用途</span></span><br><span class="line"><span class="comment">//1、可以获取整个数组占用内存空间大小</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;整个数组所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;每个元素所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组的元素个数为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、可以通过数组名获取到数组首地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组首地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)arr &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组中第一个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组中第二个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arr = 100; 错误，数组名是常量，因此不可以赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：数组名是常量，不可以赋值</p></blockquote><blockquote><p>总结1：直接打印数组名，可以查看数组所占内存的首地址</p></blockquote><blockquote><p>总结2：<strong>对数组名进行sizeof，可以获取整个数组占内存空间的大小</strong></p><p><strong>数组作为参数传递的时候，数组名会退化为指针，此时对数组名的sizeof得到是数组位置的占字节数，</strong></p></blockquote><p><strong>练习案例1</strong>：五只小猪称体重</p><p><strong>案例描述：</strong></p><p>在一个数组中记录了五只小猪的体重，如：int arr[5] &#x3D; {300,350,200,400,250};</p><p>找出并打印最重的小猪体重。</p><blockquote><ol><li><p>遍历法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">300</span>,<span class="number">350</span>,<span class="number">200</span>,<span class="number">400</span>,<span class="number">250</span>&#125;;</span><br><span class="line">    <span class="type">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;max)</span><br><span class="line">        max=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;max;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; 400<br>return 0;<br>}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. ##### sort排序后端点处找极值              #include \&lt;algorithm\&gt;</span><br><span class="line"></span><br><span class="line">   ```c++</span><br><span class="line">   #include &lt;iostream&gt;</span><br><span class="line">   #include &lt;algorithm&gt;</span><br><span class="line">   using namespace std; </span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">       int arr[5] = &#123;300,350,200,400,250&#125;;</span><br><span class="line">       sort(arr,arr+sizeof(arr)/sizeof(arr[0]));</span><br><span class="line">       for(int i=0;i&lt;sizeof(arr)/sizeof(arr[0]);i++)</span><br><span class="line">       &#123;</span><br><span class="line">           cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">       &#125;</span><br><span class="line">       // 200 250 300 350 400 </span><br><span class="line">       cout&lt;&lt;endl;</span><br><span class="line">       sort(arr,arr+sizeof(arr)/sizeof(arr[0]),greater&lt;int&gt;());</span><br><span class="line">           for(int i=0;i&lt;sizeof(arr)/sizeof(arr[0]);i++)</span><br><span class="line">       &#123;</span><br><span class="line">           cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">       &#125;</span><br><span class="line">       // 400 350 300 250 200</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p><strong>练习案例2：</strong>数组元素逆置</p><p><strong>案例描述：</strong>请声明一个5个元素的数组，并且将元素逆置.</p><p>(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);</p><blockquote><ol><li><p>标准逆序</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">9</span>,j=<span class="number">0</span>;i&gt;=<span class="number">0</span>;i--,j++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[j]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;b[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><pre><code>return 0;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. ##### 算法逆序            #include \&lt;algorithm\&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="5-2-3-冒泡排序"><a href="#5-2-3-冒泡排序" class="headerlink" title="5.2.3 冒泡排序"></a>5.2.3 冒泡排序</h4><p><strong>作用：</strong> 最常用的排序算法，对数组内元素进行排序</p><ol><li><strong>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</strong></li><li>对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。</li><li><strong>重复以上的步骤，每次比较次数-1，直到不需要比较</strong></li></ol><img src="/post/a5382a23/1541905327273.png" class="" width="1541905327273"><p><strong>示例：</strong> 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">9</span>] = &#123; <span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span> - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span> - <span class="number">1</span> - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-二维数组"><a href="#5-3-二维数组" class="headerlink" title="5.3 二维数组"></a>5.3 二维数组</h3><p>二维数组就是在一维数组上，多加一个维度。</p><img src="/post/a5382a23/1541905559138.png" class="" width="1541905559138"><h4 id="5-3-1-二维数组定义方式"><a href="#5-3-1-二维数组定义方式" class="headerlink" title="5.3.1 二维数组定义方式"></a>5.3.1 二维数组定义方式</h4><p>二维数组定义的四种方式：</p><ol><li><code>数据类型  数组名[ 行数 ][ 列数 ];</code></li><li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</code></li><li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li><li><code> 数据类型  数组名[  ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code> </li><li>列数必须确定</li></ol><blockquote><p>建议：以上4种定义方式，利用&#x3D;&#x3D;第二种更加直观，提高代码的可读性&#x3D;&#x3D;</p></blockquote><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1  </span></span><br><span class="line"><span class="comment">//数组类型 数组名 [行数][列数]</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">arr[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;0----------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2 </span></span><br><span class="line"><span class="comment">//数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr2[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;0----------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="comment">//方式3</span></span><br><span class="line"><span class="comment">//数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line"><span class="type">int</span> arr3[<span class="number">2</span>][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr3[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;0----------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式4 </span></span><br><span class="line"><span class="comment">//数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line"><span class="type">int</span> arr4[][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr4[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="comment">// 4 5 6</span></span><br><span class="line"><span class="comment">// 0----------------------------</span></span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="comment">// 4 5 6</span></span><br><span class="line"><span class="comment">// 0----------------------------</span></span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="comment">// 4 5 6</span></span><br><span class="line"><span class="comment">// 0----------------------------</span></span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="comment">// 4 5 6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>总结：在定义二维数组时，如果初始化了数据，可以省略行数</p></blockquote><h4 id="5-3-2-二维数组数组名"><a href="#5-3-2-二维数组数组名" class="headerlink" title="&#x3D;&#x3D;5.3.2 二维数组数组名&#x3D;&#x3D;"></a>&#x3D;&#x3D;5.3.2 二维数组数组名&#x3D;&#x3D;</h4><ul><li>查看二维数组所占内存空间</li><li>获取二维数组首地址</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组数组名</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组一行大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组元素大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组行数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组列数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组首地址：&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组第一行地址：&quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组第二行地址：&quot;</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组第一个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组第二个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结1：二维数组名就是这个数<strong>组的首地址</strong></p></blockquote><blockquote><p>总结2：<strong>对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小</strong></p></blockquote><h4 id="5-3-3-二维数组应用案例"><a href="#5-3-3-二维数组应用案例" class="headerlink" title="5.3.3 二维数组应用案例"></a><strong>5.3.3 二维数组应用案例</strong></h4><p><strong>考试成绩统计：</strong></p><p>案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，<strong>请分别输出三名同学的总成绩</strong></p><table><thead><tr><th></th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><td>张三</td><td>100</td><td>100</td><td>100</td></tr><tr><td>李四</td><td>90</td><td>50</td><td>100</td></tr><tr><td>王五</td><td>60</td><td>70</td><td>80</td></tr></tbody></table><p><strong>参考答案：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> scores[<span class="number">3</span>][<span class="number">3</span>] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>&#125;,</span><br><span class="line">&#123;<span class="number">90</span>,<span class="number">50</span>,<span class="number">100</span>&#125;,</span><br><span class="line">&#123;<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string names[<span class="number">3</span>] = &#123; <span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">sum += scores[i][j];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; names[i] &lt;&lt; <span class="string">&quot;同学总成绩为： &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p><strong>作用：</strong>将一段经常使用的<strong>代码封装起来，减少重复代码</strong></p><p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p><h3 id="6-2-函数的定义"><a href="#6-2-函数的定义" class="headerlink" title="6.2 函数的定义"></a>6.2 函数的定义</h3><p>函数的定义一般主要有5个步骤：</p><p>1、返回值类型 </p><p>2、函数名</p><p>3、参数表列</p><p>4、函数体语句 </p><p>5、return 表达式</p><p><strong>语法：</strong> </p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名 （参数列表）</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">       函数体语句</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span>表达式</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回值类型 ：一个函数可以返回一个值。在函数定义中</li><li>函数名：给函数起个名称</li><li>参数列表：使用该函数时，传入的数据</li><li>函数体语句：花括号内的代码，函数内需要执行的语句</li><li>return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据</li></ul><p><strong>示例：</strong>定义一个加法函数，实现两个数相加</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = num1 + num2;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-函数的调用"><a href="#6-3-函数的调用" class="headerlink" title="6.3 函数的调用"></a>6.3 函数的调用</h3><p><strong>功能：</strong>使用定义好的函数</p><p><strong>语法：</strong><code> 函数名（参数）</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> <span class="comment">//定义中的num1,num2称为形式参数，简称形参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = num1 + num2;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//调用add函数</span></span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">add</span>(a, b);<span class="comment">//调用时的a，b称为实际参数，简称实参</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">sum = <span class="built_in">add</span>(a, b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：<strong>函数定义里小括号内称为<em>形参，</em>函数调用时传入的参数称为<em>实参</em></strong></p></blockquote><h3 id="6-4-值传递"><a href="#6-4-值传递" class="headerlink" title="6.4 值传递"></a>6.4 值传递</h3><ul><li>所谓值传递，就是函数调用时实参将数值传入给形参</li><li>值传递时，&#x3D;&#x3D;如果形参发生，并不会影响实参&#x3D;&#x3D;</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> temp = num1;</span><br><span class="line">num1 = num2;</span><br><span class="line">num2 = temp;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//return ; 当函数声明时候，不需要返回值，可以不写return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mian中的 a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mian中的 b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 值传递时，形参是修饰不了实参的</p></blockquote><h3 id="6-5-函数的常见样式"><a href="#6-5-函数的常见样式" class="headerlink" title="6.5 函数的常见样式"></a><strong>6.5 函数的常见样式</strong></h3><p>常见的函数样式有4种</p><ol><li>无参无返</li><li>有参无返</li><li>无参有返</li><li>有参有返</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数常见样式</span></span><br><span class="line"><span class="comment">//1、 无参无返</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//void a = 10; //无类型不可以创建变量,原因无法分配内存</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is test01&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//test01(); 函数调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、 有参无返</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is test02&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、无参有返</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is test03 &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、有参有返</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test04</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is test04 &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> sum = a + b;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-6-函数的声明"><a href="#6-6-函数的声明" class="headerlink" title="6.6 函数的声明"></a>6.6 函数的声明</h3><hr><blockquote><h6 id="在-C-中，函数的声明可以不写的情况有两种："><a href="#在-C-中，函数的声明可以不写的情况有两种：" class="headerlink" title="&#x3D;&#x3D;在 C++ 中，函数的声明可以不写的情况有两种：&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>在 C++ 中，函数的声明可以不写的情况有两种：</strong>&#x3D;&#x3D;</h6><ol><li><p>函数定义的同时进行声明：<br>当函数在使用之前已经定义并实现了，可以不需要显式的声明。在这种情况下，函数的定义本身就起到了声明的作用。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数实现</span></span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(); <span class="comment">// 在主函数中调用函数，无需显式声明</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数定义位于函数调用之前：<br>当函数定义位于函数调用之前，编译器会自动识别并进行隐式声明。这种情况下，编译器会在函数调用之前自动插入函数声明。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>; <span class="comment">// 隐式声明</span></span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(); <span class="comment">// 在主函数中调用函数，无需显式声明</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>需要注意的是，如果函数的定义位于函数调用之后，并且没有显式的声明，编译器将会报错，因为在函数调用之前没有找到函数的声明。</p><p>总结起来，函数的声明可以不写的情况是在函数定义的同时进行声明，或者函数定义位于函数调用之前。在这些情况下，可以省略显式的函数声明。</p></blockquote><hr><p><strong>作用：</strong> <strong>告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</strong></p><ul><li>函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明可以多次，定义只能一次</span></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">max</span>(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-7-函数的分文件编写"><a href="#6-7-函数的分文件编写" class="headerlink" title="6.7 &#x3D;&#x3D;函数的分文件编写&#x3D;&#x3D;"></a>6.7 &#x3D;&#x3D;函数的分文件编写&#x3D;&#x3D;</h3><p><strong>作用：</strong>让代码结构更加清晰</p><p>函数分文件编写一般有4个步骤</p><ol><li>创建后缀名为.h的头文件  </li><li>创建后缀名为.cpp的源文件</li><li>在<strong>头文件中写函数的声明</strong></li><li>在<strong>源文件中写函数的定义</strong></li><li><strong>用的时候用””引用头文件</strong></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swap.h文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现两个数字交换的函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swap.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main函数文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7 指针"></a>7 指针</h2><h3 id="7-1-指针的基本概念"><a href="#7-1-指针的基本概念" class="headerlink" title="7.1 指针的基本概念"></a>7.1 指针的基本概念</h3><p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p><ul><li><p>内存编号是从0开始记录的，一般用<strong>十六进制数字</strong>表示</p></li><li><p>可以利用指针变量保存地址</p></li></ul><h3 id="7-2-指针变量的定义和使用"><a href="#7-2-指针变量的定义和使用" class="headerlink" title="7.2 指针变量的定义和使用"></a>7.2 指针变量的定义和使用</h3><p>指针变量定义语法： <code>数据类型 * 变量名；</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指针的定义</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//定义整型变量a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针定义语法： 数据类型 * 变量名 ;</span></span><br><span class="line"><span class="type">int</span> * p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针变量赋值</span></span><br><span class="line">p = &amp;a; <span class="comment">//指针指向变量a的地址</span></span><br><span class="line">cout &lt;&lt; &amp;a &lt;&lt; endl; <span class="comment">//打印数据a的地址</span></span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;  <span class="comment">//打印指针变量p</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、指针的使用</span></span><br><span class="line"><span class="comment">//通过*操作指针变量指向的内存</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针变量和普通变量的区别</p><ul><li><strong>普通变量</strong>存放的是<strong>数据</strong>,<strong>指针变量</strong>存放的是<strong>地址</strong></li><li>指针变量可以通过” ***** “操作符，操作指针变量指向的内存空间，这个过程称为<strong>解引用</strong></li></ul><blockquote><p>总结1： 我们<strong>可以通过 &amp; 符号 获取变量的地址</strong></p></blockquote><blockquote><p>总结2：利用指针可以记录地址</p></blockquote><blockquote><p>总结3：<strong>对指针变量解引用，可以操作指针指向的内存</strong></p></blockquote><h3 id="7-3-指针所占内存空间"><a href="#7-3-指针所占内存空间" class="headerlink" title="7.3 指针所占内存空间"></a>7.3 指针所占内存空间</h3><p>提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * p;</span><br><span class="line">p = &amp;a; <span class="comment">//指针指向数据a的地址</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">//* 解引用</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span> *) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span> *) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span> *) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：所有指针类型在32位操作系统下是4个字节</p></blockquote><h3 id="7-4-空指针和野指针"><a href="#7-4-空指针和野指针" class="headerlink" title="7.4 空指针和野指针"></a>7.4 空指针和野指针</h3><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p><p><strong>用途：</strong>初始化指针变量</p><p><strong>注意：</strong><strong><strong>空指针指向的内存是不可以访问的</strong></strong></p><p>会出现</p><p><strong>出现异常。</strong></p><p><strong>Segmentation fault</strong></p><p><strong>内存编号0 ~255为系统占用内存，不允许用户访问</strong></p><p><strong>示例1：空指针</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针变量p指向内存地址编号为0的空间</span></span><br><span class="line"><span class="type">int</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问空指针报错 </span></span><br><span class="line"><span class="comment">//内存编号0 ~255为系统占用内存，不允许用户访问</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>野指针</strong>：指针变量<strong>指向非法的内存空间</strong></p><p><strong>示例2：野指针</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针变量p指向内存地址编号为0x1100的空间</span></span><br><span class="line"><span class="type">int</span> * p = (<span class="type">int</span> *)<span class="number">0x1100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问野指针报错 </span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>空指针和野指针是指针的两种特殊情况。</strong></p><ol><li><p>空指针：空指针是指没有指向任何有效对象或函数的指针。在 C++ 中，空指针可以用字面值 <strong><code>nullptr</code> 或者 <code>NULL</code></strong> 来表示。空指针在程序中通常用来表示指针未初始化或者指向无效的内存地址。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="literal">nullptr</span>;  <span class="comment">// 或者 int* ptr = NULL;</span></span><br></pre></td></tr></table></figure></li><li><p>野指针：野指针是指指向未知或无效内存地址的指针。野指针通常是由于指针未初始化，<strong>或者指针指向的对象已经被释放或销毁</strong>，但指针本身没有被置为 <code>nullptr</code> 或者其他有效地址。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr;  <span class="comment">// 未初始化的指针，可能成为野指针</span></span><br><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">// 动态分配的内存，但未初始化，可能成为野指针</span></span><br><span class="line"><span class="keyword">delete</span> ptr;  <span class="comment">// 释放内存后，ptr 变成野指针</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>使用空指针是一种良好的编程习惯，</strong>可以避免指针悬空的问题。而野指针是一种危险的编程错误，<strong>可能导致程序崩溃或产生未定义的行为</strong>。在使用指针时，应该始终确保指针指向有效的对象或者函数，并在不需要使用指针时将其置为 <code>nullptr</code>。</p><blockquote><p>总结：<strong>空指针和野指针都不是我们申请的空间</strong>，因此不要访问。</p></blockquote><h3 id="7-5-const修饰指针"><a href="#7-5-const修饰指针" class="headerlink" title="7.5 const修饰指针"></a>7.5 const修饰指针</h3><p>const修饰指针有三种情况</p><ol><li>const修饰指针   — 常量指针</li><li>const修饰常量   — 指针常量</li><li>const即修饰指针，又修饰常量</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * p1 = &amp;a; </span><br><span class="line">p1 = &amp;b; <span class="comment">//正确</span></span><br><span class="line"><span class="comment">//*p1 = 100;  报错</span></span><br><span class="line">    <span class="comment">//常量指针</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p2 = &amp;a;</span><br><span class="line"><span class="comment">//p2 = &amp;b; //错误</span></span><br><span class="line">*p2 = <span class="number">100</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const既修饰指针又修饰常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p3 = &amp;a;</span><br><span class="line"><span class="comment">//p3 = &amp;b; //错误</span></span><br><span class="line"><span class="comment">//*p3 = 100; //错误</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>技巧：<strong>看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</strong></p></blockquote><ul><li>常量指针是指针本身是常量，不可以修改指针所指向的地址，但可以通过指针修改所指向的值。</li><li>指针常量是指指针所指向的值是常量，不可以通过指针修改所指向的值，但可以修改指针所指向的地址。</li></ul><h3 id="7-6-指针和数组"><a href="#7-6-指针和数组" class="headerlink" title="7.6 指针和数组"></a>7.6 指针和数组</h3><p><strong>作用：</strong>利用指针访问数组中元素</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * p = arr;  <span class="comment">//指向数组的指针</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一个元素： &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;指针访问第一个元素： &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//利用指针遍历数组</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指针自身自增是内存增加一个所指数据的单位。</strong></p><p>*<strong>p&#x3D;arry[0]</strong></p><p>*<strong>p+n&#x3D;arry[n]</strong></p><h3 id="7-7-指针和函数"><a href="#7-7-指针和函数" class="headerlink" title="7.7 指针和函数"></a>7.7 指针和函数</h3><p><strong>作用：</strong>利用指针作函数参数，可以修改实参的值</p><p>void swap2(int * p1, int *p2)<br>{<br>    int temp &#x3D; *p1;<br>    *p1 &#x3D; *p2;<br>    *p2 &#x3D; temp;<br>}</p><p>​swap2(&amp;a, &amp;b); &#x2F;&#x2F;地址传递会改变实参</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b; </span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span> * p1, <span class="type">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = *p1;</span><br><span class="line">*p1 = *p2;</span><br><span class="line">*p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">swap1</span>(a, b); <span class="comment">// 值传递不会改变实参</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">swap2</span>(&amp;a, &amp;b); <span class="comment">//地址传递会改变实参</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p></blockquote><h3 id="7-8-指针、数组、函数"><a href="#7-8-指针、数组、函数" class="headerlink" title="7.8 指针、数组、函数"></a>7.8 指针、数组、函数</h3><p><strong>案例描述：</strong>封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p><p>例如数组：int arr[10] &#x3D; { 4,3,6,9,1,2,10,8,7,5 };</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> * arr, <span class="type">int</span> len)</span>  <span class="comment">//int * arr 也可以写为int arr[]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bubbleSort</span>(arr, len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printArray</span>(arr, len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：<strong>当数组名传入到函数作为参数时，被退化为指向首元素的指针</strong></p></blockquote><p>此时对数组名sizeof得到的就不是数组的整个占用字节数了</p><p>而是数组名这个指针的字节（4）</p><h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8 结构体"></a>8 结构体</h2><h3 id="8-1-结构体基本概念"><a href="#8-1-结构体基本概念" class="headerlink" title="8.1 结构体基本概念"></a>8.1 结构体基本概念</h3><p>结构体属于用户&#x3D;&#x3D;自定义的数据类型&#x3D;&#x3D;，允许用户存储不同的数据类型</p><h3 id="8-2-结构体定义和使用"><a href="#8-2-结构体定义和使用" class="headerlink" title="8.2 结构体定义和使用"></a>8.2 结构体定义和使用</h3><p><strong>语法：</strong><code>struct 结构体名 &#123; 结构体成员列表 &#125;；</code></p><p>通过结构体创建变量的方式有三种：</p><ul><li>struct 结构体名 变量名</li><li>struct 结构体名 变量名 &#x3D; { 成员1值 ， 成员2值…}</li><li>定义结构体时顺便创建变量</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;stu3; <span class="comment">//结构体变量创建方式3 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体变量创建方式1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu1; <span class="comment">//struct 关键字可以省略</span></span><br><span class="line"></span><br><span class="line">stu1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">stu1.age = <span class="number">18</span>;</span><br><span class="line">stu1.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu1.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu1.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu1.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体变量创建方式2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu2 = &#123; <span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu2.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu2.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu2.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu3.name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">stu3.age = <span class="number">18</span>;</span><br><span class="line">stu3.score = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu3.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu3.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu3.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结1：<strong>定义结构体时的关键字是struct，不可省略</strong></p></blockquote><blockquote><p>总结2：<strong>创建结构体变量时，关键字struct可以省略</strong></p></blockquote><blockquote><p>总结3：<strong>结构体变量利用操作符 ‘’.’’  访问成员</strong></p></blockquote><h3 id="8-3-结构体数组"><a href="#8-3-结构体数组" class="headerlink" title="8.3 结构体数组"></a>8.3 结构体数组</h3><p><strong>作用：</strong>将自定义的结构体放入到数组中方便维护</p><p><strong>语法：</strong><code> struct  结构体名 数组名[元素个数] = &#123;  &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体数组</span></span><br><span class="line">    <span class="comment">//struct关键字也可以省略</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> arr[<span class="number">3</span>]=</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">80</span> &#125;,</span><br><span class="line">&#123;<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;,</span><br><span class="line">&#123;<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>,<span class="number">70</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; arr[i].age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; arr[i].score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-结构体指针"><a href="#8-4-结构体指针" class="headerlink" title="8.4 结构体指针"></a>8.4 结构体指针</h3><p><strong>作用：</strong>通过指针访问结构体中的成员</p><ul><li>利用操作符 <code>-&gt; </code>可以通过结构体指针访问结构体属性</li><li>结构体访问成员用.</li><li>指向结构体的指针想要访问成员用-&gt;</li></ul><p><strong>struct student * p &#x3D; &stu;</strong></p><h6 id="指针的类型和对应数据的类型需要一致"><a href="#指针的类型和对应数据的类型需要一致" class="headerlink" title="&#x3D;&#x3D;指针的类型和对应数据的类型需要一致&#x3D;&#x3D;"></a>&#x3D;&#x3D;指针的类型和对应数据的类型需要一致&#x3D;&#x3D;</h6><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>, &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> * p = &amp;stu;</span><br><span class="line"></span><br><span class="line">p-&gt;score = <span class="number">80</span>; <span class="comment">//指针通过 -&gt; 操作符可以访问成员</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：<strong>结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</strong></p></blockquote><h3 id="8-5-结构体嵌套结构体"><a href="#8-5-结构体嵌套结构体" class="headerlink" title="8.5 结构体嵌套结构体"></a>8.5 结构体嵌套结构体</h3><p><strong>作用：</strong> 结构体中的成员可以是另一个结构体</p><p><strong>例如：</strong>每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//教师结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//成员列表</span></span><br><span class="line"><span class="type">int</span> id; <span class="comment">//职工编号</span></span><br><span class="line">string name;  <span class="comment">//教师姓名</span></span><br><span class="line"><span class="type">int</span> age;   <span class="comment">//教师年龄</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu; <span class="comment">//子结构体 学生</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">teacher</span> t1;</span><br><span class="line">t1.id = <span class="number">10000</span>;</span><br><span class="line">t1.name = <span class="string">&quot;老王&quot;</span>;</span><br><span class="line">t1.age = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">t1.stu.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">t1.stu.age = <span class="number">18</span>;</span><br><span class="line">t1.stu.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;教师 职工编号： &quot;</span> &lt;&lt; t1.id &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; t1.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; t1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;辅导学员 姓名： &quot;</span> &lt;&lt; t1.stu.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; t1.stu.age &lt;&lt; <span class="string">&quot; 考试分数： &quot;</span> &lt;&lt; t1.stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：****在结构体中可以定义另一个结构体作为成员，用来解决实际问题</strong></p><h3 id="8-6-结构体做函数参数"><a href="#8-6-结构体做函数参数" class="headerlink" title="8.6 结构体做函数参数"></a>8.6 结构体做函数参数</h3><p><strong>作用：</strong>将结构体作为参数向函数中传递</p><p>传递方式有两种：</p><ul><li>值传递</li><li>地址传递</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(student stu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stu.age = <span class="number">28</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent2</span><span class="params">(student *stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stu-&gt;age = <span class="number">28</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu-&gt;age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>&#125;;</span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="built_in">printStudent</span>(stu);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="built_in">printStudent2</span>(&amp;stu);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：<strong>如果不想修改主函数中的数据，用值传递，反之用地址传递</strong></p></blockquote><h3 id="8-7-结构体中-const使用场景"><a href="#8-7-结构体中-const使用场景" class="headerlink" title="8.7 &#x3D;&#x3D;结构体中 const使用场景&#x3D;&#x3D;"></a>8.7 &#x3D;&#x3D;结构体中 const使用场景&#x3D;&#x3D;</h3><p><strong>作用：</strong>用const来防止误操作</p><p>结构体作为参数的时候，最好使用const </p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const使用场景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(<span class="type">const</span> student *stu)</span> <span class="comment">//加const防止函数体中的误操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//stu-&gt;age = 100; //操作失败，因为加了const修饰</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printStudent</span>(&amp;stu);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-8-结构体案例"><a href="#8-8-结构体案例" class="headerlink" title="8.8 结构体案例"></a>8.8 结构体案例</h3><h4 id="8-8-1-案例1"><a href="#8-8-1-案例1" class="headerlink" title="8.8.1 案例1"></a>8.8.1 案例1</h4><p><strong>案例描述：</strong></p><p>学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下</p><p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员</p><p>学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值</p><p>最终打印出老师数据以及老师所带的学生数据。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line">Student sArray[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocateSpace</span><span class="params">(Teacher tArray[] , <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string tName = <span class="string">&quot;教师&quot;</span>;</span><br><span class="line">string sName = <span class="string">&quot;学生&quot;</span>;</span><br><span class="line">string nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">tArray[i].name = tName + nameSeed[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">tArray[i].sArray[j].name = sName + nameSeed[j];</span><br><span class="line">tArray[i].sArray[j].score = <span class="built_in">rand</span>() % <span class="number">61</span> + <span class="number">40</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTeachers</span><span class="params">(Teacher tArray[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; tArray[i].name &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\t姓名：&quot;</span> &lt;&lt; tArray[i].sArray[j].name &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">//随机数种子 头文件 #include &lt;ctime&gt;</span></span><br><span class="line"></span><br><span class="line">Teacher tArray[<span class="number">3</span>]; <span class="comment">//老师数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(tArray) / <span class="built_in">sizeof</span>(Teacher);</span><br><span class="line"></span><br><span class="line"><span class="built_in">allocateSpace</span>(tArray, len); <span class="comment">//创建数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printTeachers</span>(tArray, len); <span class="comment">//打印数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-8-2-案例2"><a href="#8-8-2-案例2" class="headerlink" title="8.8.2 案例2"></a>8.8.2 案例2</h4><p><strong>案例描述：</strong></p><p>设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。</p><p>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p><p>五名英雄信息如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//英雄结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hero</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">string sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(hero arr[] , <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j].age &gt; arr[j + <span class="number">1</span>].age)</span><br><span class="line">&#123;</span><br><span class="line">hero temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHeros</span><span class="params">(hero arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 性别： &quot;</span> &lt;&lt; arr[i].sex &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; arr[i].age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hero</span> arr[<span class="number">5</span>] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(hero); <span class="comment">//获取数组元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bubbleSort</span>(arr, len); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printHeros</span>(arr, len); <span class="comment">//打印</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> c++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qt</title>
      <link href="/post/2095ef6d.html"/>
      <url>/post/2095ef6d.html</url>
      
        <content type="html"><![CDATA[<h2 id="QT前言"><a href="#QT前言" class="headerlink" title="QT前言"></a>QT前言</h2><blockquote><p>以下是一些适合用来练手的 Qt 项目，按照从简单到难的顺序排列：</p><ol><li>简单的计算器：创建一个简单的计算器应用程序，可以进行基本的数学运算，如加法、减法、乘法和除法。</li><li>TodoList 应用程序：创建一个简单的 TodoList 应用程序，可以添加、删除和编辑待办事项。</li><li>图片查看器：创建一个简单的图片查看器，可以打开和浏览图片文件，并提供一些基本的操作，如缩放、旋转和切换图片。</li><li>聊天应用程序：创建一个简单的聊天应用程序，可以实现基本的消息发送和接收功能，可以在本地或网络上进行通信。</li><li>文件管理器：创建一个简单的文件管理器，可以浏览和管理文件和文件夹，提供基本的文件操作，如复制、粘贴和删除。</li><li>图书馆管理系统：创建一个图书馆管理系统，可以管理图书的借阅和归还，提供图书搜索和借阅记录等功能。</li><li>图形化绘图应用程序：创建一个具有绘图功能的应用程序，可以绘制基本的图形，如线条、矩形和椭圆，并提供颜色和线条宽度选择等功能。</li><li>电子邮件客户端：创建一个简单的电子邮件客户端，可以发送和接收电子邮件，支持多个邮件账户和邮件夹管理。</li><li>在线音乐播放器：创建一个在线音乐播放器，可以搜索和播放音乐，支持创建播放列表和收藏喜欢的音乐。</li><li>3D 游戏：创建一个简单的 3D 游戏，可以实现基本的游戏功能，如角色移动、碰撞检测和得分计算。</li></ol><p>这些项目涵盖了从简单到复杂的不同领域和功能。你可以根据自己的兴趣和能力选择适合的项目进行练手。在实现这些项目的过程中，你将学习和应用 Qt 的各种功能，提高自己的编程技能。</p><hr><hr><p>在使用 Qt 进行项目开发时，你需要掌握一些与 C++ 和 Qt 相关的知识。以下是一些你可能需要学习的主题：</p><ol><li><p>C++ 基础知识：你需要熟悉 C++ 的基本语法、数据类型、控制流程、函数和类等概念。这些知识对于理解和编写 Qt 代码是基础。</p></li><li><p>Qt 基础知识：你需要学习 Qt 的基本概念和类库。这包括了 Qt 的核心模块（如 QObject、QWidget 和 QApplication）以及其他模块（如 Qt Widgets、Qt GUI 和 Qt Network）。你需要了解这些模块的类和功能，以便在项目中使用它们。</p></li><li><p>信号与槽机制：Qt 使用信号与槽机制来实现对象之间的通信。你需要学习如何定义和连接信号与槽，以及如何在应用程序中使用它们。</p></li><li><p>Qt 布局管理器：Qt 提供了一套布局管理器来帮助你在窗口中进行控件布局。你需要学习如何使用布局管理器来自动调整和排列控件，以适应不同的窗口大小和分辨率。</p></li><li><p>Qt 事件处理：Qt 使用事件来处理用户输入和其他系统事件。你需要学习如何重写事件处理函数，以便在应用程序中响应和处理不同类型的事件。</p></li><li><p>Qt 文件和网络操作：在许多应用程序中，你可能需要进行文件读写和网络通信。你需要学习如何使用 Qt 提供的类来进行文件和网络操作，如 QFile、QDir、QNetworkAccessManager 和 QNetworkRequest。</p></li><li><p>Qt 多线程编程：如果你的应用程序需要进行并发处理或长时间运行的任务，你可能需要学习如何使用 Qt 的多线程机制来实现线程间的通信和同步。</p></li><li><p>Qt 数据库访问：如果你的应用程序需要与数据库进行交互，你需要学习如何使用 Qt 提供的数据库模块（如 QSqlDatabase 和 QSqlQuery）来连接和操作数据库。</p></li></ol><p>以上是一些与 C++ 和 Qt 相关的主题，你可以根据自己的项目需求和兴趣选择学习的内容。Qt 官方文档和教程是学习这些知识的好资源，你可以参考它们来深入学习和实践。</p><hr><ol><li><strong>编写实际项目</strong>：实践是学习编程的关键。尝试编写一些小型的Qt应用程序或项目，以应用您学到的知识。通过实际项目的编写，您可以更好地理解概念，发现问题并学习解决方案。</li><li><strong>参考示例代码</strong>：Qt提供了大量的示例代码，涵盖了各种功能和应用场景。阅读和理解这些示例代码可以帮助您学习Qt的最佳实践和常用模式。</li><li><strong>参与社区</strong>：加入Qt和C++的开发者社区，参与讨论和交流。这样可以与其他开发者分享经验、解决问题，并从他们的经验中学习。</li><li><strong>坚持练习</strong>：编程需要不断的练习和实践。坚持练习编写代码，并尝试解决各种问题和挑战。通过不断地练习，您可以加深对Qt和C++的理解，并提高编程技能。</li><li><strong>多种学习资源</strong>：除了官方文档外，还可以使用在线教程、书籍、视频教程等多种学习资源。选择适合您学习风格和需求的资源，以帮助您更好地学习Qt和C++。</li><li><strong>复习和总结</strong>：定期复习和总结您学到的知识。回顾之前学习的内容，巩固和加深对概念和技术的理解。</li><li><strong>持续学习</strong>：Qt和C++是广阔而深入的领域，持续学习是成为优秀程序员的关键。保持对新技术和最佳实践的学习兴趣，并持续提升自己的技能。</li></ol><p>记住，学习编程需要时间和耐心。重要的是保持积极的学习态度，并坚持不懈地学习和实践。祝您在Qt和C++编程的学习中取得成功！</p></blockquote><h2 id="QT打包"><a href="#QT打包" class="headerlink" title="QT打包"></a>QT打包</h2><h2 id="c-类型转换static-cast和reinterpret-cast"><a href="#c-类型转换static-cast和reinterpret-cast" class="headerlink" title="c++类型转换static_cast&lt;&gt;和reinterpret_cast&lt;&gt;"></a>c++类型转换<em><strong>static_cast&lt;&gt;和reinterpret_cast&lt;&gt;</strong></em></h2><blockquote><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast&lt;&gt;"></a>static_cast&lt;&gt;</h2><p><code>static_cast&lt;&gt;</code> 是 C++ 中的一种<strong>类型转换运算符</strong>，用于在编译时进行类型转换。它可以用于将一种类型转换为另一种类型，包括基本类型、类类型和指针类型。</p><p><code>static_cast&lt;&gt;</code> 的语法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;目标类型&gt;(表达式)</span><br></pre></td></tr></table></figure><p>其中，<code>目标类型</code> 是你希望将表达式转换为的类型，而 <code>表达式</code> 则是要进行转换的值或<strong>变量</strong>。</p><p>下面是一些示例用法：</p><ol><li>将整数转换为浮点数：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> result = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(num);</span><br></pre></td></tr></table></figure><ol start="2"><li>将浮点数转换为整数：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> num = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(num);</span><br></pre></td></tr></table></figure><ol start="3"><li><em>将指针类型转换为另一种指针类型</em>：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">char</span>* result = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(ptr);</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>static_cast&lt;&gt;</code> <strong>不会执行运行时的类型检查</strong>，因此转换的安全性需要由开发者自行保证。如果转换是不安全的，建议使用更加安全的类型转换运算符，如 <code>dynamic_cast&lt;&gt;</code> 或 <code>reinterpret_cast&lt;&gt;</code>。</p><p>总结起来，<code>static_cast&lt;&gt;</code> 是 C++ 中一种常用的类型转换运算符，<strong>用于在编译时进行类型转换</strong>。它可以将一种类型转换为另一种类型，但需要开发者自行确保转换的安全性。</p><hr><hr><hr><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast&lt;&gt;"></a>reinterpret_cast&lt;&gt;</h2><p><code>reinterpret_cast&lt;&gt;</code> 是 C++ 中的一种类型转换运算符，用<strong>于执行底层的强制类型转换</strong>。它可以将一个指针或引用转换为另一种指针或引用类型，甚至可以将指针或引用转换为整数类型。</p><p><code>reinterpret_cast&lt;&gt;</code> 的语法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reinterpret_cast</span>&lt;目标类型&gt;(表达式)</span><br></pre></td></tr></table></figure><p>其中，<code>目标类型</code> 是你希望将表达式转换为的类型，而 <code>表达式</code> 则是要进行转换的值或变量。</p><p>下面是一些示例用法：</p><ol><li>将指针类型转换为另一种指针类型：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">char</span>* result = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ptr);</span><br></pre></td></tr></table></figure><ol start="2"><li>将指针类型转换为整数类型：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">uintptr_t</span> result = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(ptr);</span><br></pre></td></tr></table></figure><ol start="3"><li>将整数类型转换为指针类型：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">uintptr_t</span> num = <span class="number">12345</span>;</span><br><span class="line"><span class="type">int</span>* result = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(num);</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>reinterpret_cast&lt;&gt;</code> 执行的是一种底层的强制类型转换，<strong>它可以绕过编译器的类型检查</strong>，因此需要开发者自行确保转换的安全性。使用 <code>reinterpret_cast&lt;&gt;</code> 进行类型转换时应该非常小心，确保转换的结果在语义上是合理的。</p><p>总结起来，<code>reinterpret_cast&lt;&gt;</code> 是 C++ 中一种类型转换运算符，用于执行底层的强制类型转换。它可以将指针或引用转换为另一种指针或引用类型，甚至可以将指针或引用转换为整数类型。使用 <code>reinterpret_cast&lt;&gt;</code> 进行类型转换时需要非常小心，确保转换的安全性和语义正确性。</p></blockquote><h2 id="QT快捷键"><a href="#QT快捷键" class="headerlink" title="QT快捷键"></a>QT<a href="https://blog.csdn.net/xideaha/article/details/132365224?spm=1001.2014.3001.5501">快捷键</a></h2><h2 id="QWIDGET"><a href="#QWIDGET" class="headerlink" title="QWIDGET"></a>QWIDGET</h2><img src="/post/2095ef6d/image-20230731110426486.png" class="" title="image-20230731110426486"><h2 id="Qdilog"><a href="#Qdilog" class="headerlink" title="Qdilog"></a>Qdilog</h2><img src="/post/2095ef6d/image-20230731111621860.png" class="" title="image-20230731111621860"><h2 id="Qmainwindow"><a href="#Qmainwindow" class="headerlink" title="Qmainwindow"></a>Qmainwindow</h2><p><strong>菜单栏和状态栏只能有一个工具栏可以有多个</strong></p><img src="/post/2095ef6d/image-20230731112301130.png" class="" title="image-20230731112301130"><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><img src="/post/2095ef6d/image-20230731201826875.png" class="" title="image-20230731201826875"><h2 id="Qbytearry"><a href="#Qbytearry" class="headerlink" title="Qbytearry"></a>Qbytearry</h2><img src="/post/2095ef6d/image-20230803095410076.png" class="" title="image-20230803095410076"><blockquote><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造空对象, 里边没有数据</span></span><br><span class="line">QByteArray::<span class="built_in">QByteArray</span>();</span><br><span class="line"><span class="comment">// 将data中的size个字符进行构造, 得到一个字节数组对象</span></span><br><span class="line"><span class="comment">// 如果 size==-1 函数内部自动计算字符串长度, 计算方式为: strlen(data)</span></span><br><span class="line">QByteArray::<span class="built_in">QByteArray</span>(<span class="type">const</span> <span class="type">char</span> *data, <span class="type">int</span> size = <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// 构造一个长度为size个字节, 并且每个字节值都为ch的字节数组</span></span><br><span class="line">QByteArray::<span class="built_in">QByteArray</span>(<span class="type">int</span> size, <span class="type">char</span> ch);</span><br></pre></td></tr></table></figure><blockquote><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在尾部追加数据</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::append</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::push_back</span><span class="params">(<span class="type">const</span> QByteArray &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头部添加数据</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::prepend</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::push_front</span><span class="params">(<span class="type">const</span> QByteArray &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据, 将ba插入到数组第 i 个字节的位置(从0开始)</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="comment">// 从大字符串中删除len个字符, 从第pos个字符的位置开始删除</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::remove</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符数组的尾部删除 n 个字节</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::chop</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字节数组的 pos 位置将数组截断 (前边部分留下, 后边部分被删除)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::truncate</span><span class="params">(<span class="type">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象中的数据清空, 使其为null</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串替换</span></span><br><span class="line"><span class="comment">// 将字节数组中的 子字符串 before 替换为 after</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::replace</span><span class="params">(<span class="type">const</span> QByteArray &amp;before, <span class="type">const</span> QByteArray &amp;after)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><h3 id="子字符串查找和判断"><a href="#子字符串查找和判断" class="headerlink" title="子字符串查找和判断"></a>子字符串查找和判断</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断字节数组中是否包含子字符串 ba, 包含返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::contains</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::contains</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 判断字节数组中是否包含字符 ch, 包含返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::contains</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字节数组是否以字符串 ba 开始, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::startsWith</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::startsWith</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 判断字节数组是否以字符 ch 开始, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::startsWith</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字节数组是否以字符串 ba 结尾, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::endsWith</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::endsWith</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 判断字节数组是否以字符 ch 结尾, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::endsWith</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">QByteArray::begin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">QByteArray::end</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组的方式进行遍历</span></span><br><span class="line"><span class="comment">// i的取值范围 0 &lt;= i &lt; size()</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">QByteArray::at</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="type">char</span> QByteArray::<span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arry1.<span class="built_in">size</span>();i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">qDebug</span>()&lt;&lt;arry1[i];</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="查看字节数"><a href="#查看字节数" class="headerlink" title="查看字节数"></a>查看字节数</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回字节数组对象中字符的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字节数组对象中 子字符串ba 出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::count</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::count</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回字节数组对象中 字符ch 出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::count</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将QByteArray类型的字符串 转换为 char* 类型</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">QByteArray::data</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">QByteArray::data</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">先搞个空对象</span><br><span class="line">    然后对象.set数据类型</span><br><span class="line"></span><br><span class="line"><span class="comment">// int, short, long, float, double -&gt; QByteArray</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(<span class="type">short</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(qlonglong n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(<span class="type">float</span> n, <span class="type">char</span> f = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> prec = <span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(<span class="type">double</span> n, <span class="type">char</span> f = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> prec = <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">[<span class="type">static</span>] <span class="function">QByteArray <span class="title">QByteArray::number</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QByteArray <span class="title">QByteArray::number</span><span class="params">(qlonglong n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QByteArray <span class="title">QByteArray::number</span><span class="params">(<span class="type">double</span> n, <span class="type">char</span> f = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> prec = <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QByteArray -&gt; int, short, long, float, double</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::toInt</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">short</span> <span class="title">QByteArray::toShort</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">QByteArray::toLong</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">QByteArray::toFloat</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">QByteArray::toDouble</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// std::string -&gt; QByteArray</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QByteArray <span class="title">QByteArray::fromStdString</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span>;</span><br><span class="line"><span class="comment">// QByteArray -&gt; std::string</span></span><br><span class="line"><span class="function">std::string <span class="title">QByteArray::toStdString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有字符转换为大写</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QByteArray::toUpper</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 所有字符转换为小写</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QByteArray::toLower</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><h2 id="QSTRING"><a href="#QSTRING" class="headerlink" title="QSTRING"></a>QSTRING</h2><img src="/post/2095ef6d/image-20230803095906153.png" class="" title="image-20230803095906153"><blockquote><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个空字符串对象</span></span><br><span class="line">QString::<span class="built_in">QString</span>();</span><br><span class="line"><span class="comment">// 将 char* 字符串 转换为 QString 类型</span></span><br><span class="line">QString::<span class="built_in">QString</span>(<span class="type">const</span> <span class="type">char</span> *str);</span><br><span class="line"><span class="comment">// 将 QByteArray 转换为 QString 类型</span></span><br><span class="line">QString::<span class="built_in">QString</span>(<span class="type">const</span> QByteArray &amp;ba);</span><br><span class="line"><span class="comment">// 其他重载的同名构造函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="数据操作-1"><a href="#数据操作-1" class="headerlink" title="数据操作"></a>数据操作</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尾部追加数据</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::append</span><span class="params">(<span class="type">const</span> QString &amp;str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::append</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::push_back</span><span class="params">(<span class="type">const</span> QString &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头部添加数据</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::prepend</span><span class="params">(<span class="type">const</span> QString &amp;str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::prepend</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::prepend</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::push_front</span><span class="params">(<span class="type">const</span> QString &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据, 将 str 插入到字符串第 position 个字符的位置(从0开始)</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::insert</span><span class="params">(<span class="type">int</span> position, <span class="type">const</span> QString &amp;str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::insert</span><span class="params">(<span class="type">int</span> position, <span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::insert</span><span class="params">(<span class="type">int</span> position, <span class="type">const</span> QByteArray &amp;str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="comment">// 从大字符串中删除len个字符, 从第pos个字符的位置开始删除</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::remove</span><span class="params">(<span class="type">int</span> position, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串的尾部删除 n 个字符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::chop</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 从字节串的 position 位置将字符串截断 (前边部分留下, 后边部分被删除)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::truncate</span><span class="params">(<span class="type">int</span> position)</span></span>;</span><br><span class="line"><span class="comment">// 将对象中的数据清空, 使其为null</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串替换</span></span><br><span class="line"><span class="comment">// 将字节数组中的 子字符串 before 替换为 after</span></span><br><span class="line"><span class="comment">// 参数 cs 为是否区分大小写, 默认区分大小写</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::replace</span><span class="params">(<span class="type">const</span> QString &amp;before, <span class="type">const</span> QString &amp;after, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="子字符串查找和判断-1"><a href="#子字符串查找和判断-1" class="headerlink" title="子字符串查找和判断"></a>子字符串查找和判断</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数 cs 为是否区分大小写, 默认区分大小写</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串中是否包含子字符串 str, 包含返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QString::contains</span><span class="params">(<span class="type">const</span> QString &amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串是否以字符串 ba 开始, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QString::startsWith</span><span class="params">(<span class="type">const</span> QString &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串是否以字符串 ba 结尾, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QString::endsWith</span><span class="params">(<span class="type">const</span> QString &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">QString::begin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">QString::end</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组的方式进行遍历</span></span><br><span class="line"><span class="comment">// i的取值范围 0 &lt;= position &lt; size()</span></span><br><span class="line"><span class="function"><span class="type">const</span> QChar <span class="title">QString::at</span><span class="params">(<span class="type">int</span> position)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> QChar QString::<span class="keyword">operator</span>[]<span class="params">(<span class="type">int</span> position)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><blockquote><h3 id="查看字节数-1"><a href="#查看字节数-1" class="headerlink" title="查看字节数"></a>查看字节数</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回字节数组对象中字符的个数 (字符个数和字节个数是不同的概念)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字节串对象中 子字符串 str 出现的次数</span></span><br><span class="line"><span class="comment">// 参数 cs 为是否区分大小写, 默认区分大小写</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::count</span><span class="params">(<span class="type">const</span> QStringRef &amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将int, short, long, float, double 转换为 QString 类型</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">short</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">float</span> n, <span class="type">char</span> format = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> precision = <span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">double</span> n, <span class="type">char</span> format = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> precision = <span class="number">6</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QString::number</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QString::number</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QString::number</span><span class="params">(<span class="type">double</span> n, <span class="type">char</span> format = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> precision = <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 QString 转换为 int, short, long, float, double 类型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::toInt</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">short</span> <span class="title">QString::toShort</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">QString::toLong</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">QString::toFloat</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">QString::toDouble</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将标准C++中的 std::string 类型 转换为 QString 类型</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QString::fromStdString</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span>;</span><br><span class="line"><span class="comment">// 将 QString 转换为 标准C++中的 std::string 类型</span></span><br><span class="line"><span class="function">std::string <span class="title">QString::toStdString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QString -&gt; QByteArray</span></span><br><span class="line"><span class="comment">// 转换为本地编码, 跟随操作系统</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QString::toLocal8Bit</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 转换为 Latin-1 编码的字符串 不支持中文</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QString::toLatin1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 转换为 utf8 编码格式的字符串 (常用)</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QString::toUtf8</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有字符转换为大写</span></span><br><span class="line"><span class="function">QString <span class="title">QString::toUpper</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 所有字符转换为小写</span></span><br><span class="line"><span class="function">QString <span class="title">QString::toLower</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="字符串格式"><a href="#字符串格式" class="headerlink" title="字符串格式"></a>字符串格式</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString <span class="title">QString::arg</span><span class="params">(<span class="type">const</span> QString &amp;a, </span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">int</span> fieldWidth = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">          QChar fillChar = QLatin1Char( <span class="string">&#x27; &#x27;</span> ))</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QString <span class="title">QString::arg</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> fieldWidth = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">int</span> base = <span class="number">10</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">          QChar fillChar = QLatin1Char( <span class="string">&#x27; &#x27;</span> ))</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例程序</span></span><br><span class="line"><span class="type">int</span> i;                <span class="comment">// 假设该变量表示当前文件的编号</span></span><br><span class="line"><span class="type">int</span> total;            <span class="comment">// 假设该变量表示文件的总个数</span></span><br><span class="line">QString fileName;     <span class="comment">// 假设该变量表示当前文件的名字</span></span><br><span class="line"><span class="comment">// 使用以上三个变量拼接一个动态字符串</span></span><br><span class="line">QString status = <span class="built_in">QString</span>(<span class="string">&quot;Processing file %1 of %2: %3&quot;</span>)</span><br><span class="line">                  .<span class="built_in">arg</span>(i).<span class="built_in">arg</span>(total).<span class="built_in">arg</span>(fileName);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Qvariant"><a href="#Qvariant" class="headerlink" title="Qvariant"></a>Qvariant</h2><img src="/post/2095ef6d/image-20230803085428989.png" class="" title="image-20230803085428989"><img src="/post/2095ef6d/image-20230803085516873.png" class="" title="image-20230803085516873"><p>Qvariant(10+20),涉及到隐式转换，用构造函数或<strong>者,参数只能是标准数据类型</strong></p><p>现有一个QVariant空对象,,,,,,,,,,,,,,,,,,然后口对象.setvalue（10+20），就把实际计算的数据返回给了对象</p><p>T代表支持标准类型和我们自定义类型</p><img src="/post/2095ef6d/image-20230803085526477.png" class="" title="image-20230803085526477"><p>QVariant对象.type()</p><img src="/post/2095ef6d/image-20230803085534209.png" class="" title="image-20230803085534209"><p>QVariant对象.to 数据类型</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a=<span class="built_in">data</span>(<span class="number">10</span>,<span class="number">20</span>).<span class="built_in">toInt</span>();</span><br><span class="line">    QString str=<span class="built_in">data</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>).<span class="built_in">toString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;a;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">QVariant <span class="title">MainWindow::data</span><span class="params">(QVariant a,QVariant b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QVariant ret;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">type</span>()==QVariant::Int&amp;&amp;b.<span class="built_in">type</span>()==QVariant::Int)</span><br><span class="line">    &#123;</span><br><span class="line">        ret=<span class="built_in">QVariant</span>(a.<span class="built_in">toInt</span>()+b.<span class="built_in">toInt</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.<span class="built_in">type</span>()==QVariant::String&amp;&amp;b.<span class="built_in">type</span>()==QVariant::String)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        ret=QVariant(a.toString()+b.toString());</span></span><br><span class="line">        ret.<span class="built_in">setValue</span>(a.<span class="built_in">toString</span>()+b.<span class="built_in">toString</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Qvariant：：自定义数据类型"><a href="#Qvariant：：自定义数据类型" class="headerlink" title="Qvariant：：自定义数据类型"></a>Qvariant：：自定义数据类型</h2><img src="/post/2095ef6d/image-20230803090644987.png" class="" title="image-20230803090644987"><p>用Qvariant的</p><img src="/post/2095ef6d/image-20230803090805728.png" class="" title="image-20230803090805728"><img src="/post/2095ef6d/image-20230803090849381.png" class="" title="image-20230803090849381"><p><strong>———————————– ———————————- 使用方法——————————————————-</strong></p><img src="/post/2095ef6d/image-20230803091233080.png" class=""><img src="/post/2095ef6d/image-20230803091121738.png" class=""><p><strong>———————————————————下面取出数据—————————————————————————-</strong></p><blockquote><h3 id="c-value-返回里面的数据类型"><a href="#c-value-返回里面的数据类型" class="headerlink" title="c.value&lt;数据类型&gt;()返回&lt;&gt;里面的数据类型"></a><strong>c.value&lt;数据类型&gt;()返回&lt;&gt;里面的数据类型</strong></h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    Student xrb;</span><br><span class="line">    xrb.id=<span class="number">123</span>;</span><br><span class="line">    xrb.name=<span class="string">&quot;张大山&quot;</span>;</span><br><span class="line">    <span class="comment">//1//</span></span><br><span class="line">    QVariant c;</span><br><span class="line">    c.<span class="built_in">setValue</span>(xrb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2//</span></span><br><span class="line">    <span class="comment">//QVariant v=QVariant::fromValue(xrb);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c.<span class="built_in">canConvert</span>&lt;Student&gt;())</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Student temp=c.<span class="built_in">value</span>&lt;Student&gt;();</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;temp.id;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;temp.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230803085326234.png" class="" title="image-20230803085326234"><h2 id="QT位置和尺寸"><a href="#QT位置和尺寸" class="headerlink" title="QT位置和尺寸"></a>QT位置和尺寸</h2><img src="/post/2095ef6d/image-20230803140624518.png" class="" title="image-20230803140624518"><h3 id="QPOINT"><a href="#QPOINT" class="headerlink" title="QPOINT"></a>QPOINT</h3><img src="/post/2095ef6d/image-20230803140635397.png" class="" title="image-20230803140635397"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 构造一个坐标原点, 即(0, 0)</span></span><br><span class="line">QPoint::<span class="built_in">QPoint</span>();</span><br><span class="line"><span class="comment">// 参数为 x轴坐标, y轴坐标</span></span><br><span class="line">QPoint::<span class="built_in">QPoint</span>(<span class="type">int</span> xpos, <span class="type">int</span> ypos);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置x轴坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPoint::setX</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">// 设置y轴坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPoint::setY</span><span class="params">(<span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到x轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QPoint::x</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到x轴坐标的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">QPoint::rx</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 得到y轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QPoint::y</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到y轴坐标的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">QPoint::ry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接通过坐标对象进行算术运算: 加减乘除</span></span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>*=(<span class="type">float</span> factor);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>*=(<span class="type">double</span> factor);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>*=(<span class="type">int</span> factor);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>+=(<span class="type">const</span> QPoint &amp;point);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>-=(<span class="type">const</span> QPoint &amp;point);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>/=(qreal divisor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他API请自行查询Qt帮助文档, 不要犯懒哦哦哦哦哦......</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 创建坐标对象</span></span><br><span class="line">    QPoint p;</span><br><span class="line">    <span class="function">QPoint <span class="title">p1</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置x，y坐标</span></span><br><span class="line">    p.<span class="built_in">setX</span>(<span class="number">10</span>);</span><br><span class="line">    p.<span class="built_in">setY</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//2/2/2/2/2/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//得到x，y坐标</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p.<span class="built_in">x</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p.<span class="built_in">y</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p1.<span class="built_in">x</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p1.<span class="built_in">y</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到x，y坐标的引用</span></span><br><span class="line">    <span class="type">int</span> &amp;x1=p.<span class="built_in">rx</span>();</span><br><span class="line">    <span class="type">int</span> &amp;y1=p.<span class="built_in">ry</span>();</span><br><span class="line">    x1=<span class="number">100</span>;</span><br><span class="line">    y1=<span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> &amp;x2=p1.<span class="built_in">rx</span>();</span><br><span class="line">    <span class="type">int</span> &amp;y2=p1.<span class="built_in">ry</span>();</span><br><span class="line"></span><br><span class="line">    x2=<span class="number">1</span>;</span><br><span class="line">    y2=<span class="number">2</span>;</span><br><span class="line"><span class="comment">//再次得到通过引用修改后的坐标</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p.<span class="built_in">x</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p.<span class="built_in">y</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p1.<span class="built_in">x</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p1.<span class="built_in">y</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="QLINE"><a href="#QLINE" class="headerlink" title="QLINE"></a>QLINE</h3><img src="/post/2095ef6d/image-20230803141547493.png" class="" title="image-20230803141547493"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 构造一个空对象</span></span><br><span class="line">QLine::<span class="built_in">QLine</span>();</span><br><span class="line"><span class="comment">// 构造一条直线, 通过两个坐标点</span></span><br><span class="line">QLine::<span class="built_in">QLine</span>(<span class="type">const</span> QPoint &amp;p1, <span class="type">const</span> QPoint &amp;p2);</span><br><span class="line"><span class="comment">// 从点 (x1, y1) 到 (x2, y2)</span></span><br><span class="line">QLine::<span class="built_in">QLine</span>(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给直线对象设置坐标点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::setPoints</span><span class="params">(<span class="type">const</span> QPoint &amp;p1, <span class="type">const</span> QPoint &amp;p2)</span></span>;</span><br><span class="line"><span class="comment">// 起始点(x1, y1), 终点(x2, y2)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::setLine</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span>;</span><br><span class="line"><span class="comment">// 设置直线的起点坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::setP1</span><span class="params">(<span class="type">const</span> QPoint &amp;p1)</span></span>;</span><br><span class="line"><span class="comment">// 设置直线的终点坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::setP2</span><span class="params">(<span class="type">const</span> QPoint &amp;p2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回直线的起始点坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QLine::p1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回直线的终点坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QLine::p2</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值直线的中心点坐标, (p1() + p2()) / 2</span></span><br><span class="line"><span class="function">QPoint <span class="title">QLine::center</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值直线起点的 x 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::x1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值直线终点的 x 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::x2</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值直线起点的 y 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::y1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值直线终点的 y 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::y2</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用给定的坐标点平移这条直线</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::translate</span><span class="params">(<span class="type">const</span> QPoint &amp;offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::translate</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy)</span></span>;</span><br><span class="line"><span class="comment">// 用给定的坐标点平移这条直线, 返回平移之后的坐标点</span></span><br><span class="line"><span class="function">QLine <span class="title">QLine::translated</span><span class="params">(<span class="type">const</span> QPoint &amp;offset)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QLine <span class="title">QLine::translated</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直线对象进行比较</span></span><br><span class="line"><span class="type">bool</span> QLine::<span class="keyword">operator</span>!=(<span class="type">const</span> QLine &amp;line) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QLine::<span class="keyword">operator</span>==(<span class="type">const</span> QLine &amp;line) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他API请自行查询Qt帮助文档, 不要犯懒哦哦哦哦哦......</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function">QPoint <span class="title">p1</span><span class="params">(<span class="number">10</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">p2</span><span class="params">(<span class="number">20</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建直线，传入有参构造的时候直接传入两个点point</span></span><br><span class="line"> <span class="comment">//先创建一个空对象，然后空对象.setpoints</span></span><br><span class="line">    <span class="comment">//直接用四个参数的有参构造函数创建</span></span><br><span class="line">    <span class="function">QLine <span class="title">line</span><span class="params">(p1,p2)</span></span>;</span><br><span class="line">    <span class="function">QLine <span class="title">line1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    QLine line2;</span><br><span class="line">    line2.<span class="built_in">setPoints</span>(p1,p2);</span><br><span class="line"><span class="comment">//可以得到直线的坐标起点，中点，重点.四个坐标，x1,x2,y1,y2或者得到起/末点再 .x()</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;line.<span class="built_in">p1</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;line.<span class="built_in">p2</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;line.<span class="built_in">center</span>();</span><br><span class="line"><span class="comment">//    QPoint(10,20)</span></span><br><span class="line"><span class="comment">//    QPoint(20,40)</span></span><br><span class="line"><span class="comment">//    QPoint(15,30)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个是根据这个点平移后，修改直线相当于方法使用</span></span><br><span class="line">    <span class="comment">// 平移线段的起点和终点，偏移量为 (5, 5)</span></span><br><span class="line">    line.<span class="built_in">translate</span>(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; line.<span class="built_in">p1</span>(); <span class="comment">// 输出 (15, 15)</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; line.<span class="built_in">p2</span>(); <span class="comment">// 输出 (55, 55)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个是根据这个点平移后返回线段对象,相当于函数使用</span></span><br><span class="line">    QLine newline=line.<span class="built_in">translated</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; newline.<span class="built_in">p1</span>(); <span class="comment">// 输出 (15, 15)</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; newline.<span class="built_in">p2</span>(); <span class="comment">// 输出 (55, 55)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="QSIZE"><a href="#QSIZE" class="headerlink" title="QSIZE"></a>QSIZE</h3><img src="/post/2095ef6d/image-20230803143027470.png" class="" title="image-20230803143027470"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 构造空对象, 对象中的宽和高都是无效的</span></span><br><span class="line">QSize::<span class="built_in">QSize</span>();</span><br><span class="line"><span class="comment">// 使用宽和高构造一个有效对象</span></span><br><span class="line">QSize::<span class="built_in">QSize</span>(<span class="type">int</span> width, <span class="type">int</span> height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSize::setWidth</span><span class="params">(<span class="type">int</span> width)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 设置高度</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSize::setHeight</span><span class="params">(<span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QSize::width</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到宽度的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">QSize::rwidth</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 得到高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QSize::height</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到高度的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">QSize::rheight</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换高度和宽度的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSize::transpose</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 交换高度和宽度的值, 返回交换之后的尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">QSize::transposed</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行算法运算: 加减乘除</span></span><br><span class="line">QSize &amp;QSize::<span class="keyword">operator</span>*=(qreal factor);</span><br><span class="line">QSize &amp;QSize::<span class="keyword">operator</span>+=(<span class="type">const</span> QSize &amp;size);</span><br><span class="line">QSize &amp;QSize::<span class="keyword">operator</span>-=(<span class="type">const</span> QSize &amp;size);</span><br><span class="line">QSize &amp;QSize::<span class="keyword">operator</span>/=(qreal divisor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他API请自行查询Qt帮助文档, 不要犯懒哦哦哦哦哦......</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line"><span class="comment">//实例化对象，注意无参的时候千万不能有（）；</span></span><br><span class="line">    QSize p;</span><br><span class="line">    <span class="function">QSize <span class="title">p1</span><span class="params">(<span class="number">20</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动设置宽高</span></span><br><span class="line">    p.<span class="built_in">setWidth</span>(<span class="number">10</span>);</span><br><span class="line">    p.<span class="built_in">setHeight</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到宽和高</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p.<span class="built_in">width</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p.<span class="built_in">height</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p1.<span class="built_in">width</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p1.<span class="built_in">height</span>();</span><br><span class="line"><span class="comment">//得到宽和高的引用并且修改</span></span><br><span class="line">    <span class="type">int</span> &amp;w1=p.<span class="built_in">rwidth</span>();</span><br><span class="line">    <span class="type">int</span> &amp;w2=p1.<span class="built_in">rwidth</span>();</span><br><span class="line">    <span class="type">int</span> &amp;h1=p.<span class="built_in">rheight</span>();</span><br><span class="line">    <span class="type">int</span> &amp;h2=p1.<span class="built_in">rheight</span>();</span><br><span class="line"></span><br><span class="line">    w1=<span class="number">1</span>;</span><br><span class="line">    w2=<span class="number">1</span>;</span><br><span class="line">    h1=<span class="number">2</span>;</span><br><span class="line">    h2=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p.<span class="built_in">width</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p.<span class="built_in">height</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p1.<span class="built_in">width</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p1.<span class="built_in">height</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将宽和高反转</span></span><br><span class="line">    p.<span class="built_in">transpose</span>();</span><br><span class="line">    p1.<span class="built_in">transpose</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p.<span class="built_in">width</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p.<span class="built_in">height</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p1.<span class="built_in">width</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p1.<span class="built_in">height</span>();</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;------------------&quot;</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    QSize newp=p.<span class="built_in">transposed</span>();</span><br><span class="line">    QSize newp1=p1.<span class="built_in">transposed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;newp.<span class="built_in">width</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;newp.<span class="built_in">height</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;newp1.<span class="built_in">width</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;newp1.<span class="built_in">height</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line">    </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">    </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">------------------</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="QRECT"><a href="#QRECT" class="headerlink" title="QRECT"></a>QRECT</h3><img src="/post/2095ef6d/image-20230803144048156.png" class="" title="image-20230803144048156"><p><strong>长&#x2F;宽是末减初+1</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 构造一个空对象</span></span><br><span class="line">QRect::<span class="built_in">QRect</span>();</span><br><span class="line"><span class="comment">// 基于左上角坐标, 和右下角坐标构造一个矩形对象</span></span><br><span class="line">QRect::<span class="built_in">QRect</span>(<span class="type">const</span> QPoint &amp;topLeft, <span class="type">const</span> QPoint &amp;bottomRight);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">默认是左上角和右下角的关系，如果穿了一个左下角和一个右上角的，顺序就相反了，避免</span><br><span class="line"><span class="comment">// 基于左上角坐标, 和 宽度, 高度构造一个矩形对象</span></span><br><span class="line">QRect::<span class="built_in">QRect</span>(<span class="type">const</span> QPoint &amp;topLeft, <span class="type">const</span> QSize &amp;size);</span><br><span class="line"></span><br><span class="line">长/宽是末减初+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 通过 左上角坐标(x, y), 和 矩形尺寸(width, height) 构造一个矩形对象</span></span><br><span class="line">QRect::<span class="built_in">QRect</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置矩形的尺寸信息, 左上角坐标不变</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::setSize</span><span class="params">(<span class="type">const</span> QSize &amp;size)</span></span>;</span><br><span class="line"><span class="comment">// 设置矩形左上角坐标为(x,y), 大小为(width, height)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::setRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="comment">// 设置矩形宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::setWidth</span><span class="params">(<span class="type">int</span> width)</span></span>;</span><br><span class="line"><span class="comment">// 设置矩形高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::setHeight</span><span class="params">(<span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值矩形左上角坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::topLeft</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形右上角坐标</span></span><br><span class="line"><span class="comment">// 该坐标点值为: QPoint(left() + width() -1, top())</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::topRight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形左下角坐标</span></span><br><span class="line"><span class="comment">// 该坐标点值为: QPoint(left(), top() + height() - 1)</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::bottomLeft</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形右下角坐标</span></span><br><span class="line"><span class="comment">// 该坐标点值为: QPoint(left() + width() -1, top() + height() - 1)</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::bottomRight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形中心点坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::center</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回矩形上边缘y轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::top</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::y</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值矩形下边缘y轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::bottom</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形左边缘 x轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::x</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::left</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形右边缘x轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::right</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回矩形的高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::width</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形的宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::height</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形的尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">QRect::size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><h3 id="QDATE"><a href="#QDATE" class="headerlink" title="QDATE"></a>QDATE</h3><p>需要引入头文件！</p><img src="/post/2095ef6d/image-20230804080321434.png" class="" title="image-20230804080321434"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QDate::<span class="built_in">QDate</span>();</span><br><span class="line">QDate::<span class="built_in">QDate</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 重新设置日期对象中的日期</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QDate::setDate</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span>;</span><br><span class="line"><span class="comment">// 给日期对象添加 ndays 天</span></span><br><span class="line"><span class="function">QDate <span class="title">QDate::addDays</span><span class="params">(qint64 ndays)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给日期对象添加 nmonths 月</span></span><br><span class="line"><span class="function">QDate <span class="title">QDate::addMonths</span><span class="params">(<span class="type">int</span> nmonths)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给日期对象添加 nyears 月</span></span><br><span class="line"><span class="function">QDate <span class="title">QDate::addYears</span><span class="params">(<span class="type">int</span> nyears)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到日期对象中的年/月/日</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QDate::year</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QDate::month</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QDate::day</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDate::getDate</span><span class="params">(<span class="type">int</span> *year, <span class="type">int</span> *month, <span class="type">int</span> *day)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期对象格式化</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    d    - The day as a number without a leading zero (1 to 31)</span></span><br><span class="line"><span class="comment">    dd   - The day as a number with a leading zero (01 to 31)</span></span><br><span class="line"><span class="comment">    ddd -  周四</span></span><br><span class="line"><span class="comment">    dddd - 星期四</span></span><br><span class="line"><span class="comment">    M    - The month as a number without a leading zero (1 to 12)</span></span><br><span class="line"><span class="comment">    MM   - The month as a number with a leading zero (01 to 12)</span></span><br><span class="line"><span class="comment">    MMM 9月</span></span><br><span class="line"><span class="comment">    MMMM 九月</span></span><br><span class="line"><span class="comment">    yy   - The year as a two digit number (00 to 99)</span></span><br><span class="line"><span class="comment">    yyyy - The year as a four digit number. If the year is negative, a minus sign is prepended, making five characters.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">QString <span class="title">QDate::toString</span><span class="params">(<span class="type">const</span> QString &amp;format)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符重载 ==&gt; 日期比较</span></span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>!=(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>&lt;(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="built_in">operator</span>&lt;=(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>==(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>&gt;(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态函数 -&gt; 得到本地的当前日期</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QDate <span class="title">QDate::currentDate</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDate&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function">QDate <span class="title">a</span><span class="params">(<span class="number">2023</span>,<span class="number">8</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    QDate b;</span><br><span class="line">    b.<span class="built_in">setDate</span>(<span class="number">2023</span>,<span class="number">8</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//////</span></span><br><span class="line">    QDate c=QDate::<span class="built_in">currentDate</span>();</span><br><span class="line">    <span class="comment">//////</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;c;</span><br><span class="line">    c=c.<span class="built_in">addDays</span>(<span class="number">10</span>);</span><br><span class="line">    c=c.<span class="built_in">addMonths</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;c;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;c.<span class="built_in">year</span>();</span><br><span class="line"></span><br><span class="line">    QString str=c.<span class="built_in">toString</span>(<span class="string">&quot;yy-MMM-ddd&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;str;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="QTIME"><a href="#QTIME" class="headerlink" title="QTIME"></a>QTIME</h3><img src="/post/2095ef6d/image-20230804082459651.png" class="" title="image-20230804082459651"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QTime::<span class="built_in">QTime</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    h ==&gt; 取值范围： 0 ~ 23</span></span><br><span class="line"><span class="comment">    m and s ==&gt; 取值范围： 0 ~ 59</span></span><br><span class="line"><span class="comment">    ms ==&gt; 取值范围： 0 ~ 999</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">QTime::<span class="built_in">QTime</span>(<span class="type">int</span> h, <span class="type">int</span> m, <span class="type">int</span> s = <span class="number">0</span>, <span class="type">int</span> ms = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// Returns true if the set time is valid; otherwise returns false.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTime::setHMS</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> m, <span class="type">int</span> s, <span class="type">int</span> ms = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">QTime <span class="title">QTime::addSecs</span><span class="params">(<span class="type">int</span> s)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QTime <span class="title">QTime::addMSecs</span><span class="params">(<span class="type">int</span> ms)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line">  <span class="function">QTime <span class="title">n</span><span class="params">(<span class="number">14</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;                <span class="comment">// n == 14:00:00</span></span><br><span class="line">  QTime t;</span><br><span class="line">  t = n.<span class="built_in">addSecs</span>(<span class="number">70</span>);                <span class="comment">// t == 14:01:10</span></span><br><span class="line">  t = n.<span class="built_in">addSecs</span>(<span class="number">-70</span>);               <span class="comment">// t == 13:58:50</span></span><br><span class="line">  t = n.<span class="built_in">addSecs</span>(<span class="number">10</span> * <span class="number">60</span> * <span class="number">60</span> + <span class="number">5</span>);  <span class="comment">// t == 00:00:05</span></span><br><span class="line">  t = n.<span class="built_in">addSecs</span>(<span class="number">-15</span> * <span class="number">60</span> * <span class="number">60</span>);     <span class="comment">// t == 23:00:00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从时间对象中取出 时/分/秒/毫秒</span></span><br><span class="line"><span class="comment">// Returns the hour part (0 to 23) of the time. Returns -1 if the time is invalid.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::hour</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// Returns the minute part (0 to 59) of the time. Returns -1 if the time is invalid.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::minute</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// Returns the second part (0 to 59) of the time. Returns -1 if the time is invalid.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::second</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// Returns the millisecond part (0 to 999) of the time. Returns -1 if the time is invalid.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::msec</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间格式化</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    -- 时 --</span></span><br><span class="line"><span class="comment">    h==&gt;The hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)</span></span><br><span class="line"><span class="comment">    hh==&gt;The hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)</span></span><br><span class="line"><span class="comment">    H==&gt;The hour without a leading zero (0 to 23, even with AM/PM display)</span></span><br><span class="line"><span class="comment">    HH==&gt;The hour with a leading zero (00 to 23, even with AM/PM display)</span></span><br><span class="line"><span class="comment">    -- 分 --</span></span><br><span class="line"><span class="comment">    m==&gt;The minute without a leading zero (0 to 59)</span></span><br><span class="line"><span class="comment">    mm==&gt;The minute with a leading zero (00 to 59)</span></span><br><span class="line"><span class="comment">    -- 秒 --</span></span><br><span class="line"><span class="comment">    s==&gt;The whole second, without any leading zero (0 to 59)</span></span><br><span class="line"><span class="comment">    ss==&gt;The whole second, with a leading zero where applicable (00 to 59)</span></span><br><span class="line"><span class="comment">    -- 毫秒 --</span></span><br><span class="line"><span class="comment">    zzz==&gt;The fractional part of the second, to millisecond precision, </span></span><br><span class="line"><span class="comment">including trailing zeroes where applicable (000 to 999).</span></span><br><span class="line"><span class="comment">    -- 上午或者下午</span></span><br><span class="line"><span class="comment">    AP or A==&gt;使用AM/PM(大写) 描述上下午, 中文系统显示汉字</span></span><br><span class="line"><span class="comment">    ap or a==&gt;使用am/pm(小写) 描述上下午, 中文系统显示汉字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">QString <span class="title">QTime::toString</span><span class="params">(<span class="type">const</span> QString &amp;format)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阶段性计时</span></span><br><span class="line"><span class="comment">// 过时的API函数</span></span><br><span class="line"><span class="comment">// 开始计时</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTime::start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 计时结束</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::elapsed</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 重新计时</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::restart</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐使用的API函数</span></span><br><span class="line"><span class="comment">// QElapsedTimer 类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QElapsedTimer::start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">qint64 <span class="title">QElapsedTimer::restart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">qint64 <span class="title">QElapsedTimer::elapsed</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符重载 ==&gt; 时间比较</span></span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>!=(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>&lt;(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="built_in">operator</span>&lt;=(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>==(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>&gt;(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态函数 -&gt; 得到当前时间</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QTime <span class="title">QTime::currentTime</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QElapsedTimer&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();</span><br><span class="line">    <span class="function">QTime <span class="title">a</span><span class="params">(<span class="number">8</span>,<span class="number">26</span>,<span class="number">40</span>,<span class="number">999</span>)</span></span>;</span><br><span class="line"><span class="comment">//    h 0~23</span></span><br><span class="line"><span class="comment">//    m 0~59</span></span><br><span class="line"><span class="comment">//    s 0~59</span></span><br><span class="line"><span class="comment">//    ms 0~999</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;a;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;a.<span class="built_in">hour</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;a.<span class="built_in">minute</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;a.<span class="built_in">second</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;a.<span class="built_in">msec</span>();</span><br><span class="line">    QTime b;</span><br><span class="line">    b.<span class="built_in">setHMS</span>(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;b;</span><br><span class="line">    QTime c=c.<span class="built_in">currentTime</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;c;</span><br><span class="line"><span class="comment">//    QTime(&quot;08:35:08.486&quot;)</span></span><br><span class="line">    qint64 time1=time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;time1;</span><br><span class="line"></span><br><span class="line">        QElapsedTimer timer;</span><br><span class="line"></span><br><span class="line">        timer.<span class="built_in">start</span>(); <span class="comment">// 开始计时</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行一些需要测量的代码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qint64 elapsedTime = timer.<span class="built_in">elapsed</span>(); <span class="comment">// 获取经过的时间（以毫秒为单位）</span></span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Elapsed Time:&quot;</span> &lt;&lt; elapsedTime &lt;&lt; <span class="string">&quot;ms&quot;</span>;</span><br><span class="line"><span class="comment">//        Elapsed Time: 7 ms</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QDATETIME"><a href="#QDATETIME" class="headerlink" title="QDATETIME"></a>QDATETIME</h3><img src="/post/2095ef6d/image-20230804084530792.png" class="" title="image-20230804084530792"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QDateTime::<span class="built_in">QDateTime</span>();</span><br><span class="line">QDateTime::<span class="built_in">QDateTime</span>(<span class="type">const</span> QDate &amp;date, <span class="type">const</span> QTime &amp;time, Qt::TimeSpec spec = Qt::LocalTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 设置日期</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDateTime::setDate</span><span class="params">(<span class="type">const</span> QDate &amp;date)</span></span>;</span><br><span class="line"><span class="comment">// 设置时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDateTime::setTime</span><span class="params">(<span class="type">const</span> QTime &amp;time)</span></span>;</span><br><span class="line"><span class="comment">// 给当前日期对象追加 年/月/日/秒/毫秒, 参数可以是负数</span></span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addYears</span><span class="params">(<span class="type">int</span> nyears)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addMonths</span><span class="params">(<span class="type">int</span> nmonths)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addDays</span><span class="params">(qint64 ndays)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addSecs</span><span class="params">(qint64 s)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addMSecs</span><span class="params">(qint64 msecs)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到对象中的日期</span></span><br><span class="line"><span class="function">QDate <span class="title">QDateTime::date</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到对象中的时间</span></span><br><span class="line"><span class="function">QTime <span class="title">QDateTime::time</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期和时间格式, 格式字符参考QDate 和 QTime 类的 toString() 函数</span></span><br><span class="line"><span class="function">QString <span class="title">QDateTime::toString</span><span class="params">(<span class="type">const</span> QString &amp;format)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符重载 ==&gt; 日期时间对象的比较</span></span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>!=(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>&lt;(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="built_in">operator</span>&lt;=(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>==(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>&gt;(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态函数</span></span><br><span class="line"><span class="comment">// 得到当前时区的日期和时间(本地设置的时区对应的日期和时间)</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QDateTime <span class="title">QDateTime::currentDateTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDate&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDateTime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function">QDate <span class="title">date</span><span class="params">(<span class="number">2023</span>,<span class="number">8</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">QTime <span class="title">time</span><span class="params">(<span class="number">8</span>,<span class="number">55</span>,<span class="number">30</span>,<span class="number">876</span>)</span></span>;</span><br><span class="line">    <span class="function">QDateTime <span class="title">datetime</span><span class="params">(date,time)</span></span>;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;datetime;</span><br><span class="line"></span><br><span class="line">    QDateTime newtime;</span><br><span class="line">    newtime.<span class="built_in">setDate</span>(date);</span><br><span class="line">    newtime.<span class="built_in">setTime</span>(time);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    newtime=newtime.<span class="built_in">addDays</span>(<span class="number">1</span>);</span><br><span class="line">    newtime=newtime.<span class="built_in">addSecs</span>(<span class="number">23</span>);</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;newtime;</span><br><span class="line">        </span><br><span class="line">    QDateTime now= QDateTime::<span class="built_in">currentDateTime</span>();</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;now;</span><br><span class="line">        </span><br><span class="line">   QString str=now.<span class="built_in">toString</span>(<span class="string">&quot;yyyy-MM-dddd hh:mm:ss ap&quot;</span>);</span><br><span class="line">   <span class="built_in">qDebug</span>()&lt;&lt;str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="QT坐标体系"><a href="#QT坐标体系" class="headerlink" title="QT坐标体系"></a>QT坐标体系</h2><img src="/post/2095ef6d/image-20230731112623738.png" class="" title="image-20230731112623738"><p>子窗口相对于父窗口的坐标原点来进行的</p><p>用的坐标体系不一样</p><p><code>MainWindow</code>类继承自<code>QMainWindow</code>，并且使用<code>Ui_MainWindow</code>类来进行界面的设置。所以在<code>MainWindow</code>构造函数中调用了<code>ui-&gt;setupUi(this)</code>方法，将<code>MainWindow</code>作为参数传递给它，从而创建和设置了界面。</p><img src="/post/2095ef6d/image-20230731114247952.png" class="" title="image-20230731114247952"><p>至于为什么按钮不需要调用<code>show()</code>方法就可以显示，是因为在<code>ui-&gt;setupUi(this)</code>方法中已经包括了按钮的初始化和显示设置。<code>setupUi()</code>方法会创建和设置窗口中所有的控件，并根据布局和样式等配置来显示它们。所以当你调用<code>this-&gt;show()</code>来显示窗口时，已经包含了按钮的显示。</p><img src="/post/2095ef6d/image-20230731114232016.png" class="" title="image-20230731114232016"><h2 id="QT内存回收机制"><a href="#QT内存回收机制" class="headerlink" title="QT内存回收机制"></a>QT内存回收机制</h2><blockquote><p>Qt的内存回收机制主要是基于对象树的概念。当<strong>你在Qt中创建一个对象并指定了父对象时，父对象会负责管理其子对象的生命周期。</strong>具体来说，<strong>当父对象被销毁时，它会自动销毁其所有子对象。</strong></p><p><strong>这种内存回收机制的优势在于，你无需手动释放子对象的内存，而是将其交给父对象去管理。这简化了内存管理的工作，并确保了对象之间的正确关系。</strong></p><p>在你提到的情况中，当你在堆区创建一个控件并将其指定为父窗口的子控件时，父窗口会成为该控件的父对象。<strong>当父窗口关闭时，它会自动销毁其所有子控件，包括在堆区创建的控件。这就利用了Qt的内存回收机制，确保了子控件的正确释放。</strong></p><p>需要注意的是，Qt的内存回收机制只适用于通过对象树进行管理的对象。如果你在堆区创建了一个对象，但没有设置其父对象，那么它将不会被自动释放，你需要手动管理其生命周期，确保在不再需要时进行释放。</p></blockquote><p><strong>qt机制非常的聪明，他会检测一个内存是否被释放，如果被释放了就不再释放。！！！！！！</strong></p><p>**<img src="/post/2095ef6d/image-20230808120713278.png" class="" title="image-20230808120713278"></p><img src="/post/2095ef6d/image-20230731114806690.png" class="" title="image-20230731114806690"><img src="/post/2095ef6d/image-20230731114857012.png" class="" title="image-20230731114857012"><img src="/post/2095ef6d/image-20230731115011091.png" class="" title="image-20230731115011091"><img src="/post/2095ef6d/image-20230731124251606.png" class="" title="image-20230731124251606"><img src="/post/2095ef6d/image-20230731195036189.png" class="" title="image-20230731195036189"><p>先析构自己后析构儿子</p><p>父类中创建子类 的话是，先构建儿子后构建父亲</p><p>设置父对象，父对象析构的时候会自动把儿子给析构掉</p><blockquote><ol><li>当类对象作为类成员的时候，先构造儿子后构造父亲，析构相反</li></ol></blockquote><h2 id="QT的基础类型"><a href="#QT的基础类型" class="headerlink" title="QT的基础类型"></a>QT的基础类型</h2><img src="/post/2095ef6d/image-20230731195225067.png" class="" title="image-20230731195225067"><h2 id="LOG输出"><a href="#LOG输出" class="headerlink" title="LOG输出"></a>LOG输出</h2><p>QDebug类</p><p>qDebug（）方法</p><img src="/post/2095ef6d/image-20230731201638457.png" class="" title="image-20230731201638457"><p>实现控制台 在外部</p><h2 id="信号和槽机制"><a href="#信号和槽机制" class="headerlink" title="信号和槽机制"></a>信号和槽机制</h2><img src="/post/2095ef6d/image-20230802140725492.png" class="" title="image-20230802140725492"><img src="/post/2095ef6d/image-20230802140908764.png" class="" title="image-20230802140908764"><p>四个参数</p><p>1.信号发送者</p><p>2，发送的信号</p><p>3，接收者</p><p>4，接收者的行为</p><p><code>connect</code>函数的连接参数应该是函数指针或者函数对象，并且需要使用信号槽机制进行连接。</p><blockquote><h4 id="connect函数的连接参数应该是函数指针或者函数对象，并且需要使用信号槽机制进行连接。"><a href="#connect函数的连接参数应该是函数指针或者函数对象，并且需要使用信号槽机制进行连接。" class="headerlink" title="connect函数的连接参数应该是函数指针或者函数对象，并且需要使用信号槽机制进行连接。"></a>connect函数的连接参数应该是函数指针或者函数对象，并且需要使用信号槽机制进行连接。</h4><h4 id="connect-btn-QPushButton-clicked-this-MainWindow-close"><a href="#connect-btn-QPushButton-clicked-this-MainWindow-close" class="headerlink" title="connect(btn,&amp;QPushButton::clicked,this,&amp;MainWindow::close);"></a>connect(btn,&amp;QPushButton::clicked,this,&amp;MainWindow::close);</h4></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    QPushButton*btn=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">show</span>();</span><br><span class="line">    btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;第一个按钮&quot;</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">setFixedSize</span>(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">move</span>(<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//connect函数的连接参数应该是函数指针或者函数对象，并且需要使用信号槽机制进行连接。</span></span><br><span class="line">    <span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;MainWindow::close);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><img src="/post/2095ef6d/image-20230802143040664.png" class="" title="image-20230802143040664"><img src="/post/2095ef6d/image-20230802143003435.png" class="" title="image-20230802143003435"><img src="/post/2095ef6d/image-20230802143021118.png" class="" title="image-20230802143021118"><img src="/post/2095ef6d/image-20230802143124345.png" class="" title="image-20230802143124345"><img src="/post/2095ef6d/image-20230802143142947.png" class="" title="image-20230802143142947"><img src="/post/2095ef6d/image-20230802143158612.png" class="" title="image-20230802143158612"><img src="/post/2095ef6d/image-20230802143235656.png" class="" title="image-20230802143235656"><img src="/post/2095ef6d/image-20230802143313999.png" class="" title="image-20230802143313999"><blockquote><h2 id="找的时候，如果没有，就去找他的基类！！！！！"><a href="#找的时候，如果没有，就去找他的基类！！！！！" class="headerlink" title="找的时候，如果没有，就去找他的基类！！！！！"></a><strong>找的时候，如果没有，就去找他的基类！！！！！</strong></h2><h4 id="1-确定，信号发出者和信号接收者的类型-！！！"><a href="#1-确定，信号发出者和信号接收者的类型-！！！" class="headerlink" title="1.确定，信号发出者和信号接收者的类型 ！！！"></a>1.确定，信号发出者和信号接收者的类型 ！！！</h4><h4 id="2-确定-对应的信号和槽函数，传入函数的地址，-信号发出者-对应的信号函数-信号接受者-对应的槽函数"><a href="#2-确定-对应的信号和槽函数，传入函数的地址，-信号发出者-对应的信号函数-信号接受者-对应的槽函数" class="headerlink" title="2,确定 对应的信号和槽函数，传入函数的地址，&amp;信号发出者::对应的信号函数,&amp;信号接受者::对应的槽函数,"></a>2,确定 对应的信号和槽函数，传入函数的地址，&amp;信号发出者::对应的信号函数,&amp;信号接受者::对应的槽函数,</h4></blockquote><img src="/post/2095ef6d/image-20230802143351803.png" class="" title="image-20230802143351803"><img src="/post/2095ef6d/image-20230802161504786.png" class="" title="image-20230802161504786"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">功能实现： 点击窗口上的按钮, 关闭窗口</span><br><span class="line">功能分析:</span><br><span class="line">- 按钮: 信号发出者          -&gt; QPushButton 类型</span><br><span class="line">- 窗口: 信号的接收者和处理者  -&gt; QWidget 类型</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230802143600142.png" class="" title="image-20230802143600142"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 单击按钮发出的信号</span><br><span class="line">[signal] void QAbstractButton::clicked(bool checked = false)</span><br><span class="line">// 关闭窗口的槽函数</span><br><span class="line">[slot] bool QWidget::close();</span><br></pre></td></tr></table></figure><p>最终连接起来</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 单击按钮关闭窗口</span><br><span class="line">connect(btn, &amp;QPushButton::clicked, this, &amp;MainWindow::close);</span><br></pre></td></tr></table></figure><p>★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★</p><blockquote><p>connect()操作一般写在<strong>窗口的构造函数中</strong>，相当于在<em><strong>事件产生之前在qt框架中先进行注册</strong></em>，这样在程序运行过程中<strong>假设产生了按钮的点击事件，框架就会调用信号接收者对象对应的槽函数了，如果信号不产生，槽函数也就一直不会被调用。</strong>可不是connect一调用就发生了</p></blockquote><p>★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★</p><h2 id="自定义信号和槽"><a href="#自定义信号和槽" class="headerlink" title="自定义信号和槽"></a>自定义信号和槽</h2><img src="/post/2095ef6d/image-20230802143851525.png" class="" title="image-20230802143851525"><h3 id="创建新的类的注意事项：：：：：：：：：："><a href="#创建新的类的注意事项：：：：：：：：：：" class="headerlink" title="创建新的类的注意事项：：：：：：：：：："></a><strong>创建新的类的注意事项</strong>：：：：：：：：：：</h3><hr><p>在Qt中，创建新的类来定义自定义信号和槽时，有以下要求：</p><p><strong>如果要继承QObject和使用Q_OBJECT宏的时候就要引入对应的文件</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;QObject&gt;</span><br></pre></td></tr></table></figure><ol><li><p><strong>继承自QObject类：</strong>或者继承QObject的子类也就是间接继承QObject<br><strong>新的类必须继承&#x2F;间接继承自QObject类，以便能够使用Qt的信号和槽机制。</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加Q_OBJECT宏</strong>：<br>在新的类的声明中，需要添加Q_OBJECT宏。<strong>这个宏告诉Qt元对象编译器（MOC）生成必要的代码，以支持信号和槽的使用。</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>声明信号和槽函数：</strong><br>在新的类中，可以声明自定义的信号和槽函数。<strong>信号函数声明在<code>signals</code>关键字下，槽函数声明在<code>public slots</code>关键字下。</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySignal</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySlot</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>实现信号和槽函数：</strong><br>在新的类的实现中，可以实现自定义的信号和槽函数。<strong>信号函数使用<code>emit</code>关键字来发出信号，槽函数用于接收信号并进行相应的处理。</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyClass::<span class="built_in">MyClass</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::mySlot</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理槽函数的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::mySignal</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">mySignal</span><span class="params">(value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="信号和槽函数的要求"><a href="#信号和槽函数的要求" class="headerlink" title="信号和槽函数的要求"></a><strong>信号和槽函数的要求</strong></h3><p>信号L:::::::::::</p><img src="/post/2095ef6d/image-20230802145005632.png" class="" title="image-20230802145005632"><p>槽函数::”:”:”::””::””:</p><img src="/post/2095ef6d/image-20230802145635876.png" class="" title="image-20230802145635876"><hr><p><strong><code>explicit</code> 是一个关键字，用于指示该构造函数是显式的，即只能显式地调用该构造函数来创建对象，不能通过隐式转换进行对象的创建。</strong></p><img src="/post/2095ef6d/image-20230802150120972.png" class="" title="image-20230802150120972"><img src="/post/2095ef6d/image-20230802150135749.png" class="" title="image-20230802150135749"><img src="/post/2095ef6d/image-20230802211915437.png" class="" title="image-20230802211915437"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">connect(const QObject *sender, &amp;QObject::signal, </span><br><span class="line">        const QObject *receiver, &amp;QObject::siganl-new);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>信号和槽是可以断开的！</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">disconnect(const QObject *sender, &amp;QObject::signal, </span><br><span class="line">        const QObject *receiver, &amp;QObject::method);</span><br></pre></td></tr></table></figure><p>信号和槽的链接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 信号和槽函数也就是第2,4个参数传递的是地址, 编译器在编译过程中会对数据的正确性进行检测</span><br><span class="line">connect(const QObject *sender, &amp;QObject::signal, </span><br><span class="line">        const QObject *receiver, &amp;QObject::method);</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230804165512586.png" class="" title="image-20230804165512586"><img src="/post/2095ef6d/image-20230804170500811.png" class="" title="image-20230804170500811"><h3 id="连接自定义的信号和槽"><a href="#连接自定义的信号和槽" class="headerlink" title="连接自定义的信号和槽"></a>连接自定义的信号和槽</h3><p>在这个表达式中，<code>void (Me::*mysignal)(QString)</code> 定义了一个函数指针类型，该函数指针可以指向 Me 类的成员函数，该成员函数的返回类型为 <code>void</code>，接受一个 <code>QString</code> 类型的参数。</p><p><code>&amp;Me::eat</code> 是一个成员函数的指针，它指向 Me 类的 <code>eat</code> 成员函数。</p><p>通过将 <code>&amp;Me::eat</code> 赋值给 <code>mysignal</code>，将 <code>mysignal</code> 指向了 Me 类的 <code>eat</code> 成员函数。</p><p>这样，<code>mysignal</code> 就可以被用作函数指针，可以通过它来调用 Me 类的 <code>eat</code> 成员函数。</p><img src="/post/2095ef6d/image-20230802152316588.png" class="" title="image-20230802152316588"><img src="/post/2095ef6d/image-20230802152322169.png" class="" title="image-20230802152322169"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 举例：</span><br><span class="line">void (类名::*func1)(QString) = &amp;Me::eat;// func1指向带参的信号</span><br><span class="line">void (Me::*func2)() = &amp;Me::hungury;// func2指向不带参的槽函数</span><br></pre></td></tr></table></figure><blockquote><p>class Me : public QObject<br>{<br> Q_OBJECT<br> &#x2F;&#x2F; Qt4中的槽函数必须这样声明, qt5中的关键字 slots 可以被省略<br>public slots:<br> void eat();<br> void eat(QString somthing);<br> signals:<br> void hungury();<br> void hungury(QString somthing);<br>};</p><p>&#x2F;&#x2F; 基于上边的类写出解决方案<br>&#x2F;&#x2F; 处理如下逻辑: 我饿了, 我要吃东西<br>&#x2F;&#x2F; 分析: 信号的发出者是我自己, 信号的接收者也是我自己<br>Me m;<br>&#x2F;&#x2F; Qt4处理方式<br>connect(&amp;m, SIGNAL(eat()), &amp;m, SLOT(hungury()));<br>connect(&amp;m, SIGNAL(eat(QString)), &amp;m, SLOT(hungury(QString)));</p><p>&#x2F;&#x2F; Qt5处理方式<br>connect(&amp;m, &amp;Me::eat, &amp;m, &amp;Me::hungury);&#x2F;&#x2F; error</p><p>因为发生了重载</p><p>&#x2F;&#x2F;两个函数指针代替<br> &#x2F;&#x2F;函数指针<br>&#x2F;&#x2F;    void (Student::*myslot)(QString)&#x3D;&amp;Student::treat_special;<br>&#x2F;&#x2F;    void (Teacher::*mysignal)(QString)&#x3D;&amp;Teacher::Teacher_is_hungery_but;<br>&#x2F;&#x2F;    connect(teacher,mysignal,student,myslot);</p></blockquote><img src="/post/2095ef6d/image-20230804102156503.png" class="" title="image-20230804102156503"><p><strong>成员函数指针是一个与类相关联的指针</strong>，它可以用来调用该类的成员函数。它不需要特定的对象实例来初始化，只需要指定成员函数的类型和类的名称即可。</p><p>按钮触发下课</p><p>下课触发老师饿了</p><p>老师饿了触发学生请吃饭</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;student.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;teacher.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//    创建对象</span></span><br><span class="line">    teacher=<span class="keyword">new</span> Teacher;</span><br><span class="line">    student=<span class="keyword">new</span> Student;</span><br><span class="line"><span class="comment">//两个函数指针代替</span></span><br><span class="line">    <span class="comment">//函数指针</span></span><br><span class="line"><span class="comment">//    void (Student::*myslot)(QString)=&amp;Student::treat_special;</span></span><br><span class="line"><span class="comment">//    void (Teacher::*mysignal)(QString)=&amp;Teacher::Teacher_is_hungery_but;</span></span><br><span class="line"><span class="comment">//    connect(teacher,mysignal,student,myslot);</span></span><br><span class="line"><span class="comment">//    --------------</span></span><br><span class="line"><span class="comment">//    原始写法，函数名的地址</span></span><br><span class="line">    <span class="built_in">connect</span>(teacher,&amp;Teacher::Teacher_is_hungery_but,student,&amp;Student::treat_special);</span><br><span class="line"><span class="comment">//创建一个按钮</span></span><br><span class="line">    QPushButton *btn=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">setFixedSize</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;老师饿了&quot;</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">move</span>(<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//#点击按钮触发下课函数</span></span><br><span class="line">     <span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;MainWindow::classover);</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的写法</span></span><br><span class="line"><span class="comment">//     connect(btn,&amp;QPushButton::clicked,teacher,&amp;Teacher::Teacher_is_hungery_but(&quot;大竹比&quot;));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    信号连接信号,点击按钮触发老师饿了</span></span><br><span class="line"><span class="comment">//     connect(btn,&amp;QPushButton::clicked,teacher,&amp;Teacher::Teacher_is_hungery);</span></span><br><span class="line"><span class="comment">//     connect(btn,&amp;QPushButton::clicked,std::bind(&amp;Teacher::Teacher_is_hungery_but,teacher,&quot;大竹比&quot;));</span></span><br><span class="line"><span class="comment">//      connect(btn, &amp;QPushButton::clicked, std::bind(&amp;Teacher::Teacher_is_hungery_but, teacher, &quot;大苏打&quot;));</span></span><br><span class="line">     <span class="built_in">classover</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//////////////////</span></span><br><span class="line">    <span class="built_in">void</span> (QToolBox::*s)(<span class="type">int</span>)=&amp;QToolBox::currentChanged;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(tb,s,<span class="keyword">this</span>,[=](<span class="type">int</span> index)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;新年好&quot;</span>&lt;&lt;index;</span><br><span class="line">    &#125;);</span><br><span class="line">        <span class="comment">////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="built_in">connect</span>(ui-&gt;closebtn,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;MainWindow::close);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下课函数触发老师饿了</span></span><br><span class="line"><span class="type">void</span> MainWindow:: <span class="built_in">classover</span>()&#123;</span><br><span class="line">    <span class="comment">//下课函数出发老师饿了的信号</span></span><br><span class="line"><span class="comment">//    emit zt-&gt;hungery();</span></span><br><span class="line">    emit teacher-&gt;<span class="built_in">Teacher_is_hungery_but</span>(<span class="string">&quot;宫保鸡丁&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;<strong>EMIT只是帮助程序员一眼看出这是在发出信号。。。。。不写也是ok的。</strong>&#x3D;&#x3D;</p><h2 id="自定义类！继承"><a href="#自定义类！继承" class="headerlink" title="自定义类！继承"></a>自定义类！继承</h2><p>先添加一个继承自 <code>QObject</code> 的类，然后将其修改为继承自&#x3D;&#x3D;&#x3D; <code>QTextEdit</code>&#x3D;&#x3D;。修改类的继承关系后，还需要在 <code>.cpp</code> 文件中做一些相应的修改。</p><p>首先，你需要将类的声明中的 <code>Qobject</code> 修改为 <code>QTextEdit</code>，如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTextEdit</span> : <span class="keyword">public</span> <span class="comment">////QTextEdit///</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyTextEdit</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来，在 <code>.cpp</code> 文件中，你需要修改构造函数的定义，将 <code>Qobject</code> 修改为 <code>QTextEdit</code>，并将函数名改为 <code>MyTextEdit::MyTextEdit(QWidget *parent)</code>，如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyTextEdit::<span class="built_in">MyTextEdit</span>(QWidget *parent)</span><br><span class="line">    : <span class="comment">//QTextEdit//(parent)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ui控件的使用"><a href="#ui控件的使用" class="headerlink" title="ui控件的使用"></a>ui控件的使用</h2><img src="/post/2095ef6d/image-20230802162620319.png" class="" title="image-20230802162620319"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;closebtn,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;MainWindow::close);</span><br></pre></td></tr></table></figure><h2 id="添加新的类"><a href="#添加新的类" class="headerlink" title="添加新的类"></a>添加新的类</h2><p>直接继承QOBject 巨好用</p><img src="/post/2095ef6d/image-20230802210658189.png" class="" title="image-20230802210658189"><h2 id="LAMBDA表达式"><a href="#LAMBDA表达式" class="headerlink" title="LAMBDA表达式"></a>LAMBDA表达式</h2><img src="/post/2095ef6d/image-20230804102405111.png" class="" title="image-20230804102405111"><img src="/post/2095ef6d/image-20230804102428896.png" class="" title="image-20230804102428896"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture](params) opt -&gt; ret &#123;body;&#125;;</span><br><span class="line">    - capture: 捕获列表</span><br><span class="line">    - params: 参数列表</span><br><span class="line">    - opt: 函数选项</span><br><span class="line">    - ret: 返回值类型</span><br><span class="line">    - body: 函数体</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230804102818196.png" class="" title="image-20230804102818196"><img src="/post/2095ef6d/image-20230804103654121.png" class="" title="image-20230804103654121"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="comment">//    []()&#123;</span></span><br><span class="line"><span class="comment">//        qDebug()&lt;&lt;&quot;你好啊草&quot;;</span></span><br><span class="line"><span class="comment">//    &#125;;</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">//    []()&#123;</span></span><br><span class="line"><span class="comment">//        qDebug()&lt;&lt;&quot;你好啊草&quot;;</span></span><br><span class="line"><span class="comment">//    &#125;();</span></span><br><span class="line">        <span class="comment">//()</span></span><br><span class="line"><span class="comment">/// /  ////   /  //相当于调用了这个函数//</span></span><br><span class="line">    <span class="type">int</span> a=[](<span class="type">int</span> a)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;你好啊&quot;</span>&lt;&lt;a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230804103725913.png" class="" title="image-20230804103725913"><blockquote><p>就是说如果[&#x3D;]</p><p>把外部变量都捕获了，但只是可读的状态。</p><p>可以opt加上mutable，是可以修改了，但是修改的是拷贝过来的副本</p><p>而[&amp;]</p><p>也是把外部所有的变量以引用的形式拷贝过来，但是可以修改，因为操作的是内存地址</p><p>[this]指代表我们只能访问我们类内的成员变量</p><p>[&#x3D;]&#x2F;[&amp;]，代表我们可以访问匿名函数体以外的所有外部变量，相当于是[this]的超集</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    []()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;你好啊草&quot;</span>;</span><br><span class="line">    &#125;();</span><br><span class="line">    <span class="type">int</span> a=[](<span class="type">int</span> a)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;你好啊&quot;</span>&lt;&lt;a;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [&amp;]()&#123;</span><br><span class="line">        b=<span class="number">200</span>;</span><br><span class="line">    &#125;();</span><br><span class="line"></span><br><span class="line">    [=]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">        b=<span class="number">300</span>;</span><br><span class="line">    &#125;();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;你好啊&quot;</span>&lt;&lt;b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, std::<span class="built_in">bind</span>(&amp;Teacher::Teacher_is_hungery_but, teacher, <span class="string">&quot;大苏打&quot;</span>));</span><br><span class="line"><span class="comment">////////////////////////////////////</span></span><br><span class="line"><span class="built_in">connect</span>(btn, &amp;QPushButton::clicked,teacher,[=]()&#123;</span><br><span class="line">   emit teacher-&gt;<span class="built_in">Teacher_is_hungery_but</span>(<span class="string">&quot;意大dasdadasdad利面&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="QTIMER"><a href="#QTIMER" class="headerlink" title="QTIMER"></a>QTIMER</h2><img src="/post/2095ef6d/image-20230804140750932.png" class="" title="image-20230804140750932"><blockquote><h5 id="启动器在启动的同时需要指定对应的时间间隔"><a href="#启动器在启动的同时需要指定对应的时间间隔" class="headerlink" title="启动器在启动的同时需要指定对应的时间间隔."></a>启动器在启动的同时需要指定对应的时间间隔.</h5></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 如果指定了父对象, 创建的堆内存可以自动析构</span></span><br><span class="line">QTimer::<span class="built_in">QTimer</span>(QObject *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置定时器时间间隔为 msec 毫秒</span></span><br><span class="line"><span class="comment">// 默认值是0，一旦窗口系统事件队列中的所有事件都已经被处理完，一个时间间隔为0的QTimer就会触发</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::setInterval</span><span class="params">(<span class="type">int</span> msec)</span></span>;</span><br><span class="line"><span class="comment">// 获取定时器的时间间隔, 返回值单位: 毫秒</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTimer::interval</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定的时间间隔启动或者重启定时器, 需要调用 setInterval() 设置时间间隔</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QTimer::start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动或重新启动定时器，超时间隔为msec毫秒。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QTimer::start</span><span class="params">(<span class="type">int</span> msec)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止定时器。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QTimer::stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置定时器精度</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数: </span></span><br><span class="line"><span class="comment">    - Qt::PreciseTimer -&gt; 精确的精度, 毫秒级</span></span><br><span class="line"><span class="comment">    - Qt::CoarseTimer  -&gt; 粗糙的精度, 和1毫秒的误差在5%的范围内, 默认精度</span></span><br><span class="line"><span class="comment">    - Qt::VeryCoarseTimer -&gt; 非常粗糙的精度, 精度在1秒左右</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::setTimerType</span><span class="params">(Qt::TimerType atype)</span></span>;</span><br><span class="line"><span class="function">Qt::TimerType <span class="title">QTimer::timerType</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">// 获取当前定时器的精度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果定时器正在运行，返回true; 否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTimer::isActive</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断定时器是否只触发一次</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTimer::isSingleShot</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置定时器是否只触发一次, 参数为true定时器只触发一次, 为false定时器重复触发, 默认为false</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::setSingleShot</span><span class="params">(<span class="type">bool</span> singleShot)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230804173619288.png" class="" title="image-20230804173619288"><blockquote><ol><li><h5 id="首先要创建定时器"><a href="#首先要创建定时器" class="headerlink" title="首先要创建定时器"></a>首先要创建定时器</h5></li><li><h5 id="设置好时间间隔-这是必要的"><a href="#设置好时间间隔-这是必要的" class="headerlink" title="设置好时间间隔,这是必要的"></a>设置好时间间隔,这是必要的</h5></li><li><p>其次可以设置无关紧要的定时器类型</p></li><li><p>有两个状态is</p></li><li><p>有个静态函数，返回值为void,可以搞一个几秒钟发射信号给谁，谁在做出具体的行为</p></li><li><img src="/post/2095ef6d/image-20230804165526274.png" class="" title="image-20230804165526274"></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//创建定时器对象，默认是粗糙的定时器</span></span><br><span class="line">    <span class="function">QTimer <span class="title">timer</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="comment">//    设置定时器的类型</span></span><br><span class="line">    timer.<span class="built_in">setTimerType</span>(Qt::PreciseTimer);</span><br><span class="line">    timer.<span class="built_in">start</span>(<span class="number">3000</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;timer.<span class="built_in">isActive</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;timer.<span class="built_in">isSingleShot</span>();</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;closebtn,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;MainWindow::close);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;timer.<span class="built_in">timerType</span>();</span><br><span class="line">    <span class="comment">//静态函数,返回为void，设置有几秒发射一次信号,谁来接受，以及行为</span></span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(<span class="number">3000</span>,<span class="keyword">this</span>,&amp;MainWindow::close);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个</span></span><br><span class="line"> <span class="comment">///////////////////////////////</span></span><br><span class="line">    <span class="built_in">connect</span>(&amp;timer,&amp;QTimer::timeout,<span class="keyword">this</span>,&amp;MainWindow::close);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h5 id="周期性定时器"><a href="#周期性定时器" class="headerlink" title="周期性定时器"></a>周期性定时器</h5></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建定时器对象</span></span><br><span class="line">QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改定时器对象的精度</span></span><br><span class="line">timer-&gt;<span class="built_in">setTimerType</span>(Qt::PreciseTimer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮 loopBtn 的点击事件</span></span><br><span class="line"><span class="comment">// 点击按钮启动或者关闭定时器, 定时器启动, 周期性得到当前时间</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;loopBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 启动定时器</span></span><br><span class="line">    <span class="keyword">if</span>(timer-&gt;<span class="built_in">isActive</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        timer-&gt;<span class="built_in">stop</span>();  <span class="comment">// 关闭定时器</span></span><br><span class="line">        ui-&gt;loopBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;loopBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;关闭&quot;</span>);</span><br><span class="line">        timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>); <span class="comment">// 1000ms == 1s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, [=]()</span><br><span class="line">&#123;</span><br><span class="line">    QTime tm = QTime::<span class="built_in">currentTime</span>();</span><br><span class="line">    <span class="comment">// 格式化当前得到的系统时间</span></span><br><span class="line">    QString tmstr = tm.<span class="built_in">toString</span>(<span class="string">&quot;hh:mm:ss.zzz&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置要显示的时间</span></span><br><span class="line">    ui-&gt;curTime-&gt;<span class="built_in">setText</span>(tmstr);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><h5 id="一次性定时器"><a href="#一次性定时器" class="headerlink" title="一次性定时器"></a>一次性定时器</h5></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点击按钮 onceBtn 只发射一次信号</span></span><br><span class="line"><span class="comment">// 点击按钮一次, 发射一个信号, 得到某一个时间点的时间</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;onceBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 获取2s以后的系统时间, 不创建定时器对象, 直接使用类的静态方法</span></span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(<span class="number">2000</span>, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        QTime tm = QTime::<span class="built_in">currentTime</span>();</span><br><span class="line">        <span class="comment">// 格式化当前得到的系统时间</span></span><br><span class="line">        QString tmstr = tm.<span class="built_in">toString</span>(<span class="string">&quot;hh:mm:ss.zzz&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置要显示的时间</span></span><br><span class="line">        ui-&gt;onceTime-&gt;<span class="built_in">setText</span>(tmstr);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="QWIDGET-1"><a href="#QWIDGET-1" class="headerlink" title="QWIDGET"></a>QWIDGET</h2><img src="/post/2095ef6d/image-20230805083036843.png" class="" title="image-20230805083036843"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>,&amp;MainWindow::windowIconChanged,<span class="keyword">this</span>,[=](<span class="type">const</span> QIcon &amp;icon)&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;窗口的图标被修改了&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>,&amp;QMainWindow::windowTitleChanged,<span class="keyword">this</span>,[=](<span class="type">const</span> QString &amp;title)&#123;</span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;窗口的标题被修改了&quot;</span>&lt;&lt;title;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setContextMenuPolicy</span>(Qt::CustomContextMenu);</span><br><span class="line"><span class="comment">//设置菜单策略</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>,&amp;QMainWindow::customContextMenuRequested,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">    QMenu a;</span><br><span class="line">    a.<span class="built_in">addAction</span>(<span class="string">&quot;茄子&quot;</span>);</span><br><span class="line">    a.<span class="built_in">addAction</span>(<span class="string">&quot;西红花是&quot;</span>);</span><br><span class="line">    a.<span class="built_in">addAction</span>(<span class="string">&quot;牛马&quot;</span>);</span><br><span class="line">    a.<span class="built_in">addAction</span>(<span class="string">&quot;Odasd&quot;</span>);</span><br><span class="line">    a.<span class="built_in">exec</span>(QCursor::<span class="built_in">pos</span>());</span><br><span class="line">    <span class="comment">//显示在当前光标所在的一个全局坐标。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><h4 id="设置父对象"><a href="#设置父对象" class="headerlink" title="设置父对象"></a>设置父对象</h4></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QWidget::<span class="built_in">QWidget</span>(QWidget *parent = <span class="literal">nullptr</span>, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 给当前窗口设置父对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setParent</span><span class="params">(QWidget *parent)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setParent</span><span class="params">(QWidget *parent, Qt::WindowFlags f)</span></span>;</span><br><span class="line"><span class="comment">//Qt::WindowFlags f 一般不用</span></span><br><span class="line"><span class="comment">// 获取当前窗口的父对象, 没有父对象返回 nullptr</span></span><br><span class="line"><span class="comment">/////////////////////////////////</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QWidget::parentWidget</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>setparent,<strong>parentwidget</strong></p><blockquote><h4 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h4></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------- 窗口位置 -------------</span></span><br><span class="line"><span class="comment">// 得到相对于当前窗口父窗口的几何信息, 边框也被计算在内</span></span><br><span class="line"><span class="function">QRect <span class="title">QWidget::frameGeometry</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到相对于当前窗口父窗口的几何信息, 不包括边框</span></span><br><span class="line"><span class="function"><span class="type">const</span> QRect &amp;<span class="title">geometry</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">frameGeometry</span>()返回的是包括窗口边框的完整几何信息，而<span class="built_in">geometry</span>()返回的是不包括窗口边框的几何信息。</span><br><span class="line">    都是相对于父窗口</span><br><span class="line"><span class="comment">// 设置当前窗口的几何信息(位置和尺寸信息), 不包括边框</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGeometry</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGeometry</span><span class="params">(<span class="type">const</span> QRect &amp;)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 移动窗口, 重新设置窗口的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">const</span> QPoint &amp;)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>当指定了父亲，show之后被内嵌在父亲里面</strong></p><p><strong>不指定父亲show，就会独立显示</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSize&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRect&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QWidget *widget=<span class="keyword">new</span> QWidget;</span><br><span class="line">    widget-&gt;<span class="built_in">show</span>();</span><br><span class="line">    widget-&gt;<span class="built_in">frameSize</span>();</span><br><span class="line"><span class="comment">//    qDebug()&lt;&lt;widget-&gt;parentWidget();</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;widget-&gt;<span class="built_in">frameSize</span>();</span><br><span class="line"><span class="comment">//    qDebug()&lt;&lt;this-&gt;frameSize();</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;widget-&gt;<span class="built_in">geometry</span>();</span><br><span class="line">    widget-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;你好啊&quot;</span>);</span><br><span class="line">    widget-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>,<span class="number">46</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;widget-&gt;<span class="built_in">geometry</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">QSize <span class="title">a</span><span class="params">(<span class="number">250</span>,<span class="number">250</span>)</span></span>;</span><br><span class="line">    <span class="function">QRect <span class="title">b</span><span class="params">(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line">    widget-&gt;<span class="built_in">setGeometry</span>(b);</span><br><span class="line"><span class="comment">//    widget-&gt;showFullScreen();</span></span><br><span class="line"><span class="comment">//    this-&gt;showFullScreen();</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">showMaximized</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line">    widget-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line">   <span class="keyword">this</span>-&gt;<span class="built_in">setWindowIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;C:/Users/许闰博/Desktop/新建文件夹/1.png&quot;</span>));</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="keyword">this</span>-&gt;<span class="built_in">windowIcon</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h4 id="窗口尺寸"><a href="#窗口尺寸" class="headerlink" title="窗口尺寸"></a>窗口尺寸</h4></blockquote><p>设置的尺寸不包含上面那个</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------- 窗口尺寸 -------------</span></span><br><span class="line"><span class="comment">// 获取当前窗口的尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="comment">// 重新设置窗口的尺寸信息</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">const</span> QSize &amp;)</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最大尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">maximumSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最小尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">minimumSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口固定的尺寸信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedSize</span><span class="params">(<span class="type">const</span> QSize &amp;s)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedSize</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口的最大尺寸信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaximumSize</span><span class="params">(<span class="type">const</span> QSize &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaximumSize</span><span class="params">(<span class="type">int</span> maxw, <span class="type">int</span> maxh)</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口的最小尺寸信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMinimumSize</span><span class="params">(<span class="type">const</span> QSize &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMinimumSize</span><span class="params">(<span class="type">int</span> minw, <span class="type">int</span> minh)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前窗口的高度    </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最小高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumHeight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最大高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximumHeight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置固定的高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedHeight</span><span class="params">(<span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置最大高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaximumHeight</span><span class="params">(<span class="type">int</span> maxh)</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置最小高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMinimumHeight</span><span class="params">(<span class="type">int</span> minh)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前窗口的宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">width</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最小宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumWidth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最大宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximumWidth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置固定宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedWidth</span><span class="params">(<span class="type">int</span> w)</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置最大宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaximumWidth</span><span class="params">(<span class="type">int</span> maxw)</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置最小宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMinimumWidth</span><span class="params">(<span class="type">int</span> minw)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><h4 id="窗口标题和图标icon"><a href="#窗口标题和图标icon" class="headerlink" title="窗口标题和图标icon"></a>窗口标题和图标icon</h4></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------- 窗口图标 -------------</span></span><br><span class="line"><span class="comment">// 得到当前窗口的图标</span></span><br><span class="line"><span class="function">QIcon <span class="title">windowIcon</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 构造图标对象, 参数为图片的路径</span></span><br><span class="line">QIcon::<span class="built_in">QIcon</span>(<span class="type">const</span> QString &amp;fileName);</span><br><span class="line"><span class="comment">// 设置当前窗口的图标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWindowIcon</span><span class="params">(<span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------- 窗口标题 -------------</span></span><br><span class="line"><span class="comment">// 得到当前窗口的标题</span></span><br><span class="line"><span class="function">QString <span class="title">windowTitle</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口的标题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWindowTitle</span><span class="params">(<span class="type">const</span> QString &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">现设置发射策略</span><br><span class="line"> QWidget::<span class="built_in">setContextMenuPolicy</span>(Qt::ContextMenuPolicy policy);</span><br><span class="line"> 窗口的右键菜单策略 <span class="built_in">contextMenuPolicy</span>() 参数设置为 Qt::CustomContextMenu, 按下鼠标右键发射该信号</span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QWidget::customContextMenuRequested</span><span class="params">(<span class="type">const</span> QPoint &amp;pos)</span></span>;</span><br><span class="line"></span><br><span class="line">pos得到的是相对父窗口的坐标</span><br><span class="line">    QCursor::<span class="built_in">pos</span>()是相对于屏幕的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口图标发生变化, 发射此信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QWidget::windowIconChanged</span><span class="params">(<span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"><span class="comment">// 窗口标题发生变化, 发射此信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QWidget::windowTitleChanged</span><span class="params">(<span class="type">const</span> QString &amp;title)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h4 id="槽函数"><a href="#槽函数" class="headerlink" title="槽函数"></a>槽函数</h4></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------- 窗口显示 -------------</span></span><br><span class="line"><span class="comment">// 关闭当前窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">bool</span> <span class="title">QWidget::close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏当前窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::hide</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示当前创建以及其子窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::show</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全屏显示当前窗口, 只对windows有效</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::showFullScreen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口最大化显示, 只对windows有效</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::showMaximized</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 窗口最小化显示, 只对windows有效</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::showMinimized</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 将窗口回复为最大化/最小化之前的状态, 只对windows有效</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::showNormal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------- 窗口状态 -------------</span></span><br><span class="line"><span class="comment">// 判断窗口是否可用</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QWidget::isEnabled</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 非槽函数</span></span><br><span class="line"><span class="comment">// 设置窗口是否可用, 不可用窗口无法接收和处理窗口事件</span></span><br><span class="line"><span class="comment">// 参数true-&gt;可用, false-&gt;不可用</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::setEnabled</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"><span class="comment">// 设置窗口是否可用, 不可用窗口无法接收和处理窗口事件</span></span><br><span class="line"><span class="comment">// 参数true-&gt;不可用, false-&gt;可用</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::setDisabled</span><span class="params">(<span class="type">bool</span> disable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置窗口是否可见, 参数为true-&gt;可见, false-&gt;不可见</span></span><br><span class="line">对于父亲来说没用</span><br><span class="line">[slot] <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::setVisible</span><span class="params">(<span class="type">bool</span> visible)</span></span>;。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setContextMenuPolicy</span>(Qt::CustomContextMenu);</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>,&amp;QMainWindow::customContextMenuRequested,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        QMenu a;</span><br><span class="line">        a.<span class="built_in">addAction</span>(<span class="string">&quot;茄子&quot;</span>);</span><br><span class="line">        a.<span class="built_in">addAction</span>(<span class="string">&quot;西红花是&quot;</span>);</span><br><span class="line">        a.<span class="built_in">addAction</span>(<span class="string">&quot;牛马&quot;</span>);</span><br><span class="line">        a.<span class="built_in">addAction</span>(<span class="string">&quot;Odasd&quot;</span>);</span><br><span class="line">        a.<span class="built_in">exec</span>(QCursor::<span class="built_in">pos</span>());</span><br><span class="line">        <span class="comment">//显示在当前光标所在的一个全局坐标。</span></span><br><span class="line">    &#125;);详细的解释一下</span><br></pre></td></tr></table></figure><blockquote><p>首先，设置了触发策略(自定义的)</p><p><code>this-&gt;setContextMenuPolicy(Qt::CustomContextMenu)</code> <strong>设置了窗口的上下文菜单策略为自定义菜单。这意味着当用户右键单击窗口时，不会显示默认的上下文菜单，而是使用自定义的菜单。</strong></p><p>接下来，连接信号,QMainWindow::customContextMenuRequested</p><p><code>connect(this, &amp;QMainWindow::customContextMenuRequested, this, [=]() &#123; ... &#125;)</code> 用于连接 <code>customContextMenuRequested</code> 信号和一个 lambda 表达式。当用户请求上下文菜单时，即右键单击窗口时，该 lambda 表达式将被执行。</p><p>在 lambda 表达式中，首先创建了一个 <code>QMenu</code> 对象 <code>a</code>。然后，使用 <code>a.addAction(&quot;...&quot;)</code> 添加了多个动作（菜单项）。每个 <code>addAction</code> 调用都会创建一个新的 <code>QAction</code> 对象，并将其添加到菜单中。</p><p><strong>接下来，使用 <code>a.exec(QCursor::pos())</code> 显示菜单。<code>QCursor::pos()</code> 返回当前鼠标光标的全局坐标位置，这样菜单就会显示在光标所在的位置。</strong></p><p>总结起来，这段代码的作用是：当用户右键单击窗口时，显示一个自定义的上下文菜单，菜单中包含了多个动作（菜单项）。菜单显示在当前鼠标光标的位置。</p></blockquote><h2 id="QDILAG"><a href="#QDILAG" class="headerlink" title="QDILAG"></a>QDILAG</h2><img src="/post/2095ef6d/image-20230805113458609.png" class="" title="image-20230805113458609"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QDialog::<span class="built_in">QDialog</span>(QWidget *parent = <span class="literal">nullptr</span>, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模态显示窗口</span></span><br><span class="line">[<span class="keyword">virtual</span> slot] <span class="function"><span class="type">int</span> <span class="title">QDialog::exec</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏模态窗口, 并且解除模态窗口的阻塞, 将 exec() 的返回值设置为 QDialog::Accepted1</span></span><br><span class="line">[<span class="keyword">virtual</span> slot] <span class="function"><span class="type">void</span> <span class="title">QDialog::accept</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏模态窗口, 并且解除模态窗口的阻塞, 将 exec() 的返回值设置为 QDialog::Rejected0</span></span><br><span class="line">[<span class="keyword">virtual</span> slot] <span class="function"><span class="type">void</span> <span class="title">QDialog::reject</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭对话框并将其结果代码设置为r。finished()信号将发出r;</span></span><br><span class="line"><span class="comment">// 如果r是QDialog::Accepted 或 QDialog::Rejected，则还将分别发出accept()或Rejected()信号。</span></span><br><span class="line">[<span class="keyword">virtual</span> slot] <span class="function"><span class="type">void</span> <span class="title">QDialog::done</span><span class="params">(<span class="type">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QDialog::accepted</span><span class="params">()</span></span>;</span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QDialog::rejected</span><span class="params">()</span></span>;</span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QDialog::finished</span><span class="params">(<span class="type">int</span> result)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mydialog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyDialog dig;</span><br><span class="line">    <span class="built_in">connect</span>(&amp;dig,&amp;QDialog::accepted,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;accepted信号发射了&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(&amp;dig,&amp;QDialog::rejected,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;rejected信号发射了&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(&amp;dig,&amp;QDialog::finished,<span class="keyword">this</span>,[=](<span class="type">int</span> result)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;finished信号发射了，且返回了&quot;</span>&lt;&lt;result;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///////////////////////////////////////////</span></span><br><span class="line">    <span class="type">int</span> ret=dig.<span class="built_in">exec</span>();</span><br><span class="line">    <span class="comment">//会有一个返回值，如果你点击的是accept会返回1,reject是0 done是对应的参数</span></span><br><span class="line">    <span class="comment">//就是在设置被点击的时候对象.done(r)</span></span><br><span class="line">    <span class="comment">//点击accept或者reject会发射两个信号，一个是对应自己的信号，另一个是finshed信号</span></span><br><span class="line">    <span class="comment">//finshed信号会知道返回的是多少</span></span><br><span class="line">    <span class="keyword">if</span>(ret==QDialog::Accepted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;accepted clicked.....返回值为1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret==QDialog::Rejected) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Rejected clicked.....返回值为0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Done clicked.....返回值为&quot;</span>&lt;&lt;ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>void QDialog::finished(int <em>result</em>)</p><p>这个信号 <code>finished(int result)</code> 是 <code>QDialog</code> 类的一个信号。当对话框的结果代码被设置时，无论是由用户操作还是通过调用 <code>done()</code>、<code>accept()</code> 或 <code>reject()</code> 方法设置，都会发出这个信号。</p><p>需要注意的是，当使用 <code>hide()</code> 或 <code>setVisible(false)</code> 隐藏对话框时，不会发出这个信号。这也包括在对话框可见时删除对话框。</p><p>换句话说，只有在对话框的结果代码被设置时，才会发出 <code>finished(int result)</code> 信号。</p><p>这个信号可以用于在对话框关闭后执行一些特定的操作，比如处理对话框的结果、清理资源等。</p><p><strong>在 <code>connect</code> 函数中，通过指定 <code>&amp;QDialog::finished</code> 作为信号参数，告诉 Qt 连接的信号是 <code>QDialog</code> 的 <code>finished</code> 信号。</strong></p><p>当 <code>finished</code> 信号被触发时，<strong>Qt 会自动将信号的参数传递给槽函数。在这种情况下，<code>finished</code> 信号的参数是 <code>int result</code>，表示对话框的结果代码。</strong></p><p>在 lambda 表达式中，<strong>通过声明 <code>[=](int result)</code> 来接收这个参数。<code>[=]</code> 表示以值捕获的方式捕获所有外部变量，包括 <code>result</code> 参数。因此，当 <code>finished</code> 信号被触发时，<code>result</code> 参数会被传递给 lambda 表达式，你就可以在 lambda 表达式中使用它了</strong>。</p></blockquote><h3 id="QDILAG-》qmessagebox"><a href="#QDILAG-》qmessagebox" class="headerlink" title="QDILAG-》qmessagebox"></a>QDILAG-》qmessagebox</h3><p><strong>参数依次是父对象、标题、主要文本和按钮参数。</strong></p><img src="/post/2095ef6d/image-20230807133721830.png" class="" title="image-20230807133721830"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示一个模态对话框, 将参数 text 的信息展示到窗口中</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">QMessageBox::about</span><span class="params">(QWidget *parent, <span class="type">const</span> QString &amp;title, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">- parent: 对话框窗口的父窗口</span></span><br><span class="line"><span class="comment">- title: 对话框窗口的标题</span></span><br><span class="line"><span class="comment">- text: 对话框窗口中显示的提示信息</span></span><br><span class="line"><span class="comment">- buttons: 对话框窗口中显示的按钮(一个或多个)</span></span><br><span class="line"><span class="comment">- defaultButton</span></span><br><span class="line"><span class="comment">    1. defaultButton指定按下Enter键时使用的按钮。</span></span><br><span class="line"><span class="comment">    2. defaultButton必须引用在参数 buttons 中给定的按钮。</span></span><br><span class="line"><span class="comment">    3. 如果defaultButton是QMessageBox::NoButton, QMessageBox会自动选择一个合适的默认值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 显示一个信息模态对话框</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QMessageBox::StandardButton <span class="title">QMessageBox::information</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">           QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> QString &amp;text, </span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButtons buttons = Ok,</span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButton defaultButton = NoButton)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示一个错误模态对话框</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QMessageBox::StandardButton <span class="title">QMessageBox::critical</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">           QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> QString &amp;text, </span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButtons buttons = Ok,</span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButton defaultButton = NoButton)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示一个问题模态对话框</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QMessageBox::StandardButton <span class="title">QMessageBox::question</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">           QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> QString &amp;text, </span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButtons buttons = StandardButtons(Yes | No), </span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButton defaultButton = NoButton)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示一个警告模态对话框</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QMessageBox::StandardButton <span class="title">QMessageBox::warning</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">           QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> QString &amp;text, </span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButtons buttons = Ok,</span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButton defaultButton = NoButton)</span></span>;</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230807143709141.png" class="" title="image-20230807143709141"><p>不同按钮对应的枚举值，然后ifelse提示不同的信息。</p><img src="/post/2095ef6d/image-20230807143743669.png" class="" title="image-20230807143743669"><p>举例QDIALOG</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_msg_about_btn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            QMessageBox::<span class="built_in">about</span>(<span class="keyword">this</span>,<span class="string">&quot;你好&quot;</span>,<span class="string">&quot;我真的超级喜欢你啊草&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_msg_about_QTbtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            QMessageBox::<span class="built_in">aboutQt</span>(<span class="keyword">this</span>,<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_msg_critical_btn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">           QMessageBox::<span class="built_in">critical</span>(<span class="keyword">this</span>,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;这是违法行为！！！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_msg_information_btn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>,<span class="string">&quot;information&quot;</span>,<span class="string">&quot;你要噶那么&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_msg_warning_btn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>,<span class="string">&quot;warning&quot;</span>,<span class="string">&quot;吃屎是不对的!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_msg_question_btn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    int ret=QMessageBox::question(this,&quot;牛牛牛&quot;,&quot;你确定要吃屎吗？&quot;);</span></span><br><span class="line"><span class="comment">//    yes no</span></span><br><span class="line">    <span class="type">int</span> ret1=QMessageBox::<span class="built_in">question</span>(<span class="keyword">this</span>,<span class="string">&quot;question&quot;</span>,<span class="string">&quot;你确定要吃屎吗？&quot;</span>,QMessageBox::Ok|QMessageBox::No);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret1==QMessageBox::Ok)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;你可太牛了&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;你shi都不敢吃，太胆小了&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230807170048759.png" class="" title="image-20230807170048759"><hr><h3 id="QFILEDIALOG"><a href="#QFILEDIALOG" class="headerlink" title="QFILEDIALOG"></a>QFILEDIALOG</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通用参数:</span></span><br><span class="line"><span class="comment">  - parent: 当前对话框窗口的父对象也就是父窗口</span></span><br><span class="line"><span class="comment">  - caption: 当前对话框窗口的标题</span></span><br><span class="line"><span class="comment">  - dir: 当前对话框窗口打开的默认目录 e:\\dsad\\das</span></span><br><span class="line"><span class="comment">  - options: 当前对话框窗口的一些可选项,枚举类型, 一般不需要进行设置, 使用默认值即可</span></span><br><span class="line"><span class="comment">  - filter: 过滤器, 在对话框中只显示满足条件的文件, 可以指定多个过滤器, 使用 ;; 分隔</span></span><br><span class="line"><span class="comment">    - 样式举例: </span></span><br><span class="line"><span class="comment">- Images (*.png *.jpg)</span></span><br><span class="line"><span class="comment">- Images (*.png *.jpg);;Text files (*.txt)</span></span><br><span class="line"><span class="comment">  - selectedFilter: 如果指定了多个过滤器, 通过该参数指定默认使用哪一个, 不指定默认使用第一个过滤器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 打开一个目录, 得到这个目录的绝对路径</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QFileDialog::getExistingDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                  QWidget *parent = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;caption = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;dir = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  QFileDialog::Options options = ShowDirsOnly)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开一个文件, 得到这个文件的绝对路径</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QFileDialog::getOpenFileName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">              QWidget *parent = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> QString &amp;caption = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;dir = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;filter = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  QString *selectedFilter = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  QFileDialog::Options options = Options())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开多个文件, 得到这多个文件的绝对路径</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QStringList <span class="title">QFileDialog::getOpenFileNames</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">              QWidget *parent = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;caption = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;dir = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;filter = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  QString *selectedFilter = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  QFileDialog::Options options = Options())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开一个目录, 使用这个目录来保存指定的文件</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QFileDialog::getSaveFileName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      QWidget *parent = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;caption = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;dir = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;filter = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  QString *selectedFilter = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  QFileDialog::Options options = Options())</span></span>;</span><br><span class="line">不能帮我们弄创建一个新的文件，需要用open，打开然后w</span><br></pre></td></tr></table></figure><p>自己的项目QFILEDIALOG</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFileDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//tr()的介绍</span></span><br><span class="line"><span class="comment">//    如果你的应用程序需要支持多种语言，并且你希望在不同的语言环境下显示不同的翻译，</span></span><br><span class="line"><span class="comment">//    那么你需要在应用程序中配置相应的翻译文件，并使用 tr() 函数对需要翻译的文本进行标记。</span></span><br><span class="line"><span class="comment">//    这样，Qt会根据当前的语言环境自动加载相应的翻译文件，并将文本翻译为适当的语言。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    单个过滤器tr(选择名(*.h *.c))       tr(&quot;yuan(*.c *.h)&quot;)</span></span><br><span class="line"><span class="comment">//    多个过滤器   tr(&quot;yuan(*.c *.h);;ok(*.txt)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    默认会选择第一种过滤器，如果要想默认选择某个过滤器的话，就要传入对应的字符串指针</span></span><br><span class="line"><span class="comment">//    QString *se1ectedFilter = nullptr,</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    QString filename= QFileDialog::<span class="built_in">getExistingDirectory</span>(<span class="keyword">this</span>,<span class="string">&quot;选撒大苏打&quot;</span>,<span class="string">&quot;E:/QTPROJECT&quot;</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>,<span class="string">&quot;提示&quot;</span>,<span class="string">&quot;你选择的路径是\n&quot;</span>+filename);</span><br><span class="line">    <span class="comment">//找的是目录</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_2_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="function">QString <span class="title">a</span><span class="params">(<span class="string">&quot;ok(*.txt)&quot;</span>)</span></span>;</span><br><span class="line">     QString filename= QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>,<span class="string">&quot;选择文件&quot;</span>,<span class="string">&quot;E:/QTPROJECT&quot;</span>,<span class="string">&quot;yuan(*.txt);;ok(*.c *.h)&quot;</span>,&amp;a);</span><br><span class="line">     QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>,<span class="string">&quot;提示&quot;</span>,<span class="string">&quot;你选择的路径是\n&quot;</span>+filename);</span><br><span class="line">     <span class="comment">//找的是文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_3_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QString <span class="title">a</span><span class="params">(<span class="string">&quot;ok(*.txt)&quot;</span>)</span></span>;</span><br><span class="line">    QStringList filename=QFileDialog::<span class="built_in">getOpenFileNames</span>(<span class="keyword">this</span>,<span class="string">&quot;路径&quot;</span>,<span class="string">&quot;E:/QTPROJECT&quot;</span>,<span class="string">&quot;源件(*.c *.h)&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;filename.<span class="built_in">length</span>();i++) &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>,<span class="string">&quot;提示&quot;</span>,<span class="string">&quot;你选择的路径是\n&quot;</span>+filename[i]+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找的是多个文件</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;filename.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="QFONTDIALOG"><a href="#QFONTDIALOG" class="headerlink" title="QFONTDIALOG!!!"></a>QFONTDIALOG!!!</h3><p>先引入Qfont</p><blockquote><p><strong>在 <code>QFont</code> 构造函数中，中间两个参数 <code>pointSize</code> 和 <code>weight</code> 的范围如下：</strong></p><ul><li><strong><code>pointSize</code>：表示字体的大小，是一个整数参数。它的范围是正整数，表示字体的点大小。例如，<code>pointSize</code> 为 18 表示字体大小为 18 点。</strong></li><li><strong><code>weight</code>：表示字体的粗细程度，是一个整数参数。它的范围是 <code>QFont::Thin</code>（0）到 <code>QFont::Black</code>（99）之间的整数值。其中，<code>QFont::Thin</code> 表示最细的字体，<code>QFont::Black</code> 表示最粗的字体。Qt 提供了一些预定义的 <code>QFont::Weight</code> 值，如 <code>QFont::Light</code>、<code>QFont::Normal</code>、<code>QFont::Bold</code> 等，它们对应着不同的粗细程度。</strong></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFont&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function">QFont <span class="title">f</span><span class="params">(<span class="string">&quot;你好啊&quot;</span>,<span class="number">38</span>,QFont::Black,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setFont</span>(f);</span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">  QFont::<span class="built_in">QFont</span>();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  参数:</span></span><br><span class="line"><span class="comment">    - family: 本地字库中的字体名, 通过 office 等文件软件可以查看</span></span><br><span class="line"><span class="comment">    - pointSize: 字体的字号</span></span><br><span class="line"><span class="comment">    - weight: 字体的粗细, 有效范围为 0 ~ 99</span></span><br><span class="line"><span class="comment">    - italic: 字体是否倾斜显示, 默认不倾斜</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  QFont::<span class="built_in">QFont</span>(<span class="type">const</span> QString &amp;family, <span class="type">int</span> pointSize = <span class="number">-1</span>, <span class="type">int</span> weight = <span class="number">-1</span>, <span class="type">bool</span> italic = <span class="literal">false</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置字体</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setFamily</span><span class="params">(<span class="type">const</span> QString &amp;family)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据字号设置字体大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setPointSize</span><span class="params">(<span class="type">int</span> pointSize)</span></span>;</span><br><span class="line">  <span class="comment">// 根据像素设置字体大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setPixelSize</span><span class="params">(<span class="type">int</span> pixelSize)</span></span>;</span><br><span class="line">  <span class="comment">// 设置字体的粗细程度, 有效范围: 0 ~ 99</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setWeight</span><span class="params">(<span class="type">int</span> weight)</span></span>;</span><br><span class="line">  <span class="comment">// 设置字体是否加粗显示</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setBold</span><span class="params">(<span class="type">bool</span> enable)</span></span>;</span><br><span class="line">  <span class="comment">// 设置字体是否要倾斜显示</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setItalic</span><span class="params">(<span class="type">bool</span> enable)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取字体相关属性(一般规律: 去掉设置函数的 set 就是获取相关属性对应的函数名)</span></span><br><span class="line">  <span class="function">QString <span class="title">QFont::family</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">QFont::italic</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">QFont::pixelSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">QFont::pointSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">QFont::bold</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">QFont::weight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230807172557719.png" class="" title="image-20230807172557719"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否获得了有效字体信息, 指定一个布尔类型变量地址</span></span><br><span class="line"><span class="comment">  ,如果我们点击了选择了字体就是true，点击了cancle就是false</span></span><br><span class="line"><span class="comment">  - initial: 字体对话框中默认选中并显示该字体信息, 用于对话框的初始化</span></span><br><span class="line"><span class="comment">  - parent: 字体对话框窗口的父对象</span></span><br><span class="line"><span class="comment">  - title: 字体对话框的窗口标题</span></span><br><span class="line"><span class="comment">  - options: 字体对话框选项, 使用默认属性即可, 一般不设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  [<span class="type">static</span>] <span class="function">QFont <span class="title">QFontDialog::getFont</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">bool</span> *ok, <span class="type">const</span> QFont &amp;initial, </span></span></span><br><span class="line"><span class="params"><span class="function">QWidget *parent = <span class="literal">nullptr</span>, <span class="type">const</span> QString &amp;title = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">QFontDialog::FontDialogOptions options = FontDialogOptions())</span></span>;</span><br><span class="line">  </span><br><span class="line">  [<span class="type">static</span>] <span class="function">QFont <span class="title">QFontDialog::getFont</span><span class="params">(<span class="type">bool</span> *ok, QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230807172626468.png" class="" title="image-20230807172626468"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">    QFont f=QFontDialog::<span class="built_in">getFont</span>(&amp;ok,<span class="built_in">QFont</span>(<span class="string">&quot;微软雅黑&quot;</span>,<span class="number">30</span>,<span class="number">70</span>),<span class="keyword">this</span>,<span class="string">&quot;设置字体&quot;</span>);</span><br><span class="line"><span class="comment">//    QFont f=QFontDialog::getFont(NULL);</span></span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setFont</span>(f);</span><br><span class="line">&#125;</span><br><span class="line">不指定的话也能实现设置字体。</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230807173444450.png" class="" title="image-20230807173444450"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">    QFont f=QFontDialog::<span class="built_in">getFont</span>(&amp;ok,<span class="built_in">QFont</span>(<span class="string">&quot;微软雅黑&quot;</span>,<span class="number">30</span>,<span class="number">70</span>),<span class="keyword">this</span>,<span class="string">&quot;设置字体&quot;</span>);</span><br><span class="line"><span class="comment">//    QFont f=QFontDialog::getFont(NULL);</span></span><br><span class="line">    QApplication::<span class="built_in">setFont</span>(f);</span><br><span class="line">    <span class="comment">//设置给当前应用程序的所有窗口的字体都一样</span></span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setFont</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QCOLORDIALOG"><a href="#QCOLORDIALOG" class="headerlink" title="QCOLORDIALOG"></a>QCOLORDIALOG</h3><p>QCOLOR</p><img src="/post/2095ef6d/image-20230807174210005.png" class="" title="image-20230807174210005"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QColor::<span class="built_in">QColor</span>(Qt::GlobalColor color);</span><br><span class="line">QColor::<span class="built_in">QColor</span>(<span class="type">int</span> r, <span class="type">int</span> g, <span class="type">int</span> b, <span class="type">int</span> a = ...);</span><br><span class="line">QColor::<span class="built_in">QColor</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数设置 red, green, blue, alpha, 取值范围都是 0-255</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::setRed</span><span class="params">(<span class="type">int</span> red)</span></span>;<span class="comment">// 红色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::setGreen</span><span class="params">(<span class="type">int</span> green)</span></span>;<span class="comment">// 绿色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::setBlue</span><span class="params">(<span class="type">int</span> blue)</span></span>;<span class="comment">// 蓝色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::setAlpha</span><span class="params">(<span class="type">int</span> alpha)</span></span>;<span class="comment">// 透明度, 默认不透明(255)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::setRgb</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> g, <span class="type">int</span> b, <span class="type">int</span> a = <span class="number">255</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QColor::red</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QColor::green</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QColor::blue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QColor::alpha</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">//都是传出参数，把参数作为返回值.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::getRgb</span><span class="params">(<span class="type">int</span> *r, <span class="type">int</span> *g, <span class="type">int</span> *b, <span class="type">int</span> *a = <span class="literal">nullptr</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用方法，就相当于之前函数有一个指针类型的参数我们要传入一个地址进去，的逆过程！！！能够的包原来的变量，</span><br><span class="line">    原来是<span class="type">int</span>....-&gt;<span class="type">int</span>*</span><br><span class="line">    现在是<span class="type">int</span>*-&gt;<span class="type">int</span></span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function">QColor <span class="title">color</span><span class="params">(<span class="number">234</span>,<span class="number">22</span>,<span class="number">13</span>,<span class="number">150</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">int</span> g;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    color.<span class="built_in">getRgb</span>(&amp;r,&amp;g,&amp;b,&amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;r&lt;&lt;g&lt;&lt;b&lt;&lt;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    234 22 13 150</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>qcolordialog</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 弹出颜色选择对话框, 并返回选中的颜色信息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">    - initial: 对话框中默认选中的颜色, 用于窗口初始化</span></span><br><span class="line"><span class="comment">    - parent: 给对话框窗口指定父对象</span></span><br><span class="line"><span class="comment">    - title: 对话框窗口的标题</span></span><br><span class="line"><span class="comment">    - options: 颜色对话框窗口选项, 使用默认属性即可, 一般不需要设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  [<span class="type">static</span>] <span class="function">QColor <span class="title">QColorDialog::getColor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> QColor &amp;initial = Qt::white, </span></span></span><br><span class="line"><span class="params"><span class="function">QWidget *parent = <span class="literal">nullptr</span>, <span class="type">const</span> QString &amp;title = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">QColorDialog::ColorDialogOptions options = ColorDialogOptions())</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QColor&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QColorDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function">QColor <span class="title">color</span><span class="params">(<span class="number">234</span>,<span class="number">22</span>,<span class="number">13</span>,<span class="number">150</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">int</span> g;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    color.<span class="built_in">getRgb</span>(&amp;r,&amp;g,&amp;b,&amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;r&lt;&lt;g&lt;&lt;b&lt;&lt;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    234 22 13 150</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     QColor c= QColorDialog::<span class="built_in">getColor</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="static-QColor-qcolor-53-200-255-254"><a href="#static-QColor-qcolor-53-200-255-254" class="headerlink" title="static QColor qcolor(53,200,255,254);"></a>static QColor qcolor(53,200,255,254);</h3></blockquote><p>这样就是全局变量！！！</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString color_str=<span class="built_in">QString</span>(<span class="string">&quot;color:%1&quot;</span>).<span class="built_in">arg</span>(color.<span class="built_in">name</span>());</span><br><span class="line">ui-&gt;groupBox-&gt;<span class="built_in">setStyleSheet</span>(c);</span><br><span class="line">color.name方法得到颜色对应的<span class="number">16</span>进制数据，然后设置css属性.</span><br></pre></td></tr></table></figure><h3 id="qinputdialog"><a href="#qinputdialog" class="headerlink" title="qinputdialog"></a>qinputdialog</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到一个可以输入浮点数的对话框窗口, 返回对话框窗口中输入的浮点数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - parent: 对话框窗口的父窗口</span></span><br><span class="line"><span class="comment">  - title: 对话框窗口显示的标题信息</span></span><br><span class="line"><span class="comment">  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)</span></span><br><span class="line"><span class="comment">  - value: 对话框窗口中显示的浮点值, 默认为 0</span></span><br><span class="line"><span class="comment">  - min: 对话框窗口支持显示的最小数值</span></span><br><span class="line"><span class="comment">  - max: 对话框窗口支持显示的最大数值</span></span><br><span class="line"><span class="comment">  - decimals: 浮点数的精度, 默认保留小数点以后1位</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数</span></span><br><span class="line"><span class="comment">  - flags: 对话框窗口的窗口属性, 使用默认值即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">double</span> <span class="title">QInputDialog::getDouble</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString &amp;label, <span class="type">double</span> value = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> min = <span class="number">-2147483647</span>, <span class="type">double</span> max = <span class="number">2147483647</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> decimals = <span class="number">1</span>, <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::WindowFlags flags = Qt::WindowFlags())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个可以输入整形数的对话框窗口, 返回对话框窗口中输入的整形数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - parent: 对话框窗口的父窗口</span></span><br><span class="line"><span class="comment">  - title: 对话框窗口显示的标题信息</span></span><br><span class="line"><span class="comment">  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)</span></span><br><span class="line"><span class="comment">  - value: 对话框窗口中显示的整形值, 默认为 0</span></span><br><span class="line"><span class="comment">  - min: 对话框窗口支持显示的最小数值</span></span><br><span class="line"><span class="comment">  - max: 对话框窗口支持显示的最大数值</span></span><br><span class="line"><span class="comment">  - step: 步长, 通过对话框提供的按钮调节数值每次增长/递减的量</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数</span></span><br><span class="line"><span class="comment">  - flags: 对话框窗口的窗口属性, 使用默认值即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">int</span> <span class="title">QInputDialog::getInt</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString &amp;label, <span class="type">int</span> value = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> min = <span class="number">-2147483647</span>, <span class="type">int</span> max = <span class="number">2147483647</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> step = <span class="number">1</span>, <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::WindowFlags flags = Qt::WindowFlags())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个带下来菜单的对话框窗口, 返回选择的菜单项上边的文本信息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - parent: 对话框窗口的父窗口</span></span><br><span class="line"><span class="comment">  - title: 对话框窗口显示的标题信息</span></span><br><span class="line"><span class="comment">  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)</span></span><br><span class="line"><span class="comment">  - items: 字符串列表, 用于初始化窗口中的下拉菜单, 每个字符串对应一个菜单项</span></span><br><span class="line"><span class="comment">  - current: 通过菜单项的索引指定显示下拉菜单中的哪个菜单项, 默认显示第一个(编号为0)</span></span><br><span class="line"><span class="comment">  - editable: 设置菜单项上的文本信息是否可以进行编辑, 默认为true, 即可以编辑</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数</span></span><br><span class="line"><span class="comment">  - flags: 对话框窗口的窗口属性, 使用默认值即可</span></span><br><span class="line"><span class="comment">  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串</span></span><br><span class="line"><span class="comment">    - 如果有特殊需求, 可以参数帮助文档进行相关设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QInputDialog::getItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString &amp;label, <span class="type">const</span> QStringList &amp;items, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> current = <span class="number">0</span>, <span class="type">bool</span> editable = <span class="literal">true</span>, <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::WindowFlags flags = Qt::WindowFlags(), </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::InputMethodHints inputMethodHints = Qt::ImhNone)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个可以输入多行数据的对话框窗口, 返回用户在窗口中输入的文本信息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - parent: 对话框窗口的父窗口</span></span><br><span class="line"><span class="comment">  - title: 对话框窗口显示的标题信息</span></span><br><span class="line"><span class="comment">  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)</span></span><br><span class="line"><span class="comment">  - text: 指定显示到多行输入框中的文本信息, 默认是空字符串</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数</span></span><br><span class="line"><span class="comment">  - flags: 对话框窗口的窗口属性, 使用默认值即可</span></span><br><span class="line"><span class="comment">  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串</span></span><br><span class="line"><span class="comment">    - 如果有特殊需求, 可以参数帮助文档进行相关设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QInputDialog::getMultiLineText</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    QWidget *parent, <span class="type">const</span> QString &amp;title, <span class="type">const</span> QString &amp;label, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString &amp;text = QString(), <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::WindowFlags flags = Qt::WindowFlags(), </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::InputMethodHints inputMethodHints = Qt::ImhNone)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个可以输入单行信息的对话框窗口, 返回用户在窗口中输入的文本信息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - parent: 对话框窗口的父窗口 </span></span><br><span class="line"><span class="comment">  - title: 对话框窗口显示的标题信息</span></span><br><span class="line"><span class="comment">  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)</span></span><br><span class="line"><span class="comment">  - mode: 指定单行编辑框中数据的反馈模式, 是一个 QLineEdit::EchoMode 类型的枚举值</span></span><br><span class="line"><span class="comment">    - QLineEdit::Normal: 显示输入的字符。这是默认值</span></span><br><span class="line"><span class="comment">    - QLineEdit::NoEcho: 不要展示任何东西。这可能适用于连密码长度都应该保密的密码。</span></span><br><span class="line"><span class="comment">    - QLineEdit::Password: 显示与平台相关的密码掩码字符，而不是实际输入的字符。</span></span><br><span class="line"><span class="comment">    - QLineEdit::PasswordEchoOnEdit: 在编辑时按输入显示字符，否则按密码显示字符。</span></span><br><span class="line"><span class="comment">  - text: 指定显示到单行输入框中的文本信息, 默认是空字符串</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数</span></span><br><span class="line"><span class="comment">  - flags: 对话框窗口的窗口属性, 使用默认值即可</span></span><br><span class="line"><span class="comment">  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串</span></span><br><span class="line"><span class="comment">     - 如果有特殊需求, 可以参数帮助文档进行相关设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QInputDialog::getText</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    QWidget *parent, <span class="type">const</span> QString &amp;title, <span class="type">const</span> QString &amp;label,</span></span></span><br><span class="line"><span class="params"><span class="function">    QLineEdit::EchoMode mode = QLineEdit::Normal, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString &amp;text = QString(), <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::WindowFlags flags = Qt::WindowFlags(), </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::InputMethodHints inputMethodHints = Qt::ImhNone)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>qinputdialog</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QInputDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">    <span class="type">int</span> a=QInputDialog::<span class="built_in">getInt</span>(<span class="keyword">this</span>,<span class="string">&quot;输入&quot;</span>,<span class="string">&quot;输入你的年龄&quot;</span>,<span class="number">18</span>,<span class="number">0</span>,<span class="number">20</span>,<span class="number">1</span>,&amp;ok);</span><br><span class="line">    <span class="comment">//不能跳跃参数</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_2_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">    <span class="type">double</span> a=QInputDialog::<span class="built_in">getDouble</span>(<span class="keyword">this</span>,<span class="string">&quot;inputdouble&quot;</span>,<span class="string">&quot;请输入你的长度&quot;</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,&amp;ok);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_5_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QStringList strlist=&#123;<span class="string">&quot;小红&quot;</span>,<span class="string">&quot;小绿&quot;</span>,<span class="string">&quot;小紫&quot;</span>&#125;;</span><br><span class="line">    QString text=QInputDialog::<span class="built_in">getItem</span>(<span class="keyword">this</span>,<span class="string">&quot;输入item&quot;</span>,<span class="string">&quot;选择输入喜欢的人&quot;</span>,strlist,<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_3_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">    QString text= QInputDialog::<span class="built_in">getText</span>(<span class="keyword">this</span>,<span class="string">&quot;gettext&quot;</span>,<span class="string">&quot;输入你喜欢的书&quot;</span>,QLineEdit::NoEcho,<span class="string">&quot;活着&quot;</span>,&amp;ok);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_4_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">    QString text= QInputDialog::<span class="built_in">getMultiLineText</span>(<span class="keyword">this</span>,<span class="string">&quot;getmultiline&quot;</span>,<span class="string">&quot;输入多行&quot;</span>,<span class="string">&quot;大笨猪666&quot;</span>,&amp;ok);</span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="qprogressdialog"><a href="#qprogressdialog" class="headerlink" title="qprogressdialog"></a>qprogressdialog</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - labelText: 对话框中显示的提示信息</span></span><br><span class="line"><span class="comment">  - cancelButtonText: 取消按钮上显示的文本信息</span></span><br><span class="line"><span class="comment">  - minimum: 进度条最小值</span></span><br><span class="line"><span class="comment">  - maximum: 进度条最大值</span></span><br><span class="line"><span class="comment">  - parent: 当前窗口的父对象</span></span><br><span class="line"><span class="comment">  - f: 当前进度窗口的flag属性, 使用默认属性即可, 无需设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QProgressDialog::<span class="built_in">QProgressDialog</span>(</span><br><span class="line">QWidget *parent = <span class="literal">nullptr</span>, </span><br><span class="line">Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"></span><br><span class="line">QProgressDialog::<span class="built_in">QProgressDialog</span>(</span><br><span class="line"><span class="type">const</span> QString &amp;labelText, <span class="type">const</span> QString &amp;cancelButtonText, </span><br><span class="line"><span class="type">int</span> minimum, <span class="type">int</span> maximum, QWidget *parent = <span class="literal">nullptr</span>,</span><br><span class="line">Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置取消按钮显示的文本信息</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setCancelButtonText</span><span class="params">(<span class="type">const</span> QString &amp;cancelButtonText)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数和槽函数</span></span><br><span class="line"><span class="function">QString <span class="title">QProgressDialog::labelText</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setLabelText</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到进度条最小值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QProgressDialog::minimum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置进度条最小值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setMinimum</span><span class="params">(<span class="type">int</span> minimum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到进度条最大值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QProgressDialog::maximum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置进度条最大值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setMaximum</span><span class="params">(<span class="type">int</span> maximum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置进度条范围(最大和最小值)</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setRange</span><span class="params">(<span class="type">int</span> minimum, <span class="type">int</span> maximum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到进度条当前的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QProgressDialog::value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置进度条当前的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setValue</span><span class="params">(<span class="type">int</span> progress)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QProgressDialog::autoReset</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 当value() = maximum()时，进程对话框是否调用reset()，此属性默认为true。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setAutoReset</span><span class="params">(<span class="type">bool</span> reset)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QProgressDialog::autoClose</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 当value() = maximum()时，进程对话框是否调用reset()并且隐藏，此属性默认为true。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setAutoClose</span><span class="params">(<span class="type">bool</span> close)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断用户是否按下了取消键, 按下了返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wasCanceled</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置进度条</span></span><br><span class="line"><span class="comment">// 重置进度对话框。wascancelled()变为true，直到进程对话框被重置。进度对话框被隐藏。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QProgressDialog::cancel</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 重置进度对话框。如果autoClose()为真，进程对话框将隐藏。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QProgressDialog::reset</span><span class="params">()</span></span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号</span></span><br><span class="line"><span class="comment">// 当单击cancel按钮时，将发出此信号。默认情况下，它连接到cancel()槽。</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QProgressDialog::canceled</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">这是他的积累的组件函数，基类！！！！！</span><br><span class="line"><span class="comment">// 设置窗口的显示状态(模态, 非模态)</span></span><br><span class="line">    需要写在show之前！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span><br><span class="line">    需要写在show之前！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span><br><span class="line">    需要写在show之前！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span><br><span class="line">    需要写在show之前！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">Qt::NonModal  -&gt; 非模态</span></span><br><span class="line"><span class="comment">Qt::WindowModal-&gt; 模态, 阻塞父窗口</span></span><br><span class="line"><span class="comment">Qt::ApplicationModal -&gt; 模态, 阻塞应用程序中的所有窗口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setWindowModality</span><span class="params">(Qt::WindowModality windowModality)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QProgressDialog *progress=<span class="keyword">new</span> <span class="built_in">QProgressDialog</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//    指定了父亲，当大窗口关闭的时候，progress就被释放 了！！！</span></span><br><span class="line">    progress-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;更新中&quot;</span>);</span><br><span class="line">    progress-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    QTimer *tmer=<span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//    指定了父亲，当大窗口关闭的时候，tmer就被释放 了！！！</span></span><br><span class="line">    tmer-&gt;<span class="built_in">start</span>();</span><br><span class="line">    tmer-&gt;<span class="built_in">setInterval</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value=<span class="number">0</span>;</span><br><span class="line">    progress-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(tmer,&amp;QTimer::timeout,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line"></span><br><span class="line">        progress-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line">        value++;</span><br><span class="line">        <span class="keyword">if</span>(value&gt;progress-&gt;<span class="built_in">maximum</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            value=<span class="number">0</span>;</span><br><span class="line">            tmer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(progress-&gt;<span class="built_in">wasCanceled</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        value=<span class="number">0</span>;</span><br><span class="line">        tmer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    connect(progress,&amp;QProgressDialog::canceled,this,[=]()&#123;</span></span><br><span class="line"><span class="comment">//        value=0;</span></span><br><span class="line"><span class="comment">//        tmer-&gt;stop();</span></span><br><span class="line"><span class="comment">//    &#125;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己手动释放的话</p><p>一般都配合着定时器使用</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QProgressDialog *progress=<span class="keyword">new</span> <span class="built_in">QProgressDialog</span>();</span><br><span class="line"><span class="comment">//    指定了父亲，当大窗口关闭的时候，progress就被释放 了！！！</span></span><br><span class="line">    progress-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;更新中&quot;</span>);</span><br><span class="line">    progress-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    QTimer *tmer=<span class="keyword">new</span> <span class="built_in">QTimer</span>();</span><br><span class="line">    <span class="comment">//    指定了父亲，当大窗口关闭的时候，tmer就被释放 了！！！</span></span><br><span class="line">    tmer-&gt;<span class="built_in">start</span>();</span><br><span class="line">    tmer-&gt;<span class="built_in">setInterval</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value=<span class="number">0</span>;</span><br><span class="line">    progress-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(tmer,&amp;QTimer::timeout,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line"></span><br><span class="line">        progress-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line">        value++;</span><br><span class="line">        <span class="keyword">if</span>(value&gt;progress-&gt;<span class="built_in">maximum</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            value=<span class="number">0</span>;</span><br><span class="line">            tmer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">            <span class="keyword">delete</span>  progress;</span><br><span class="line">            <span class="keyword">delete</span> tmer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(progress-&gt;<span class="built_in">wasCanceled</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        value=<span class="number">0</span>;</span><br><span class="line">        tmer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">        <span class="keyword">delete</span>  progress;</span><br><span class="line">        <span class="keyword">delete</span> tmer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    connect(progress,&amp;QProgressDialog::canceled,this,[=]()&#123;</span></span><br><span class="line"><span class="comment">//        value=0;</span></span><br><span class="line"><span class="comment">//        tmer-&gt;stop();</span></span><br><span class="line"><span class="comment">//    &#125;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Qmainwindow-1"><a href="#Qmainwindow-1" class="headerlink" title="Qmainwindow"></a>Qmainwindow</h2><img src="/post/2095ef6d/image-20230808160356220.png" class="" title="image-20230808160356220"><img src="/post/2095ef6d/image-20230808160406271.png" class="" title="image-20230808160406271"><h3 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h3><img src="/post/2095ef6d/image-20230808161932543.png" class="" title="image-20230808161932543"><img src="/post/2095ef6d/image-20230808161945774.png" class="" title="image-20230808161945774"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给菜单栏添加菜单</span></span><br><span class="line"><span class="function">QAction *<span class="title">QMenuBar::addMenu</span><span class="params">(QMenu *menu)</span></span>;</span><br><span class="line"><span class="function">QMenu *<span class="title">QMenuBar::addMenu</span><span class="params">(<span class="type">const</span> QString &amp;title)</span></span>;</span><br><span class="line"><span class="function">QMenu *<span class="title">QMenuBar::addMenu</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;title)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给菜单对象添加菜单项(QAction)</span></span><br><span class="line"><span class="function">QAction *<span class="title">QMenu::addAction</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="function">QAction *<span class="title">QMenu::addAction</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加分割线</span></span><br><span class="line"><span class="function">QAction *<span class="title">QMenu::addSeparator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>&#x2F;&#x2F; 点击QAction对象发出该信号</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAction::triggered</span><span class="params">(<span class="type">bool</span> checked = <span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// save_action 是某个菜单项对象名, 点击这个菜单项会弹出一个对话框</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;save_action, &amp;QAction::triggered, <span class="keyword">this</span>, [=]()</span><br><span class="line">&#123;</span><br><span class="line">   QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;Triggered&quot;</span>, <span class="string">&quot;我是菜单项, 你不要调戏我...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><p>对应的方法就是set神马神马！</p><img src="/post/2095ef6d/image-20230808163239944.png" class="" title="image-20230808163239944"><img src="/post/2095ef6d/image-20230808163310859.png" class="" title="image-20230808163310859"><img src="/post/2095ef6d/image-20230808163320921.png" class="" title="image-20230808163320921"><img src="/post/2095ef6d/image-20230808163338503.png" class="" title="image-20230808163338503"><h3 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h3><img src="/post/2095ef6d/image-20230808163405209.png" class="" title="image-20230808163405209"><img src="/post/2095ef6d/image-20230808163440189.png" class="" title="image-20230808163440189"><h2 id="有的控件我们不给他设置父对象的时候，他为谁服务谁就是他的父亲！"><a href="#有的控件我们不给他设置父对象的时候，他为谁服务谁就是他的父亲！" class="headerlink" title="有的控件我们不给他设置父对象的时候，他为谁服务谁就是他的父亲！"></a><strong>有的控件我们不给他设置父对象的时候，他为谁服务谁就是他的父亲！</strong></h2><img src="/post/2095ef6d/image-20230808172503102.png" class="" title="image-20230808172503102"><p>状态栏</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    ui-&gt;toolBar-&gt;<span class="built_in">setFixedSize</span>(<span class="number">800</span>,<span class="number">50</span>);</span><br><span class="line">    ui-&gt;toolBar-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;点击&quot;</span>,<span class="keyword">this</span>));</span><br><span class="line">    ui-&gt;toolBar-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QLineEdit</span>(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addToolBar</span>(<span class="string">&quot;打住&quot;</span>);</span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">showMessage</span>(<span class="string">&quot;我是状态栏的message&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">    <span class="comment">//第二个参数指定多少毫秒后消失</span></span><br><span class="line">    <span class="comment">//虽然但是这样就把覆盖了，那些还不现实</span></span><br><span class="line">    QPushButton *btn= <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮&quot;</span>);</span><br><span class="line">    QLabel *lb =<span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;不教胡马度阴山！&quot;</span>);</span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(btn);</span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(lb);</span><br><span class="line"></span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(<span class="number">10000</span>,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        btn-&gt;<span class="built_in">show</span>();</span><br><span class="line">        lb-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ui-&gt;statusbar-&gt;<span class="built_in">clearMessage</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="停靠面板"><a href="#停靠面板" class="headerlink" title="停靠面板"></a>停靠面板</h2><img src="/post/2095ef6d/image-20230808180716646.png" class="" title="image-20230808180716646"><img src="/post/2095ef6d/image-20230808180848021.png" class="" title="image-20230808180848021"><h2 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h2><img src="/post/2095ef6d/image-20230808182015037.png" class="" title="image-20230808182015037"><p>资源放在和pro文件相同路静或者更深了</p><img src="/post/2095ef6d/image-20230808181951630.png" class="" title="image-20230808181951630"><img src="/post/2095ef6d/image-20230808182000941.png" class="" title="image-20230808182000941"><img src="/post/2095ef6d/image-20230808182047360.png" class="" title="image-20230808182047360"><h2 id="layout布局"><a href="#layout布局" class="headerlink" title="layout布局"></a>layout布局</h2><img src="/post/2095ef6d/image-20230809102850405.png" class="" title="image-20230809102850405"><blockquote><p>有问有答:<br>    1. 控件的位置可以通过坐标指定, 为什么还要使用布局?<br>        - 坐标指定的位置是固定的, 当窗口大小发生改变, 子窗口位置不会变化<br>            - 使用坐标指定子窗口位置, 这个控件可能会被其他控件覆盖导致无法显示出来<br>            - 使用布局的方式可以完美解决以上的问题<br>                <strong>- 一般在制作窗口的过程中都是给子控件进行布局, 而不是指定固定坐标位置</strong><br>    2. 布局有局限性吗, 窗口结构复杂如何解决呢?<br>        - 没有局限性, 并且布局的使用是非常灵活的<br>        - 各种布局是可以无限嵌套使用的, 这样就可以制作成非常复杂的窗口了<br>            - 思路是这样的: <strong>给窗口设置</strong>布局, 在布局中添加窗口, 子窗口中再设置布局,**<br>              在子窗口布局中再次添加窗口, ……(无限循环)**</p></blockquote><img src="/post/2095ef6d/image-20230809103824470.png" class="" title="image-20230809103824470"><img src="/post/2095ef6d/image-20230809103831288.png" class="" title="image-20230809103831288"><img src="/post/2095ef6d/image-20230809103837334.png" class="" title="image-20230809103837334"><img src="/post/2095ef6d/image-20230809103851464.png" class="" title="image-20230809103851464"><img src="/post/2095ef6d/image-20230809103859157.png" class="" title="image-20230809103859157"><img src="/post/2095ef6d/image-20230809103906937.png" class="" title="image-20230809103906937"><img src="/post/2095ef6d/image-20230816131302850.png" class="" title="image-20230816131302850"><h3 id="通过aPI布局"><a href="#通过aPI布局" class="headerlink" title="通过aPI布局"></a>通过aPI布局</h3><img src="/post/2095ef6d/image-20230816131335828.png" class="" title="image-20230816131335828"><img src="/post/2095ef6d/image-20230816131357522.png" class="" title="image-20230816131357522"><img src="/post/2095ef6d/image-20230816131407076.png" class="" title="image-20230816131407076"><h3 id="Qlayout"><a href="#Qlayout" class="headerlink" title="Qlayout"></a>Qlayout</h3><img src="/post/2095ef6d/image-20230816131446315.png" class="" title="image-20230816131446315"><h3 id="Qhboxlayout"><a href="#Qhboxlayout" class="headerlink" title="Qhboxlayout"></a>Qhboxlayout</h3><img src="/post/2095ef6d/image-20230816131604164.png" class="" title="image-20230816131604164"><img src="/post/2095ef6d/image-20230816131615468.png" class="" title="image-20230816131615468"><blockquote><p>先创建布局对象</p><p>然后addwidget往布局里面放东西</p><p>然后再把布局setlayout给父亲窗口</p><p>这样父亲窗口就有这个布局了且是内嵌，</p><h4 id="直接初始化的时候指定父亲和布局后再指定父亲的内嵌效果是有区别的"><a href="#直接初始化的时候指定父亲和布局后再指定父亲的内嵌效果是有区别的" class="headerlink" title="直接初始化的时候指定父亲和布局后再指定父亲的内嵌效果是有区别的"></a>直接初始化的时候指定父亲和布局后再指定父亲的内嵌效果是有区别的</h4></blockquote><h3 id="QVboxlayout"><a href="#QVboxlayout" class="headerlink" title="QVboxlayout"></a>QVboxlayout</h3><img src="/post/2095ef6d/image-20230816133128199.png" class="" title="image-20230816133128199"><img src="/post/2095ef6d/image-20230816133211794.png" class="" title="image-20230816133211794"><h3 id="qgridboxlayout"><a href="#qgridboxlayout" class="headerlink" title="qgridboxlayout"></a>qgridboxlayout</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QGridLayout::<span class="built_in">QGridLayout</span>();</span><br><span class="line">QGridLayout::<span class="built_in">QGridLayout</span>(QWidget *parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加窗口对象到网格布局中</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - widget: 添加到布局中的窗口对象</span></span><br><span class="line"><span class="comment">  - row: 添加到布局中的窗口对象位于第几行 (从0开始)</span></span><br><span class="line"><span class="comment">  - column: 添加到布局中的窗口对象位于第几列 (从0开始)</span></span><br><span class="line"><span class="comment">  - alignment: 窗口在布局中的对齐方式, 没有特殊需求使用默认值即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGridLayout::addWidget</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">QWidget *widget, <span class="type">int</span> row, <span class="type">int</span> column, </span></span></span><br><span class="line"><span class="params"><span class="function">Qt::Alignment alignment = Qt::Alignment())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - widget: 添加到布局中的窗口对象</span></span><br><span class="line"><span class="comment">  - fromRow: 添加到布局中的窗口对象位于第几行 (从0开始)</span></span><br><span class="line"><span class="comment">  - fromColumn: 添加到布局中的窗口对象位于第几列 (从0开始)</span></span><br><span class="line"><span class="comment">  - rowSpan: 添加的窗口从 fromRow 行开始跨越的行数</span></span><br><span class="line"><span class="comment">  - columnSpan: 添加的窗口从 fromColumn 列开始跨越的列数</span></span><br><span class="line"><span class="comment">  - alignment: 窗口在布局中的对齐方式, 没有特殊需求使用默认值即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGridLayout::addWidget</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">QWidget *widget, <span class="type">int</span> fromRow, <span class="type">int</span> fromColumn, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> rowSpan, <span class="type">int</span> columnSpan, </span></span></span><br><span class="line"><span class="params"><span class="function">Qt::Alignment alignment = Qt::Alignment())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 column 对应的列的最新宽度, 单位: 像素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGridLayout::setColumnMinimumWidth</span><span class="params">(<span class="type">int</span> column, <span class="type">int</span> minSize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置布局中水平方向窗口之间间隔的宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGridLayout::setHorizontalSpacing</span><span class="params">(<span class="type">int</span> spacing)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置布局中垂直方向窗口之间间隔的宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGridLayout::setVerticalSpacing</span><span class="params">(<span class="type">int</span> spacing)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//    qDebug()&lt;&lt;area-&gt;takeWidget();</span></span><br><span class="line"><span class="comment">//    area-&gt;setWidgetResizable(true);</span></span><br><span class="line"><span class="comment">//    area-&gt;setAlignment(Qt::AlignHCenter);</span></span><br><span class="line"><span class="comment">//    ui-&gt;scrollArea_2-&gt;setAlignment(Qt::AlignHCenter);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建父窗口对象</span></span><br><span class="line">    QWidget* window = <span class="keyword">new</span> QWidget;</span><br><span class="line">    <span class="comment">// 创建子窗口对象</span></span><br><span class="line">    QPushButton *button1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;One&quot;</span>);</span><br><span class="line">    QPushButton *button2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Two&quot;</span>);</span><br><span class="line">    QPushButton *button3 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Three&quot;</span>);</span><br><span class="line">    QPushButton *button4 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Four&quot;</span>);</span><br><span class="line">    QPushButton *button5 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Five&quot;</span>);</span><br><span class="line">    QPushButton *button6 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Six&quot;</span>);</span><br><span class="line">    <span class="comment">// 多行文本编辑框</span></span><br><span class="line">    QTextEdit* txedit = <span class="keyword">new</span> QTextEdit;</span><br><span class="line">    txedit-&gt;<span class="built_in">setText</span>(<span class="string">&quot;我占用了两行两列的空间哦。&quot;</span>);</span><br><span class="line"></span><br><span class="line">    QGridLayout* layout = <span class="keyword">new</span> QGridLayout;</span><br><span class="line">    <span class="comment">// 按钮起始位置: 第1行, 第1列, 该按钮占用空间情况为1行1列</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 按钮起始位置: 第1行, 第2列, 该按钮占用空间情况为1行1列</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button2, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 按钮起始位置: 第1行, 第3列, 该按钮占用空间情况为1行1列</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button3, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 编辑框起始位置: 第2行, 第1列, 该按钮占用空间情况为2行2列</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(txedit, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 按钮起始位置: 第2行, 第3列, 该按钮占用空间情况为1行1列</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button4, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 按钮起始位置: 第3行, 第3列, 该按钮占用空间情况为1行1列</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button5, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 按钮起始位置: 第4行, 第1列, 该按钮占用空间情况为1行3列</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button6, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 网格布局设置给父窗口对象</span></span><br><span class="line">    window-&gt;<span class="built_in">setLayout</span>(layout);</span><br><span class="line">    <span class="comment">// 显示父窗口</span></span><br><span class="line">    window-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230816133845787.png" class="" title="image-20230816133845787"><h2 id="———————————"><a href="#———————————" class="headerlink" title="———————————-"></a>———————————-</h2><h2 id="qt窗口实现右键菜单8-14"><a href="#qt窗口实现右键菜单8-14" class="headerlink" title="qt窗口实现右键菜单8.14"></a>qt窗口实现右键菜单8.14</h2><p>学习目标：会熟练使用自定义信号来实现右键的时候弹出自己设置的menu菜单.,区别这四种方法</p><p>实现方法:</p><blockquote><ol><li><h4 id="通过鼠标事件实现"><a href="#通过鼠标事件实现" class="headerlink" title="通过鼠标事件实现"></a>通过鼠标事件实现</h4><blockquote><ol><li><p><code>QWidget</code>是Qt框架中的一个基类，用于创建用户界面的窗口部件。它提供了许多事件处理函数，其中包括<code>mousePressEvent</code>和<code>mouseReleaseEvent</code>。</p><p>这两个函数都是<code>virtual</code>和<code>protected</code>的，意味着它们<strong>可以被子类重写</strong>，并且<strong>只能在类内部或其子类中访问</strong>。</p><p><code>mousePressEvent</code>函数在鼠标按下事件发生时被调用。它接收一个<code>QMouseEvent</code>类型的指针参数<code>event</code>，该参数包含有关鼠标事件的信息，如鼠标位置、按下的按钮等。你可以在重写的<code>mousePressEvent</code>函数中编写自定义的处理代码，以响应鼠标按下事件。</p><p><strong>qDebug()&lt;<event->position();</strong></p><p><code>mouseReleaseEvent</code>函数在<strong>鼠标释放事件发生时被调用</strong>。它也接收一个<code>QMouseEvent</code>类型的指针参数<code>event</code>，该参数包含有关鼠标事件的信息。你可以在重写的<code>mouseReleaseEvent</code>函数中编写自定义的处理代码，以响应鼠标释放事件。</p><p>通过重写这两个函数，你可以在<code>QWidget</code>的子类中实现自定义的鼠标交互行为。例如，你可以捕获鼠标按下和释放事件，并根据需要执行一些操作，如移动窗口、绘制图形等。</p></li><li><pre><code class="c++">//重写这个函数void MainWindow::mousePressEvent(QMouseEvent*event)&#123;    if(event-&gt;button()==Qt::RightButton)    &#123;        qDebug()&lt;&lt;event-&gt;position();              //设置一个菜单栏menu!+menubar        QMenu *bar=new QMenu(this);        bar-&gt;addAction(new QAction(&quot;C++&quot;));        bar-&gt;addAction(new QAction(&quot;Python&quot;));        bar-&gt;addAction(new QAction(&quot;Javascript&quot;));        //        bar-&gt;show();        //设置显示的位置，点击位置的右下角！       // QAction：QAction是一个表示菜单项的类。        QAction对象可以被添加到QMenu中，以在菜单中显示对应的菜单项。            QMenu是一个用于创建菜单的类。它可以包含多个菜单项（QAction对象）或子菜单（QMenu对象）。        bar-&gt;exec(QCursor::pos());    &#125;      &#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. &#123;% asset_img image-20230814171018243.png image-20230814171018243 %&#125;</span><br><span class="line"></span><br><span class="line">   ---</span><br><span class="line"></span><br><span class="line">   ```c++</span><br><span class="line">   // 函数原型:</span><br><span class="line">   上下文菜单策略用于定义在用户右键单击控件时如何显示上下文菜单。</span><br><span class="line">       上下文菜单策略只会影响右键单击事件。如果你想在其他事件（如鼠标中键单击、双击等）上显示上下文菜单，你需要根据具体的需求来处理。</span><br><span class="line">   void QWidget::setContextMenuPolicy(Qt::ContextMenuPolicy policy);</span><br><span class="line">   参数: </span><br><span class="line">     - Qt::NoContextMenu     --&gt; 不能实现右键菜单</span><br><span class="line">     - Qt::PreventContextMenu   --&gt; 不能实现右键菜单</span><br><span class="line">     - Qt::DefaultContextMenu   --&gt; 基于事件处理器函数 QWidget::contextMenuEvent() 实现</span><br><span class="line">     - Qt::ActionsContextMenu   --&gt; 添加到当前窗口中所有 QAction 都会作为右键菜单项显示出来</span><br><span class="line">     - Qt::CustomContextMenu    --&gt; 基于 QWidget::customContextMenuRequested() 信号实现</span><br></pre></td></tr></table></figure></code></pre></li></ol></blockquote><hr></li><li><h4 id="通过Qt-CustomContextMenu菜单策略实现"><a href="#通过Qt-CustomContextMenu菜单策略实现" class="headerlink" title="通过Qt::CustomContextMenu菜单策略实现"></a>通过Qt::CustomContextMenu菜单策略实现</h4><blockquote><ol><li><p><code>Qt::CustomContextMenu</code>策略会在用户右键单击控件时发射<code>QWidget::customContextMenuRequested()</code>信号。这个信号可以用于自定义处理右键菜单的显示和操作。</p></li><li><p>使<strong>用这个策略实现右键菜单, 当点击鼠标右键，窗口会产生一个 QWidget::customContextMenuRequested() 信号，注意仅仅只是发射信号，意味着要自己写显示右键菜单的槽函数（slot），这个信号是QWidget唯一与右键菜单有关的信号。</strong></p></li><li><p><strong>大家一定要注意这个坐标是当前窗口的窗口坐标, 不是屏幕坐标, 显示右键菜单需要使用屏幕坐标</strong></p></li><li><pre><code class="c++">    this-&gt;setContextMenuPolicy(Qt::DefaultContextMenu);      //Qt::CustomContextMenu策略会在用户右键单击控件时发射QWidget::customContextMenuRequested()信号。    //这个信号可以用于自定义处理右键菜单的显示和操作。    connect(this,&amp;MainWindow::customContextMenuRequested,this,[=]()&#123;        QMenu *bar=new QMenu(this);        bar-&gt;addAction(new QAction(&quot;C++&quot;));        bar-&gt;addAction(&quot;铸币&quot;);        bar-&gt;addAction(new QAction(&quot;Python&quot;));        bar-&gt;addAction(new QAction(&quot;Javascript&quot;));        //        bar-&gt;show();        //设置显示的位置，点击位置的右下角！        bar-&gt;exec(QCursor::pos());    &#125;);<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. &#123;% asset_img image-20230814173017444.png image-20230814173017444 %&#125;</span><br><span class="line"></span><br><span class="line">3. #### 通过 Qt::DefaultContextMenu菜单策略实现</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  ```c++</span><br><span class="line">  重写函数</span><br><span class="line">    this-&gt;setContextMenuPolicy(Qt::DefaultContextMenu);</span><br><span class="line">  void MainWindow::contextMenuEvent(QContextMenuEvent *event)</span><br><span class="line">  &#123;</span><br><span class="line">  </span><br><span class="line">   //设置一个菜单栏menu!+menubar</span><br><span class="line">   QMenu *bar=new QMenu(this);</span><br><span class="line">   bar-&gt;addAction(new QAction(&quot;C++&quot;));</span><br><span class="line">   bar-&gt;addAction(new QAction(&quot;Python&quot;));</span><br><span class="line">   bar-&gt;addAction(new QAction(&quot;Javascript&quot;));</span><br><span class="line">   //        bar-&gt;show();</span><br><span class="line">   //设置显示的位置，点击位置的右下角！</span><br><span class="line">   bar-&gt;exec(QCursor::pos());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol></blockquote></li><li><h4 id="通过-Qt-ActionsContextMenu菜单策略实现（z最简单的）"><a href="#通过-Qt-ActionsContextMenu菜单策略实现（z最简单的）" class="headerlink" title="通过 Qt::ActionsContextMenu菜单策略实现（z最简单的）"></a>通过 Qt::ActionsContextMenu菜单策略实现（z最简单的）</h4><p><strong>使用这个策略实现右键菜单, 是最简单的一种, 我们只需要创建一些 QAction类型的对象并且将他们添加到当前的窗口中, 当我们在窗口中点击鼠标右键这些QAction类型的菜单项就可以显示出来了。</strong></p><p><strong>但是它有一定的局限性，就是在一个窗口中不能根据不同的需求制作不同的右键菜单，这种方式只能得到一个唯一的右键菜单。</strong></p><p>直接在构造函数里面写！</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setContextMenuPolicy</span>(Qt::ActionsContextMenu);</span><br><span class="line">  </span><br><span class="line">QAction* act1  = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">QAction* act2 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">QAction* act3  = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">addAction</span>(act1);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">addAction</span>(act2);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">addAction</span>(act3);</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>注意:</p><ol><li><p>默认的菜单策略是Qt::NoContextMenu     –&gt; 不能实现右键菜单</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    QMenu *bar=<span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//    bar.setParent(this);</span></span><br><span class="line">    bar-&gt;<span class="built_in">resize</span>(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">    bar-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;野猪&quot;</span>);</span><br><span class="line">    bar-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure><p>是无效的，要想生效得设置后两张菜单策略</p></li><li><p>加一些对应的处理操作qaction有对应的信号</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(act1, &amp;QAction::triggered, <span class="keyword">this</span>, [=]()</span><br><span class="line">&#123;</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;您选择的是C++...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>tri ggered触发</p><p>最后如果想要让自己的右键菜单项显示图标, 可以调用这个函数</p></li><li><pre><code>// 只显示文本字符串QAction *QMenu::addAction(const QString &amp;text);// 可以显示图标 + 文本字符串QAction *QMenu::addAction(const QIcon &amp;icon, const QString &amp;text);<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## qt的按钮控件8.15</span><br><span class="line"></span><br><span class="line">&gt; 菜单类：</span><br><span class="line">&gt;</span><br><span class="line">&gt; ```c++</span><br><span class="line">&gt;      QMenu *m=new QMenu(this);</span><br><span class="line">&gt;      QAction *act1=m-&gt;addAction(&quot;1&quot;);</span><br><span class="line">&gt;      m-&gt;addAction(&quot;2&quot;);</span><br><span class="line">&gt;      m-&gt;addAction(&quot;3&quot;);</span><br><span class="line">&gt; </span><br><span class="line">&gt;      QMenu *n=new QMenu(this);</span><br><span class="line">&gt;      n-&gt;addAction(&quot;1&quot;);</span><br><span class="line">&gt;      n-&gt;addAction(&quot;2&quot;);</span><br><span class="line">&gt;      QAction*act=n-&gt;addAction(&quot;3&quot;);</span><br><span class="line">&gt;      //设置标题</span><br><span class="line">&gt;      n-&gt;setTitle(&quot;adsds&quot;);</span><br><span class="line">&gt; </span><br><span class="line">&gt;      m-&gt;addMenu(n);</span><br><span class="line">&gt; //给原来的菜单加了一个子菜单，当鼠标放到上面的时候会出现子菜单的内容，但是要手动设置那个标题</span><br><span class="line">&gt;      connect(act,&amp;QAction::triggered,this,[=]()&#123;</span><br><span class="line">&gt; //            n-&gt;exec(QCursor::pos());</span><br><span class="line">&gt;          QMessageBox::about(this,&quot;提示&quot;,&quot;去去去&quot;);</span><br><span class="line">&gt;      &#125;);</span><br><span class="line">&gt;      m-&gt;exec(QCursor::pos());</span><br></pre></td></tr></table></figure>&gt;&gt; &#123;% asset_img image-20230902094949570.png image-20230902094949570 %&#125;</code></pre></li></ol><h3 id="1-按钮基类-QAbstractButton"><a href="#1-按钮基类-QAbstractButton" class="headerlink" title="1. 按钮基类 QAbstractButton"></a>1. 按钮基类 QAbstractButton</h3><img src="/post/2095ef6d/image-20230815090815132.png" class="" title="image-20230815090815132"><p>后两个基本不需要使用</p><blockquote><p>继承关系</p></blockquote><img src="/post/2095ef6d/image-20230815090855947.png" class="" title="image-20230815090855947"><blockquote><p>常用的api</p></blockquote><ol><li><p>标题和图标</p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数text的内容显示到按钮上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QAbstractButton::setText</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="comment">// 得到按钮上显示的文本内容, 函数的返回就是</span></span><br><span class="line"><span class="function">QString <span class="title">QAbstractButton::text</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到按钮设置的图标</span></span><br><span class="line"><span class="function">QIcon <span class="title">icon</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给按钮设置图标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setIcon</span><span class="params">(<span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到按钮图标大小</span></span><br><span class="line"><span class="function">QSize <span class="title">iconSize</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="comment">// 设置按钮图标的大小</span></span></span><br><span class="line"><span class="function">[slot]<span class="type">void</span> <span class="title">setIconSize</span><span class="params">(<span class="type">const</span> QSize &amp;size)</span></span>;</span><br></pre></td></tr></table></figure><p>对应实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"> QPushButton *btn=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line"> btn-&gt;<span class="built_in">show</span>();</span><br><span class="line"> <span class="comment">//    ---继承自qabstructbutton</span></span><br><span class="line"> btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;按钮&quot;</span>);</span><br><span class="line"> btn-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/D:/icon/img.png&quot;</span>));</span><br><span class="line"></span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;btn-&gt;<span class="built_in">text</span>();</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;btn-&gt;<span class="built_in">icon</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>result</p><img src="/post/2095ef6d/image-20230815092044094.png" class="" title="image-20230815092044094"><p>总结:资源文件里的路径也不要有中文！！！！！</p></blockquote></li><li><img src="/post/2095ef6d/image-20230815092223821.png" class="" title="image-20230815092223821"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断按钮是否设置了checkable属性, 如果设置了点击按钮, 按钮一直处于选中状态</span></span><br><span class="line"><span class="comment">// 默认这个属性是关闭的, not checkable</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QAbstractButton::isCheckable</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置按钮的checkable属性</span></span><br><span class="line"><span class="comment">// 参数为true: 点击按钮, 按钮被选中, 松开鼠标, 按钮不弹起</span></span><br><span class="line"><span class="comment">// 参数为false: 点击按钮, 按钮被选中, 松开鼠标, 按钮弹起</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QAbstractButton::setCheckable</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line">-------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断按钮是不是被按下的选中状态</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QAbstractButton::isChecked</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置按钮的选中状态: true-选中, false-没选中</span></span><br><span class="line"><span class="comment">// 设置该属性前, 必须先进行 checkable属性的设置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QAbstractButton::setChecked</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line">btn-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);<span class="comment">//设置按钮也可以check，默认是不可以的.</span></span><br><span class="line"></span><br><span class="line">btn-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);<span class="comment">//设置默认是选中状态</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;btn-&gt;<span class="built_in">isChecked</span>();<span class="comment">//true</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;btn-&gt;<span class="built_in">isCheckable</span>();<span class="comment">//true</span></span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230815092710333.png" class="" title="image-20230815092710333"></li><li><img src="/post/2095ef6d/image-20230815092840907.png" class="" title="image-20230815092840907"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当按钮被激活时(即，当鼠标光标在按钮内时按下然后释放)，当键入快捷键时，或者当click()或animateClick()被调用时，这个信号被发出。值得注意的是，如果调用setDown()、setChecked()或toggle()，则不会触发此信号。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::clicked</span><span class="params">(<span class="type">bool</span> checked = <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="comment">// 在按下按钮的时候发射这个信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::pressed</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 在释放这个按钮的时候发射直观信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::released</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 每当可检查按钮改变其状态时，就会发出此信号。checked在选中按钮时为true，在未选中按钮时为false。</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::toggled</span><span class="params">(<span class="type">bool</span> checked)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>槽函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行一个动画点击:按钮被立即按下，并在毫秒后释放(默认是100毫秒)。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::animateClick</span><span class="params">(<span class="type">int</span> msec = <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="comment">// 执行一次按钮点击, 相当于使用鼠标点击了按钮</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::click</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参考 1.2 中的函数介绍</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::setChecked</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"><span class="comment">// 设置按钮上图标大小</span></span><br><span class="line">[slot]<span class="function"><span class="type">void</span> <span class="title">setIconSize</span><span class="params">(<span class="type">const</span> QSize &amp;size)</span></span>;<span class="comment">//15/15</span></span><br><span class="line"><span class="comment">// 切换可检查按钮的状态。 checked &lt;==&gt; unchecked</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::toggle</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-QPushButton"><a href="#2-QPushButton" class="headerlink" title="2.QPushButton"></a>2.QPushButton</h3><img src="/post/2095ef6d/image-20230815101543434.png" class="" title="image-20230815101543434"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">    - icon: 按钮上显示的图标</span></span><br><span class="line"><span class="comment">    - text: 按钮上显示的标题</span></span><br><span class="line"><span class="comment">    - parent: 按钮的父对象, 可以不指定,默认是不指定的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QPushButton::<span class="built_in">QPushButton</span>(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;text, QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">QPushButton::<span class="built_in">QPushButton</span>(<span class="type">const</span> QString &amp;text, QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">QPushButton::<span class="built_in">QPushButton</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断按钮是不是默认按钮</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDefault</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 一般在对话框窗口中使用, 将按钮设置为默认按钮, 自动关联 Enter 键 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setDefault</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将弹出菜单菜单与此按钮关联起来。这将把按钮变成一个菜单按钮，</span></span><br><span class="line"><span class="comment">在某些样式中会在按钮文本的右边产生一个小三角形。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPushButton::setMenu</span><span class="params">(QMenu *menu)</span></span>;</span><br><span class="line"><span class="comment">////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">显示(弹出)相关的弹出菜单。如果没有这样的菜单，这个函数什么也不做。</span></span><br><span class="line"><span class="comment">这个函数直到弹出菜单被用户关闭后才返回。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QPushButton::showMenu</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,btn1,&amp;QPushButton::showMenu);</span><br><span class="line">实现点击别的按钮，实现由带小三角的按钮，打开她的菜单。</span><br><span class="line">    前提是这个按钮得setmenu</span><br><span class="line">    槽函数其实就是行为函数，可以单独使用，也可以连接信号使用</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMenu *menu=<span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="function">QAction <span class="title">action</span><span class="params">(<span class="string">&quot;铸币&quot;</span>,<span class="keyword">this</span>)</span></span>;</span><br><span class="line">   QAction* act1  = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">   QAction* act2 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">   QAction* act3  = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">   menu-&gt;<span class="built_in">addAction</span>(act1);</span><br><span class="line">   menu-&gt;<span class="built_in">addAction</span>(act2);</span><br><span class="line">   menu-&gt;<span class="built_in">addAction</span>(act3);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">connect</span>(act3,&amp;QAction::triggered ,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">     QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>,<span class="string">&quot;提示&quot;</span>,<span class="string">&quot;你选择了铸币&quot;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="comment">//把菜单给关联起来</span></span><br><span class="line">btn1-&gt;<span class="built_in">setMenu</span>(menu);</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230815105246763.png" class="" title="image-20230815105246763"><blockquote><ol><li>普通按钮</li><li>带菜单的按钮</li><li>可以设置选中的按钮</li></ol></blockquote><p>注意:</p><blockquote><p>[signal] void QAbstractButton::toggled(bool checked)</p><p>该信号的参数checked表示QAction的状态是否被切换为选中状态。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;checkedBtn, &amp;QPushButton::toggled, <span class="keyword">this</span>, [=](<span class="type">bool</span> bl)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;我是一个checked按钮, 当前状态为:&quot;</span> &lt;&lt; bl;</span><br><span class="line">     &#125;);意思是匿名函数可以捕获信号函数的参数。</span><br></pre></td></tr></table></figure></blockquote><h3 id="3Qtoolbutton"><a href="#3Qtoolbutton" class="headerlink" title="3Qtoolbutton"></a>3Qtoolbutton</h3><img src="/post/2095ef6d/image-20230815140257037.png" class="" title="image-20230815140257037"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///////////////////////////// 构造函数 /////////////////////////////</span></span><br><span class="line">QToolButton::<span class="built_in">QToolButton</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////// 公共成员函数 ///////////////////////////</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 将给定的菜单与此工具按钮相关联。</span></span><br><span class="line"><span class="comment">    2. 菜单将根据按钮的弹出模式显示。</span></span><br><span class="line"><span class="comment">    3. 菜单的所有权没有转移到“工具”按钮(不能建立父子关系)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QToolButton::setMenu</span><span class="params">(QMenu *menu)</span></span>;</span><br><span class="line"><span class="comment">// 返回关联的菜单，如果没有定义菜单，则返回nullptr。</span></span><br><span class="line"><span class="function">QMenu *<span class="title">QToolButton::menu</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">弹出菜单的弹出模式是一个枚举类型: QToolButton::ToolButtonPopupMode, 取值如下:</span></span><br><span class="line"><span class="comment">    - QToolButton::DelayedPopup: </span></span><br><span class="line"><span class="comment">        - 延时弹出, 按压工具按钮一段时间后才能弹出, 比如:浏览器的返回按钮</span></span><br><span class="line"><span class="comment">        - 长按按钮菜单弹出, 但是按钮的 clicked 信号不会被发射</span></span><br><span class="line"><span class="comment">    - QToolButton::MenuButtonPopup: </span></span><br><span class="line"><span class="comment">        - 在这种模式下，工具按钮会显示一个特殊的箭头，表示有菜单。</span></span><br><span class="line"><span class="comment">- 当按下按钮的箭头部分时，将显示菜单。按下按钮部分发射 clicked 信号</span></span><br><span class="line"><span class="comment">    - QToolButton::InstantPopup: </span></span><br><span class="line"><span class="comment">        - 当按下工具按钮时，菜单立即显示出来。</span></span><br><span class="line"><span class="comment">        - 在这种模式下，按钮本身的动作不会被触发(不会发射clicked信号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 设置弹出菜单的弹出方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setPopupMode</span><span class="params">(QToolButton::ToolButtonPopupMode mode)</span></span>;</span><br><span class="line"><span class="comment">// 获取弹出菜单的弹出方式</span></span><br><span class="line"><span class="function">QToolButton::ToolButtonPopupMode <span class="title">popupMode</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">QToolButton可以帮助我们在按钮上绘制箭头图标, 是一个枚举类型, 取值如下: </span></span><br><span class="line"><span class="comment">    - Qt::NoArrow: 没有箭头</span></span><br><span class="line"><span class="comment">    - Qt::UpArrow: 箭头向上</span></span><br><span class="line"><span class="comment">    - Qt::DownArrow: 箭头向下</span></span><br><span class="line"><span class="comment">    - Qt::LeftArrow: 箭头向左</span></span><br><span class="line"><span class="comment">    - Qt::RightArrow: 箭头向右</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 显示一个箭头作为QToolButton的图标。默认情况下，这个属性被设置为Qt::NoArrow。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setArrowType</span><span class="params">(Qt::ArrowType type)</span></span>;</span><br><span class="line"><span class="comment">// 获取工具按钮上显示的箭头图标样式</span></span><br><span class="line"><span class="function">Qt::ArrowType <span class="title">arrowType</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////// 槽函数 /////////////////////////////</span></span><br><span class="line"><span class="comment">// 给按钮关联一个QAction对象, 主要目的是美化按钮</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QToolButton::setDefaultAction</span><span class="params">(QAction *action)</span></span>;</span><br><span class="line"><span class="comment">// 返回给按钮设置的QAction对象</span></span><br><span class="line"><span class="function">QAction *<span class="title">QToolButton::defaultAction</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">图标的显示样式是一个枚举类型-&gt;Qt::ToolButtonStyle, 取值如下:</span></span><br><span class="line"><span class="comment">    - Qt::ToolButtonIconOnly: 只有图标, 不显示文本信息</span></span><br><span class="line"><span class="comment">    - Qt::ToolButtonTextOnly: 不显示图标, 只显示文本信息</span></span><br><span class="line"><span class="comment">    - Qt::ToolButtonTextBesideIcon: 文本信息在图标的后边显示</span></span><br><span class="line"><span class="comment">    - Qt::ToolButtonTextUnderIcon: 文本信息在图标的下边显示</span></span><br><span class="line"><span class="comment">    - Qt::ToolButtonFollowStyle: 跟随默认样式(只显示图标)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 设置的这个属性决定工具按钮是只显示一个图标、只显示文本，还是在图标旁边/下面显示文本。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QToolButton::setToolButtonStyle</span><span class="params">(Qt::ToolButtonStyle style)</span></span>;</span><br><span class="line"><span class="comment">// 返回工具按钮设置的图标显示模式</span></span><br><span class="line"><span class="function">Qt::ToolButtonStyle <span class="title">toolButtonStyle</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示相关的弹出菜单。如果没有这样的菜单，这个函数将什么也不做。这个函数直到弹出菜单被用户关闭才会返回。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QToolButton::showMenu</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QToolButton *tbtn=<span class="keyword">new</span> <span class="built_in">QToolButton</span>(<span class="keyword">this</span>);</span><br><span class="line">    QToolButton *tbtn1=<span class="keyword">new</span> <span class="built_in">QToolButton</span>(<span class="keyword">this</span>);</span><br><span class="line">    tbtn-&gt;<span class="built_in">show</span>();</span><br><span class="line">     tbtn1-&gt;<span class="built_in">show</span>();</span><br><span class="line">     tbtn1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;toolbtn普通&quot;</span>);</span><br><span class="line">     QToolButton *tbtn2=<span class="keyword">new</span> <span class="built_in">QToolButton</span>(<span class="keyword">this</span>);</span><br><span class="line">     tbtn2-&gt;<span class="built_in">show</span>();</span><br><span class="line">     tbtn2-&gt;<span class="built_in">setText</span>(<span class="string">&quot;check&quot;</span>);</span><br><span class="line">     tbtn2-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line">     tbtn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     tbtn1-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    tbtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;toolbtn&quot;</span>);</span><br><span class="line">    tbtn-&gt;<span class="built_in">setPopupMode</span>(QToolButton::InstantPopup);</span><br><span class="line"></span><br><span class="line">    QMenu *menu=<span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="keyword">this</span>);</span><br><span class="line">    QAction *act1=<span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;牛&quot;</span>);</span><br><span class="line">    QAction *act2=<span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;比&quot;</span>);</span><br><span class="line">    QAction *act3=<span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;奶&quot;</span>);</span><br><span class="line">    QAction *act4=<span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;嘴&quot;</span>);</span><br><span class="line">    QAction *act5=<span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;嘴sdasdasd&quot;</span>);</span><br><span class="line"><span class="comment">//tbtn-&gt;setArrowType(Qt::RightArrow);</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;tbtn-&gt;<span class="built_in">popupMode</span>();</span><br><span class="line">    tbtn-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;D:/icon/img.png&quot;</span>));</span><br><span class="line">    menu-&gt;<span class="built_in">addAction</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;D:/icon/img.png&quot;</span>),<span class="string">&quot;牛逼&quot;</span>);</span><br><span class="line">    menu-&gt;<span class="built_in">addAction</span>(act2);</span><br><span class="line">    menu-&gt;<span class="built_in">addAction</span>(act3);</span><br><span class="line">    menu-&gt;<span class="built_in">addAction</span>(act4);</span><br><span class="line">    menu-&gt;<span class="built_in">setDefaultAction</span>(act3);</span><br><span class="line"></span><br><span class="line">    tbtn-&gt;<span class="built_in">setMenu</span>(menu);</span><br><span class="line">    <span class="comment">//设置是菜单里某个加粗，相当于默认选择</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置的是toolbutton按钮上的字体</span></span><br><span class="line"><span class="comment">//    connect(ui-&gt;pushButton,&amp;QPushButton::clicked,std::bind(&amp;QToolButton::setDefaultAction,tbtn,(act1)));</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton,&amp;QPushButton::clicked,std::<span class="built_in">bind</span>(&amp;QToolButton::setToolButtonStyle,tbtn,(Qt::ToolButtonTextBesideIcon)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230815151439198.png" class="" title="image-20230815151439198"><h3 id="4Qradiobutton"><a href="#4Qradiobutton" class="headerlink" title="4Qradiobutton"></a>4Qradiobutton</h3><img src="/post/2095ef6d/image-20230815153818178.png" class="" title="image-20230815153818178"><img src="/post/2095ef6d/image-20230815153919464.png" class="" title="image-20230815153919464"><img src="/post/2095ef6d/image-20230815154156522.png" class="" title="image-20230815154156522"><img src="/post/2095ef6d/image-20230815154634875.png" class="" title="image-20230815154634875"><p><strong>分组后，互相不打扰不干涉</strong></p><img src="/post/2095ef6d/image-20230815154725203.png" class="" title="image-20230815154725203"><p>测试是否发出clicked信号</p><img src="/post/2095ef6d/image-20230815154751505.png" class="" title="image-20230815154751505"><h3 id="5Qcheckbox"><a href="#5Qcheckbox" class="headerlink" title="5Qcheckbox"></a>5Qcheckbox</h3><img src="/post/2095ef6d/image-20230815154936709.png" class="" title="image-20230815154936709"><p>常用的API函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">    - text: 按钮上显示的文本信息</span></span><br><span class="line"><span class="comment">    - parent: 按钮的父对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QCheckBox::<span class="built_in">QCheckBox</span>(<span class="type">const</span> QString &amp;text, QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">QCheckBox::<span class="built_in">QCheckBox</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前复选框是否为三态复选框, 默认情况下为两种状态: 未选中, 选中</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isTristate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">tri state</span><br><span class="line"><span class="comment">// 设置当前复选框为三态复选框: 未选中, 选中, 半选中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTristate</span><span class="params">(<span class="type">bool</span> y = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数 state, 枚举类型 Qt::CheckState:</span></span><br><span class="line"><span class="comment">    - Qt::Unchecked      --&gt; 当前复选框没有被选中</span></span><br><span class="line"><span class="comment">    - Qt::PartiallyChecked    --&gt; 当前复选框处于半选中状态, 部分被选中(三态复选框)</span></span><br><span class="line"><span class="comment">    - Qt::Checked      --&gt; 当前复选框处于选中状态</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 设置复选框按钮的状态</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QCheckBox::setCheckState</span><span class="params">(Qt::CheckState state)</span></span>;</span><br><span class="line"><span class="comment">// 获取当前复选框的状态</span></span><br><span class="line"><span class="function">Qt::CheckState <span class="title">QCheckBox::checkState</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>信号signal</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当复选框的状态改变时，即当用户选中或取消选中复选框时，他的信号就会发出。</span></span><br><span class="line"><span class="comment">// 参数 state 表示的是复选框的三种状态中某一种, 可参考 Qt::CheckState</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QCheckBox::stateChanged</span><span class="params">(<span class="type">int</span> state)</span></span>;</span><br><span class="line">利用槽函数去捕捉这个参数</span><br><span class="line">    执行对应的操作</span><br><span class="line">    是一个枚举值，对应着不同的状态！</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QCheckBox  *cb1=<span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;性感&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    QCheckBox  *cb2=<span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;性感1&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    QCheckBox  *cb3=<span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;性感2&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    cb1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cb2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cb3-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cb2-&gt;<span class="built_in">move</span>(<span class="number">0</span>,<span class="number">40</span>);</span><br><span class="line">    cb3-&gt;<span class="built_in">move</span>(<span class="number">0</span>,<span class="number">80</span>);</span><br><span class="line">    cb3-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;D:/icon/img.png&quot;</span>));</span><br><span class="line">    <span class="comment">//开启三选功能</span></span><br><span class="line">    cb3-&gt;<span class="built_in">setTristate</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//是否开启了三选功能</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;cb3-&gt;<span class="built_in">isTristate</span>();</span><br><span class="line">    <span class="comment">//设置默认的选择状态</span></span><br><span class="line">    cb3-&gt;<span class="built_in">setCheckState</span>(Qt::Unchecked);</span><br><span class="line"><span class="comment">//信号</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;cb3-&gt;<span class="built_in">checkState</span>();</span><br><span class="line">    <span class="built_in">connect</span>(cb3,&amp;QCheckBox::stateChanged,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;复选框的状态发生了改变！&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现完美的多选功能</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="built_in">connect</span>(ui-&gt;checkBox_5,&amp;QCheckBox::stateChanged,<span class="keyword">this</span>,&amp;MainWindow::statenum);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;checkBox_6,&amp;QCheckBox::stateChanged,<span class="keyword">this</span>,&amp;MainWindow::statenum);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;checkBox_7,&amp;QCheckBox::stateChanged,<span class="keyword">this</span>,&amp;MainWindow::statenum);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;checkBox_8,&amp;QCheckBox::stateChanged,<span class="keyword">this</span>,&amp;MainWindow::statenum);</span><br><span class="line"><span class="comment">//自定义个槽函数，当子选项的状态修改的时候，就利用我们自己的槽函数记录一下操作数,4个子选项</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;checkBox_9,&amp;QCheckBox::stateChanged,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ui-&gt;checkBox_9-&gt;<span class="built_in">checkState</span>()==Qt::Checked)</span><br><span class="line">        &#123;</span><br><span class="line">            ui-&gt;checkBox_5-&gt;<span class="built_in">setCheckState</span>(Qt::Checked);</span><br><span class="line">            ui-&gt;checkBox_6-&gt;<span class="built_in">setCheckState</span>(Qt::Checked);</span><br><span class="line">            ui-&gt;checkBox_7-&gt;<span class="built_in">setCheckState</span>(Qt::Checked);</span><br><span class="line">            ui-&gt;checkBox_8-&gt;<span class="built_in">setCheckState</span>(Qt::Checked);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ui-&gt;checkBox_9-&gt;<span class="built_in">checkState</span>()==Qt::Unchecked)</span><br><span class="line">        &#123;</span><br><span class="line">            ui-&gt;checkBox_5-&gt;<span class="built_in">setCheckState</span>(Qt::Unchecked);</span><br><span class="line">            ui-&gt;checkBox_6-&gt;<span class="built_in">setCheckState</span>(Qt::Unchecked);</span><br><span class="line">            ui-&gt;checkBox_7-&gt;<span class="built_in">setCheckState</span>(Qt::Unchecked);</span><br><span class="line">            ui-&gt;checkBox_8-&gt;<span class="built_in">setCheckState</span>(Qt::Unchecked);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//实现父选项对子选项的控制</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MainWindow::statenum</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==Qt::Checked)</span><br><span class="line">    &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s==Qt::Unchecked)</span><br><span class="line">    &#123;</span><br><span class="line">        num--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;checkBox_9-&gt;<span class="built_in">setCheckState</span>(Qt::Checked);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;checkBox_9-&gt;<span class="built_in">setCheckState</span>(Qt::Unchecked);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ui-&gt;checkBox_9-&gt;<span class="built_in">setCheckState</span>(Qt::PartiallyChecked);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自己的槽函数，记录一个数，执行对应的操作！！！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230815175052198.png" class="" title="image-20230815175052198"><p>完美实现！</p><h2 id="qt中容器类型的控件"><a href="#qt中容器类型的控件" class="headerlink" title="qt中容器类型的控件"></a>qt中容器类型的控件</h2><img src="/post/2095ef6d/image-20230816102149246.png" class="" title="image-20230816102149246"><h3 id="Qwidget"><a href="#Qwidget" class="headerlink" title="Qwidget"></a>Qwidget</h3><img src="/post/2095ef6d/image-20230816101851752.png" class="" title="image-20230816101851752"><img src="/post/2095ef6d/image-20230816102059469.png" class="" title="image-20230816102059469"><img src="/post/2095ef6d/image-20230816102113462.png" class="" title="image-20230816102113462"><h3 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h3><img src="/post/2095ef6d/image-20230816102258664.png" class="" title="image-20230816102258664"><p>常用api</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">边框形状为布尔类型, 可选项为:</span></span><br><span class="line"><span class="comment">    - QFrame::NoFrame: 没有边框</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    - QFrame::Box: 绘制一个框</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    - QFrame::Panel: 绘制一个面板，使内容显示为凸起或凹陷</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    - QFrame::StyledPanel: 绘制一个外观取决于当前GUI样式的矩形面板。它可以上升也可以下沉。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    - QFrame::HLine: 画一条没有边框的水平线(用作分隔符)</span></span><br><span class="line"><span class="comment">    - QFrame::VLine: 画一条没有边框的垂直线(用作分隔符)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    - QFrame::WinPanel: 绘制一个矩形面板，可以像Windows 2000那样向上或向下移动。</span></span><br><span class="line"><span class="comment">                指定此形状将线宽设置为2像素。WinPanel是为了兼容而提供的。</span></span><br><span class="line"><span class="comment">                对于GUI风格的独立性，我们建议使用StyledPanel代替。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 获取边框形状</span></span><br><span class="line"><span class="function">Shape <span class="title">frameShape</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置边框形状</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setFrameShape</span><span class="params">(Shape)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Qt中关于边框的阴影(QFrame::Shadow)提供了3种样式, 分别为: </span></span><br><span class="line"><span class="comment">    - QFrame::Plain: 简单的,朴素的, 框架和内容与周围环境显得水平;</span></span><br><span class="line"><span class="comment">             使用调色板绘制QPalette::WindowText颜色(没有任何3D效果)</span></span><br><span class="line"><span class="comment">    - QFrame::Raised: 框架和内容出现凸起;使用当前颜色组的明暗颜色绘制3D凸起线</span></span><br><span class="line"><span class="comment">    - QFrame::Sunken: 框架及内容物凹陷;使用当前颜色组的明暗颜色绘制3D凹线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取边框阴影样式</span></span><br><span class="line"><span class="function">Shadow <span class="title">frameShadow</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置边框阴影样式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setFrameShadow</span><span class="params">(Shadow)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到边框线宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lineWidth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置边框线宽度, 默认值为1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setLineWidth</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到中线的宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">midLineWidth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置中线宽度, 默认值为0, 这条线会影响边框阴影的显示</span></span><br><span class="line">设置边框线的宽度。中线的宽度大了，那么边框也就变厚了！</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMidLineWidth</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;ui-&gt;frame-&gt;<span class="built_in">frameShape</span>();</span><br><span class="line">    ui-&gt;frame-&gt;<span class="built_in">setFrameShape</span>(QFrame::Box);</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;ui-&gt;frame-&gt;<span class="built_in">frameShape</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;ui-&gt;frame-&gt;<span class="built_in">frameShadow</span>();</span><br><span class="line">        ui-&gt;frame-&gt;<span class="built_in">setFrameShadow</span>(QFrame::Raised);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;ui-&gt;frame-&gt;<span class="built_in">frameWidth</span>();</span><br><span class="line">        <span class="comment">///////是setlinwidth不是setframwidth</span></span><br><span class="line"><span class="comment">//    ui-&gt;frame-&gt;setLineWidth(10);</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;ui-&gt;frame-&gt;<span class="built_in">midLineWidth</span>();</span><br><span class="line">    ui-&gt;frame-&gt;<span class="built_in">setMidLineWidth</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230816103505118.png" class="" title="image-20230816103505118"><img src="/post/2095ef6d/image-20230816103629504.png" class="" title="image-20230816103629504"><img src="/post/2095ef6d/image-20230816103636361.png" class="" title="image-20230816103636361"><h3 id="Groupbox不常用"><a href="#Groupbox不常用" class="headerlink" title="Groupbox不常用"></a>Groupbox不常用</h3><img src="/post/2095ef6d/image-20230816103720552.png" class="" title="image-20230816103720552"><img src="/post/2095ef6d/image-20230816103730019.png" class="" title="image-20230816103730019"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QGroupBox::<span class="built_in">QGroupBox</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line">第二种食用</span><br><span class="line">QGroupBox::<span class="built_in">QGroupBox</span>(<span class="type">const</span> QString &amp;title, QWidget *parent = Q_NULLPTR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QGroupBox::isCheckable</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置是否在组框中显示一个复选框</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGroupBox::setCheckable</span><span class="params">(<span class="type">bool</span> checkable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于对齐方式需要使用枚举类型 Qt::Alignment, 其可选项为:</span></span><br><span class="line"><span class="comment">    - Qt::AlignLeft: 左对齐(水平方向)</span></span><br><span class="line"><span class="comment">    - Qt::AlignRight: 右对齐(水平方向)</span></span><br><span class="line"><span class="comment">    - Qt::AlignHCenter: 水平居中</span></span><br><span class="line"><span class="comment">    - Qt::AlignJustify: 在可用的空间内调整文本(水平方向)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    - Qt::AlignTop: 上对齐(垂直方向)</span></span><br><span class="line"><span class="comment">    - Qt::AlignBottom: 下对齐(垂直方向)</span></span><br><span class="line"><span class="comment">    - Qt::AlignVCenter: 垂直居中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Qt::Alignment <span class="title">QGroupBox::alignment</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置组框标题的对其方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGroupBox::setAlignment</span><span class="params">(<span class="type">int</span> alignment)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">QGroupBox::title</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置组框的标题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGroupBox::setTitle</span><span class="params">(<span class="type">const</span> QString &amp;title)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QGroupBox::isChecked</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置组框中复选框的选中状态</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QGroupBox::setChecked</span><span class="params">(<span class="type">bool</span> checked)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QGroupBox*box=<span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="string">&quot;我是牛马&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">box-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">box-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;box-&gt;<span class="built_in">isCheckable</span>();</span><br><span class="line">box-&gt;<span class="built_in">setChecked</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;box-&gt;<span class="built_in">isChecked</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;box-&gt;<span class="built_in">title</span>();</span><br><span class="line"></span><br><span class="line">box-&gt;<span class="built_in">setAlignment</span>(Qt::AlignVCenter);</span><br><span class="line">肥肠简单奥</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230816105613333.png" class="" title="image-20230816105613333"><blockquote><p>flat间接的，平原</p><p>只能在属性窗口中设置，设置后组件的边框就没有了</p></blockquote><img src="/post/2095ef6d/image-20230816110011195.png" class="" title="image-20230816110011195"><h3 id="Scroll-Area"><a href="#Scroll-Area" class="headerlink" title="Scroll Area"></a>Scroll Area</h3><p>scroll滚筒，画卷</p><img src="/post/2095ef6d/image-20230816110150076.png" class="" title="image-20230816110150076"><img src="/post/2095ef6d/image-20230816110245793.png" class="" title="image-20230816110245793"><img src="/post/2095ef6d/image-20230816110321930.png" class="" title="image-20230816110321930"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QScrollArea::<span class="built_in">QScrollArea</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 给滚动区域设置要显示的子窗口widget</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QScrollArea::setWidget</span><span class="params">(QWidget *widget)</span></span>;</span><br><span class="line"><span class="comment">// 删除滚动区域中的子窗口, 并返回被删除的子窗口对象</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QScrollArea::takeWidget</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于显示位置的设定, 是一个枚举类型, 可选项为:</span></span><br><span class="line"><span class="comment">    - Qt::AlignLeft: 左对齐</span></span><br><span class="line"><span class="comment">    - Qt::AlignHCenter: 水平居中</span></span><br><span class="line"><span class="comment">    - Qt::AlignRight: 右对齐</span></span><br><span class="line"><span class="comment">    - Qt::AlignTop: 顶部对齐</span></span><br><span class="line"><span class="comment">    - Qt::AlignVCenter: 垂直对其</span></span><br><span class="line"><span class="comment">    - Qt::AlignBottom: 底部对其</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 获取子窗口在滚动区域中的显示位置</span></span><br><span class="line"><span class="function">Qt::Alignment <span class="title">alignment</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置滚动区域中子窗口的对其方式, 默认显示的位置是右上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAlignment</span><span class="params">(Qt::Alignment)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断滚动区域是否有自动调节小部件大小的属性</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">widgetResizable</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 设置滚动区域是否应该调整视图小部件的大小, 该属性默认为false, 滚动区域按照小部件的默认大小进行显示。</span></span><br><span class="line"><span class="comment">2. 如果该属性设置为true，滚动区域将自动调整小部件的大小，避免滚动条出现在本可以避免的地方，</span></span><br><span class="line"><span class="comment">   或者利用额外的空间。</span></span><br><span class="line"><span class="comment">3. 不管这个属性是什么，我们都可以使用widget()-&gt;resize()以编程方式调整小部件的大小，</span></span><br><span class="line"><span class="comment">   滚动区域将自动调整自己以适应新的大小。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWidgetResizable</span><span class="params">(<span class="type">bool</span> resizable)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QScrollArea *area=<span class="keyword">new</span> <span class="built_in">QScrollArea</span>(<span class="keyword">this</span>);</span><br><span class="line">    area-&gt;<span class="built_in">setFixedHeight</span>(<span class="number">200</span>);</span><br><span class="line">    ui-&gt;groupBox-&gt;<span class="built_in">setFixedSize</span>(<span class="number">1000</span>,<span class="number">1000</span>);</span><br><span class="line">    area-&gt;<span class="built_in">setWidget</span>(ui-&gt;groupBox);</span><br><span class="line"><span class="comment">//    QWidget *a=area-&gt;takeWidget();</span></span><br><span class="line"><span class="comment">//    a-&gt;setFixedSize(100,100);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    qDebug()&lt;&lt;area-&gt;takeWidget();</span></span><br><span class="line">    area-&gt;<span class="built_in">setWidgetResizable</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230816125045128.png" class="" title="image-20230816125045128"><img src="/post/2095ef6d/image-20230816140215909.png" class="" title="image-20230816140215909"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个垂直布局对象</span></span><br><span class="line">    QVBoxLayout* vlayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">11</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建标签对象</span></span><br><span class="line">        QLabel* pic = <span class="keyword">new</span> QLabel;</span><br><span class="line">        <span class="comment">// 拼接图片在资源文件中的路径</span></span><br><span class="line">        QString name = <span class="built_in">QString</span>(<span class="string">&quot;:/images/%1.png&quot;</span>).<span class="built_in">arg</span>(i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 给标签对象设置显示的图片</span></span><br><span class="line">        pic-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(name));</span><br><span class="line">        <span class="comment">// 设置图片在便签内部的对其方式</span></span><br><span class="line">        pic-&gt;<span class="built_in">setAlignment</span>(Qt::AlignHCenter);</span><br><span class="line">        <span class="comment">// 将标签添加到垂直布局中</span></span><br><span class="line">        vlayout-&gt;<span class="built_in">addWidget</span>(pic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个窗口对象</span></span><br><span class="line">    QWidget* wg = <span class="keyword">new</span> QWidget;</span><br><span class="line">    <span class="comment">// 将垂直布局设置给窗口对象</span></span><br><span class="line">    wg-&gt;<span class="built_in">setLayout</span>(vlayout);</span><br><span class="line">    <span class="comment">// 将带有垂直布局的窗口设置到滚动区域中</span></span><br><span class="line">    ui-&gt;scrollArea-&gt;<span class="built_in">setWidget</span>(wg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230816140310271.png" class="" title="image-20230816140310271"><h3 id="Toolbox（item）"><a href="#Toolbox（item）" class="headerlink" title="Toolbox（item）"></a>Toolbox（item）</h3><img src="/post/2095ef6d/image-20230816221109227.png" class="" title="image-20230816221109227"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QToolBox::<span class="built_in">QToolBox</span>(QWidget *parent = Q_NULLPTR, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">addItem(), insertItem()函数相关参数:</span></span><br><span class="line"><span class="comment">    - widget: 添加到工具箱中的选项卡对应的子窗口对象</span></span><br><span class="line"><span class="comment">    - icon: 工具箱新的选项卡上显示的图标</span></span><br><span class="line"><span class="comment">    - text: 工具箱新的选项卡上显示的标题</span></span><br><span class="line"><span class="comment">    - index: 指定在工具箱中插入的新的选项卡的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 给工具箱尾部添加一个选项卡, 每个选项卡在工具箱中就是一个子窗口, 即参数widget</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::addItem</span><span class="params">(QWidget *widget, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::addItem</span><span class="params">(QWidget *widget, <span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="comment">// 在工具箱的指定位置添加一个选项卡, 即添加一个子窗口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::insertItem</span><span class="params">(<span class="type">int</span> index, QWidget *widget, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::insertItem</span><span class="params">(<span class="type">int</span> index, QWidget *widget, <span class="type">const</span> QIcon &amp;icon, </span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> QString &amp;text )</span></span>;</span><br><span class="line"><span class="comment">// 移除工具箱中索引index位置对应的选项卡, 注意: 只是移除对应的窗口对象并没有被销毁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QToolBox::removeItem</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置索引index位置的选项卡是否可用, 参数 enabled=true为可用, enabled=false为禁用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QToolBox::setItemEnabled</span><span class="params">(<span class="type">int</span> index, <span class="type">bool</span> enabled)</span></span>;</span><br><span class="line"><span class="comment">// 设置工具箱中index位置选项卡的图标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QToolBox::setItemIcon</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"><span class="comment">// 设置工具箱中index位置选项卡的标题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QToolBox::setItemText</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置工具箱中index位置选项卡的提示信息(需要鼠标在选项卡上悬停一定时长才能显示)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QToolBox::setItemToolTip</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> QString &amp;toolTip)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果位置索引的项已启用，则返回true;否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QToolBox::isItemEnabled</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回位置索引处项目的图标，如果索引超出范围，则返回空图标。</span></span><br><span class="line"><span class="function">QIcon <span class="title">QToolBox::itemIcon</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回位于位置索引处的项的文本，如果索引超出范围，则返回空字符串。</span></span><br><span class="line"><span class="function">QString <span class="title">QToolBox::itemText</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回位于位置索引处的项的工具提示，如果索引超出范围，则返回空字符串。</span></span><br><span class="line"><span class="function">QString <span class="title">QToolBox::itemToolTip</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到当前工具箱中显示的选项卡对应的索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::currentIndex</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回指向当前选项卡对应的子窗口的指针，如果没有这样的项，则返回0。</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QToolBox::currentWidget</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回工具箱中子窗口的索引，如果widget对象不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::indexOf</span><span class="params">(QWidget *widget)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回工具箱中包含的项的数量。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号</span></span><br><span class="line"><span class="comment">// 工具箱中当前显示的选项卡发生变化, 该信号被发射, index为当前显示的新的选项卡的对应的索引</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QToolBox::currentChanged</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 槽函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过工具箱中选项卡对应的索引设置当前要显示哪一个选项卡中的子窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QToolBox::setCurrentIndex</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过工具箱中选项卡对应的子窗口对象设置当前要显示哪一个选项卡中的子窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QToolBox::setCurrentWidget</span><span class="params">(QWidget *widget)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QToolBox *tb=<span class="keyword">new</span> <span class="built_in">QToolBox</span>(<span class="keyword">this</span>);</span><br><span class="line">    QWidget *w1=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    QHBoxLayout *bj=<span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>(<span class="keyword">this</span>);</span><br><span class="line">    QPushButton *btn1=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮1&quot;</span>);</span><br><span class="line">    QPushButton *btn2=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮2&quot;</span>);</span><br><span class="line">    QPushButton *btn3=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮3&quot;</span>);</span><br><span class="line">    bj-&gt;<span class="built_in">addWidget</span>(btn1);</span><br><span class="line">    bj-&gt;<span class="built_in">addWidget</span>(btn2);</span><br><span class="line">    bj-&gt;<span class="built_in">addWidget</span>(btn3);</span><br><span class="line">    w1-&gt;<span class="built_in">setLayout</span>(bj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QWidget *w2=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">    QWidget *w3=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">    QWidget *w4=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选项卡就是一个子窗口，通过布局设置自定义窗口</span></span><br><span class="line">    tb-&gt;<span class="built_in">addItem</span>(w1,<span class="string">&quot;选项卡1&quot;</span>);</span><br><span class="line">    tb-&gt;<span class="built_in">addItem</span>(w2,<span class="string">&quot;选项卡2&quot;</span>);</span><br><span class="line">    tb-&gt;<span class="built_in">addItem</span>(w3,<span class="string">&quot;选项卡3&quot;</span>);</span><br><span class="line">    <span class="comment">//插入在index的位置</span></span><br><span class="line">    tb-&gt;<span class="built_in">insertItem</span>(<span class="number">0</span>,w4,<span class="string">&quot;我是插入进来的&quot;</span>);</span><br><span class="line">    <span class="comment">//移除index位置的选项卡，但是并没有销毁这个选项卡。</span></span><br><span class="line">    tb-&gt;<span class="built_in">removeItem</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span> w1;</span><br><span class="line">    <span class="comment">//Qt 使用了自动内存管理机制，即对象树（object tree）机制。根据对象树机制，当一个对象作为另一个对象的子对象时，父对象负责管理子对象的生命周期。当父对象被销毁时，它会自动销毁其所有子对象。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在你的代码中，bj 布局的父对象对象是 w1 ，因此在 w1 被销毁时，bj 会负责销毁其中的按钮对象 btn1、btn2 和 btn3。这意味着你不需要手动删除这些按钮对象，它们会在适当的时候自动被销毁。</span></span><br><span class="line"></span><br><span class="line">    tb-&gt;<span class="built_in">setFixedSize</span>(<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全部都不能用了</span></span><br><span class="line"><span class="comment">//    tb-&gt;setEnabled(false);</span></span><br><span class="line">    <span class="comment">//限制具体的选项卡</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    tb-&gt;setItemEnabled(1,false);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    tb-&gt;setItemIcon();</span></span><br><span class="line"><span class="comment">//    tb-&gt;setItemText();</span></span><br><span class="line">    tb-&gt;<span class="built_in">setItemToolTip</span>(<span class="number">2</span>,<span class="string">&quot;我是牛马&quot;</span>);</span><br><span class="line">    tb-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//获取默认打开的选项卡的对象和下标</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;tb-&gt;<span class="built_in">currentWidget</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;tb-&gt;<span class="built_in">currentIndex</span>();</span><br><span class="line">    <span class="comment">//得到子窗口的下标</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;tb-&gt;<span class="built_in">indexOf</span>(w3);</span><br><span class="line">    <span class="comment">//得到现存的选项卡的数量</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;tb-&gt;<span class="built_in">count</span>();</span><br><span class="line"><span class="comment">//    QToolBox::currentChanged(int)</span></span><br><span class="line">    <span class="built_in">void</span> (QToolBox::*s)(<span class="type">int</span>)=&amp;QToolBox::currentChanged;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(tb,s,<span class="keyword">this</span>,[=](<span class="type">int</span> index)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;新年好&quot;</span>&lt;&lt;index;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Qt 使用了自动内存管理机制，即对象树（object tree）机制。根据对象树机制，当一个对象作为另一个对象的子对象时，父对象负责管理子对象的生命周期。当父对象被销毁时，它会自动销毁其所有子对象。</p><p>在你的代码中，<code>bj</code> 布局对象是 <code>w1</code> 的父对象，因此在 <code>w1</code> 被销毁时，<code>bj</code> 会负责销毁其中的按钮对象 <code>btn1</code>、<code>btn2</code> 和 <code>btn3</code>。这意味着你不需要手动删除这些按钮对象，它们会在适当的时候自动被销毁。</p><p>qtool属性设置</p><img src="/post/2095ef6d/image-20230817105510340.png" class="" title="image-20230817105510340"><h3 id="Tabwidget-tab"><a href="#Tabwidget-tab" class="headerlink" title="Tabwidget(tab)"></a>Tabwidget(tab)</h3><img src="/post/2095ef6d/image-20230817105534856.png" class="" title="image-20230817105534856"><img src="/post/2095ef6d/image-20230817105556763.png" class="" title="image-20230817105556763"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QTabWidget::<span class="built_in">QTabWidget</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">添加选项卡addTab()或者插入选项卡insertTab()函数相关的参数如下:</span></span><br><span class="line"><span class="comment">    - page: 添加或者插入的选项卡对应的窗口实例对象</span></span><br><span class="line"><span class="comment">    - label: 添加或者插入的选项卡的标题</span></span><br><span class="line"><span class="comment">    - icon: 添加或者插入的选项卡的图标</span></span><br><span class="line"><span class="comment">    - index: 将新的选项卡插入到索引index的位置上</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTabWidget::addTab</span><span class="params">(QWidget *page, <span class="type">const</span> QString &amp;label)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTabWidget::addTab</span><span class="params">(QWidget *page, <span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;label)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTabWidget::insertTab</span><span class="params">(<span class="type">int</span> index, QWidget *page, <span class="type">const</span> QString &amp;label)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTabWidget::insertTab</span><span class="params">(<span class="type">int</span> index, QWidget *page, </span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;label)</span></span>;</span><br><span class="line"><span class="comment">// 删除index位置的选项卡</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::removeTab</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到选项卡栏中的选项卡的数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 从窗口中移除所有页面，但不删除它们。调用这个函数相当于调用removeTab()，直到选项卡小部件为空为止。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取当前选项卡对应的索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTabWidget::currentIndex</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前选项卡对应的窗口对象地址</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QTabWidget::currentWidget</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回索引位置为index的选项卡页，如果索引超出范围则返回0。</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QTabWidget::widget</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">标签上显示的文本样式为枚举类型 Qt::TextElideMode, 可选项为:</span></span><br><span class="line"><span class="comment">    - Qt::ElideLeft: 省略号应出现在课文的开头，例如：.....是的,我很帅。</span></span><br><span class="line"><span class="comment">    - Qt::ElideRight: 省略号应出现在文本的末尾，例如：我帅吗.....。</span></span><br><span class="line"><span class="comment">    - Qt::ElideMiddle: 省略号应出现在文本的中间，例如：我帅.....很帅。</span></span><br><span class="line"><span class="comment">    - Qt::ElideNone: 省略号不应出现在文本中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 获取标签上显示的文本模式</span></span><br><span class="line"><span class="function">Qt::TextElideMode <span class="title">QTabWidget::elideMode</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 如何省略标签栏中的文本, 此属性控制在给定的选项卡栏大小没有足够的空间显示项时如何省略项。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setElideMode</span><span class="params">(Qt::TextElideMode)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 得到选项卡上图标的尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">QTabWidget::iconSize</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="comment">// 设置选项卡上显示的图标大小</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setIconSize</span><span class="params">(<span class="type">const</span> QSize &amp;size)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 判断用户是否可以在选项卡区域内移动选项卡, 可以返回true, 否则返回false</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTabWidget::isMovable</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 此属性用于设置用户是否可以在选项卡区域内移动选项卡。默认情况下，此属性为false;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setMovable</span><span class="params">(<span class="type">bool</span> movable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断选项卡是否可以自动隐藏, 如果可以自动隐藏返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTabWidget::tabBarAutoHide</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 如果为true，则当选项卡栏包含少于2个选项卡时，它将自动隐藏。默认情况下，此属性为false。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabBarAutoHide</span><span class="params">(<span class="type">bool</span> enabled)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断index对应的选项卡是否是被启用的, 如果是被启用的返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTabWidget::isTabEnabled</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 如果enable为true，则在索引位置的页面是启用的;否则，在位置索引处的页面将被禁用。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabEnabled</span><span class="params">(<span class="type">int</span> index, <span class="type">bool</span> enable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到index位置的标签对应的图标</span></span><br><span class="line"><span class="function">QIcon <span class="title">QTabWidget::tabIcon</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 在位置索引处设置标签的图标。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabIcon</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">选项卡标签的位置通过枚举值进行指定, 可使用的选项如下:</span></span><br><span class="line"><span class="comment">- QTabWidget::North: 北(上), 默认</span></span><br><span class="line"><span class="comment">- QTabWidget::South: 南(下)</span></span><br><span class="line"><span class="comment">- QTabWidget::West: 西(左)</span></span><br><span class="line"><span class="comment">- QTabWidget::East:  东(右)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 得到选项卡中显示的标签的位置, 即: 东, 西, 南, 北</span></span><br><span class="line"><span class="function">TabPosition <span class="title">QTabWidget::tabPosition</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置选项卡中标签显示的位置, 默认情况下，此属性设置为North。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabPosition</span><span class="params">(TabPosition)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">选项卡标签的形状通过枚举值进行指定, 可使用的选项如下:</span></span><br><span class="line"><span class="comment">- QTabWidget::Rounded: 标签以圆形的外观绘制。这是默认形状</span></span><br><span class="line"><span class="comment">- QTabWidget::Triangular: 选项卡以三角形外观绘制。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 获得选项卡标签的形状</span></span><br><span class="line"><span class="function">TabShape <span class="title">QTabWidget::tabShape</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置选项卡标签的形状</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabShape</span><span class="params">(TabShape s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到index位置的标签的标题</span></span><br><span class="line"><span class="function">QString <span class="title">QTabWidget::tabText</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置选项卡index位置的标签的标题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabText</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> QString &amp;label)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取index对应的标签页上设置的提示信息</span></span><br><span class="line"><span class="function">QString <span class="title">QTabWidget::tabToolTip</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置选项卡index位置的标签的提示信息(鼠标需要悬停在标签上一定时长才能显示)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabToolTip</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> QString &amp;tip)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断选项卡标签也上是否有关闭按钮, 如果有返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTabWidget::tabsClosable</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置选项卡的标签页上是否显示关闭按钮, 该属性默认情况下为false</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabsClosable</span><span class="params">(<span class="type">bool</span> closeable)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断选项卡栏中是否有滚动按钮, 如果有返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTabWidget::usesScrollButtons</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置选项卡栏有许多标签时，它是否应该使用按钮来滚动标签。</span></span><br><span class="line"><span class="comment">// 当一个选项卡栏有太多的标签时，选项卡栏可以选择扩大它的大小，或者添加按钮，让标签在选项卡栏中滚动。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setUsesScrollButtons</span><span class="params">(<span class="type">bool</span> useButtons)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断窗口是否设置了文档模式, 如果设置了返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTabWidget::documentMode</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 此属性保存选项卡小部件是否以适合文档页面的模式呈现。这与macOS上的文档模式相同。</span></span><br><span class="line"><span class="comment">// 不设置该属性, QTabWidget窗口是带边框的, 如果设置了该属性边框就没有了。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setDocumentMode</span><span class="params">(<span class="type">bool</span> set)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QTabWidget *tw=<span class="keyword">new</span> <span class="built_in">QTabWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">    tw-&gt;<span class="built_in">setFixedSize</span>(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">    QHBoxLayout *bj=<span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    QPushButton *btn1=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮1&quot;</span>);</span><br><span class="line">     QPushButton *btn2=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮2&quot;</span>);</span><br><span class="line">      QPushButton *btn3=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮3&quot;</span>);</span><br><span class="line">     bj-&gt;<span class="built_in">addWidget</span>(btn1);</span><br><span class="line">     bj-&gt;<span class="built_in">addWidget</span>(btn2);</span><br><span class="line">     bj-&gt;<span class="built_in">addWidget</span>(btn3);</span><br><span class="line"></span><br><span class="line">     QWidget *w1=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">     QWidget *w2=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">     QWidget *w3=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">      QWidget *w4=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">      QWidget *w5=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">       QWidget *w6=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//     w3-&gt;setLayout(bj);</span></span><br><span class="line"><span class="comment">//     在你的代码中，你尝试将 bj 布局对象同时设置给了 w1 和 w3，这是不正确的。一个布局对象只能被设置给一个父部件，否则会导致布局对象的所有权问题。</span></span><br><span class="line">     w1-&gt;<span class="built_in">setLayout</span>(bj);</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">     tw-&gt;<span class="built_in">addTab</span>(w1,<span class="string">&quot;111&quot;</span>);</span><br><span class="line">     tw-&gt;<span class="built_in">addTab</span>(w2,<span class="string">&quot;222&quot;</span>);</span><br><span class="line">     tw-&gt;<span class="built_in">addTab</span>(w4,<span class="string">&quot;222&quot;</span>);</span><br><span class="line">     tw-&gt;<span class="built_in">addTab</span>(w5,<span class="string">&quot;222&quot;</span>);</span><br><span class="line">     tw-&gt;<span class="built_in">addTab</span>(w6,<span class="string">&quot;222&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     tw-&gt;<span class="built_in">insertTab</span>(<span class="number">1</span>,w3,<span class="string">&quot;333&quot;</span>);</span><br><span class="line">     <span class="comment">//插入到下标为index的位置</span></span><br><span class="line">     tw-&gt;<span class="built_in">removeTab</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//     delete w3;</span></span><br><span class="line"></span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">count</span>();</span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">currentIndex</span>();</span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">currentWidget</span>();</span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">elideMode</span>();</span><br><span class="line"><span class="comment">//设置当文本不适合的时候省略号出现的位置</span></span><br><span class="line">     tw-&gt;<span class="built_in">setElideMode</span>(Qt::ElideMiddle);</span><br><span class="line"><span class="comment">//     Qt::ElideLeft（值为0）表示省略号应该出现在文本的开头。</span></span><br><span class="line"><span class="comment">//     Qt::ElideRight（值为1）表示省略号应该出现在文本的末尾。</span></span><br><span class="line"><span class="comment">//     Qt::ElideMiddle（值为2）表示省略号应该出现在文本的中间。</span></span><br><span class="line"><span class="comment">//     Qt::ElideNone（值为3）表示省略号不应该出现在文本中。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">//设置具体的选项卡的icon</span></span><br><span class="line">     tw-&gt;<span class="built_in">setTabIcon</span>(<span class="number">0</span>,<span class="built_in">QIcon</span>(<span class="string">&quot;://D:/icon/hig.png&quot;</span>));</span><br><span class="line">     <span class="comment">//设置所有选项卡的icon的尺寸</span></span><br><span class="line">     tw-&gt;<span class="built_in">setIconSize</span>(<span class="built_in">QSize</span>(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="comment">//得到具体位置的icon的信息</span></span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">tabIcon</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">isMovable</span>();</span><br><span class="line">     <span class="comment">//是指选项卡的移动，不是整个tab移动</span></span><br><span class="line"></span><br><span class="line">     tw-&gt;<span class="built_in">setMovable</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">tabBarAutoHide</span>();</span><br><span class="line"><span class="comment">//     tw-&gt;setTabBarAutoHide(true);</span></span><br><span class="line">     <span class="comment">//选项卡只有一个的时候会隐藏掉上面的选项卡栏</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     tw-&gt;removeTab(1);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">isTabEnabled</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//设置具体选项卡的权限</span></span><br><span class="line">     tw-&gt;<span class="built_in">setTabEnabled</span>(<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">tabPosition</span>();</span><br><span class="line">     <span class="comment">//设置选项卡的方向，东南西北</span></span><br><span class="line">     tw-&gt;<span class="built_in">setTabPosition</span>(QTabWidget::East);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">tabShape</span>();</span><br><span class="line">     tw-&gt;<span class="built_in">setTabShape</span>(QTabWidget::Triangular);</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标悬浮在上面的时候tooltip</span></span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">tabToolTip</span>(<span class="number">0</span>);</span><br><span class="line">     tw-&gt;<span class="built_in">setTabToolTip</span>(<span class="number">0</span>,<span class="string">&quot;选项阿卡！@！#@##@#&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//给选项卡添加关闭按钮</span></span><br><span class="line">     tw-&gt;<span class="built_in">setTabsClosable</span>(<span class="literal">true</span>);</span><br><span class="line">          <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">tabsClosable</span>();</span><br><span class="line">     tw-&gt;<span class="built_in">setTabEnabled</span>(<span class="number">1</span>,<span class="literal">true</span>);</span><br><span class="line">\</span><br><span class="line">      <span class="comment">//设置</span></span><br><span class="line">     tw-&gt;<span class="built_in">setUsesScrollButtons</span>(<span class="literal">false</span>);</span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">usesScrollButtons</span>();</span><br><span class="line"></span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">documentMode</span>();</span><br><span class="line">     <span class="comment">//设置了文档模式就没有了边框</span></span><br><span class="line">     tw-&gt;<span class="built_in">setDocumentMode</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     tw-&gt;<span class="built_in">setCurrentWidget</span>(w1);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">connect</span>(tw,&amp;QTabWidget::tabCloseRequested,<span class="keyword">this</span>,[=](<span class="type">int</span> index)&#123;</span><br><span class="line">         tw-&gt;<span class="built_in">removeTab</span>(index);</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">connect</span>(tw,&amp;QTabWidget::tabBarClicked,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">         <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;单击&quot;</span>;</span><br><span class="line"></span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="built_in">connect</span>(tw,&amp;QTabWidget::tabBarDoubleClicked,<span class="keyword">this</span>,[=](<span class="type">int</span> index)&#123;</span><br><span class="line">         <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;双击&quot;</span>;</span><br><span class="line">         tw-&gt;<span class="built_in">removeTab</span>(index);</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230817145000425.png" class="" title="image-20230817145000425"><img src="/post/2095ef6d/image-20230817143941679.png" class="" title="image-20230817143941679"><img src="/post/2095ef6d/image-20230817144054580.png" class="" title="image-20230817144054580"><h4 id="QQueue"><a href="#QQueue" class="headerlink" title="&#x3D;&#x3D;QQueue&#x3D;&#x3D;"></a>&#x3D;&#x3D;QQueue&#x3D;&#x3D;</h4><blockquote><p><code>QQueue</code> 是 Qt 提供的一个<strong>队列（queue）容器类</strong>，用于存储一系列的元素。它是一个<strong>先进先出（FIFO）的数据结构</strong>，类似于现实生活中的排队。在 <code>QQueue</code> 中，<strong>元素从队列的尾部添加，从队列的头部移除</strong>。</p><p><code>QQueue</code> 是一个模板类，<strong>可以存储任意类型的元素</strong>。在你的代码中，<code>QQueue&lt;QWidget*&gt;</code> 表示一个存储 <code>QWidget*</code> 类型指针的队列，即存储 <code>QWidget</code> 对象的指针。</p><p>以下是一些常用的 <code>QQueue</code> 函数：</p><ul><li><code>enqueue(const T &amp;value)</code>：<strong>将元素添加到队列的尾部。</strong></li><li><code>dequeue()</code>：<strong>移除并返回队列头部的元素。</strong></li><li><code>head()</code>：<strong>返回队列头部的元素，但不会移除它。</strong></li><li><code>isEmpty()</code>：<strong>检查队列是否为空。</strong></li><li><code>size()</code>：<strong>返回队列中元素的数量。</strong></li></ul></blockquote><h3 id="Stacked-widget（addwidget）"><a href="#Stacked-widget（addwidget）" class="headerlink" title="Stacked widget（addwidget）"></a>Stacked widget（addwidget）</h3><img src="/post/2095ef6d/image-20230817162315762.png" class="" title="image-20230817162315762"><img src="/post/2095ef6d/image-20230817162347283.png" class="" title="image-20230817162347283"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QStackedWidget::<span class="built_in">QStackedWidget</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 在栈窗口中后边添加一个子窗口, 返回这个子窗口在栈窗口中的索引值(从0开始计数)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QStackedWidget::addWidget</span><span class="params">(QWidget *widget)</span></span>;</span><br><span class="line"><span class="comment">// 将子窗口widget插入到栈窗口的index位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QStackedWidget::insertWidget</span><span class="params">(<span class="type">int</span> index, QWidget *widget)</span></span>;</span><br><span class="line"><span class="comment">// 将子窗口widget从栈窗口中删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QStackedWidget::removeWidget</span><span class="params">(QWidget *widget)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回栈容器窗口中存储的子窗口的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QStackedWidget::count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到当前栈窗口中显示的子窗口的索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QStackedWidget::currentIndex</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到当前栈窗口中显示的子窗口的指针(窗口地址)</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QStackedWidget::currentWidget</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 基于索引index得到栈窗口中对应的子窗口的指针</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QStackedWidget::widget</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 基于子窗口的指针(实例地址)得到其在栈窗口中的索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QStackedWidget::indexOf</span><span class="params">(QWidget *widget)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 信号</span></span><br><span class="line"><span class="comment">// 切换栈窗口中显示子窗口, 该信息被发射出来, index为新的当前窗口对应的索引值</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QStackedWidget::currentChanged</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">// 当栈窗口的子窗口被删除, 该信号被发射出来, index为被删除的窗口对应的索引值</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QStackedWidget::widgetRemoved</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 槽函数</span></span><br><span class="line"><span class="comment">// 基于子窗口的index索引指定当前栈窗口中显示哪一个子窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QStackedWidget::setCurrentIndex</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QStackedWidget::setCurrentWidget</span><span class="params">(QWidget *widget)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">QStackedWidget *sw=<span class="keyword">new</span> <span class="built_in">QStackedWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">sw-&gt;<span class="built_in">setFixedSize</span>(<span class="number">400</span>,<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QHBoxLayout *bj=<span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">QPushButton *btn1=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮1&quot;</span>);</span><br><span class="line"> QPushButton *btn2=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮2&quot;</span>);</span><br><span class="line">  QPushButton *btn3=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮3&quot;</span>);</span><br><span class="line"> bj-&gt;<span class="built_in">addWidget</span>(btn1);</span><br><span class="line"> bj-&gt;<span class="built_in">addWidget</span>(btn2);</span><br><span class="line"> bj-&gt;<span class="built_in">addWidget</span>(btn3);</span><br><span class="line"></span><br><span class="line"> QWidget *w1=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> QWidget *w2=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"> w1-&gt;<span class="built_in">setLayout</span>(bj);</span><br><span class="line">          sw-&gt;<span class="built_in">addWidget</span>(w1);</span><br><span class="line">          sw-&gt;<span class="built_in">addWidget</span>(w2);</span><br><span class="line">                        <span class="built_in">qDebug</span>()&lt;&lt;sw-&gt;<span class="built_in">count</span>();</span><br><span class="line"> sw-&gt;<span class="built_in">setCurrentWidget</span>(w1);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;sw-&gt;<span class="built_in">currentIndex</span>();</span><br><span class="line"></span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;sw-&gt;<span class="built_in">widget</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;sw-&gt;<span class="built_in">indexOf</span>(w2);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230817163236990.png" class="" title="image-20230817163236990"><img src="/post/2095ef6d/image-20230817163341666.png" class="" title="image-20230817163341666"><img src="/post/2095ef6d/image-20230817164113991.png" class="" title="image-20230817164113991"><blockquote><p>可以在属性面板直接（添加页）,然后拖拽相应的 控件！！！所有控件都是他妈的容器</p></blockquote><h2 id="QT事件处理"><a href="#QT事件处理" class="headerlink" title="QT事件处理"></a>QT事件处理</h2><img src="/post/2095ef6d/image-20230818135346990.png" class="" title="image-20230818135346990"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">//框架内部开始事件检测了</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>事件在Qt中产生之后，的分发过程是这样的：</strong></p><ol><li><p>当事件产生之后，Qt使用用应用程序对象调用notify()(通知)函数将事件<strong>发送到指定的窗口</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">override</span> <span class="keyword">virtual</span>] <span class="function"><span class="type">bool</span> <span class="title">QApplication::notify</span><span class="params">(QObject *receiver, QEvent *e)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>事件在发送过程中可以通过事件<strong>过滤器进行过滤，默认不对任何产生的事件进行过滤。</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span>] <span class="function"><span class="type">bool</span> <span class="title">QObject::eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span></span><br></pre></td></tr></table></figure></li><li><p>当事件发送到指定窗口之后，窗口的<strong>事件分发器会对收到的事件进行分类:</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">override</span> <span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">bool</span> <span class="title">QWidget::event</span><span class="params">(QEvent *event)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>事件分发器会将分类之后的事件<strong>（鼠标事件、键盘事件、绘图事件。。。）</strong>&#x3D;&#x3D;分发给对应的事件处理器函数进行处理&#x3D;&#x3D;，每个<strong>事件处理器函数都有默认的处理动作（我们也可以重写这些事件处理器函数）</strong>，比如：鼠标事件：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 鼠标按下</span></span><br><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line"><span class="comment">// 鼠标释放</span></span><br><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line"><span class="comment">// 鼠标移动</span></span><br><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="事件处理器函数"><a href="#事件处理器函数" class="headerlink" title="事件处理器函数"></a>事件处理器函数</h3><img src="/post/2095ef6d/image-20230818140257416.png" class="" title="image-20230818140257416"><h4 id="鼠标事件mouse…-Event-特别2"><a href="#鼠标事件mouse…-Event-特别2" class="headerlink" title="鼠标事件mouse….Event,特别2"></a>鼠标事件mouse….Event,特别2</h4><blockquote><ol><li><h3 id="鼠标按下事件"><a href="#鼠标按下事件" class="headerlink" title="鼠标按下事件"></a>鼠标按下事件</h3><blockquote><p><strong>当鼠标左键、鼠标右键、鼠标中键被按下，该函数被&#x3D;&#x3D;自动调用&#x3D;&#x3D;<strong>，</strong>通过参数可以得到当前按下的是哪个鼠标键</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;event-&gt;<span class="built_in">button</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>()==Qt::RightButton)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="comment">//        Qt::RightButton</span></span><br><span class="line"><span class="comment">//            Qt::LeftButton</span></span><br><span class="line"><span class="comment">//            Qt::MiddleButtonq</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;event-&gt;<span class="built_in">position</span>();</span><br><span class="line">     <span class="comment">//设置一个菜单栏menu!+menubar</span></span><br><span class="line">     QMenu *bar=<span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="keyword">this</span>);</span><br><span class="line">     bar-&gt;<span class="built_in">addAction</span>(<span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;C++&quot;</span>));</span><br><span class="line">     bar-&gt;<span class="built_in">addAction</span>(<span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;Python&quot;</span>));</span><br><span class="line">     bar-&gt;<span class="built_in">addAction</span>(<span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;Javascript&quot;</span>));</span><br><span class="line">     <span class="comment">//        bar-&gt;show();</span></span><br><span class="line">     <span class="comment">//设置显示的位置，点击位置的右下角！</span></span><br><span class="line">     bar-&gt;<span class="built_in">exec</span>(QCursor::<span class="built_in">pos</span>());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><h3 id="鼠标释放事件"><a href="#鼠标释放事件" class="headerlink" title="鼠标释放事件"></a>鼠标释放事件</h3><blockquote><p>当鼠标左键、鼠标右键、鼠标中键被释放，该函数被自动调用，<strong>通过参数可以得到当前释放的是哪个鼠标键</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;event-&gt;<span class="built_in">button</span>();</span><br><span class="line"> <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>()==Qt::RightButton)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;你按下了右键&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上面的触发相比，只是触发时机不</p></blockquote></li><li><h3 id="鼠标移动事件"><a href="#鼠标移动事件" class="headerlink" title="鼠标移动事件"></a>鼠标移动事件</h3><blockquote><p>当鼠标移动（也可以按住一个或多个鼠标键移动），该函数被自动调用，通过参数可以得到在移动过程中哪些鼠标键被按下了。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> MainWindow:: <span class="built_in">mouseMoveEvent</span>(QMouseEvent *event)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;event-&gt;<span class="built_in">buttons</span>()&lt;&lt;<span class="string">&quot;经过&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><code>event-&gt;buttons()</code>：这是一个成员函数，用于获取鼠标移动事件发生时的鼠标按钮状态。它返回一个枚举值，表示当前按下的鼠标按钮。在 <code>qDebug()</code> 输出语句中，<strong>它将输出当前按钮状态。</strong></li><li><code>event-&gt;button()</code>：这也是一个成员函数，用于获取鼠标移动事件发生时的鼠标按钮。它返回一个枚举值，表示最后一次按下或释放的鼠标按钮。在 <code>qDebug()</code> 输出语句中，<strong>它将输出最后一次按下或释放的按钮。</strong></li></ol><p>所以，<code>event-&gt;buttons()</code> 输出的是当前按钮状态，而 <code>event-&gt;button()</code> 输出的是最后一次按下或释放的按钮。</p></blockquote></li><li><h3 id="鼠标双鸡事件"><a href="#鼠标双鸡事件" class="headerlink" title="鼠标双鸡事件"></a>鼠标双鸡事件</h3><blockquote><p>当鼠标双击该函数被调用，通过参数可以得到是通过哪个鼠标键进行了双击操作。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mouseDoubleClickEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::mouseDoubleClickEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;event-&gt;<span class="built_in">buttons</span>()&lt;&lt;<span class="string">&quot;双鸡了&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><h3 id="鼠标进入事件——————————————–"><a href="#鼠标进入事件——————————————–" class="headerlink" title="鼠标进入事件——————————————–"></a>鼠标进入事件——————————————–</h3><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::enterEvent</span><span class="params">(QEvent *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::enterEvent</span><span class="params">(QEnterEvent *event)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::enterEvent</span><span class="params">(QEnterEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;event-&gt;<span class="built_in">button</span>()&lt;&lt;<span class="string">&quot;大苏打&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::enterEvent</span><span class="params">(QEnterEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;dasdasd&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别注意一下，这里面不是qevent而是qenterevent</p></blockquote></li><li><h3 id="鼠标离开事件"><a href="#鼠标离开事件" class="headerlink" title="鼠标离开事件"></a>鼠标离开事件</h3><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::enterEvent</span><span class="params">(QEnterEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;dasdasd&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::leaveEvent</span><span class="params">(QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;移出去了&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><hr><p>&#x2F;&#x2F;    void mousePressEvent(QMouseEvent *event);<br>&#x2F;&#x2F;    void mouseReleaseEvent(QMouseEvent *event);<br>&#x2F;&#x2F;    void mouseMoveEvent(QMouseEvent *event);<br>&#x2F;&#x2F;    void mouseDoubleClickEvent(QMouseEvent *event);<br>&#x2F;&#x2F;    void enterEvent(QEnterEvent *event);<br>&#x2F;&#x2F;    void leaveEvent(QEvent *event);</p></li></ol></blockquote><h4 id="键盘事件key……Event"><a href="#键盘事件key……Event" class="headerlink" title="键盘事件key……Event"></a>键盘事件key……Event</h4><blockquote><ol><li><p>键盘按下事件</p><blockquote><p>当键盘上的按键被按下了，该函数被自动调用，通过参数可以得知按下的是哪个键。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::keyPressEvent</span><span class="params">(QKeyEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::keyPressEvent</span><span class="params">(QKeyEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;event-&gt;<span class="built_in">key</span>()&lt;&lt;<span class="string">&quot;被按下了&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>键盘释放事件</p><blockquote><p>当键盘上的按键被释放了，该函数被自动调用，通过参数可以得知释放的是哪个键。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::keyReleaseEvent</span><span class="params">(QKeyEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::keyReleaseEvent</span><span class="params">(QKeyEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;event-&gt;<span class="built_in">key</span>()&lt;&lt;<span class="string">&quot;被按下了&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230820101016537.png" class="" title="image-20230820101016537"></blockquote></li></ol></blockquote><h4 id="窗口重绘事件paintEvent"><a href="#窗口重绘事件paintEvent" class="headerlink" title="窗口重绘事件paintEvent"></a>窗口重绘事件paintEvent</h4><blockquote><p>当窗口需要刷新的时候，该函数就会自动被调用。窗口需要刷新的情景很多，比如：<strong>窗口大小发生变化，窗口显示等，另外我们还可以通过该函数给窗口绘制背景图</strong>，总之这是一个需要经常被重写的一个事件处理器函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::paintEvent</span><span class="params">(QPaintEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::paintEvent</span><span class="params">(QPaintEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    event-&gt;type();</span></span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;窗口他妈重绘了！！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>窗口的缩放，打开，都有</p></blockquote><h4 id="窗口关闭事件closeEvent"><a href="#窗口关闭事件closeEvent" class="headerlink" title="窗口关闭事件closeEvent"></a>窗口关闭事件closeEvent</h4><blockquote><p>当窗口标题栏的<strong>关闭按钮被按下并且在窗口关闭之前该函数被调用</strong>，可以通过该函数控制窗口是否被关闭。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::closeEvent</span><span class="params">(QCloseEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::closeEvent</span><span class="params">(QCloseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//在点击了关闭按钮之后，窗口关闭之前，这个函数被调用</span></span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;窗口被关闭；了啊&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="重置窗口大小事件resize-Event"><a href="#重置窗口大小事件resize-Event" class="headerlink" title="重置窗口大小事件resize Event"></a>重置窗口大小事件resize Event</h4><blockquote><pre><code>    当窗口的大小发生变化，该函数被调用。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::resizeEvent</span><span class="params">(QResizeEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::resizeEvent</span><span class="params">(QResizeEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;我去&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当窗口的大小发生变化，该函数被调用。</code></pre></blockquote><p>&#x2F;&#x2F;    void keyPressEvent(QKeyEvent *event);<br>&#x2F;&#x2F;    void keyReleaseEvent(QKeyEvent *event);<br>&#x2F;&#x2F;    void paintEvent(QPaintEvent *event);<br>&#x2F;&#x2F;    void closeEvent(QCloseEvent *event);<br>&#x2F;&#x2F;    void resizeEvent(QResizeEvent *event);</p><hr><h4 id="以上总结的规律"><a href="#以上总结的规律" class="headerlink" title="以上总结的规律"></a>以上总结的规律</h4><p>除此之外，关于Qt窗口提供的其他事件处理器函数还有很多，感兴趣的话可以仔细阅读Qt的帮助文档，窗口的事件处理器函数非常好找，规律是这样的：</p><blockquote><p><strong>受保护的虚函数</strong><br>函数名分为两部分: <strong>事件描述+Event</strong><br><strong>函数带一个事件类型的参数</strong></p></blockquote><h4 id="重写得到你自己的方案"><a href="#重写得到你自己的方案" class="headerlink" title="重写得到你自己的方案"></a>重写得到你自己的方案</h4><img src="/post/2095ef6d/image-20230818155940410.png" class="" title="image-20230818155940410"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>(<span class="number">828</span>,<span class="number">509</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">MainWindow::closeEvent</span><span class="params">(QCloseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=QMessageBox::<span class="built_in">question</span>(<span class="keyword">this</span>,<span class="string">&quot;信息&quot;</span>,<span class="string">&quot;你确定要关闭吗&quot;</span>,QMessageBox::Yes|QMessageBox::No);</span><br><span class="line">    <span class="keyword">if</span>(ret==QMessageBox::Yes)</span><br><span class="line">    &#123;</span><br><span class="line">        event-&gt;<span class="built_in">accept</span>();</span><br><span class="line"><span class="comment">//        event-&gt;ignore();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        event-&gt;<span class="built_in">ignore</span>();</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>,<span class="string">&quot;!&quot;</span>,<span class="string">&quot;干嘛想要干我&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::resizeEvent</span><span class="params">(QResizeEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;老的尺寸&quot;</span>&lt;&lt;event-&gt;<span class="built_in">oldSize</span>()&lt;&lt;<span class="string">&quot;新的尺寸&quot;</span>&lt;&lt;event-&gt;<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230818161109114.png" class="" title="image-20230818161109114"><img src="/post/2095ef6d/image-20230818161127925.png" class="" title="image-20230818161127925"><h3 id="自定义按钮"><a href="#自定义按钮" class="headerlink" title="自定义按钮"></a>自定义按钮</h3><img src="/post/2095ef6d/image-20230818161233519.png" class="" title="image-20230818161233519"><p>在Qt中，<code>p.drawPixmap(rect(), img)</code> 是用于在绘图设备上绘制一个图片的函数调用。</p><p><code>p</code> 是一个绘图设备（通常是一个 <code>QPainter</code> 对象），用于在其上进行绘制操作。</p><p><code>drawPixmap()</code> 是 <code>QPainter</code> 类的成员函数，用于绘制一个 <code>QPixmap</code> 对象或者其子类的图像。</p><p><strong><code>rect()</code> 是一个成员函数，用于获取当前对象的矩形区域。在这个上下文中，<code>rect()</code> 是 <code>QWidget</code> 类的成员函数，用于获取 <code>QWidget</code> 对象的矩形区域。</strong></p><p>所以，<code>rect()</code> 返回了一个描述当前 <code>QWidget</code> 对象矩形区域的 <code>QRect</code> 对象。</p><p>在 <code>p.drawPixmap(rect(), img)</code> 中，<code>rect()</code> 返回的矩形区域作为绘制的目标区域，**<code>img</code> 是要绘制的图片对象。**</p><p>这样的调用将在绘图设备上绘制 <code>img</code> 图片对象，绘制的区域为当前 <code>QWidget</code> 对象的矩形区域。</p><img src="/post/2095ef6d/image-20230818171009657.png" class="" title="image-20230818171009657"><h4 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mybutton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line">mybutton::<span class="built_in">mybutton</span>(QWidget *parent)</span><br><span class="line">    : QWidget&#123;parent&#125;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    img.<span class="built_in">load</span>(<span class="string">&quot;://D:/sucai/girl1.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">setFixedSize</span>(<span class="number">500</span>,<span class="number">800</span>);</span><br><span class="line">    <span class="comment">//提升，相当于把父类当成子类，</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mybutton::mousePressEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">img.<span class="built_in">load</span>(<span class="string">&quot;://D:/sucai/girl2.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//相当于手动刷新</span></span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mybutton::mouseReleaseEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">img.<span class="built_in">load</span>(<span class="string">&quot;://D:/sucai/girl3.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mybutton::enterEvent</span><span class="params">(QEnterEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">img.<span class="built_in">load</span>(<span class="string">&quot;://D:/sucai/girl7.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mybutton::leaveEvent</span><span class="params">(QEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">img.<span class="built_in">load</span>(<span class="string">&quot;://D:/sucai/girl6.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mybutton::paintEvent</span><span class="params">(QPaintEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(),img);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYBUTTON_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYBUTTON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mybutton</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">mybutton</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setImage</span><span class="params">(QString normal, QString hover, QString pressed)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent* ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent* ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enterEvent</span><span class="params">(QEnterEvent* ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">leaveEvent</span><span class="params">(QEvent* ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span></span>;</span><br><span class="line">    <span class="comment">//qt框架调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要自己写信号发射</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPixmap m_normal;</span><br><span class="line">    QPixmap img;</span><br><span class="line">    QPixmap m_press;</span><br><span class="line">    QPixmap m_hover;</span><br><span class="line"><span class="comment">//    qpixmap专注于显示，效率更高，qimg是像素级别的修改，绘图</span></span><br><span class="line"><span class="comment">//    都能用于显示</span></span><br><span class="line"><span class="comment">//    QPixmap(const QString &amp;fileName, const char *format = nullptr)</span></span><br><span class="line"><span class="comment">//    加在磁盘图片</span></span><br><span class="line"><span class="comment">//    或者load加载</span></span><br><span class="line">    QPixmap m_current;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYBUTTON_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>对于没有使用的函数参数有两种解决方案</p><ol><li><h3 id="Q-UNUSED-ev"><a href="#Q-UNUSED-ev" class="headerlink" title="Q_UNUSED(ev);"></a>Q_UNUSED(ev);</h3><img src="/post/2095ef6d/image-20230819082950999.png" class="" title="image-20230819082950999"></li><li><h4 id="通过省略参数名，你告诉编译器你不会在函数体内使用该参数，这样就不会再收到未使用参数的警告。这是一种常见的做法，特别是在事件处理函数中，因为有些事件处理函数可能不需要使用事件对象的信息。"><a href="#通过省略参数名，你告诉编译器你不会在函数体内使用该参数，这样就不会再收到未使用参数的警告。这是一种常见的做法，特别是在事件处理函数中，因为有些事件处理函数可能不需要使用事件对象的信息。" class="headerlink" title="通过省略参数名，你告诉编译器你不会在函数体内使用该参数，这样就不会再收到未使用参数的警告。这是一种常见的做法，特别是在事件处理函数中，因为有些事件处理函数可能不需要使用事件对象的信息。"></a>通过省略参数名，你告诉编译器你不会在函数体内使用该参数，这样就不会再收到未使用参数的警告。这是一种常见的做法，特别是在事件处理函数中，因为有些事件处理函数可能不需要使用事件对象的信息。</h4><img src="/post/2095ef6d/image-20230819083020837.png" class="" title="image-20230819083020837"></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mybtn::mousePressEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    img.<span class="built_in">load</span>(<span class="string">&quot;://D:/sucai/girl5.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">    QPushButton::<span class="built_in">mousePressEvent</span>(ev);</span><br><span class="line">    <span class="function">emit <span class="title">clicked</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//    QPushButton::mouseReleaseEvent(ev);</span></span><br><span class="line"><span class="comment">//    在默认情况下，QPushButton 的 mousePressEvent() 函数会在鼠标按钮按下后发射 clicked() 信号，</span></span><br><span class="line"><span class="comment">//    并在鼠标按钮释放后再次发射 clicked() 信号。这是为了模拟按钮的点击效果。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230819092014059.png" class="" title="image-20230819092014059"><p>这样才能发射出父亲原来的信号</p><img src="/post/2095ef6d/image-20230819092044956.png" class="" title="image-20230819092044956"><p>qwidget窗口的特点指定父亲就内嵌进去了 </p><h4 id="案例！"><a href="#案例！" class="headerlink" title="案例！"></a>案例！</h4><ol><li><pre><code class="c++">ui-&gt;setupUi(this);Buterfly *win=new Buterfly(this);win-&gt;move((width()-win-&gt;width())/2,(height()-win-&gt;height())/2);<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```c++</span><br><span class="line">   #include &quot;buterfly.h&quot;</span><br><span class="line">   #include &lt;QPainter&gt;</span><br><span class="line">   Buterfly::Buterfly(QWidget *parent)</span><br><span class="line">       : QWidget&#123;parent&#125;</span><br><span class="line">   &#123;</span><br><span class="line">       img.load(&quot;:/1&quot;);</span><br><span class="line">       setFixedSize(img.size());</span><br><span class="line">       startTimer(100);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   void Buterfly::paintEvent(QPaintEvent *ev)</span><br><span class="line">   &#123;</span><br><span class="line">       QPainter p(this);</span><br><span class="line">       p.drawPixmap(rect(),img);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   void Buterfly::timerEvent(QTimerEvent *ev)</span><br><span class="line">   &#123;</span><br><span class="line">       //123</span><br><span class="line">       //</span><br><span class="line">       m++;</span><br><span class="line">       if(m==2)</span><br><span class="line">       &#123;</span><br><span class="line">           m=2;</span><br><span class="line">       &#125;</span><br><span class="line">       else if(m==3)</span><br><span class="line">       &#123;</span><br><span class="line">           m=3;</span><br><span class="line">       &#125;</span><br><span class="line">       else if(m==4)</span><br><span class="line">       &#123;</span><br><span class="line">           m=4;</span><br><span class="line">       &#125;</span><br><span class="line">       else</span><br><span class="line">           m=1;</span><br><span class="line">       QString name=QString(&quot;:%1&quot;).arg(m);</span><br><span class="line">       img.load(name);</span><br><span class="line">       update();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="c++">#ifndef BUTERFLY_H#define BUTERFLY_H#include &lt;QWidget&gt;class Buterfly : public QWidget&#123;    Q_OBJECTpublic:    explicit Buterfly(QWidget *parent = nullptr);protected:    void paintEvent(QPaintEvent *ev);    void timerEvent(QTimerEvent *ev);private:    QPixmap img;    int m=1;&#125;;#endif // BUTERFLY_H<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20230819100809654.png image-20230819100809654 %&#125;</span><br><span class="line"></span><br><span class="line">&gt; 222222222222222222</span><br><span class="line"></span><br><span class="line">###### 2.73逻辑运算符-与或非-</span><br><span class="line"></span><br><span class="line">1. 与and   **==第一个为0就返回0，第一个为1就返回第二个操作数==**</span><br><span class="line"></span><br><span class="line">2. ###### 或or   ==第一个为1就返回1，第一个为0就返回第二个操作数==</span><br><span class="line"></span><br><span class="line">3. 根据第一个操作数的真假来确定是否返回第二个操作数</span><br><span class="line"></span><br><span class="line">4. 非not</span><br><span class="line"></span><br><span class="line">5. ==注意逻辑运算符左右不能直接与操作数直接接触==</span><br><span class="line"></span><br><span class="line">`if(ev-&gt;buttons() &amp; Qt::LeftButton)` 是一个条件判断语句，用于检查鼠标事件中的按钮状态。</span><br><span class="line"></span><br><span class="line">`ev-&gt;buttons()` 返回一个表示当前鼠标按钮状态的整数值。`Qt::LeftButton` 是一个常量，表示鼠标左键。</span><br><span class="line"></span><br><span class="line">通过使用位运算符 `&amp;`，将 `ev-&gt;buttons()` 和 `Qt::LeftButton` 进行按位与运算。如果结果为非零值，则表示鼠标左键处于按下状态。</span><br><span class="line"></span><br><span class="line">因此，`if(ev-&gt;buttons() &amp; Qt::LeftButton)` 的意思是，如果鼠标左键处于按下状态，就执行 `if` 语句块中的代码。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">void Buterfly::mousePressEvent(QMouseEvent *ev)</span><br><span class="line">&#123;</span><br><span class="line">    //得到一个非零的数，然后与操作，就相当于看后面的数据了</span><br><span class="line">    if(ev-&gt;button()==Qt::LeftButton)</span><br><span class="line">    &#123;</span><br><span class="line">        index=ev-&gt;globalPos()-this-&gt;geometry().topLeft();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Buterfly::mouseMoveEvent(QMouseEvent *ev)</span><br><span class="line">&#123;</span><br><span class="line">    if(ev-&gt;buttons()&amp;Qt::LeftButton)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;move(ev-&gt;globalPos()-index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ol><hr><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> setpx=QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">10</span>,<span class="number">50</span>);</span><br><span class="line"><span class="type">int</span> setpy=QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">10</span>,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> curx=<span class="keyword">this</span>-&gt;<span class="built_in">geometry</span>().<span class="built_in">topLeft</span>().<span class="built_in">x</span>()+setpx;</span><br><span class="line"><span class="type">int</span> cury=<span class="keyword">this</span>-&gt;<span class="built_in">geometry</span>().<span class="built_in">topLeft</span>().<span class="built_in">y</span>()+setpy;</span><br><span class="line"></span><br><span class="line">QScreen *screen = QGuiApplication::<span class="built_in">primaryScreen</span>();</span><br><span class="line"><span class="keyword">if</span>(curx&gt;=screen-&gt;<span class="built_in">geometry</span>().<span class="built_in">right</span>())</span><br><span class="line">&#123;</span><br><span class="line">    curx=screen-&gt;<span class="built_in">geometry</span>().<span class="built_in">left</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cury&gt;=screen-&gt;<span class="built_in">geometry</span>().<span class="built_in">bottom</span>())</span><br><span class="line">&#123;</span><br><span class="line">    cury=screen-&gt;<span class="built_in">geometry</span>().<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">move</span>(curx,cury);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现移动和边界处理</p><p>Mainwindow文件cpp</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;buterfly.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRandomGenerator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QScreen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCloseEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QInputDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//    this-&gt;setFixedSize(2560,1440);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//去掉边框</span></span><br><span class="line">    <span class="built_in">setWindowFlags</span>(<span class="built_in">windowFlags</span>()|Qt::FramelessWindowHint);</span><br><span class="line"><span class="comment">//设置窗口透明</span></span><br><span class="line">    <span class="built_in">setAttribute</span>(Qt::WA_TranslucentBackground);</span><br><span class="line"><span class="comment">//窗口最大化显示</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">showMaximized</span>();</span><br><span class="line">    QScreen *screen = QGuiApplication::<span class="built_in">primaryScreen</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;screen-&gt;<span class="built_in">geometry</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">25</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Buterfly *win=<span class="keyword">new</span> <span class="built_in">Buterfly</span>(<span class="keyword">this</span>);</span><br><span class="line">        win-&gt;<span class="built_in">move</span>(QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="keyword">this</span>-&gt;<span class="built_in">width</span>()),QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="keyword">this</span>-&gt;<span class="built_in">height</span>()));</span><br><span class="line">        win-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::closeEvent</span><span class="params">(QCloseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    ev-&gt;ignore;</span></span><br><span class="line">    ev-&gt;<span class="built_in">ignore</span>();</span><br><span class="line">    QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>,<span class="string">&quot;warning&quot;</span>,<span class="string">&quot;你真的以为你能关掉我嘛？&quot;</span>,QMessageBox::No);</span><br><span class="line"><span class="comment">//    int ret=QMessageBox::question(this,&quot;作答&quot;,&quot;4+4=?&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret=QInputDialog::<span class="built_in">getInt</span>(<span class="keyword">this</span>,<span class="string">&quot;作答&quot;</span>,<span class="string">&quot;4+4=?&quot;</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret!=<span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        ev-&gt;<span class="built_in">ignore</span>();</span><br><span class="line">        QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>,<span class="string">&quot;不对！&quot;</span>,<span class="string">&quot;再试试吧&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        ev-&gt;<span class="built_in">accept</span>();</span><br><span class="line">        QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>,<span class="string">&quot;恭喜!&quot;</span>,<span class="string">&quot;恭喜你答对了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>butfly.h</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUTERFLY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUTERFLY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buterfly</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Buterfly</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">timerEvent</span><span class="params">(QTimerEvent *ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent*ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enterEvent</span><span class="params">(QEnterEvent* ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">int</span> min,<span class="type">int</span> max)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPixmap img;</span><br><span class="line">    <span class="type">int</span> m=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    ----</span></span><br><span class="line">    QPoint index;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// BUTERFLY_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>butflycpp</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buterfly.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMouseEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRandomGenerator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QScreen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGuiApplication&gt;</span></span></span><br><span class="line">Buterfly::<span class="built_in">Buterfly</span>(QWidget *parent)</span><br><span class="line">    : QWidget&#123;parent&#125;</span><br><span class="line">&#123;</span><br><span class="line">    img.<span class="built_in">load</span>(<span class="string">&quot;:/1&quot;</span>);</span><br><span class="line">    <span class="built_in">setFixedSize</span>(img.<span class="built_in">size</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">startTimer</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buterfly::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(),img);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buterfly::timerEvent</span><span class="params">(QTimerEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fly</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buterfly::mousePressEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//得到一个非零的数，然后与操作，就相当于看后面的数据了</span></span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">button</span>()==Qt::LeftButton)</span><br><span class="line">    &#123;</span><br><span class="line">        index=ev-&gt;<span class="built_in">globalPos</span>()-<span class="keyword">this</span>-&gt;<span class="built_in">geometry</span>().<span class="built_in">topLeft</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buterfly::mouseMoveEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">buttons</span>()&amp;Qt::LeftButton)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">move</span>(ev-&gt;<span class="built_in">globalPos</span>()-index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buterfly::enterEvent</span><span class="params">(QEnterEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fly</span>(<span class="number">-200</span>,<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buterfly::fly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fly</span>(<span class="number">10</span>,<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buterfly::fly</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m++;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m=<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        m=<span class="number">1</span>;</span><br><span class="line">    QString name=<span class="built_in">QString</span>(<span class="string">&quot;:%1&quot;</span>).<span class="built_in">arg</span>(m);</span><br><span class="line">    img.<span class="built_in">load</span>(name);</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">    <span class="type">int</span> setpx=QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(min,max);</span><br><span class="line">    <span class="type">int</span> setpy=QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(min,max);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> curx=<span class="keyword">this</span>-&gt;<span class="built_in">geometry</span>().<span class="built_in">topLeft</span>().<span class="built_in">x</span>()+setpx;</span><br><span class="line">    <span class="type">int</span> cury=<span class="keyword">this</span>-&gt;<span class="built_in">geometry</span>().<span class="built_in">topLeft</span>().<span class="built_in">y</span>()+setpy;</span><br><span class="line"></span><br><span class="line">    QScreen *screen = QGuiApplication::<span class="built_in">primaryScreen</span>();</span><br><span class="line">    <span class="keyword">if</span>(curx&gt;=screen-&gt;<span class="built_in">geometry</span>().<span class="built_in">right</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        curx=screen-&gt;<span class="built_in">geometry</span>().<span class="built_in">left</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cury&gt;=screen-&gt;<span class="built_in">geometry</span>().<span class="built_in">bottom</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cury=screen-&gt;<span class="built_in">geometry</span>().<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">move</span>(curx,cury);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 Qt 6 中，可以直接使用 <code>QGuiApplication::primaryScreen()</code> 来获取主屏幕的 <code>QScreen</code> 对象。所以你可以继续使用这个方法来获取屏幕对象。</p><p>简单地说，在 Qt 6 中，没有替代 <code>QGuiApplication::primaryScreen()</code> 的更简单的方法来获取主屏幕的 <code>QScreen</code> 对象。因此，你可以继续使用这个方法来获取主屏幕信息。</p><h2 id="QT事件分发器"><a href="#QT事件分发器" class="headerlink" title="QT事件分发器"></a>QT事件分发器</h2><img src="/post/2095ef6d/image-20230820091925794.png" class="" title="image-20230820091925794"><p><strong>关于窗口事件的分发，对应一个事件分发器，叫做event</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">override</span> <span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">bool</span> <span class="title">QWidget::event</span><span class="params">(QEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><h4 id="override-是-C-11-中的一个关键字，用于显式地指示派生类中的成员函数是对基类中的虚函数的重写（override）。在你提到的情况下，override-关键字用于指示派生类中的-event-函数是对-QWidget-基类中的-event-函数的重写。"><a href="#override-是-C-11-中的一个关键字，用于显式地指示派生类中的成员函数是对基类中的虚函数的重写（override）。在你提到的情况下，override-关键字用于指示派生类中的-event-函数是对-QWidget-基类中的-event-函数的重写。" class="headerlink" title="override 是 C++11 中的一个关键字，用于显式地指示派生类中的成员函数是对基类中的虚函数的重写（override）。在你提到的情况下，override 关键字用于指示派生类中的 event 函数是对 QWidget 基类中的 event 函数的重写。"></a><code>override</code> 是 C++11 中的一个关键字，用于显式地指示派生类中的成员函数是对基类中的虚函数的重写（override）。在你提到的情况下，<code>override</code> 关键字用于指示派生类中的 <code>event</code> 函数是对 <code>QWidget</code> 基类中的 <code>event</code> 函数的重写。</h4></blockquote><p>通过事件分发器的函数原型可以得知，<strong>关于事件类型的判断是基于参数完成的，</strong>这个参数是一个<strong>QEvent类</strong>型的对象，下面来看一下这个类中常用的一些API函数:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void QEvent::accept();</span><br></pre></td></tr></table></figure><p>该函数的作用是<strong>让窗口接受传递过来的事件</strong>，<strong>事件不会向上层窗口（父窗口）传递</strong>。–到此为止</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void QEvent::ignore();</span><br></pre></td></tr></table></figure><p>该函数的作用是<strong>让窗口忽略传递过来的事件</strong>，事件<strong>被传递给父窗口（向上传递）</strong>。–继续传递</p><hr><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool QEvent::isAccepted() const;</span><br><span class="line">void QEvent::setAccepted(bool accepted);</span><br></pre></td></tr></table></figure><blockquote><p><strong>设置传递过来的事件是被接受还是被忽略</strong><br><strong>setAccepted(true) &#x3D;&#x3D; accept()</strong><br><strong>setAccepted(false) &#x3D;&#x3D; ignore()</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QEvent::Type <span class="title">QEvent::type</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><strong>得到传递的窗口的事件的类型</strong>，<strong>返回值是一个枚举类型</strong>，内容很多可以自己查帮助文档，简单的贴个图：</p><img src="/post/2095ef6d/image-20230820093000591.png" class="" title="image-20230820093000591"><h3 id="事件分发器"><a href="#事件分发器" class="headerlink" title="事件分发器"></a>事件分发器</h3><p><strong>在不需要人为干预的情况下</strong>，<strong>事件分发器会自主的完成相关事件的分发</strong>，下面来还原一下事件分发器的分发流程，以下是这个函数的部分源码展示：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QWidget::event</span><span class="params">(QEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(ev-&gt;<span class="built_in">type</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 鼠标移动</span></span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseMove:</span><br><span class="line">        <span class="built_in">mouseMoveEvent</span>((QMouseEvent*)event);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 鼠标按下</span></span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonPress:</span><br><span class="line">        <span class="built_in">mousePressEvent</span>((QMouseEvent*)event);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 鼠标释放</span></span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonRelease:</span><br><span class="line">        <span class="built_in">mouseReleaseEvent</span>((QMouseEvent*)event);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 鼠标双击</span></span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonDblClick:</span><br><span class="line">        <span class="built_in">mouseDoubleClickEvent</span>((QMouseEvent*)event);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 键盘按键被按下事件</span></span><br><span class="line">    <span class="keyword">case</span> QEvent::KeyPress:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>看到事件分发器在对事件进行判定之后会调用相关的事件处理器函数，这样事件就被最终处理掉了。</p></blockquote><p>如果我们不想让某些触发的事件进入到当前窗口中，<strong>可以在事件分发器中进行拦截</strong>，拦截之前<strong>先来了解一下事件分发器函数的返回值：</strong></p><blockquote><p>如果传入的事件<strong>已被识别并且处理，则需要返回 true，否则返回 false。</strong>如果<strong>返回值是 true，那么 Qt 会认为这个事件已经处理完毕</strong>，<strong>不会再将这个事件发送给其它对象</strong>，而<strong>是会继续处理事件队列中的下一事件</strong>。</p><p>在event()函数中，<strong>调用事件对象的 accept() 和 ignore() 函数是没有作用的，不会影响到事件的传播。</strong></p></blockquote><p>举个例子，在窗口中<strong>过滤掉鼠标按下的事件</strong>:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::event</span><span class="params">(QEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">type</span>() == QEvent::MouseButtonPress ||</span><br><span class="line">            ev-&gt;<span class="built_in">type</span>() == QEvent::MouseButtonDblClick)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 过滤调用鼠标按下的事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">event</span>(ev);</span><br><span class="line">    <span class="comment">/////是具体的窗口</span></span><br><span class="line">    <span class="keyword">return</span> qtextevent::<span class="built_in">event</span>(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这样窗口就再也收不到鼠标的单击和双击事件了</strong>，对于这两个事件以外的其他事件是没有任何影响的，因为在重写的事件分发器函数的&#x3D;&#x3D;<strong>最后调用了父类的事件分发器函数</strong>&#x3D;&#x3D;</p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> QWidget::<span class="built_in">event</span>(ev);</span><br></pre></td></tr></table></figure><h5 id="这样就能保证其他事件按照默认的分发流程进行分发，并最终被窗口处理掉。"><a href="#这样就能保证其他事件按照默认的分发流程进行分发，并最终被窗口处理掉。" class="headerlink" title="这样就能保证其他事件按照默认的分发流程进行分发，并最终被窗口处理掉。"></a>这样就能保证其他事件按照默认的分发流程进行分发，并最终被窗口处理掉。</h5></blockquote><h2 id="QT事件过滤器-fliter"><a href="#QT事件过滤器-fliter" class="headerlink" title="QT事件过滤器(fliter)"></a>QT事件过滤器(fliter)</h2><p><strong>除了使用事件分发器来过滤Qt窗口中产生的事件，还可以通过事件过滤器过滤相关的事件</strong>。当Qt的事件通过应用程序对象发送给相关窗口之后，<strong>窗口接收到数据之前这个期间可对事件进行过滤</strong>，<strong>过滤掉的事件就不能被继续处</strong>理了。**&#x3D;&#x3D;QObject有一个eventFilter()函数，用于建立事件过滤器。函数原型如下：&#x3D;&#x3D;**</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span>] <span class="function"><span class="type">bool</span> <span class="title">QObject::eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>watched：要过滤的事件的所有者对象</strong>  过滤流<br><strong>event：要过滤的具体的事件</strong>    过滤对象</p><p><strong>返回值：</strong>*<strong>如果想过滤掉这个事件，停止它被进一步处理，返回true，否则返回 false</strong></p><h3 id="方法！！"><a href="#方法！！" class="headerlink" title="方法！！"></a>方法！！</h3><p>既然要过滤传递中的事件，<strong>首当其冲还是要搞明白如何通过事件过滤器进行事件的过滤，主要分为两步：</strong></p><blockquote><ol><li><p>给要被过滤事件的<strong>类对象安装事件过滤器</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QObject::installEventFilter</span><span class="params">(QObject *filterObj)</span></span>;</span><br></pre></td></tr></table></figure><p>假设调用installEventFilter()函数的对象为当前对象，那么就可以基于参数指定的filterObj对象来过滤当前对象中的指定的事件了。</p><p>*<em>QObject <em>filterObj);是修改过默认事件过滤器的对象</em></em></p></li><li><p>在要进行事件过滤的类中<strong>（filterObj 参数对应的类）</strong>**&#x3D;&#x3D;<strong>重写从QObject类继承的虚函数eventFilter()</strong>&#x3D;&#x3D;</p></li></ol></blockquote><h3 id="事件过滤器的使用"><a href="#事件过滤器的使用" class="headerlink" title="事件过滤器的使用"></a>事件过滤器的使用</h3><p><a href="https://blog.csdn.net/xideaha/article/details/132389149?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22132389149%22,%22source%22:%22xideaha%22%7D">举一个例子</a></p><blockquote><p>在一个窗口中<strong>有一个多行文本输入框QTextEdit，****需要让我们屏蔽掉键盘上的回车键</strong>，也就是按回车键之<strong>后在这个文本编辑框中再也不能换行了。</strong></p></blockquote><p>这三种方法 </p><p>1.自定义一个新的类让其继承QTextEdit，在这个子类中重写键盘事件keyPressEvent，在这个函数里边屏蔽掉回车键</p><p>2.自定义一个新的类让其继承QTextEdit，在这个子类中重写事件分发器event，在这个函数里边屏蔽掉回车键</p><p>3.给QTextEdit安装事件过滤器，基于QTextEdit的父窗口对这个控件的事件进行过滤</p><p><strong>820</strong></p><p><strong>Qt::Key_Enter是小键盘上的回车（确认）键，有些键盘没有小键盘，因此也就没有该按键。</strong><br><strong>Qt::Key_Return是大键盘上的回车键</strong></p><p><strong>通过这样的处理，事件在被应用程序对象发送出去之后，进入到对应的窗口之前就被其父窗口过滤掉了。</strong></p><p><strong>如果在Qt的窗口中有多层嵌套的窗口，如下图：</strong></p><img src="/post/2095ef6d/image-20230820105739083.png" class="" title="image-20230820105739083"><p>先来描述一下这四层窗口的关系：</p><p>顶层窗口A的直接子窗口是 B，间接子窗口是 C，QTextEdit<br>二级窗口B的直接子窗口是 C，间接子窗口是 QTextEdit<br>三级窗口C的直接子窗口是 QTextEdit</p><p>在这种多层嵌套窗口中如果想要过滤掉QTextEdit的某些事件，可以交给A或者B或者C去处理，当然也可以给QTextEdit同时安装多个过滤器：</p><p><strong>ui-&gt;textEdit-&gt;installEventFilter(窗口A对象);</strong><br><strong>ui-&gt;textEdit-&gt;installEventFilter(窗口B对象);</strong><br><strong>ui-&gt;textEdit-&gt;installEventFilter(窗口C对象);</strong></p><blockquote><p>如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是说窗口C先进行事件过滤，然后窗口B，最后窗口A。 </p><hr><hr><p>注意事项：</p><p><strong>事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</strong></p></blockquote><hr><blockquote><h3 id="在Qt中，事件传递是根据对象树结构进行的，从父级对象向子级对象传递。"><a href="#在Qt中，事件传递是根据对象树结构进行的，从父级对象向子级对象传递。" class="headerlink" title="在Qt中，事件传递是根据对象树结构进行的，从父级对象向子级对象传递。"></a><strong>在Qt中，事件传递是根据对象树结构进行的，从父级对象向子级对象传递。</strong></h3><p>当一个事件发生时，<strong>它首先被发送给顶层窗口</strong>（也就是<strong>应用程序的主窗口</strong>），然后<strong>通过对象树结构一层层向下传递，直到找到合适的接收者</strong>。</p><p>具体来说，事件传递的过程如下：</p><ol><li>事件首先被发送给顶层窗口，即应用程序的主窗口。</li><li>如果顶层窗口不处理该事件，它会将事件传递给它的直接子窗口（也就是窗口A）。</li><li>如果窗口A不处理该事件，它会将事件继续传递给它的直接子窗口（也就是窗口B）。</li><li>如果窗口B不处理该事件，它会将事件继续传递给它的直接子窗口（也就是窗口C）。</li><li>如果窗口C不处理该事件，它会将事件继续传递给它的直接子窗口（也就是QTextEdit）。</li><li><strong>如果QTextEdit不处理该事件，事件将被丢弃。</strong></li></ol><p>在这个过程中，<strong>每个窗口或控件都有机会处理事件。如果某个窗口或控件处理了事件，那么该事件就不会继续传递给它的子窗口或控件。</strong></p><p>在这种多层嵌套窗口的情况下，如果你想要过滤掉 <code>QTextEdit</code> 的某些事件，你有几种选择：</p><ol><li><p>将事件过滤器安装在顶层窗口A上：你可以在顶层窗口A的代码中安装一个事件过滤器，并在过滤器中对 <code>QTextEdit</code> 的事件进行处理。这样，所有发生在 <code>QTextEdit</code> 上的事件都会首先经过顶层窗口A的事件过滤器，然后再传递给 <code>QTextEdit</code> 进行处理。</p></li><li><p>将事件过滤器安装在二级窗口B上：类似地，你也可以在二级窗口B的代码中安装一个事件过滤器，并在过滤器中对 <code>QTextEdit</code> 的事件进行处理。这样，所有发生在 <code>QTextEdit</code> 上的事件都会首先经过二级窗口B的事件过滤器，然后再传递给 <code>QTextEdit</code> 进行处理。</p></li><li><p>将事件过滤器安装在三级窗口C上：同样地，你可以在三级窗口C的代码中安装一个事件过滤器，并在过滤器中对 <code>QTextEdit</code> 的事件进行处理。这样，所有发生在 <code>QTextEdit</code> 上的事件都会首先经过三级窗口C的事件过滤器，然后再传递给 <code>QTextEdit</code> 进行处理。</p></li><li><p>给 <code>QTextEdit</code> 同时安装多个过滤器：你也可以给 <code>QTextEdit</code> 同时安装多个事件过滤器。这样，每个过滤器都会对 <code>QTextEdit</code> 的事件进行处理。这种方法适用于需要多个过滤器分别处理不同类型的事件的情况。</p><p>流下来的时候直接被过滤掉了</p></li></ol><p>事件过滤器是按照安装的顺序依次处理事件的。**&#x3D;&#x3D;如果多个过滤器都对同一个事件进行了处理，最后安装的过滤器会先被调用。&#x3D;&#x3D;**</p></blockquote><h2 id="QT基于TCP的Qt网络通信"><a href="#QT基于TCP的Qt网络通信" class="headerlink" title="QT基于TCP的Qt网络通信"></a>QT基于TCP的Qt网络通信</h2><img src="/post/2095ef6d/image-20230820170203941.png" class="" title="image-20230820170203941"><p>tcp安全较于udp双向断开</p><h3 id="1-QTcpServer"><a href="#1-QTcpServer" class="headerlink" title="1.QTcpServer"></a>1.QTcpServer</h3><p>1.可以监听有没有客户端连接我</p><p>2.可以建立和客户端的连接</p><hr><h4 id="常用API！"><a href="#常用API！" class="headerlink" title="常用API！"></a>常用API！</h4><blockquote><ol><li><p>构造函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QTcpServer::<span class="built_in">QTcpServer</span>(QObject *parent = Q_NULLPTR);</span><br></pre></td></tr></table></figure></li><li><pre><code class="c++">// 判断当前对象是否在监听, 是返回true，没有监听返回falsebool QTcpServer::isListening() const;// 如果当前对象正在监听返回监听的服务器地址信息, 否则返回 QHostAddress::NullQHostAddress QTcpServer::serverAddress() const;// 如果服务器正在侦听连接，则返回服务器的端口; 否则返回0quint16 QTcpServer::serverPort() const//设置监听对象bool QTcpServer::listen(const QHostAddress &amp;address = QHostAddress::Any, quint16 port = 0);参数：address：通过类QHostAddress可以封装IPv4、IPv6格式的IP地址，QHostAddress::Any表示自动绑定port：如果指定为0表示//随机//绑定一个可用端口。【0，65535】》=5000返回值：绑定成功返回true，失败返回false<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. ```c++</span><br><span class="line">   //////////////////////////////////////////////</span><br><span class="line">   QTcpSocket *QTcpServer::nextPendingConnection();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   得到和客户端建立连接之后用于通信的QTcpSocket套接字对象</span><br><span class="line">   它是QTcpServer的一个子对象</span><br><span class="line">   当QTcpServer对象析构的时候会自动析构这个子对象，当然也可自己手动析构</span><br><span class="line">   建议用完之后自己手动析构这个通信的QTcpSocket对象。</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="c++">bool QTcpServer::waitForNewConnection(int msec = 0, bool *timedOut = Q_NULLPTR);阻塞等待客户端发起的连接请求不推荐在单线程程序中使用，建议使用非阻塞方式处理新连接，即使用信号 newConnection() 。    参数：msec：指定阻塞的最大时长，单位为毫秒（ms）timeout：传出参数，如果操作超时timeout为true，没有超时timeout为false<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 信号</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">[signal] void QTcpServer::acceptError(QAbstractSocket::SocketError socketError);</span><br><span class="line">当接受新连接导致错误时，将发射如下信号。socketError参数描述了发生的错误相关的信息。</span><br></pre></td></tr></table></figure></code></pre></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QTcpServer::newConnection</span><span class="params">()</span></span>;</span><br><span class="line">每次有新连接可用时都会发出 <span class="built_in">newConnection</span>() 信号。</span><br></pre></td></tr></table></figure><h3 id="2-QTcpsSocket继承于qtcpserver"><a href="#2-QTcpsSocket继承于qtcpserver" class="headerlink" title="2.QTcpsSocket继承于qtcpserver"></a>2.QTcpsSocket继承于qtcpserver</h3><img src="/post/2095ef6d/image-20230820171252982.png" class="" title="image-20230820171252982"><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><blockquote><ol><li><pre><code class="c++">QTcpSocket::QTcpSocket(QObject *parent = Q_NULLPTR);构造函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```c++</span><br><span class="line">   virtual] void QAbstractSocket::connectToHost(const QString &amp;hostName, quint16 port, OpenMode openMode = ReadWrite, NetworkLayerProtocol protocol = AnyIPProtocol);</span><br><span class="line">         </span><br><span class="line">   [virtual] void QAbstractSocket::connectToHost(const QHostAddress &amp;address, quint16 port, OpenMode openMode = ReadWrite);</span><br><span class="line">   连接服务器</span><br><span class="line">         </span><br></pre></td></tr></table></figure>**在Qt中不管调用读操作函数接收数据，还是调用写函数发送数据**，操作的对象都是**本地的由Qt框架维护的一块内存**。因此，调用了发送函数数据不一定会马上被发送到网络中，调用了接收函数也不是直接从网络中接收数据，**关于底层的相关操作是不需要使用者来维护的.**</code></pre></li><li><pre><code class="c++">// 指定可接收的最大字节数 maxSize 的数据到指针 data 指向的内存中qint64 QIODevice::read(char *data, qint64 maxSize);// 指定可接收的最大字节数 maxSize，返回接收的字符串QByteArray QIODevice::read(qint64 maxSize);// 将当前可用操作数据全部读出，通过返回值返回读出的字符串QByteArray QIODevice::readAll();接收数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. ```c++</span><br><span class="line">   // 发送指针 data 指向的内存中的 maxSize 个字节的数据</span><br><span class="line">   qint64 QIODevice::write(const char *data, qint64 maxSize);</span><br><span class="line">   // 发送指针 data 指向的内存中的数据，字符串以 \0 作为结束标记</span><br><span class="line">   qint64 QIODevice::write(const char *data);</span><br><span class="line">   // 发送参数指定的字符串</span><br><span class="line">   qint64 QIODevice::write(const QByteArray &amp;byteArray);</span><br><span class="line">   发送数据</span><br></pre></td></tr></table></figure></code></pre></li></ol></blockquote><h4 id="信号-1"><a href="#信号-1" class="headerlink" title="信号"></a>信号</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QIODevice::readyRead</span><span class="params">()</span></span>;</span><br><span class="line">在使用QTcpSocket进行套接字通信的过程中，如果该类对象发射出<span class="built_in">readyRead</span>()信号，说明对端发送的数据达到了，之后就可以调用 read 函数接收数据了。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractSocket::connected</span><span class="params">()</span></span>;</span><br><span class="line">调用<span class="built_in">connectToHost</span>()函数并成功建立连接之后发出<span class="built_in">connected</span>()信号。</span><br><span class="line">    检测客户端是否与服务器连接成功，再客户端使用</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractSocket::disconnected</span><span class="params">()</span></span>;</span><br><span class="line">在套接字断开连接时发出<span class="built_in">disconnected</span>()信号。</span><br><span class="line">    两端都能使用，一旦使用就发出disconnect的信号</span><br></pre></td></tr></table></figure><p><strong>qt维护的那一块内存是中间人</strong></p><h3 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h3><p><em><strong>使用Qt提供的类进行套接字通信比使用标准C API进行网络通信要简单</strong></em>（因为在内部进行了封装）</p><p><strong>接收就是读，发送就是写</strong></p><ol><li><p>服务器端</p><blockquote><p>1.创建套接字服务器QTcpServer对象</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_s=<span class="keyword">new</span> <span class="built_in">QTcpServer</span>(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>2.通过QTcpServer对象设置监听，即：QTcpServer::listen()</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">connect</span>(m_s,&amp;QTcpServer::newConnection,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">     <span class="comment">//接受连接成功后的子对象qtcpsocket</span></span><br><span class="line"><span class="comment">//        QTcpSocket *tcp=m_s-&gt;nextPendingConnection();</span></span><br><span class="line">     m_o=m_s-&gt;<span class="built_in">nextPendingConnection</span>();</span><br><span class="line">      m_l-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/pass.png&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>));</span><br><span class="line"><span class="comment">//        ui-&gt;hmsg-&gt;append(&quot;和客户端连接成功!&quot;);</span></span><br><span class="line">      ui-&gt;hmsg-&gt;<span class="built_in">append</span>(<span class="string">&quot;帅到汽车爆胎的小帅上线了&quot;</span>);</span><br><span class="line">      QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>,<span class="string">&quot;提示&quot;</span>,<span class="string">&quot;小帅上线了！！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">connect</span>(m_o,&amp;QTcpSocket::readyRead,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line"><span class="comment">//            qDebug()&lt;&lt;&quot;信息来咯&quot;;</span></span><br><span class="line">         <span class="comment">//先读取信息</span></span><br><span class="line">         QByteArray data=m_o-&gt;<span class="built_in">readAll</span>();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//把信息添加到历史画框里</span></span><br><span class="line">         QDateTime now= QDateTime::<span class="built_in">currentDateTime</span>();</span><br><span class="line">         QString str=now.<span class="built_in">toString</span>(<span class="string">&quot;[yyyy-MM-dd hh:mm:ss AP]&gt;&gt;&quot;</span>);</span><br><span class="line">         ui-&gt;hmsg-&gt;<span class="built_in">append</span>(<span class="string">&quot;小帅&quot;</span>+str+data);</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="built_in">connect</span>(m_o,&amp;QTcpSocket::disconnected,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">         m_o-&gt;<span class="built_in">close</span>();</span><br><span class="line">         m_o-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">         m_l-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/pass.png&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>));</span><br><span class="line">         ui-&gt;hmsg-&gt;<span class="built_in">append</span>(<span class="string">&quot;小帅断开了连接....难道是我不够美吗？呜呜呜&quot;</span>);</span><br><span class="line">         m_l-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/wrong.png&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>));</span><br><span class="line">         ui-&gt;playserver-&gt;<span class="built_in">setDisabled</span>(<span class="literal">false</span>);</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure><p>3.基于QTcpServer::newConnection()信号检测是否有新的客户端连接<br>4.如果有新的客户端连接调用QTcpSocket *QTcpServer::nextPendingConnection()得到通信的套接字对象<br>5.使用通信的套接字对象QTcpSocket和客户端进行通信</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> qt-c++开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
