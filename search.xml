<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test1</title>
      <link href="/post/8ab2dce2.html"/>
      <url>/post/8ab2dce2.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h1><p>本阶段主要针对C++&#x3D;&#x3D;面向对象&#x3D;&#x3D;编程技术做详细讲解，探讨C++中的核心和精髓。</p><h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p><ul><li>代码区：存放<strong>函数体</strong>的<strong>二进制代码</strong>，由<strong>操作系统</strong>进行管理的</li><li>注释不在代码区</li><li>全局区：存放<strong>全局变量和静态变量以及常量</strong></li><li>栈区：由<strong>编译器自动分配释放</strong>, 存放<strong>函数的参数值</strong>,<strong>局部变量</strong>等</li><li>堆区：由**程序员分配和释放,**<strong><strong>若程序员不释放,程序结束时由操作系统回收</strong></strong></li></ul><p><strong>内存四区意义：</strong></p><p>不同区域存放的数据，<strong>赋予不同的生命周期</strong>, 给我们更大的<strong>灵活编程</strong></p><h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>​<strong>在程序编译后，生成了exe可执行程序</strong>，<strong>未执行该程序前</strong>分为两个区域</p><p>​<strong>代码区：</strong></p><p>​存放 CPU 执行的机器指令</p><p>​代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，<strong>只需要在内存中有一份代码即可</strong></p><p>​代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令,<strong>金币变点券</strong></p><p>​<strong>全局区：</strong></p><p>​<strong>全局变量 和 静态变量</strong>存放在此.</p><p>​全局区还包含了<strong>常量区</strong>, <strong>字符串常量和全局常量</strong>存放在此.</p><p>&#x3D;&#x3D;<strong>局部常量也局部变量都在栈区</strong>&#x3D;&#x3D;</p><p>​&#x3D;&#x3D;该区域的数据在程序结束后由操作系统释放&#x3D;&#x3D;.</p><p>![image-20230725153630117](C:\Users\许闰博\Desktop\C++\C-Resource-master\第3阶段-C++核心编程 资料\讲义\C++核心编程.assets\image-20230725153630117.png)</p><hr><p>(int)指针的地址，是不被定义的行为.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">10</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;a)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;b)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;g_a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;g_b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;s_a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;s_b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;<span class="string">&quot;hello world&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;c_g_a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;c_g_b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;c_l_a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;c_l_b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印结果：</p><p><strong>局部变量</strong>a地址为： 6422044<br><strong>局部变量</strong>b地址为： 6422040<br>全局变量g_a地址为： 4206608<br>全局变量g_b地址为： 4206612<br>静态变量s_a地址为： 4206616<br>静态变量s_b地址为： 4206620<br>字符串常量地址为： 4210842<br>全局常量c_g_a地址为： 4210692<br>全局常量c_g_b地址为： 4210696<br><strong>局部常量</strong>c_l_a地址为： 6422036<br><strong>局部常量</strong>c_l_b地址为： 6422032<br>请按任意键继续. . .</p><p><img src="E:/MD/assets/1545017602518.png" alt="1545017602518"></p><p>总结：</p><ul><li>C++中在<strong>程序运行前</strong>分为全局区和代码区</li><li>代码区特点是<strong>共享和只读</strong></li><li>全局区中存放&#x3D;&#x3D;全局变量、静态变量、常量&#x3D;&#x3D;,<strong>不包括局部常量和局部变量</strong></li><li>常量区中存放 const修饰的<strong>全局常量  和 字符串常量</strong></li></ul><h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p>​<strong>栈区：</strong><strong><strong>编译器的天下.</strong></strong></p><p>​由<strong>编译器</strong>自动分配释放, 存放<strong>函数的参数值,局部变量</strong>等</p><p>​注意事项：<strong>不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;<span class="comment">//理论上第一次打印10</span></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;<span class="comment">//第二次打印乱码，就是因为编译器帮你做了一次保留，栈区的数据由编译器主宰。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>堆区：</strong></p><p>​由<strong>程序员分配释放,若程序员不释放,程序结束时由操作系统回收</strong></p><p>​在C++中<strong>主要利用new在堆区开辟内存</strong></p><p>​&#x3D;&#x3D;并且返回new出来内存的地址，也就是指针！&#x3D;&#x3D;</p><p>![image-20230725160019240](C:\Users\许闰博\Desktop\C++\C-Resource-master\第3阶段-C++核心编程 资料\讲义\C++核心编程.assets\image-20230725160019240.png)</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;<span class="comment">//都是10，因为堆区的数据只有点击了x才被释放。在此之前一直存在。不像堆区离开了局部（函数）就被释放了，虽然编译器会帮你保留一次，但第二次就要出问题了。</span></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>堆区数据由程序员管理开辟和释放</p><p>堆区数据利用new关键字进行开辟内存</p><h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>​C++中利用&#x3D;&#x3D;new&#x3D;&#x3D;操作符在堆区开辟数据</p><p>​堆区开辟的数据，<strong>由程序员手动开辟，手动释放</strong>，释放利用操作符 &#x3D;&#x3D;delete&#x3D;&#x3D;</p><p>​语法：<code> new 数据类型</code>(初始值)</p><p>​利用new创建的数据，<strong>会返回该数据对应的类型的指针(地址)</strong></p><p>int *a&#x3D;new int(10)</p><p>​&#x3D;&#x3D;最后需要delete对应的指针！&#x3D;&#x3D;加new返回的 指针！</p><blockquote><p>![image-20230725160534499](C:\Users\许闰博\Desktop\C++\C-Resource-master\第3阶段-C++核心编程 资料\讲义\C++核心编程.assets\image-20230725160534499.png)</p></blockquote><p>​&#x3D;&#x3D;<strong>释放的空间不可访问</strong>&#x3D;&#x3D;</p><p><strong>示例1： 基本语法</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用delete释放堆区数据</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//15735568</span></span><br></pre></td></tr></table></figure><p><strong>示例2：开辟数组</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//开辟字符串,开辟字符串数组的时候换成[]再加个数</span></span><br><span class="line">    string* str=<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    cout&lt;&lt;*str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = i + <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []  arr;</span><br><span class="line">    <span class="keyword">delete</span> str;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p><strong>作用： <strong>给</strong>变量</strong>起别名</p><p>土豆，马铃薯都是。。</p><p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p><p>类型得相同</p><p>![image-20230725170131910](C:\Users\许闰博\Desktop\C++\C-Resource-master\第3阶段-C++核心编程 资料\讲义\C++核心编程.assets\image-20230725170131910.png)</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h3><ul><li><strong>引用必须初始化</strong></li><li>引用在初始化后，不可以改变也就是</li><li>一旦引用被初始化绑定到一个对象上，它将一直引用该对象，无法改变引用所绑定的对象。</li></ul><p>示例：</p><p>![image-20230725170414023](C:\Users\许闰博\Desktop\C++\C-Resource-master\第3阶段-C++核心编程 资料\讲义\C++核心编程.assets\image-20230725170414023.png)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line"><span class="type">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line">    <span class="comment">//实际上是操作a的值。。</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利<strong>用引用的技术让形参修饰实参</strong></p><p><strong>优点：</strong>可以简化指针修改实参</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sp1</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sp2</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=*a;</span><br><span class="line">    *a=*b;</span><br><span class="line">    *b=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sp3</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入两个数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;值传递，不可以修改实参的本身&quot;</span>&lt;&lt;endl;</span><br><span class="line">      <span class="built_in">sp1</span>(a,b);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;地址传递--指针，可以修改实参的本身&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">sp2</span>(&amp;a,&amp;b);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;地址传递--引用，可以修改实参的本身&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">sp3</span>(a,b);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>总结：<strong>通过引用参数产生的效果同按地址传递是一样的</strong>。引用的语法更清楚简单</p><h5 id="当引用作为一个函数形参时，它所引用的变量的生命周期必须保证在函数的执行期间内是有效的。在函数执行期间内，对于引用所指向的变量所进行的任何修改都将影响到函数调用方式中的原始变量。"><a href="#当引用作为一个函数形参时，它所引用的变量的生命周期必须保证在函数的执行期间内是有效的。在函数执行期间内，对于引用所指向的变量所进行的任何修改都将影响到函数调用方式中的原始变量。" class="headerlink" title="当引用作为一个函数形参时，它所引用的变量的生命周期必须保证在函数的执行期间内是有效的。在函数执行期间内，对于引用所指向的变量所进行的任何修改都将影响到函数调用方式中的原始变量。"></a>当引用作为一个函数形参时，它所引用的变量的生命周期必须保证在函数的执行期间内是有效的。在函数执行期间内，对于引用所指向的变量所进行的任何修改都将影响到函数调用方式中的原始变量。</h5><p>引用和指针操作最大的区别在于，指<strong>针的方式借助的形参会占用栈区空间</strong>，而用引用则不会，<strong>因此引用节省了栈区空间！</strong></p></blockquote><hr><h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>作用：引用是可以<strong>作为函数的返回值</strong>存在的</p><p>注意：**&#x3D;&#x3D;不要返回局部变量引用和地址&#x3D;&#x3D;**</p><p><strong>也要用引用的形式去接受</strong></p><p><strong>变量有可以同时存在多个别名，别名与别名与变量之间的操作是共通的</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;b=a;</span><br><span class="line">    <span class="type">int</span> &amp;c=a;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;c=&quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用法：<em>函数调用作为左值</em></p><hr><p>在 C++ 中，<strong>不建议返回指向局部变量的引用，因为局部变量在函数执行完毕后会被销毁，而引用仍然指向该变量的内存地址。</strong>这样会导致返回的引用指向一个无效的内存位置，访问该引用可能会导致未定义行为。</p><p><strong>而静态变量是在程序运行期间一直存在的，不会在函数执行完毕后被销毁。</strong>因此，返回静态变量的引用是安全的，因为静态变量的生命周期超出了函数的作用域。</p><hr><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回a的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span><span class="comment">//全局区，在整个程序运行完才释放</span></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">    <span class="comment">//返回的a是以类型“int&amp;”返回的，所以必须要以类型“int&amp;”去接收，这里用ref去接收，即int&amp; ref = a  ，即ref为a的别名</span></span><br><span class="line"><span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果函数做左值，那么必须返回引用,ref2也是a的别名</span></span><br><span class="line"><span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">////</span></span><br><span class="line">    <span class="comment">//int &amp;别名=1000 也相当于是a的别名只不过是函数</span></span><br><span class="line"><span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">////</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>int * const 变量名字&#x3D;</p><p>费曼学习法，先学面向过程C，在学面向对象CSharp，然后又滚来学C++面向对象过程（滑稽）</p><h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p><blockquote><p>常量指针是指 指针指向的数据不可更改</p><p>const指针常量是值 指针的指向不可更改</p></blockquote><p>讲解示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line"><span class="type">int</span>&amp; ref = a; </span><br><span class="line">ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">func</span>(a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p><h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p><strong>作用：</strong>常量引用<strong>主要用来修饰形参，防止误操作</strong></p><p>在函数形参列表中，可以加改变实参</p><p>引用必须引用一块合法的内存空间</p><p>int&amp; a&#x3D;10;  不可以</p><p>const int&amp; a&#x3D;10  可以</p><p>相当于，编译器帮助这样处理.</p><p>{</p><p>int temp&#x3D;10;</p><p>const int&amp; a&#x3D;temp;</p><p>}</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="comment">//v += 10;</span></span><br><span class="line">cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="comment">//void showValue(const int* const name) &#123;</span></span><br><span class="line"><span class="comment">//v += 10;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; v &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line"><span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p><p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p><p>&#x3D;&#x3D;如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值&#x3D;&#x3D;</p><h6 id="如果函数声明有默认值，函数实现的时候就不能有默认参数"><a href="#如果函数声明有默认值，函数实现的时候就不能有默认参数" class="headerlink" title="&#x3D;&#x3D;如果函数声明有默认值，函数实现的时候就不能有默认参数&#x3D;&#x3D;"></a>&#x3D;&#x3D;如果函数<strong>声明有默认值</strong>，函数实现的时候就不能有默认参数&#x3D;&#x3D;</h6><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p><p>占一个位置，可以接受实参。</p><p><strong>占位参数必须填补</strong></p><p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> =<span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h4 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p><p><strong>函数重载满足条件：</strong></p><ul><li><p>同一个作用域下</p></li><li><p>函数名称相同</p></li><li><p>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong>（前提是参数类型不同！！！）</p></li><li><blockquote><p>函数的返回值类型不可以重载！！！</p></blockquote></li></ul><p><strong>注意:</strong>  <strong>函数的返回值不可以作为函数重载的条件</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h4><ul><li><strong>引用作为重载条件</strong></li><li>函数重载碰到<strong>函数默认参数</strong></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">func</span>(a); <span class="comment">//调用无const</span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const</span></span><br><span class="line">    相当于弄了一个临时变量</span><br><span class="line">      <span class="comment">//  int &amp;a=10 不可以</span></span><br><span class="line">      <span class="comment">//  const int &amp;a=10;可以</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免 二义性！~！！</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="&#x3D;&#x3D;4 类和对象&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>4</strong> 类和对象&#x3D;&#x3D;</h2><p>C++面向对象的三大特性为：&#x3D;&#x3D;封装、继承、多态&#x3D;&#x3D;</p><p>C++认为&#x3D;&#x3D;万事万物都皆为对象&#x3D;&#x3D;，对象上有其属性和行为</p><blockquote><p><strong>类里面的属性和行为都是成员！</strong></p><p><strong>创建具体的对象的过程叫做类的实例化！</strong></p></blockquote><p><strong>例如：</strong></p><p>​人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p><p>​车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、开空调…</p><p>​具有相同性质的&#x3D;&#x3D;对象&#x3D;&#x3D;，我们可以抽象称为&#x3D;&#x3D;类&#x3D;&#x3D;，人属于人类，车属于车类</p><h3 id="4-1-封装–1"><a href="#4-1-封装–1" class="headerlink" title="4.1 封装–1"></a>4.1 封装–1</h3><h4 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1  封装的意义"></a>4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p><p>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为<strong>加以权限控制</strong></li></ul><p><strong>封装意义一：</strong></p><p>​在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p><p><strong>示例1：</strong>设计一个圆类，求圆的周长</p><p><strong>示例代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="type">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//行为</span></span><br><span class="line"><span class="comment">//获取到圆的周长</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//2 * pi  * r</span></span><br><span class="line"><span class="comment">//获取圆的周长</span></span><br><span class="line"><span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过圆类，创建圆的对象</span></span><br><span class="line"><span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">Circle c1;</span><br><span class="line">c1.m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p><p><strong>示例2代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setname</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setid</span><span class="params">(string number)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;number=number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showmessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="keyword">this</span>-&gt;name&lt;&lt;<span class="string">&quot;----&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;number&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    string number;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    student xrb;</span><br><span class="line">    xrb.<span class="built_in">setname</span>(<span class="string">&quot;徐润波&quot;</span>);</span><br><span class="line">    xrb.<span class="built_in">setid</span>(<span class="string">&quot;542207230725&quot;</span>);</span><br><span class="line">    xrb.<span class="built_in">showmessage</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>封装意义二：</strong></p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ol><li>public        公共权限  </li><li>protected 保护权限</li><li>private      私有权限</li></ol><blockquote><p>在C++中，类的成员可以不同的访问权限，包括私有（private）、保护（protected）和公共（public）权限。这些权限决定了类的成员对于<strong>类内部和类外部</strong>的<strong>可见性和可访问性。</strong></p><p><strong>私有权限（private）是最严格的权限</strong>，它表示<strong>只有类内部的成员函数可以访问该成员，</strong>类外部的代码无法直接访问私有成员。私有成员对于类外部的用户是隐藏的，只有类内部的函数可以直接访问和操作私有成员。私有成员常用于封装类的实现细节，以确保数据的安全性和一致性。</p><p>保护权限（protected）<strong>介于私有权限和公共权限之间。</strong>保护成员<strong>可以被类内部的成员函数和派生类的成员函数访问</strong>，但对于类外部的代码是不可见的。<strong>保护成员常用于实现继承中的数据共享和派生类的访问控制。</strong></p><p>区别总结如下：</p><ul><li><strong>私有权限（private）：只有类内部的成员函数可以访问，类外部的代码无法直接访问。</strong></li><li>*<em>保护权限（protected）：类内部的成员函数和派生类的成员函数可以访问，类外部的代码无法直接访问。</em></li><li><strong>公共权限（public）：类内部的成员函数和类外部的代码都可以访问。</strong></li></ul><p>需要注意的是，这些<strong>访问权限只是在编译时进行的静态检查</strong>，<em><strong>而不是运行时的限制</strong></em>。因此，通过类的<strong>公共成员函数可以间接地访问私有和保护成员</strong>。</p></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string m_Car;</span><br><span class="line"></span><br><span class="line"><span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">m_Password = <span class="number">123456</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line"><span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line"><span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p><p>区别：</p><blockquote><ul><li><h4 id="struct-默认权限为公共"><a href="#struct-默认权限为公共" class="headerlink" title="struct 默认权限为公共"></a>struct 默认权限为公共</h4></li><li><h4 id="class-默认权限为私有"><a href="#class-默认权限为私有" class="headerlink" title="class   默认权限为私有"></a>class   默认权限为私有</h4></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">C1 c1;</span><br><span class="line">c1.m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">C2 c2;</span><br><span class="line">c2.m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 &#x3D;&#x3D;成员属性设置为私有&#x3D;&#x3D;"></a>4.1.3 &#x3D;&#x3D;成员属性设置为私有&#x3D;&#x3D;</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以<strong>自己控制读写权限</strong></p><p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p><hr><p><em>在 C++ 中，私有成员是类的成员，<strong>只有类的成员函数可以直接访问和修改私有成员。</strong>其他函数或代码块无法直接访问和修改私有成员。</em></p><p><em>然而，<strong>可以通过指针间接访问和修改私有成员</strong>。如果你有一个指向类对象的指针，你可以使用指针来访问和修改私有成员。这是因为<strong>指针可以具有与类成员函数相同的访问权限。</strong></em></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateMember;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPrivateMember</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        privateMember = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getPrivateMember</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateMember;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    MyClass* ptr = &amp;obj;</span><br><span class="line"></span><br><span class="line">    ptr-&gt;<span class="built_in">setPrivateMember</span>(<span class="number">200</span>);</span><br><span class="line">    <span class="type">int</span> value = ptr-&gt;<span class="built_in">getPrivateMember</span>();</span><br><span class="line">    cout&lt;&lt;value&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//姓名设置可读可写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取年龄</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置年龄</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情人设置为只写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">        m_Lover = lover;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">    string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Person p;</span><br><span class="line">    <span class="comment">//姓名设置</span></span><br><span class="line">    p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//年龄设置</span></span><br><span class="line">    p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情人设置</span></span><br><span class="line">    p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习案例1：设计立方体类</strong></p><p>设计立方体类(Cube)</p><p>求出立方体的面积和体积</p><p>分别用全局函数和成员函数判断两个立方体是否相等。</p><p><img src="E:/MD/assets/1545533548532.png" alt="1545533548532"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cubic</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getwidth</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setwidth</span><span class="params">(<span class="type">int</span> width)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;width=width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getlength</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setlength</span><span class="params">(<span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;length=length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getheight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setheight</span><span class="params">(<span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;height=height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">caculateV</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;length*<span class="keyword">this</span>-&gt;height*<span class="keyword">this</span>-&gt;width;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cubic abc;</span><br><span class="line">    abc.<span class="built_in">setwidth</span>(<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;得到立方体的宽度&quot;</span>&lt;&lt;abc.<span class="built_in">getwidth</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    abc.<span class="built_in">setlength</span>(<span class="number">4</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;得到立方体的长度&quot;</span>&lt;&lt;abc.<span class="built_in">getlength</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    abc.<span class="built_in">setheight</span>(<span class="number">5</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;得到立方体的高度&quot;</span>&lt;&lt;abc.<span class="built_in">getheight</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;得到立方体的体积V=&quot;</span>&lt;&lt;abc.<span class="built_in">caculateV</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到立方体的宽度3</span></span><br><span class="line"><span class="comment">//得到立方体的长度4</span></span><br><span class="line"><span class="comment">//得到立方体的高度5</span></span><br><span class="line"><span class="comment">//得到立方体的体积V=60</span></span><br><span class="line"><span class="comment">//请按任意键继续. .</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习案例2：点和圆的关系</strong></p><p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p><p><img src="E:/MD/assets/1545533829184.png" alt="1545533829184"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getx</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setx</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gety</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sety</span><span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y=y;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setx</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;c_x=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sety</span><span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;c_y=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setr</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;c_r=r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;c_r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">CaculateTheRelationshipBetweenCircleAndPoint</span><span class="params">(point abc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> p_x=abc.<span class="built_in">getx</span>();</span><br><span class="line">        <span class="type">int</span> p_y=abc.<span class="built_in">gety</span>();</span><br><span class="line">        <span class="type">int</span> distance=<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">sqrt</span>((p_x-<span class="keyword">this</span>-&gt;c_x)*(p_x-<span class="keyword">this</span>-&gt;c_x)-(p_y-<span class="keyword">this</span>-&gt;c_y)*(p_y-<span class="keyword">this</span>-&gt;c_y)));</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> c_x;</span><br><span class="line">    <span class="type">int</span> c_y;</span><br><span class="line">    <span class="type">int</span> c_r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    circle circle;</span><br><span class="line">    circle.<span class="built_in">setx</span>(<span class="number">0</span>);</span><br><span class="line">    circle.<span class="built_in">sety</span>(<span class="number">1</span>);</span><br><span class="line">    circle.<span class="built_in">setr</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    point point;</span><br><span class="line"></span><br><span class="line">    point.<span class="built_in">setx</span>(<span class="number">2</span>);</span><br><span class="line">    point.<span class="built_in">sety</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result=circle.<span class="built_in">CaculateTheRelationshipBetweenCircleAndPoint</span>(point);</span><br><span class="line">    <span class="keyword">if</span>(result==circle.<span class="built_in">getr</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;点在圆上！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(result&gt;circle.<span class="built_in">getr</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;点在园外!!!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;点在园内！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//点在园外!!!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="static-cast和reinterpret-cast"><a href="#static-cast和reinterpret-cast" class="headerlink" title="static_cast&lt;&gt;和reinterpret_cast&lt;&gt;"></a><em><strong>static_cast&lt;&gt;和reinterpret_cast&lt;&gt;</strong></em></h4><blockquote><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast&lt;&gt;"></a>static_cast&lt;&gt;</h2><p><code>static_cast&lt;&gt;</code> 是 C++ 中的一种<strong>类型转换运算符</strong>，用于在编译时进行类型转换。它可以用于将一种类型转换为另一种类型，包括基本类型、类类型和指针类型。</p><p><code>static_cast&lt;&gt;</code> 的语法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;目标类型&gt;(表达式)</span><br></pre></td></tr></table></figure><p>其中，<code>目标类型</code> 是你希望将表达式转换为的类型，而 <code>表达式</code> 则是要进行转换的值或<strong>变量</strong>。</p><p>下面是一些示例用法：</p><ol><li>将整数转换为浮点数：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> result = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(num);</span><br></pre></td></tr></table></figure><ol start="2"><li>将浮点数转换为整数：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> num = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(num);</span><br></pre></td></tr></table></figure><ol start="3"><li><em>将指针类型转换为另一种指针类型</em>：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">char</span>* result = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(ptr);</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>static_cast&lt;&gt;</code> <strong>不会执行运行时的类型检查</strong>，因此转换的安全性需要由开发者自行保证。如果转换是不安全的，建议使用更加安全的类型转换运算符，如 <code>dynamic_cast&lt;&gt;</code> 或 <code>reinterpret_cast&lt;&gt;</code>。</p><p>总结起来，<code>static_cast&lt;&gt;</code> 是 C++ 中一种常用的类型转换运算符，<strong>用于在编译时进行类型转换</strong>。它可以将一种类型转换为另一种类型，但需要开发者自行确保转换的安全性。</p><hr><hr><hr><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast&lt;&gt;"></a>reinterpret_cast&lt;&gt;</h2><p><code>reinterpret_cast&lt;&gt;</code> 是 C++ 中的一种类型转换运算符，用<strong>于执行底层的强制类型转换</strong>。它可以将一个指针或引用转换为另一种指针或引用类型，甚至可以将指针或引用转换为整数类型。</p><p><code>reinterpret_cast&lt;&gt;</code> 的语法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reinterpret_cast</span>&lt;目标类型&gt;(表达式)</span><br></pre></td></tr></table></figure><p>其中，<code>目标类型</code> 是你希望将表达式转换为的类型，而 <code>表达式</code> 则是要进行转换的值或变量。</p><p>下面是一些示例用法：</p><ol><li>将指针类型转换为另一种指针类型：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">char</span>* result = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ptr);</span><br></pre></td></tr></table></figure><ol start="2"><li>将指针类型转换为整数类型：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">uintptr_t</span> result = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(ptr);</span><br></pre></td></tr></table></figure><ol start="3"><li>将整数类型转换为指针类型：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">uintptr_t</span> num = <span class="number">12345</span>;</span><br><span class="line"><span class="type">int</span>* result = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(num);</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>reinterpret_cast&lt;&gt;</code> 执行的是一种底层的强制类型转换，<strong>它可以绕过编译器的类型检查</strong>，因此需要开发者自行确保转换的安全性。使用 <code>reinterpret_cast&lt;&gt;</code> 进行类型转换时应该非常小心，确保转换的结果在语义上是合理的。</p><p>总结起来，<code>reinterpret_cast&lt;&gt;</code> 是 C++ 中一种类型转换运算符，用于执行底层的强制类型转换。它可以将指针或引用转换为另一种指针或引用类型，甚至可以将指针或引用转换为整数类型。使用 <code>reinterpret_cast&lt;&gt;</code> 进行类型转换时需要非常小心，确保转换的安全性和语义正确性。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">10</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;a)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;(&amp;b)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><ul><li>生活中我们买的电子产品都基本会有<strong>出厂设置</strong>，在某一天我们不用时候也会删除一些自己信息数据保证安全</li><li>C++中的<strong>面向对象来源于生活，</strong>每个对象也都会有<strong>初始设置</strong>以及 对象销毁前的<strong>清理数据</strong>的设置。</li></ul><h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p><p><strong>多个对象的时候，先构造的后析构！！</strong></p><p><strong>在类外调用类的成员</strong></p><p><strong>类名::成员</strong></p><blockquote><p>​一个对象或者变量没有初始状态，对其使用后果是未知</p><p>​同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p></blockquote><p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这<strong>两个函数将会被编译器自动调用</strong>，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译<strong>器强制要我们做的事情</strong>，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p><p><strong>编译器提供的构造函数和析构函数是-&#x3D;空实现-&#x3D;。</strong></p><ul><li>构造函数：主要作用在于创建对象时<strong>为对象的成员属性赋值</strong>，<strong>构造函数由编译器自动调用</strong>，无须手动调用。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong><em>系统自动调用</em>，执行一些<strong>清理工作</strong>。</li></ul><p>可以写在类内</p><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><blockquote><ol><li><strong>构造函数，没有返回值也写void</strong></li><li><strong>函数名称与类名相同</strong></li><li><strong>构造函数可以有参数，因此可以发生重载</strong></li><li>程序在<strong>调用对象时候会自动调用构造</strong>，无须手动调用**,而且只会调用一次**</li></ol></blockquote><p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p><blockquote><ol><li><h5 id="析构函数，没有返回值也写void"><a href="#析构函数，没有返回值也写void" class="headerlink" title="析构函数，没有返回值也写void"></a>析构函数，没有返回值也写void</h5></li><li><h5 id="函数名称是类名，但前面要加个"><a href="#函数名称是类名，但前面要加个" class="headerlink" title="函数名称是类名，但前面要加个~"></a>函数名称是类名，但前面要加个~</h5></li><li><h5 id="函数不可以有参数，不能发生重载"><a href="#函数不可以有参数，不能发生重载" class="headerlink" title="函数不可以有参数，不能发生重载"></a>函数不可以有参数，不能发生重载</h5></li><li><h5 id="程序在对象销毁前对自动调用析构函数，无需手动调用，且只会调用一次"><a href="#程序在对象销毁前对自动调用析构函数，无需手动调用，且只会调用一次" class="headerlink" title="程序在对象销毁前对自动调用析构函数，无需手动调用，且只会调用一次"></a>程序在<em>对象销毁前</em>对自动调用析构函数，无需手动调用，且只会调用一次</h5></li></ol></blockquote><hr><p>C++ 类的构造函数和析构函数可以在类的定义外部进行定义和实现。这样做的目的是将类的声明和实现分离，使代码更加清晰和可维护。</p><p><strong>构造函数和析构函数的定义和实现可以放在类的定义之后的任何地方，通常会放在类的定义之后的源文件中。</strong></p><p>以下是一个示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyClass.h 头文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateMember;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(); <span class="comment">// 构造函数的声明</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>(); <span class="comment">// 析构函数的声明</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyClass.cpp 源文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">    <span class="comment">// 构造函数的实现</span></span><br><span class="line">    privateMember = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass::~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">    <span class="comment">// 析构函数的实现</span></span><br><span class="line">    <span class="comment">// 可以进行资源的释放等清理工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>MyClass</code> 类的构造函数和析构函数的声明放在了头文件 <code>MyClass.h</code> 中，而定义和实现则放在了源文件 <code>MyClass.cpp</code> 中。这样可以使类的接口和实现分离，提高代码的可读性和可维护性。</p><p><strong>如果构造函数和析构函数的定义和实现在类的定义内部，编译器会隐式地将它们声明为内联函数。</strong>而将它们定义在类的定义外部时，不会自动成为内联函数，需要显式地在定义中加上 <code>inline</code> 关键字来指示编译器将其作为内联函数处理。</p><blockquote><p><strong>当编译器将函数的定义插入到调用它的地方时，这被称为内联展开</strong>。相比于生成函数调用，内联展开具有以下优点和缺点：</p><p>优点：</p><ol><li><strong>减少函数调用的开销</strong>：函数调用涉及到保存和恢复寄存器、跳转到函数代码、返回地址等操作，这些操作会消耗一定的时间和空间。通过内联展开，可以避免这些开销，从而提高程序的执行效率。</li><li><strong>优化循环和递归</strong>：内联展开可以优化循环和递归函数的性能。将循环或递归函数内联展开，可以减少函数调用的次数，避免重复的栈帧创建和销毁，从而加快循环或递归的执行速度。</li><li><strong>提高编译器优化的机会</strong>：内联展开可以<strong>提供更多的代码上下文信息给编译器</strong>，使其有更多的优化机会。例如，编译器可以进行常量折叠、循环展开、代码复制等优化，从而进一步提高程序的执行效率。</li></ol><p>缺点：</p><ol><li><strong>增加代码的体积</strong>：内联展开会将函数的定义插入到调用它的地方，这会增加代码的体积。如果函数体很大，内联展开可能会导致代码膨胀，<strong>增加可执行文件的大小。</strong></li><li>增加编译时间：内联展开会增加编译器的工作量，因为编译器需要将函数的定义插入到每个调用它的地方。<strong>如果程序中有大量的函数调用，内联展开可能会导致编译时间的增加。</strong></li><li>可读性下降：内联展开会使代码变得更加冗长，可读性可能会下降。特别是对于复杂的函数体，将其内联展开可能会使代码难以理解和维护。</li></ol><p>综上所述，<strong>内联展开可以提高程序的执行效率，特别是对于频繁调用的小型函数和循环或递归函数。</strong>然而，内联展开也会增加代码的体积和编译时间，并可能降低代码的可读性。因此，在使用内联展开时需要权衡这些优缺点，并根据具体的情况进行选择。</p></blockquote><hr><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;我是构造函数，调用对象前会自动执行，只执行一次，没有返回值也不写void，可以有参数也就说我一般用于创建对象的同时对其成员进行赋值&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;我是析构函数，对象销毁前会被自动执行，没有返回值也不写void，不可以有参数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;begin&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;end&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//begin</span></span><br><span class="line"><span class="comment">//我是构造函数，调用对象前会自动执行，只执行一次，没有返回值也不写void，可以有参数也就说我一般用于创建对象的同时对其成员进行赋值</span></span><br><span class="line"><span class="comment">//我是析构函数，对象销毁前会被自动执行，没有返回值也不写void，不可以有参数</span></span><br><span class="line"><span class="comment">//end</span></span><br></pre></td></tr></table></figure><h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p><p>​按参数分为： 无参构造和有参构造</p><p>​按类型分为： 普通构造（简单的有参无参）和拷贝构造</p><p>三种调用方式：</p><p>​括号法</p><p>​显示法</p><p>​隐式转换法</p><hr><p><strong>注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</strong></p><hr><blockquote><p>C++ 中的构造函数可以分为以下几种类型：</p><ol><li><p>无参构造(默认构造)（Default Constructor）：没有参数的构造函数。如果一个类没有定义任何构造函数，编译器会自动生成一个默认构造函数。默认构造函数用于创建对象时不需要提供任何参数。</p></li><li><p>有参构造（Parameterized Constructor）：带有参数的构造函数，可以在<strong>创建对象时传递参数来初始化对象的成员变量。</strong></p></li><li><p>拷贝构造函数（Copy Constructor）：*<em>用于创建一个新对象并将其初始化为已有对象的副本。</em>**<em>拷贝构造函数的参数是 &gt; <strong>同类型的对象的引用</strong></em>*。</p></li><li><p>深拷贝构造函数（Move Constructor）：用于将一个对象的资源（如动态分配的内存）转移到另一个对象中，通常用于提高程序的性能。</p></li></ol><p>构造函数的调用方式有以下几种：</p><ol><li><p>直接调用：通过类名和参数列表直接调用构造函数来创建对象。例如：<code>MyClass obj(10);</code></p></li><li><p>隐式调用：在不显式调用构造函数的情况下，使用类的对象声明来创建对象。例如：<code>MyClass obj = 10;</code></p></li><li><p>拷贝初始化：使用一个已存在的对象来初始化新对象，会调用拷贝构造函数。例如：<code>MyClass obj2 = obj1;</code></p></li><li><p>动态创建对象：使用 <code>new</code> 运算符在堆上动态创建对象，会调用构造函数。例如：<code>MyClass* ptr = new MyClass();</code></p></li></ol><p>需要注意的是，<strong>构造函数在对象创建时自动调用，无法手动调用构造函数来重新初始化已经存在的对象</strong>。构造函数的调用顺序是<strong>先调用基类的构造函数，再调用成员对象的构造函数，最后调用派生类的构造函数</strong>。析构函数的调用顺序与构造函数相反，先调用派生类的析构函数，再调用成员对象的析构函数，最后调用基类的析构函数。</p></blockquote><p>推荐使用括号</p><p>了解匿名对象</p><p>有参构造函数直接Person（10）的时候创了一个匿名对象。</p><p>相当于没人接受这个对象。</p><p>要想利用拷贝构造函数，先有一个自己同类型的对象，然后再以引用的形式传入就ok了</p><p>![image-20230726211121976](C:\Users\许闰博\Desktop\C++\C-Resource-master\第3阶段-C++核心编程 资料\讲义\C++核心编程.assets\image-20230726211121976.png)</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.1  括号法，常用</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line"><span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.2 显式法</span></span><br><span class="line">Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line"><span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构，直接构造析构然后立马销毁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.3 隐式转换法</span></span><br><span class="line">Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line"><span class="comment">//Person p5(p4);</span></span><br><span class="line">    <span class="comment">///数声明和对象定义的语法非常相似，都可以使用括号来表示。</span></span><br><span class="line">    <span class="comment">//使用额外的括号：可以在匿名对象的括号外面再加一对括号，这样编译器就不会将其解释为函数声明。</span></span><br><span class="line"><span class="comment">//MyClass obj((MyClass())); // 使用括号明确告诉编译器我们要定义一个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = p.mAge;</span><br><span class="line">默认的简单拷贝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li><strong>值传递</strong>的方式给函数参数传值</li><li>以<strong>值方式</strong>返回局部对象</li></ul><blockquote><ol><li><p><code>Person newman3 = man;</code> 和 <code>Person newman3; newman3 = man;</code> 是有区别的。</p><ol><li><code>Person newman3 = man;</code> 使用<strong>拷贝初始化的方式创建了一个新的对象</strong> <code>newman3</code>，并将 <code>man</code> 对象的值复制给 <code>newman3</code>。这里会<strong>调用拷贝构造函数来完成对象的复制初始化。</strong></li><li>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</li><li><code>Person newman3; newman3 = man;</code> 首先创建了一个新的对象 <code>newman3</code>，但它<strong>是通过默认构造函数创建的</strong>，并不包含任何数据。然后，通<strong>过赋值操作符 <code>=</code> 将 <code>man</code> 对象的值赋给了 <code>newman3</code><strong>。这里会调用</strong>赋值运算符重载函数来完成对象的赋值操作。</strong></li></ol><p>总体来说，两种形式都会将 <code>man</code> 对象的值复制到 <code>newman3</code> 对象中，但是在实现细节上有所不同。<strong>拷贝初始化会调用拷贝构造函数</strong>，<strong>而赋值操作会调用赋值运算符重载函数</strong>。在某些情况下，拷贝构造函数和赋值运算符重载函数的实现可能会有差异，因此两种形式可能具有不同的行为。<strong>在一般情况下</strong>，如果需要创建并初始化一个新对象，<strong>建议使用拷贝初始化的方式</strong>，而不是先创建对象再赋值的方式。</p></li><li><p><strong>值传递是指将实参的值</strong>复制一份传递给函数的形参。<strong>在函数调用时，会创建一个新的变量（形参），并将实参的值复制到形参中。</strong>&#x3D;&#x3D;在函数内部，对形参的修改不会影响到实参的值。&#x3D;&#x3D;当函数执行完毕后，形参的生命周期结束<strong>，它所占用的内存会被释放。</strong></p><p>text02()在你的例子中，<code>doWork</code> 函数的形参 <code>p1</code> 是通过值传递的方式进行传递的。当你调用 <code>doWork(p)</code> 时，会创建一个新的 <code>Person</code> 对象 <code>p1</code>，并将 <code>p</code> 对象的值复制给 <code>p1</code>。</p></li><li><p>可以以值方式返回<strong>局部对象</strong>。当函数返回一个对象时，编<strong><em>译器会执行对象的拷贝构造函数来创建一个临时对象，并将其作为返回值</em>。这个临时对象是在函数调用栈上分配的</strong>，<strong>它的生命周期与函数的返回值绑定。</strong></p><p>&#x2F;&#x2F;</p><p><strong>假如说我用a来接受这个局部对象，那么这个临时对象将会在a的销毁的时候同时销毁</strong></p><p>![image-20230727153838243](C:\Users\许闰博\Desktop\C++\C-Resource-master\第3阶段-C++核心编程 资料\讲义\C++核心编程.assets\image-20230727153838243.png)</p></li></ol></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = p.mAge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line"><span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person newman3;</span></span><br><span class="line"><span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p; <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> p1;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//此时return *this;也会拷贝一个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h4><p>默认情况下，创建一个类的时候，c++编译器至少给一个类添加3个函数,</p><p>1．默认构造函数(无参，函数体为空)</p><p>2．默认析构函数(无参，函数体为空)</p><p>3．默认拷贝构造函数，对属性进行值拷贝</p><p>构造函数调用规则如下：</p><ul><li><p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</p></li><li><p>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;<span class="comment">//18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4><p><strong>深浅拷贝是面试经典问题，也是常见的一个坑</strong></p><p>浅拷贝：<strong>简单的赋值拷贝操作</strong>  编译器提供的那个拷贝构造函数，浅拷贝</p><p>深拷贝：<strong>在堆区重新申请空间，进行拷贝操作</strong></p><p>![image-20230727164829489](C:\Users\许闰博\Desktop\C++\C-Resource-master\第3阶段-C++核心编程 资料\讲义\C++核心编程.assets\image-20230727164829489.png)</p><p><strong>这是编译器帮忙写的浅拷贝</strong></p><p>![image-20230727172119889](C:\Users\许闰博\Desktop\C++\C-Resource-master\第3阶段-C++核心编程 资料\讲义\C++核心编程.assets\image-20230727172119889.png)</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age, <span class="type">int</span> height) &#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">m_age = age;</span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数  </span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_age = a.m_age;</span><br><span class="line"><span class="comment">//m_height = a.m_height;</span></span><br><span class="line"><span class="comment">//利用拷贝对象的数据来开辟一个新的空间。</span></span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*a.m_height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line"><span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">160</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"><span class="comment">//Person p2 = p1;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：<strong>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</strong></p></blockquote><ol><li><p>自己写拷贝构造函数，用拷贝对象的数据来开辟对应的空间</p></li><li><pre><code class="c++">//拷贝构造函数  Person(const Person&amp; a)&#123;    cout &lt;&lt; &quot;拷贝构造函数&quot; &lt;&lt; endl;    m_age = a.m_age;    //m_height = a.m_height;    //利用拷贝对象的数据来开辟一个新的空间。    m_height = new int(*a.m_height);&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 析构函数PLUS！</span><br><span class="line"></span><br><span class="line">4. ```c++</span><br><span class="line">   //析构函数</span><br><span class="line">   ~Person() &#123;</span><br><span class="line">   cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">   if (m_height != NULL)</span><br><span class="line">   &#123;</span><br><span class="line">   delete m_height;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><p>只有new出来的空间才能用delete，而且只能delete一次！</p><h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p><strong>作用：</strong></p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p><p><code>//初始化列表方式初始化</code></p><p><code>Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c)&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">////传统方式初始化</span></span><br><span class="line"><span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line"><span class="comment">//m_A = a;</span></span><br><span class="line"><span class="comment">//m_B = b;</span></span><br><span class="line"><span class="comment">//m_C = c;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表方式初始化</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="&#x3D;&#x3D;4.2.7 类对象作为类成员&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.2.7 类对象作为类成员&#x3D;&#x3D;</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>B类中有对象A作为成员，A为对象成员</p><p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p><blockquote><p><strong>&#x2F;&#x2F;构造的顺序是 ：先调用<em>对象成员</em>的构造，再调用本类构造</strong><br><strong>&#x2F;&#x2F;析构顺序与构造相反</strong></p></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Phone</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">m_PhoneName = name;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Phone</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line">Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line"><span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line"><span class="comment">//析构顺序与构造相反</span></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>();</span><br><span class="line">~<span class="built_in">Son</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Father</span>();</span><br><span class="line">~<span class="built_in">Father</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Son* a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Father::<span class="built_in">Father</span>()</span><br><span class="line">&#123;</span><br><span class="line">a = <span class="keyword">new</span> Son;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;父亲被构造了&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father::~<span class="built_in">Father</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;父亲被析构了&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son::<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;儿子被构造了&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son::~<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;儿子被析构了&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Father father;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>();</span><br><span class="line">~<span class="built_in">Son</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Father</span>();</span><br><span class="line">~<span class="built_in">Father</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Son a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Father::<span class="built_in">Father</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;父亲被构造了&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father::~<span class="built_in">Father</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;父亲被析构了&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son::<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;儿子被构造了&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son::~<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;儿子被析构了&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Father father;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这两种都是先构造儿子后构造父亲，析构相反</strong></p><p><strong>只有在父亲的构造函数里面再栈区开辟一个儿子对象的时候才是先构造父亲，然后构造儿子，其他相反</strong></p><h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4><p><strong>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</strong></p><p>—————————————-<em>可以通过类名访问静态成员</em>————————————————-</p><p><strong><em>静态成员分为</em>：</strong></p><ul><li><strong>静态成员变量</strong><ul><li><strong>所有对象共享同一份数据</strong></li><li><strong>在编译阶段分配内存</strong>（全局区运行前）</li><li><strong>类内声明，类外初始化</strong>（记得加作用域！！！！）</li></ul></li><li><strong>静态成员函数</strong><ul><li><strong>所有对象共享同一个函数</strong></li><li><strong>静态成员函数只能访问静态成员变量</strong></li></ul></li></ul><blockquote><p><strong>静态成员变量也有私有的时候。外部不能直接访问</strong></p><p><strong>可以通过类名访问静态成员</strong></p><p><strong>普通的成员public变量不可以直接用类名：：变量名访问！！！</strong></p></blockquote><p><strong>示例1 ：</strong>静态成员变量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员变量特点：</span></span><br><span class="line"><span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line"><span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line"><span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过对象</span></span><br><span class="line">Person p1;</span><br><span class="line">p1.m_A = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p2.m_A = <span class="number">200</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong>静态成员函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数特点：</span></span><br><span class="line"><span class="comment">//1 程序共享一个函数</span></span><br><span class="line"><span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//静态static成员函数它只属于类本身不属于每一个对象实例，独立存在。非静态成员，仅当实例化对象之后才存在。静态成员函数产生在前，非静态成员函数产生在后，静态函数无法访问一个不存在的东西。也就是静态成员函数离不能用this指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"><span class="type">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过对象</span></span><br><span class="line">Person p1;</span><br><span class="line">p1.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名</span></span><br><span class="line">Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，<strong>类内的成员变量和成员函数分开存储</strong></p><p>只有<strong>非静态成员变量才属于类的对象上</strong></p><blockquote><h5 id="只有非静态成员变量在真正属于类！！！！！"><a href="#只有非静态成员变量在真正属于类！！！！！" class="headerlink" title="只有非静态成员变量在真正属于类！！！！！"></a>只有非静态成员变量在真正属于类！！！！！</h5><h5 id="空对象占用1字节，为了区分空对象。"><a href="#空对象占用1字节，为了区分空对象。" class="headerlink" title="空对象占用1字节，为了区分空对象。"></a>空对象占用1字节，为了区分空对象。</h5><h5 id="也就是类的大小是根据非静态成员变量的"><a href="#也就是类的大小是根据非静态成员变量的" class="headerlink" title="也就是类的大小是根据非静态成员变量的"></a>也就是类的大小是根据非静态成员变量的</h5></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">mA = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line"><span class="type">int</span> mA;</span><br><span class="line"><span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mB;</span><br><span class="line"><span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4</span></span><br></pre></td></tr></table></figure><h4 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>c++通过提供特殊的对象指针，this指针，解决上述问题。<em><strong>this指针指向被调用的成员函数所属的对象</strong></em></p><blockquote><p><strong>this指针是隐含每一个非静态成员函数内的一种指针</strong></p><p><strong>this指针不需要定义，直接使用即可</strong></p><p><strong>静态成员函数没有this指针</strong></p><p>本质是指针常量！！！，已经指向了a，不可以修改指向，但可以修改值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showperson</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span> = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_a = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Person a;</span><br><span class="line">a.<span class="built_in">showperson</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>this指针的用途：</p><ul><li>当形参和成员变量同名时，可用this指针来区分</li><li>*<em>在类的非静态成员函数中返回对象本身，可使用return <em>this</em></em></li></ul><h5 id="链式编程思想！！！"><a href="#链式编程思想！！！" class="headerlink" title="&#x3D;&#x3D;链式编程思想！！！&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>链式编程思想！！！</strong>&#x3D;&#x3D;</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line"><span class="comment">//返回对象本身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line">p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><blockquote><p>类类型的指针，在成员里this就是指针。</p></blockquote><p>但不能用空指针访问里面的属性，可以用函数。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showperosn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是person类&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showpp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//代码健壮！！！</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sdadasdassdasdasdasdsda&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person* p = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;<span class="built_in">showperosn</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">p-&gt;<span class="built_in">showpp</span>(); <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p><blockquote><ul><li><strong>成员函数后</strong>加const后我们称为这个函数为<strong>常函数</strong></li><li><strong>常函数内不可以修改成员属性</strong></li><li><strong>成员属性声明时加关键字mutable后，在常函数中依然可以修改</strong></li></ul></blockquote><p><strong>常对象：</strong></p><ul><li><strong>声明对象前加const称该对象为常对象</strong></li><li><strong>常对象只能调用常函数</strong></li><li><strong>常对象可以修改静态变量的值</strong></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">m_A = <span class="number">0</span>;</span><br><span class="line">m_B = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line"><span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//const Type* const pointer;</span></span><br><span class="line"><span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line"><span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//mA = 10000;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常对象访问成员函数</span></span><br><span class="line">person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p><p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p><p>但是呢，你也可以允许你的好闺蜜好基友进去。</p><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是<strong>让一个函数或者类 访问另一个类中私有成员</strong></p><p>友元的关键字为  &#x3D;&#x3D;friend&#x3D;&#x3D;</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodgay</span><span class="params">(building* building)</span></span>;<span class="comment">//写在类里面就ok，最好在上面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">building</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_sittingrom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">m_bedroom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_sittingrom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_bedroom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodgay</span><span class="params">(building* building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友 全局函数正在访问:&quot;</span> &lt;&lt;building-&gt;m_sittingrom&lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友 全局函数正在访问:&quot;</span> &lt;&lt; building-&gt;m_bedroom&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">building b;</span><br><span class="line"><span class="built_in">goodgay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">text01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">goodGay</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">goodGay gg;</span><br><span class="line">gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="comment">//你可以在goodGay类的定义之前提供一个Building类的前向声明来解决编译错误。</span></span><br><span class="line"><span class="comment">//但是，在这种情况下，你不能直接在goodGay类的构造函数中使用new来创建Building对象，因为编译器仍然无法识别Building类的具体定义。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">goodGay</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Building* building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">goodGay gg;</span><br><span class="line">gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p><blockquote><p>通过成员函数重载</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public: </span><br><span class="line">person(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_a = a;</span><br><span class="line">this-&gt;m_b = b;</span><br><span class="line">&#125;</span><br><span class="line">person operator+(person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">person p3(0, 0);</span><br><span class="line">p3.m_a = this-&gt;m_a + p.m_a;</span><br><span class="line">p3.m_b = this-&gt;m_b + p.m_b;</span><br><span class="line">return p3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int m_a;</span><br><span class="line">int m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">person p1(10, 10);</span><br><span class="line">person p2(20, 20);</span><br><span class="line">person p3=p1+(p2);</span><br><span class="line">cout &lt;&lt; p3.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;_------------------&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p3.m_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过全局函数重载</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//person fucn(person&amp; p1, person&amp; p2)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//person p3(0,0);</span></span><br><span class="line"><span class="comment">//p3.m_a = p1.m_a + p2.m_a;</span></span><br><span class="line"><span class="comment">//p3.m_b = p3.m_b + p2.m_b;</span></span><br><span class="line"><span class="comment">//return p3;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">person <span class="keyword">operator</span>+(person&amp; p1, person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">person <span class="title">p3</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">p3.m_a = p1.m_a + p2.m_a;</span><br><span class="line">p3.m_b = p1.m_b + p2.m_b;</span><br><span class="line"><span class="keyword">return</span> p3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//person p3 = func(p1, p2);</span></span><br><span class="line">    <span class="comment">//可以简写为这样！</span></span><br><span class="line">person p3 = p1 + p2;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p3.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;_------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p3.m_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>运算符对应的函数重载</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person <span class="keyword">operator</span>+(person&amp; p1, person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">person <span class="title">p3</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">p3.m_a = p1.m_a + p2.m_a;</span><br><span class="line">p3.m_b = p1.m_b + p2.m_b;</span><br><span class="line"><span class="keyword">return</span> p3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person <span class="keyword">operator</span>+(person&amp; p1, <span class="type">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">person <span class="title">p3</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">p3.m_a = p1.m_a + num;</span><br><span class="line">p3.m_b = p1.m_b + num;</span><br><span class="line"><span class="keyword">return</span> p3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//person p3 = operator+(p1, p2);</span></span><br><span class="line">person p3 = p1 + p2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//现在如果</span></span><br><span class="line">person p4 = p1 + <span class="number">100</span>;<span class="comment">//person + int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p3.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p3.m_b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;_------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p4.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p4.m_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>通过成员函数或者全局函数写一个目标重载运算符的作用函数,然后把函数的名字改为operator+就可以说使用+号来重载了</li><li>不把函数名改写为operator+之前的加号还默认是原来的样子!!!!</li><li>熟练之后直接函数名字就是operator+</li><li>如果二者同时存在的时候就会报错</li></ol></blockquote><blockquote><p>总结1：对于<strong>内置的数据类型</strong>的表达式的的运算符是不可能改变的1+1&#x3D;2,变成1+1&#x3D;0?不可以</p></blockquote><blockquote><p>总结2：不要滥用运算符重载,加号运算符重载,实现就不要用减号..</p></blockquote><h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="&#x3D;&#x3D;4.5.2 左移运算符重载&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.5.2 左移运算符重载&#x3D;&#x3D;</h4><p>作用：可以输出自定义数据类型</p><p>加个cosnt最好，引用作为函数参数传递的时候不修改最好加上cosnt！！！！！！！！！</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p) <span class="comment">//本质operator&lt;&lt;(cout,p) 简化cout&lt;&lt;p;</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a ;</span><br><span class="line">cout &lt;&lt; p.m_b;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链式思想,返回cout对应的</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> person&amp; p) <span class="comment">//本质operator&lt;&lt;(cout,p) 简化cout&lt;&lt;p;</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a ;</span><br><span class="line">cout &lt;&lt; p.m_b;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也是ok的因为,引用本来就是起别名,而真正传入的实参确实cout所以</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line"><span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个,所以要用引用的形式修改,否则覆盖不了原来的cout</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结<strong>：重载左移运算符配合友元可以实现输出自定义数据类型</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, person&amp; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>(<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout对象和我的p对象</span></span><br><span class="line"><span class="comment">//void operator&lt;&lt;(cout)  // p.operator&lt;&lt;(cout)  简化为p&lt;&lt;cout</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, person&amp; p) <span class="comment">//本质operator&lt;&lt;(cout,p) 简化cout&lt;&lt;p;</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a ;</span><br><span class="line">cout &lt;&lt; p.m_b;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl &lt;&lt; <span class="string">&quot;helloworld&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p><p>但用引用可以节省空间，而且不怕拷贝函数有错误。</p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>++() &#123;  <span class="comment">// 前置递增运算符重载</span></span><br><span class="line">  <span class="comment">// 执行递增操作</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回递增后的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;  <span class="comment">// 后置递增运算符重载</span></span><br><span class="line">  MyClass temp = *<span class="keyword">this</span>;  <span class="comment">// 创建一个临时对象保存当前对象的值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行递增操作</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> temp;  <span class="comment">// 返回之前的对象</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//class MyClass &#123;</span></span><br><span class="line"><span class="comment">//    // 类定义</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>++(MyClass&amp; obj) &#123;  <span class="comment">// 前置递增运算符重载</span></span><br><span class="line"><span class="comment">// 执行递增操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> obj;  <span class="comment">// 返回递增后的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass <span class="keyword">operator</span>++(MyClass&amp; obj, <span class="type">int</span>) &#123;  <span class="comment">// 后置递增运算符重载</span></span><br><span class="line">MyClass temp = obj;  <span class="comment">// 创建一个临时对象保存当前对象的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行递增操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> temp;  <span class="comment">// 返回之前的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意conse，会有一定的影响，如果引用做函数参数的时候确认是不修改的 话就加上const！！！</span></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>前置++</p><p>返回引用！！可以链式</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, person&amp; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//p.operator++(person&amp; p)</span></span><br><span class="line">person&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数重载的时候</span></span><br><span class="line">person&amp; <span class="keyword">operator</span>++(person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">p.m_a++;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意conse，会有一定的影响，如果引用做函数参数的时候确认是不修改的 话就加上const！！！</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">person p;</span><br><span class="line">cout &lt;&lt; ++(++p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>后置递增！</p><p>返回同类，不可以用链式</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p);</span><br><span class="line"><span class="keyword">friend</span> person <span class="keyword">operator</span>++(person&amp; obj, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person <span class="keyword">operator</span>++(person&amp; obj, <span class="type">int</span>) &#123;  <span class="comment">// 后置递增运算符重载</span></span><br><span class="line">person temp = obj;  <span class="comment">// 创建一个临时对象保存当前对象的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行递增操作</span></span><br><span class="line">obj.m_a++;=</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> temp;  <span class="comment">// 返回之前的对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意conse，会有一定的影响，如果引用做函数参数的时候确认是不修改的 话就加上const！！！</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">person myInt;</span><br><span class="line">cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">person p;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><blockquote><h4 id="总结：-前置递增返回引用，后置递增返回值"><a href="#总结：-前置递增返回引用，后置递增返回值" class="headerlink" title="总结： 前置递增返回引用，后置递增返回值"></a>总结： 前置递增返回引用，后置递增返回值</h4></blockquote><p>递减！！的成员函数 的 写法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person&amp; <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a--;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">person <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">person temp = *<span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a--;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">person myInt;</span><br><span class="line">cout &lt;&lt; --myInt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">person myInt;</span><br><span class="line">cout &lt;&lt; myInt--&lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">person p;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递减的全局函数重载写法！！</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p);</span><br><span class="line"><span class="keyword">friend</span> person&amp; <span class="keyword">operator</span>--(person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> person <span class="keyword">operator</span>--(person&amp; p, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.m_a;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person&amp; <span class="keyword">operator</span>--(person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">p.m_a--;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person <span class="keyword">operator</span>--(person&amp; p,<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">person temp = p;</span><br><span class="line">p.m_a--;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">person myInt;</span><br><span class="line">cout &lt;&lt; --myInt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">person myInt;</span><br><span class="line">cout &lt;&lt; myInt--&lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">person p;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p><blockquote><ol><li><h5 id="默认构造函数-无参，函数体为空"><a href="#默认构造函数-无参，函数体为空" class="headerlink" title="默认构造函数(无参，函数体为空)"></a>默认构造函数(无参，函数体为空)</h5></li><li><h5 id="默认析构函数-无参，函数体为空"><a href="#默认析构函数-无参，函数体为空" class="headerlink" title="默认析构函数(无参，函数体为空)"></a>默认析构函数(无参，函数体为空)</h5></li><li><h5 id="默认拷贝构造函数，对属性进行值拷贝"><a href="#默认拷贝构造函数，对属性进行值拷贝" class="headerlink" title="默认拷贝构造函数，对属性进行值拷贝"></a>默认拷贝构造函数，对属性进行值拷贝</h5></li><li><h5 id="赋值运算符-operator-对属性进行值拷贝"><a href="#赋值运算符-operator-对属性进行值拷贝" class="headerlink" title="赋值运算符 operator&#x3D;, 对属性进行值拷贝"></a>赋值运算符 operator&#x3D;, 对属性进行值拷贝</h5></li></ol></blockquote><ol><li>也是浅拷贝</li></ol><p><strong>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</strong></p><p>类中有属性指向堆区，就要考虑深拷贝了</p><hr><p><strong>思考，指出那里出现了问题????</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>(<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in">int</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;p;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="comment">//此处使用拷贝构造函数的隐式转换</span></span><br><span class="line">    <span class="comment">//person p3=p1</span></span><br><span class="line">    <span class="comment">//由于我们并没有写自己的深拷贝,也就是说还用的是编译器帮我们写的浅拷贝,造成了简单的赋值操作,让我么两个指针都指向了同一块数据,然后释放了两次就鸡; </span></span><br><span class="line">    <span class="comment">//我们只是写了自己的=的重载.</span></span><br><span class="line">    <span class="comment">//避免了重载的时候释放两次同一个位置</span></span><br><span class="line">    <span class="comment">//p2=p1这样的操作不会有问题</span></span><br><span class="line">person p3 = p1;</span><br><span class="line">cout &lt;&lt; *p1.p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p2.p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p3.p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![image-20230729143751080](C:\Users\许闰博\Desktop\C++\C-Resource-master\第3阶段-C++核心编程 资料\讲义\C++核心编程.assets\image-20230729143751080.png)</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载赋值运算符 </span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line"><span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回自身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄的指针</span></span><br><span class="line"><span class="type">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//int a = 10;</span></span><br><span class="line"><span class="comment">//int b = 20;</span></span><br><span class="line"><span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c = b = a;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="可以是实现这样的操作，从右到左赋值！！！"><a href="#可以是实现这样的操作，从右到左赋值！！！" class="headerlink" title="可以是实现这样的操作，从右到左赋值！！！"></a>可以是实现这样的操作，从右到左赋值！！！</h4></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//test();</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">a = b = c;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a  &lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b  &lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c=&quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>给&#x3D;进行链式思想实连等</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>(<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in">int</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;p;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> person&amp; pp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//需要看原来的堆区是否有数据，如果有需要先释放干净，然后再利用数据开辟空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in">int</span>(*pp.p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">person p3 =(<span class="number">30</span>);</span><br><span class="line">p3 = p2 = p1;</span><br><span class="line">cout &lt;&lt; *p1.p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p2.p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p3.p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="4-5-5-关系运算符重载—返回BOOL"><a href="#4-5-5-关系运算符重载—返回BOOL" class="headerlink" title="4.5.5 关系运算符重载—返回BOOL"></a>4.5.5 关系运算符重载—返回BOOL</h4><p><strong>作用：</strong>重<strong>载关系运算符，可以让两个自定义类型对象进行对比操作</strong></p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;name == p2.name &amp;&amp; <span class="keyword">this</span>-&gt;age == p2.age)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////////</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> == p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;name != p2.name &amp;&amp; <span class="keyword">this</span>-&gt;age != p2.age)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////全局函数重载的时候</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(person&amp; p1, person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p1.name == p2.name &amp;&amp; p1.age == p2.age)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(person&amp; p1, person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p1.name == p2.name &amp;&amp; p1.age == p2.age)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//全局记得加上友元!!!@#@#@#@#@#!#!</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>(string name, <span class="type">int</span> age):<span class="built_in">name</span>(name), <span class="built_in">age</span>(age)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;name == p2.name &amp;&amp; <span class="keyword">this</span>-&gt;age == p2.age)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="string">&quot;tom&quot;</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line"><span class="function">person <span class="title">p2</span><span class="params">(<span class="string">&quot;tom&quot;</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line">person p3 = <span class="built_in">person</span>(<span class="string">&quot;jerry&quot;</span>,<span class="number">20</span>);</span><br><span class="line"><span class="comment">///erson p4 = p2;//浅拷贝！！！危险，如果指针操纵他—+析构释放，就要考虑深拷贝！！！</span></span><br><span class="line"><span class="keyword">if</span> (p1==p2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1和p2是相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1和p2是不相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载()"></a>4.5.6 函数调用运算符重载()</h4><ul><li>函数调用运算符 ()  也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><blockquote><h4 id="刚试了一下，operator（）（）只能在类里面定义，报错说不允许他为全局函数。"><a href="#刚试了一下，operator（）（）只能在类里面定义，报错说不允许他为全局函数。" class="headerlink" title="刚试了一下，operator（）（）只能在类里面定义，报错说不允许他为全局函数。"></a>刚试了一下，operator（）（）只能在类里面定义，报错说不允许他为全局函数。</h4></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line"><span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line"><span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line"><span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myadd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+<span class="number">1</span> + b+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//匿名对象调用  </span></span><br><span class="line"><span class="comment">//有参构造Person(10)单独写就是匿名对象  当前行结束之后，马上析构，直接构造析构然后立马销毁</span></span><br><span class="line"><span class="comment">//Person()单独写就是匿名对象  当前行结束之后，马上析构，直接构造析构然后立马销毁</span></span><br><span class="line">person p;</span><br><span class="line"><span class="built_in">p</span>(<span class="string">&quot;你好啊）OP&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----匿名函数----------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">person</span>()(<span class="string">&quot;你好啊匿名函数&quot;</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">Myadd add;</span><br><span class="line">cout&lt;&lt;<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">30</span>)&lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----匿名函数----------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Myadd</span>()(<span class="number">90</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-继承–2"><a href="#4-6-继承–2" class="headerlink" title="4.6  继承–2"></a>4.6  继承–2</h3><p><strong>继承是面向对象三大特性之一</strong></p><p>有些类与类之间存在特殊的关系，例如下图中：</p><p><img src="E:/MD/assets/1544861202252.png" alt="1544861202252"></p><p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p>重要但不难</p><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p><strong>普通实现：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.<span class="built_in">header</span>();</span><br><span class="line">cp.<span class="built_in">footer</span>();</span><br><span class="line">cp.<span class="built_in">left</span>();</span><br><span class="line">cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承实现：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.<span class="built_in">header</span>();</span><br><span class="line">cp.<span class="built_in">footer</span>();</span><br><span class="line">cp.<span class="built_in">left</span>();</span><br><span class="line">cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>继承的好处：&#x3D;&#x3D;可以减少重复的代码&#x3D;&#x3D;</p><blockquote><p>class A : public B; </p><p><strong>A 类称为子类 或 派生类</strong></p><p><strong>B 类称为父类 或 基类</strong></p></blockquote><p><strong>派生类中的成员，包含两大部分</strong>：</p><p><strong>一类是从基类继承过来的，一类是自己增加的成员。</strong></p><p>从基类继承过过来的表现其共性，而新增的成员体现了<strong>其个性</strong>。</p><h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p><p><strong>继承方式一共有三种：</strong></p><blockquote><ul><li><h4 id="公共继承-原来是啥还是啥，只不过不可以访问父亲的私有的"><a href="#公共继承-原来是啥还是啥，只不过不可以访问父亲的私有的" class="headerlink" title="公共继承,原来是啥还是啥，只不过不可以访问父亲的私有的"></a>公共继承,原来是啥还是啥，只不过不可以访问父亲的私有的</h4></li><li><h4 id="保护继承-除了private都变成protected"><a href="#保护继承-除了private都变成protected" class="headerlink" title="保护继承  除了private都变成protected"></a>保护继承  除了private都变成protected</h4></li><li><h4 id="私有继承-全变成private；"><a href="#私有继承-全变成private；" class="headerlink" title="私有继承 全变成private；"></a>私有继承 全变成private；</h4></li></ul><p>在C++中，<strong>派生类确实继承了基类的所有成员，包括私有成员。</strong>但是，<strong>私有成员在派生类中是不可访问的。</strong>这<strong>意味着派生类无法直接访问或继承基类的私有成员。</strong></p><p><strong>私有成员只能在基类内部访问</strong>，派生类无法直接访问或继承私有成员。这是因为<strong>私有成员被设计为只能在基类内部使用，对外部是不可见的。****派生类只能通过基类的公有和保护成员来访问和操作私有成员</strong>。</p><p><strong>只是编译器把父类的private给隐藏了，子类不可访问</strong></p></blockquote><p><img src="E:/MD/assets/clip_image002.png" alt="img"></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son1 s1;</span><br><span class="line">s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2 s;</span><br><span class="line"><span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line"><span class="comment">//m_A;</span></span><br><span class="line"><span class="comment">//m_B;</span></span><br><span class="line"><span class="comment">//m_C;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="&#x3D;&#x3D;4.6.3 继承中的对象模型&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.6.3 继承中的对象模型&#x3D;&#x3D;</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p><blockquote><p><strong>在C++中，子类继承了父类的函数，但子类函数和父类函数并不指向同一块地址。</strong></p><p><strong>当子类继承父类的函数时，子类会创建一个新的函数，该函数与父类的函数具有相同的名称和参数列表，但是可以有不同的实现（重写）或相同的实现（继承）。</strong></p><p><strong>子类函数和父类函数是两个独立的函数，它们具有不同的地址。子类对象可以通过子类函数来调用子类的实现，而父类对象可以通过父类函数来调用父类的实现。</strong></p><hr><p><strong>在C++中，子类继承了父类的成员变量，但子类的成员变量和父类的成员变量并不指向同一块地址。子类对象包含了父类对象的所有成员变量，但它们在内存中是独立存储的。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> parentVar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Parent parent;</span><br><span class="line">    Child child;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印父类成员变量地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;父类成员变量地址：&quot;</span> &lt;&lt; &amp;(parent.parentVar) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印子类成员变量地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子类成员变量地址：&quot;</span> &lt;&lt; &amp;(child.parentVar) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//16</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用工具查看：</p><p>![image-20230729223112618](C:\Users\许闰博\Desktop\C++\C-Resource-master\第3阶段-C++核心编程 资料\讲义\C++核心编程.assets\image-20230729223112618.png)</p><p>打开工具窗口后，定位到当前CPP文件的盘符</p><p>![image-20230729222903401](C:\Users\许闰博\Desktop\C++\C-Resource-master\第3阶段-C++核心编程 资料\讲义\C++核心编程.assets\image-20230729222903401.png)</p><p>然后输入： cl &#x2F;d1 reportSingleClassLayout查看的类名   所属文件名</p><p>table</p><p>效果如下图：</p><p><img src="E:/MD/assets/1545882158050.png" alt="1545882158050"></p><blockquote><p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote><h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><p><strong>因为是继承，肯定要先创建一个父类</strong></p><p><strong>先父亲后儿子，和之前的类里面有别的类的时候，</strong></p><p>4.2.7 类对象作为类成员是有区别的</p><p>类里面有类的时候是先构造里面的然后再构造外面的！！！</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="总结：继承中-先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反"><a href="#总结：继承中-先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反" class="headerlink" title="总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反"></a>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</h4></blockquote><h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><blockquote><ul><li><h4 id="访问子类同名成员-直接访问即可"><a href="#访问子类同名成员-直接访问即可" class="headerlink" title="访问子类同名成员   直接访问即可"></a>访问子类同名成员   直接访问即可</h4></li><li><h4 id="访问父类同名成员-需要加作用域"><a href="#访问父类同名成员-需要加作用域" class="headerlink" title="访问父类同名成员   需要加作用域"></a>访问父类同名成员   需要加作用域</h4></li><li><p>直接调用就是儿子的，</p><p><strong>&#x2F;&#x2F;当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</strong><br><strong>&#x2F;&#x2F;如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</strong></p></li></ul></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这是父类的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Base1</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这是父类的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是父亲！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B ;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是儿子！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Son1</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这是子类的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Son1</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这是子类的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_A=<span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line"><span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son1 s1;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;子类的同名是&quot;</span>&lt;&lt; s1.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;父类的同名是&quot;</span> &lt;&lt; s1.Base1::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">s1.<span class="built_in">func</span>();</span><br><span class="line">s1.Base1::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s1.Base1::<span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Son1) &lt;&lt; endl;</span><br><span class="line"><span class="comment">//16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><blockquote><ol><li><h5 id="子类对象可以直接访问到子类中同名成员"><a href="#子类对象可以直接访问到子类中同名成员" class="headerlink" title="子类对象可以直接访问到子类中同名成员"></a>子类对象可以直接访问到子类中同名成员</h5></li><li><h5 id="子类对象加作用域可以访问到父类同名成员"><a href="#子类对象加作用域可以访问到父类同名成员" class="headerlink" title="子类对象加作用域可以访问到父类同名成员"></a>子类对象加作用域可以访问到父类同名成员</h5></li><li><h5 id="当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数-包括重载的，都没用，加作用域可以访问到父类中同名函数"><a href="#当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数-包括重载的，都没用，加作用域可以访问到父类中同名函数" class="headerlink" title="当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数,包括重载的，都没用，加作用域可以访问到父类中同名函数"></a>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数,包括重载的，都没用，<em>加作用域</em>可以访问到父类中同名函数</h5></li></ol></blockquote><h4 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h4><p><strong>1.静态成员可以通过类名来访问！</strong></p><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p><strong>静态成员和非静态成员出现同名，处理方式一致</strong></p><p>想要使用父亲的就加作用域就欧克了！！！</p><blockquote><h5 id="访问子类同名成员-直接访问即可-1"><a href="#访问子类同名成员-直接访问即可-1" class="headerlink" title="访问子类同名成员   直接访问即可"></a>访问子类同名成员   直接访问即可</h5><h5 id="访问父类同名成员-需要加作用域-1"><a href="#访问父类同名成员-需要加作用域-1" class="headerlink" title="访问父类同名成员   需要加作用域"></a>访问父类同名成员   需要加作用域</h5></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">    <span class="comment">//第一个双冒号：代表通过类名方式访问，第二个双冒号是，代表访问父类的作用域下！！！！</span></span><br><span class="line">Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认是Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;要想用父亲的就加作用域Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Base::m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//想要用子类来访问父类的静态成员变量就得用这种</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认是Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;要想用父亲的就加作用域Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Base::m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//想要用子类来访问父类的静态成员变量就得用这种</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">    <span class="comment">//第一个双冒号：代表通过类名方式访问，第二个双冒号是，代表访问父类的作用域下！！！！</span></span><br><span class="line">Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p></blockquote><h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p><hr><p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><hr><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><p>子类想用自己的 就类名.使用</p><p>子类想用爹爹们的 就用 子类名.父类::对应的数据</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base2</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_C = <span class="number">300</span>;</span><br><span class="line">m_D = <span class="number">400</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line"><span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote><h4 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p><p>​两个派生类继承同一个基类</p><p>​又有某个类同时继承者两个派生类</p><p>​这种继承被称为菱形继承，或者钻石继承</p><p><strong>典型的菱形继承案例：</strong></p><p><img src="E:/MD/assets/clip_image002.jpg" alt="IMG_256"></p><p><strong>菱形继承问题：</strong></p><ol><li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</code></pre></li><li><pre><code>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</code></pre></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SheepTuo st;</span><br><span class="line">st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul><blockquote><p><strong>解释虚继承（virtual inheritance）的概念</strong></p><p>在C++中，当一个类被继承时，子类会包含父类的成员变量和成员函数。如果一个类被多个子类继承，那么每个子类都会包含一份父类的成员变量和成员函数，这可能会导致冗余和浪费。</p><p>为了解决这个问题，C++引入了虚继承（virtual inheritance）的概念。虚继承可以确保在多继承中，对于公共的基类，只有一份实例存在于继承体系中。通过使用<code>virtual</code>关键字来声明虚继承。</p><p>在您的代码中，<code>Sheep</code>和<code>Tuo</code>类都使用了虚继承，它们都继承自虚基类<code>Animal</code>。而<code>SheepTuo</code>类继承自<code>Sheep</code>和<code>Tuo</code>类。</p><p>在加入虚继承之前，<code>SheepTuo</code>类中会包含两份<code>m_Age</code>成员变量，分别来自于<code>Sheep</code>和<code>Tuo</code>类。而加入虚继承后，<code>SheepTuo</code>类中只会包含一份<code>m_Age</code>成员变量，来自于虚基类<code>Animal</code>。</p><p>因此，加入虚继承后，<code>SheepTuo</code>对象的大小（占用的字节数）会减小。在您的代码中，输出<code>sizeof(st)</code>可以看到<code>SheepTuo</code>对象的大小变为4。</p><p>另外，由于虚继承的特性，通过类名作用域来访问虚基类的成员变量。在您的代码中，使用<code>st.Sheep::m_Age</code>和<code>st.Tuo::m_Age</code>来访问<code>Sheep</code>和<code>Tuo</code>类中的<code>m_Age</code>成员变量。</p><p>最后，注释掉的<code>cout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;</code>语句会导致编译错误，因为在虚继承中，访问虚基类的成员变量需要使用类名作用域。</p><hr><p>在虚继承中，除了会包含虚基类的成员变量，还会包含一些额外的信息来处理虚继承的相关操作，比如虚基类指针或虚基类表。这些额外的信息会导致对象的大小增加。</p><hr><p><strong>确定虚基类的大小？想吧你哈哈</strong></p><p>确定虚基类指针或虚基类表所占字节的具体方法是依赖于编译器和系统的实现细节的。不同的编译器和系统可能会有不同的实现方式。</p><p>一种常见的实现方式是，在虚继承中，编译器会为每个包含虚基类的类生成一个虚基类表（vtable）。虚基类表是一个数据结构，用于存储虚基类的相关信息，比如虚基类的偏移量等。</p><p>虚基类指针是一个指向虚基类表的指针，用于在运行时动态查找虚基类的成员。虚基类指针的大小通常是一个指针的大小，即在32位系统中通常是4个字节，在64位系统中通常是8个字节。</p><p>虚基类表的大小取决于虚基类的数量和虚基类的成员变量和成员函数的数量。每个虚基类在虚基类表中占据一定的空间，用于存储虚基类的相关信息。</p></blockquote><h3 id="4-7-多态–3"><a href="#4-7-多态–3" class="headerlink" title="4.7  多态–3"></a>4.7  多态–3</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li>静态多态: <strong>函数重载 和 运算符重载属于静态多态，复用函数名</strong></li><li>动态多态: <strong>派生类和虚函数实现运行时多态</strong></li></ul><p>静态多态和动态多态区别：</p><ul><li><strong>静态多态的函数地址早绑定  -  编译阶段确定函数地址</strong></li><li><strong>动态多态的函数地址晚绑定</strong>  -  运行阶段确定函数地址</li></ul><hr><p><strong>等号左边编译类型右边运行类型，早绑定看编译类型，晚绑定看运行类型</strong></p><p><strong>Animal&amp; animal与传入的东西</strong></p><hr><p>&#x3D;&#x3D;就相当于重载函数，本来必须在同一作用域下才能重载，vritual允许父子类之间函数重载&#x3D;&#x3D;</p><p>下面通过案例进行讲解多态</p><blockquote><p>&#x2F;函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</p><p>&#x2F;&#x2F;我们希望传入什么对象，那么就调用什么对象的函数<br>&#x2F;&#x2F;如果函数地址在编译阶段就能确定，那么静态联编<br>&#x2F;&#x2F;如果函数地址在运行阶段才能确定，就是动态联编</p><hr><p>&#x2F;&#x2F;多态满足条件：<br>&#x2F;&#x2F;1、有继承关系<br>&#x2F;&#x2F;2、子类重写父类中的虚函数,,此时加不加 virtual都欧克<br>&#x2F;&#x2F;多态使用：<br><strong>———————————————&#x2F;&#x2F;父类指针或引用指向子类对象</strong>—————————————————-</p><p>父亲类 *pointer&#x3D;new 子类名;</p><p>父亲类&amp;p&#x3D;子类具体对象</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建+法计算器</span></span><br><span class="line">addCalculator add;</span><br><span class="line">AbstractCalculator&amp; abc = add;</span><br><span class="line"></span><br><span class="line">abc.a = <span class="number">10</span>;</span><br><span class="line">abc.b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc.<span class="built_in">getresult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">////////////////////////</span></span><br><span class="line"><span class="comment">//创建+法计算器</span></span><br><span class="line">AbstractCalculator* abc = <span class="keyword">new</span> <span class="built_in">addCalculator</span>();</span><br><span class="line"></span><br><span class="line">abc-&gt;a = <span class="number">10</span>;</span><br><span class="line">abc-&gt;b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;<span class="built_in">getresult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//释放对应的数据</span></span><br><span class="line"><span class="keyword">delete</span> abc;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//Speak函数就是虚函数</span></span><br><span class="line"><span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;动物在叫！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;喵喵喵！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//早绑定，编译阶段就把函数地址给绑定了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">(Animal&amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal.<span class="built_in">Speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal am;</span><br><span class="line">Cat cat;</span><br><span class="line"><span class="built_in">speak</span>(am);</span><br><span class="line"><span class="built_in">speak</span>(cat);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>没有重写speak函数的时候，通过继承，把父亲的虚函数也也继承下来了，而且在虚基表里是父类的函数</strong></p><p>![image-20230730140026926](C:\Users\许闰博\Desktop\C++\C-Resource-master\第3阶段-C++核心编程 资料\讲义\C++核心编程.assets\image-20230730140026926.png)</p><p>重写后</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;喵喵喵！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>![image-20230730140251440](C:\Users\许闰博\Desktop\C++\C-Resource-master\第3阶段-C++核心编程 资料\讲义\C++核心编程.assets\image-20230730140251440.png)</p><p>总结：</p><blockquote><p>C++中的多态是通过<strong>虚函数实现的</strong>。当<strong>基类指针或引用指向派生类对象时</strong>，可以通过<strong>该指针或引用调用虚函数时，会根据对象的实际类型来确定调用哪个类的虚函数。</strong></p><p>在C++中，<strong>每个包含虚函数的类都有一个虚函数表（vtable）</strong>。<strong>虚函数表是一个存储指向虚函数地址的指针数组。****每个对象都有一个指向其类的虚函数表的指针，称为虚函数指针（vptr）。</strong></p><p><strong>当对象被创建时，编译器会在对象的内存布局中添加一个隐藏的虚函数指针。</strong>这个指针指向该类的虚函数表。**&#x3D;&#x3D;如果类没有虚函数，那么它也不会有虚函数表和虚函数指针。&#x3D;&#x3D;**</p><p>当调用一个虚函数时，<strong>编译器会根据对象的虚函数指针找到对应的虚函数表，</strong>然<strong>后根据函数在虚函数表中的索引找到要调用的函数地址。</strong>这个过程是<strong>在运行时动态确定的</strong>，因此可以实现多态。</p><p>继承和重写是多态的基础。<strong>当派生类继承基类时，它会继承基类的虚函数，并可以选择重写这些虚函数。</strong></p><p>.<strong>通过重写，派生类可以为基类的虚函数提供自己的实现</strong>。</p><p>当使用基类指针或引用调用虚函数时，根据对象的实际类型，将调用派生类的虚函数。</p></blockquote><p>多态满足条件</p><ul><li><strong>有继承关系</strong></li><li><strong>子类重写父类中的虚函数</strong></li></ul><p>多态使用条件</p><ul><li><strong>父类指针或引用指向子类对象</strong></li></ul><p>重写：<strong>函数返回值类型  函数名 参数列表 完全一致称为重写</strong></p><h4 id="4-7-2-多态案例一-计算器类"><a href="#4-7-2-多态案例一-计算器类" class="headerlink" title="4.7.2 多态案例一-计算器类"></a>4.7.2 多态案例一-计算器类</h4><p><strong>‘’字符,””字符串</strong></p><p><strong>delete会把指针指向的内存权限释放，让这块内存可以被其他进程使用</strong></p><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getresult</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//+是一个字符串const char*</span></span><br><span class="line"><span class="comment">//或者strcmp(c,&#x27;+&#x27;)==0</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> a * b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Caculator caculator;</span><br><span class="line">caculator.a = <span class="number">10</span>;</span><br><span class="line">caculator.b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; caculator.<span class="built_in">getresult</span>(<span class="string">&#x27;+&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; caculator.<span class="built_in">getresult</span>(<span class="string">&#x27;-&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; caculator.<span class="built_in">getresult</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; caculator.<span class="built_in">getresult</span>(<span class="string">&#x27;/&#x27;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getresult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">addCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getresult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">jianCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getresult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">chengCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getresult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">chuCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getresult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建+法计算器</span></span><br><span class="line">AbstractCalculator* abc = <span class="keyword">new</span> <span class="built_in">addCalculator</span>();</span><br><span class="line"></span><br><span class="line">abc-&gt;a = <span class="number">10</span>;</span><br><span class="line">abc-&gt;b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;<span class="built_in">getresult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//释放对应的数据</span></span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建-法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> <span class="built_in">jianCalculator</span>();</span><br><span class="line">abc-&gt;a = <span class="number">10</span>;</span><br><span class="line">abc-&gt;b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;<span class="built_in">getresult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建*法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> <span class="built_in">chengCalculator</span>();</span><br><span class="line">abc-&gt;a = <span class="number">10</span>;</span><br><span class="line">abc-&gt;b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;<span class="built_in">getresult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line"><span class="comment">//创建/法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> <span class="built_in">chuCalculator</span>();</span><br><span class="line">abc-&gt;a = <span class="number">10</span>;</span><br><span class="line">abc-&gt;b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;<span class="built_in">getresult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line"><span class="comment">//销毁一次后仅仅完成了空间的释放,此时还可以使用,即指向关系依然存在,</span></span><br><span class="line"><span class="comment">//但如果释放了两次以上指向关系将不存在,但一般不建议这样使用,</span></span><br><span class="line"><span class="comment">//既然释放了某空间,紧接着给该空间的指针赋值为NULL或者指向一个地方,养成良好的编程风格</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p><p><strong><strong>&#x2F;&#x2F;销毁一次后仅仅完成了空间的释放,此时还可以使用,即指向关系依然存在,</strong><br>    <strong>&#x2F;&#x2F;但如果释放了两次以上指向关系将不存在,但一般不建议这样使用,</strong><br>    &#x2F;&#x2F;既然释放了某空间,紧接着给该空间的指针赋值为NULL或者指向一个地方,养成良好的编程风格</strong></p></blockquote><h4 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="&#x3D;&#x3D;4.7.3 纯虚函数和抽象类&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.7.3 纯虚函数和抽象类&#x3D;&#x3D;</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><blockquote><p><strong>抽象类不能实例化，但是能定义一个指向该类的指针</strong></p></blockquote><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><hr><p><strong>当类中有了纯虚函数，这个类也称为&#x3D;&#x3D;抽象类&#x3D;&#x3D;</strong></p><p><strong>纯虚函数是在<em>基类</em>中声明为纯虚函数的虚函数，它没有实现，只是用来作为接口的占位符，要求派生类必须实现这个函数。</strong></p><hr><p><strong>抽象类特点</strong>：</p><ul><li><strong>无法实例化对象</strong></li><li><strong>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</strong></li></ul><blockquote><p>纯虚函数来自</p><ol><li><strong>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></strong></li><li><strong>继承抽象类但不重写对应的纯虚函数！！！！！！！</strong></li><li>有虚析构函数或者纯虚析构函数</li></ol></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line"><span class="comment">//抽象类无法实例化对象</span></span><br><span class="line"><span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base * base = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">base = <span class="keyword">new</span> Son;</span><br><span class="line">base-&gt;<span class="built_in">func</span>();</span><br><span class="line"><span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-4-多态案例二-制作饮品"><a href="#4-7-4-多态案例二-制作饮品" class="headerlink" title="4.7.4 多态案例二-制作饮品"></a>4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p><p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><p><img src="E:/MD/assets/1545985945198.png" alt="1545985945198"></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Makedrink</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">zhushui</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">chongru</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">daorubeizhong</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">jiaruzuoliao</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//规定流程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Makeit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">zhushui</span>();</span><br><span class="line"><span class="built_in">chongru</span>();</span><br><span class="line"><span class="built_in">daorubeizhong</span>();</span><br><span class="line"><span class="built_in">jiaruzuoliao</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MakeCha</span> :<span class="keyword">public</span> Makedrink</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zhushui</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;做茶的时候煮水&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chongru</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡茶叶&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">daorubeizhong</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;倒入杯子&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">jiaruzuoliao</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加柠檬&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Makecoffee</span> :<span class="keyword">public</span> Makedrink</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zhushui</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;做咖啡的时候煮水&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chongru</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡咖啡&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">daorubeizhong</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;倒入杯子&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">jiaruzuoliao</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加牛奶和冰糖&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dowork</span><span class="params">(Makedrink* abc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">abc-&gt;<span class="built_in">Makeit</span>();</span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Makedrink* mc = <span class="keyword">new</span> <span class="built_in">MakeCha</span>();</span><br><span class="line"><span class="built_in">Dowork</span>(mc);</span><br><span class="line"><span class="built_in">Dowork</span>(<span class="keyword">new</span> MakeCha);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;现在开始制作咖啡&quot;</span> &lt;&lt; endl;</span><br><span class="line">Makedrink* cf = <span class="keyword">new</span> <span class="built_in">Makecoffee</span>();</span><br><span class="line"><span class="built_in">Dowork</span>(cf);</span><br><span class="line"><span class="built_in">Dowork</span>(<span class="keyword">new</span> MakeCha);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h4><p><strong>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</strong></p><p><strong>也就是说不运行子类的析构函数！！！造成内存泄漏</strong></p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>​<strong>如果改成纯虚析构的话需要在函数外部进行 函数实现</strong></p><p>​<strong>或者就是简单的弄一个虚析构函数就ok了</strong></p><p>虚析构和纯虚析构共性：</p><ul><li><strong>可以解决父类指针释放子类对象</strong></li><li><strong>都需要有具体的函数实现</strong>，纯虚析构函数的实现必须在外部！</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p><strong>虚析构函数通常在希望通过基类指针或引用来删除派生类对象时使用。这样可以确保派生类的析构函数被正确调用，避免内存泄漏。</strong></p><p>虚析构语法：</p><p><code>virtual ~类名()&#123;&#125;</code></p><p>纯虚析构语法：</p><p><code> virtual ~类名() = 0;</code></p><p><strong>必须需要有外部实现！！！</strong></p><p><code>类名::~类名()&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//不加virtual的时候不会走子类的 析构函数 造成内存泄露</span></span><br><span class="line"><span class="comment">//析构函数加上virtual关键字，变成虚析构函数  就会走子类的析构函数了</span></span><br><span class="line"><span class="comment">//virtual ~Animal()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者是纯虚析构函数，但要有函数实现！！且在外部</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cat</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//虚函数的重写</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; *m_Name &lt;&lt; <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Cat</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_Name;</span><br><span class="line">m_Name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string* m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal* animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line"><span class="comment">//怎么解决？给基类增加一个虚析构函数 或者纯虚析构函数，但是明显是虚析构函数简单a Aaaaa</span></span><br><span class="line"><span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line"><span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><blockquote><h4 id="1-虚析构或纯虚析构就是用来解决通过父类指针释放子类对象"><a href="#1-虚析构或纯虚析构就是用来解决通过父类指针释放子类对象" class="headerlink" title="1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象"></a>1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</h4><h4 id="2-如果子类中没有堆区数据，可以不写为虚析构或纯虚析构"><a href="#2-如果子类中没有堆区数据，可以不写为虚析构或纯虚析构" class="headerlink" title="2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构"></a>2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</h4><h4 id="3-拥有纯虚析构函数的类也属于抽象类"><a href="#3-拥有纯虚析构函数的类也属于抽象类" class="headerlink" title="3. 拥有纯虚析构函数的类也属于抽象类"></a>3. 拥有纯虚析构函数的类也属于抽象类</h4></blockquote><h4 id="4-7-6-多态案例三-电脑组装"><a href="#4-7-6-多态案例三-电脑组装" class="headerlink" title="&#x3D;&#x3D;4.7.6 多态案例三-电脑组装&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.7.6 多态案例三-电脑组装&#x3D;&#x3D;</h4><p><strong>案例描述：</strong></p><p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p><p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p><p>测试时组装三台不同的电脑进行工作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的计算函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的存储函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Computer</span>(CPU* cpu, VideoCard* vc, Memory* mem)</span><br><span class="line">&#123;</span><br><span class="line">m_cpu = cpu;</span><br><span class="line">m_vc = vc;</span><br><span class="line">m_mem = mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供工作的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">~<span class="built_in">Computer</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放CPU零件</span></span><br><span class="line"><span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_cpu;</span><br><span class="line">m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放显卡零件</span></span><br><span class="line"><span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_vc;</span><br><span class="line">m_vc = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存条零件</span></span><br><span class="line"><span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_mem;</span><br><span class="line">m_mem = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">CPU* m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">VideoCard* m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">Memory* m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//第一台电脑零件</span></span><br><span class="line">CPU* intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">VideoCard* intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">Memory* intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//创建第一台电脑</span></span><br><span class="line">Computer* computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//第二台电脑组装</span></span><br><span class="line">Computer* computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);</span><br><span class="line">computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer2;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//第三台电脑组装</span></span><br><span class="line">Computer* computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);</span><br><span class="line">computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过<strong>文件可以将数据持久化</strong></p><p>C++中对文件操作需要包含头文件 &#x3D;&#x3D;&lt; fstream &gt;&#x3D;&#x3D;</p><p>文件类型分为两种：</p><ol><li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li><li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li></ol><p>操作文件的三大类:</p><ol><li>ofstream：写操作</li><li>ifstream： 读操作</li><li>fstream ： 读写操作</li></ol><h3 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h3><h4 id="5-1-1写文件"><a href="#5-1-1写文件" class="headerlink" title="5.1.1写文件"></a>5.1.1写文件</h4><p>   写文件步骤如下：</p><ol><li><p>包含头文件   </p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象  </p><p>ofstream ofs;</p></li><li><p>打开文件</p><p>ofs.open(“文件路径”,打开方式);</p></li><li><p>写数据</p><p>ofs &lt;&lt; “写入的数据”;</p></li><li><p>关闭文件</p><p>ofs.close();</p></li></ol><p>文件打开方式：</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p><p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p><blockquote><p>在C++中，<code>|</code> 是位运算符中的按位或运算符。当它用于两个整数时，它将对这两个整数的每个位执行逻辑或操作。</p><p>在文件操作中，<code>|</code> 运算符通常用于将多个标志（flag）组合在一起。在你提供的例子中，<code>ios::binary | ios::out</code> 将 <code>ios::binary</code> 和 <code>ios::out</code> 这两个标志进行按位或运算，以便将它们组合在一起。</p><p><code>ios::binary</code> 是 <code>ios</code> 类中的一个标志，表示以二进制模式打开文件。在二进制模式下，文件将以字节流的形式进行读写，而不会进行任何文本转换。</p><p><code>ios::out</code> 是另一个 <code>ios</code> 类中的标志，表示以写入模式打开文件。在写入模式下，文件将被打开以供写入操作。</p><p>通过将这两个标志使用 <code>|</code> 运算符组合在一起，你可以同时指定二进制模式和写入模式来打开文件。</p></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件操作必须包含头文件 fstream</li><li>读文件可以利用 ofstream  ，或者fstream类</li><li>打开文件时候需要指定操作文件的路径，以及打开方式</li><li>利用&lt;&lt;可以向文件中写数据</li><li>操作完毕，要关闭文件</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.包含fstream头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.测试写操作ooooo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.1创建对象!</span></span><br><span class="line"><span class="comment">//fstream a;</span></span><br><span class="line"><span class="comment">//也是ok的，为了区分，先引入总的头文件fstream，再用其分类ostream创建具体要写的对象</span></span><br><span class="line">ofstream a;</span><br><span class="line"><span class="comment">//1.2打开文件</span></span><br><span class="line">a.<span class="built_in">open</span>(<span class="string">&quot;E:/PROPORECODE/文件的读写操作/12.txt&quot;</span>, ios::out);</span><br><span class="line"><span class="comment">//1.3写入操作</span></span><br><span class="line">a &lt;&lt; <span class="string">&quot;你好啊&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//1.4关闭文件</span></span><br><span class="line">a.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-2读文件"><a href="#5-1-2读文件" class="headerlink" title="5.1.2读文件"></a>5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步骤如下：</p><ol><li><p>包含头文件   </p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象  </p><p>ifstream ifs;</p></li><li><p>打开文件并判断文件是否打开成功</p><p>ifs.open(“文件路径”,打开方式);</p></li><li><p>读数据</p><p>四种方式读取</p></li><li><p>关闭文件</p><p>ifs.close();</p></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//1.包含fstream头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.测试写操作ooooo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.1创建对象!</span></span><br><span class="line"><span class="comment">//fstream a;</span></span><br><span class="line"><span class="comment">//也是ok的，为了区分，先引入总的头文件fstream，再用其分类ostream创建具体要写的对象</span></span><br><span class="line">ofstream a;</span><br><span class="line"><span class="comment">//1.2打开文件</span></span><br><span class="line">a.<span class="built_in">open</span>(<span class="string">&quot;E:/PROPORECODE/文件的读写操作/11.txt&quot;</span>, ios::out | ios::binary);</span><br><span class="line"><span class="comment">//1.3写入操作</span></span><br><span class="line"><span class="comment">//&quot;你好啊&quot; &lt;&lt; endl;都被写进去了</span></span><br><span class="line">a &lt;&lt; <span class="string">&quot;你好啊dasdad &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//1.4关闭文件</span></span><br><span class="line">a.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.测试读文件</span></span><br><span class="line"><span class="comment">//2.1创建读的对象iiii</span></span><br><span class="line">fstream b;</span><br><span class="line">b.<span class="built_in">open</span>(<span class="string">&quot;E:/PROPORECODE/文件的读写操作/11.txt&quot;</span>, ios::in);</span><br><span class="line"><span class="keyword">if</span> (b.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;打开成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;打开失败！，草！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//读取1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//char bufer[1024];</span></span><br><span class="line"><span class="comment">//while (b&gt;&gt;bufer)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; bufer;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//读取2类内的getline</span></span><br><span class="line"><span class="comment">//char bufer[1024] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//while (b.getline(bufer, sizeof(bufer)))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; bufer &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//读取3全局getline</span></span><br><span class="line"><span class="comment">//string str;</span></span><br><span class="line"><span class="comment">//while (getline(b,str))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; str &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> (c=b.<span class="built_in">get</span>()!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从右到左！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><blockquote><ul><li><strong>读文件可以利用 ifstream  ，或者fstream类</strong></li><li><strong>利用is_open函数可以判断文件是否打开成功</strong></li><li><strong>close 关闭文件</strong></li></ul></blockquote><h3 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为 &#x3D;&#x3D;ios::binary&#x3D;&#x3D;</p><h4 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> name[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">fstream <span class="title">a</span><span class="params">(<span class="string">&quot;E:/PROPORECODE/文件的读写操作/21.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">MyStruct xrb = &#123; <span class="number">18</span>,<span class="string">&quot;李四&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//结构体的实例化</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">a.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;xrb, <span class="built_in">sizeof</span>(str));</span><br><span class="line"></span><br><span class="line">a.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件输出流对象 可以通过write函数，以二进制方式写数据</li></ul><h4 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> name[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">fstream <span class="title">a</span><span class="params">(<span class="string">&quot;E:/PROPORECODE/文件的读写操作/21.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">MyStruct xrb = &#123; <span class="number">18</span>,<span class="string">&quot;李四&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//结构体的实例化</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">a.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;xrb, <span class="built_in">sizeof</span>(xrb));</span><br><span class="line"></span><br><span class="line">a.<span class="built_in">close</span>();</span><br><span class="line">fstream b;</span><br><span class="line">b.<span class="built_in">open</span>(<span class="string">&quot;E:/PROPORECODE/文件的读写操作/21.txt&quot;</span>, ios::in | ios::binary);</span><br><span class="line"><span class="keyword">if</span> (b.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;读取成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">MyStruct l;</span><br><span class="line">b.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;l, <span class="built_in">sizeof</span>(l));</span><br><span class="line">cout &lt;&lt; l.age &lt;&lt; l.name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文件输入流对象 可以通过read函数，以二进制方式读数据</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>qt</title>
      <link href="/post/2095ef6d.html"/>
      <url>/post/2095ef6d.html</url>
      
        <content type="html"><![CDATA[<h2 id="QT前言"><a href="#QT前言" class="headerlink" title="QT前言"></a>QT前言</h2><blockquote><p>以下是一些适合用来练手的 Qt 项目，按照从简单到难的顺序排列：</p><ol><li>简单的计算器：创建一个简单的计算器应用程序，可以进行基本的数学运算，如加法、减法、乘法和除法。</li><li>TodoList 应用程序：创建一个简单的 TodoList 应用程序，可以添加、删除和编辑待办事项。</li><li>图片查看器：创建一个简单的图片查看器，可以打开和浏览图片文件，并提供一些基本的操作，如缩放、旋转和切换图片。</li><li>聊天应用程序：创建一个简单的聊天应用程序，可以实现基本的消息发送和接收功能，可以在本地或网络上进行通信。</li><li>文件管理器：创建一个简单的文件管理器，可以浏览和管理文件和文件夹，提供基本的文件操作，如复制、粘贴和删除。</li><li>图书馆管理系统：创建一个图书馆管理系统，可以管理图书的借阅和归还，提供图书搜索和借阅记录等功能。</li><li>图形化绘图应用程序：创建一个具有绘图功能的应用程序，可以绘制基本的图形，如线条、矩形和椭圆，并提供颜色和线条宽度选择等功能。</li><li>电子邮件客户端：创建一个简单的电子邮件客户端，可以发送和接收电子邮件，支持多个邮件账户和邮件夹管理。</li><li>在线音乐播放器：创建一个在线音乐播放器，可以搜索和播放音乐，支持创建播放列表和收藏喜欢的音乐。</li><li>3D 游戏：创建一个简单的 3D 游戏，可以实现基本的游戏功能，如角色移动、碰撞检测和得分计算。</li></ol><p>这些项目涵盖了从简单到复杂的不同领域和功能。你可以根据自己的兴趣和能力选择适合的项目进行练手。在实现这些项目的过程中，你将学习和应用 Qt 的各种功能，提高自己的编程技能。</p><hr><hr><p>在使用 Qt 进行项目开发时，你需要掌握一些与 C++ 和 Qt 相关的知识。以下是一些你可能需要学习的主题：</p><ol><li><p>C++ 基础知识：你需要熟悉 C++ 的基本语法、数据类型、控制流程、函数和类等概念。这些知识对于理解和编写 Qt 代码是基础。</p></li><li><p>Qt 基础知识：你需要学习 Qt 的基本概念和类库。这包括了 Qt 的核心模块（如 QObject、QWidget 和 QApplication）以及其他模块（如 Qt Widgets、Qt GUI 和 Qt Network）。你需要了解这些模块的类和功能，以便在项目中使用它们。</p></li><li><p>信号与槽机制：Qt 使用信号与槽机制来实现对象之间的通信。你需要学习如何定义和连接信号与槽，以及如何在应用程序中使用它们。</p></li><li><p>Qt 布局管理器：Qt 提供了一套布局管理器来帮助你在窗口中进行控件布局。你需要学习如何使用布局管理器来自动调整和排列控件，以适应不同的窗口大小和分辨率。</p></li><li><p>Qt 事件处理：Qt 使用事件来处理用户输入和其他系统事件。你需要学习如何重写事件处理函数，以便在应用程序中响应和处理不同类型的事件。</p></li><li><p>Qt 文件和网络操作：在许多应用程序中，你可能需要进行文件读写和网络通信。你需要学习如何使用 Qt 提供的类来进行文件和网络操作，如 QFile、QDir、QNetworkAccessManager 和 QNetworkRequest。</p></li><li><p>Qt 多线程编程：如果你的应用程序需要进行并发处理或长时间运行的任务，你可能需要学习如何使用 Qt 的多线程机制来实现线程间的通信和同步。</p></li><li><p>Qt 数据库访问：如果你的应用程序需要与数据库进行交互，你需要学习如何使用 Qt 提供的数据库模块（如 QSqlDatabase 和 QSqlQuery）来连接和操作数据库。</p></li></ol><p>以上是一些与 C++ 和 Qt 相关的主题，你可以根据自己的项目需求和兴趣选择学习的内容。Qt 官方文档和教程是学习这些知识的好资源，你可以参考它们来深入学习和实践。</p><hr><ol><li><strong>编写实际项目</strong>：实践是学习编程的关键。尝试编写一些小型的Qt应用程序或项目，以应用您学到的知识。通过实际项目的编写，您可以更好地理解概念，发现问题并学习解决方案。</li><li><strong>参考示例代码</strong>：Qt提供了大量的示例代码，涵盖了各种功能和应用场景。阅读和理解这些示例代码可以帮助您学习Qt的最佳实践和常用模式。</li><li><strong>参与社区</strong>：加入Qt和C++的开发者社区，参与讨论和交流。这样可以与其他开发者分享经验、解决问题，并从他们的经验中学习。</li><li><strong>坚持练习</strong>：编程需要不断的练习和实践。坚持练习编写代码，并尝试解决各种问题和挑战。通过不断地练习，您可以加深对Qt和C++的理解，并提高编程技能。</li><li><strong>多种学习资源</strong>：除了官方文档外，还可以使用在线教程、书籍、视频教程等多种学习资源。选择适合您学习风格和需求的资源，以帮助您更好地学习Qt和C++。</li><li><strong>复习和总结</strong>：定期复习和总结您学到的知识。回顾之前学习的内容，巩固和加深对概念和技术的理解。</li><li><strong>持续学习</strong>：Qt和C++是广阔而深入的领域，持续学习是成为优秀程序员的关键。保持对新技术和最佳实践的学习兴趣，并持续提升自己的技能。</li></ol><p>记住，学习编程需要时间和耐心。重要的是保持积极的学习态度，并坚持不懈地学习和实践。祝您在Qt和C++编程的学习中取得成功！</p></blockquote><h2 id="QT打包"><a href="#QT打包" class="headerlink" title="QT打包"></a>QT打包</h2><h2 id="c-类型转换static-cast和reinterpret-cast"><a href="#c-类型转换static-cast和reinterpret-cast" class="headerlink" title="c++类型转换static_cast&lt;&gt;和reinterpret_cast&lt;&gt;"></a>c++类型转换<em><strong>static_cast&lt;&gt;和reinterpret_cast&lt;&gt;</strong></em></h2><blockquote><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast&lt;&gt;"></a>static_cast&lt;&gt;</h2><p><code>static_cast&lt;&gt;</code> 是 C++ 中的一种<strong>类型转换运算符</strong>，用于在编译时进行类型转换。它可以用于将一种类型转换为另一种类型，包括基本类型、类类型和指针类型。</p><p><code>static_cast&lt;&gt;</code> 的语法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;目标类型&gt;(表达式)</span><br></pre></td></tr></table></figure><p>其中，<code>目标类型</code> 是你希望将表达式转换为的类型，而 <code>表达式</code> 则是要进行转换的值或<strong>变量</strong>。</p><p>下面是一些示例用法：</p><ol><li>将整数转换为浮点数：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> result = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(num);</span><br></pre></td></tr></table></figure><ol start="2"><li>将浮点数转换为整数：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> num = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(num);</span><br></pre></td></tr></table></figure><ol start="3"><li><em>将指针类型转换为另一种指针类型</em>：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">char</span>* result = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(ptr);</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>static_cast&lt;&gt;</code> <strong>不会执行运行时的类型检查</strong>，因此转换的安全性需要由开发者自行保证。如果转换是不安全的，建议使用更加安全的类型转换运算符，如 <code>dynamic_cast&lt;&gt;</code> 或 <code>reinterpret_cast&lt;&gt;</code>。</p><p>总结起来，<code>static_cast&lt;&gt;</code> 是 C++ 中一种常用的类型转换运算符，<strong>用于在编译时进行类型转换</strong>。它可以将一种类型转换为另一种类型，但需要开发者自行确保转换的安全性。</p><hr><hr><hr><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast&lt;&gt;"></a>reinterpret_cast&lt;&gt;</h2><p><code>reinterpret_cast&lt;&gt;</code> 是 C++ 中的一种类型转换运算符，用<strong>于执行底层的强制类型转换</strong>。它可以将一个指针或引用转换为另一种指针或引用类型，甚至可以将指针或引用转换为整数类型。</p><p><code>reinterpret_cast&lt;&gt;</code> 的语法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reinterpret_cast</span>&lt;目标类型&gt;(表达式)</span><br></pre></td></tr></table></figure><p>其中，<code>目标类型</code> 是你希望将表达式转换为的类型，而 <code>表达式</code> 则是要进行转换的值或变量。</p><p>下面是一些示例用法：</p><ol><li>将指针类型转换为另一种指针类型：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">char</span>* result = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ptr);</span><br></pre></td></tr></table></figure><ol start="2"><li>将指针类型转换为整数类型：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">uintptr_t</span> result = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(ptr);</span><br></pre></td></tr></table></figure><ol start="3"><li>将整数类型转换为指针类型：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">uintptr_t</span> num = <span class="number">12345</span>;</span><br><span class="line"><span class="type">int</span>* result = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(num);</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>reinterpret_cast&lt;&gt;</code> 执行的是一种底层的强制类型转换，<strong>它可以绕过编译器的类型检查</strong>，因此需要开发者自行确保转换的安全性。使用 <code>reinterpret_cast&lt;&gt;</code> 进行类型转换时应该非常小心，确保转换的结果在语义上是合理的。</p><p>总结起来，<code>reinterpret_cast&lt;&gt;</code> 是 C++ 中一种类型转换运算符，用于执行底层的强制类型转换。它可以将指针或引用转换为另一种指针或引用类型，甚至可以将指针或引用转换为整数类型。使用 <code>reinterpret_cast&lt;&gt;</code> 进行类型转换时需要非常小心，确保转换的安全性和语义正确性。</p></blockquote><h2 id="QT快捷键"><a href="#QT快捷键" class="headerlink" title="QT快捷键"></a>QT<a href="https://blog.csdn.net/xideaha/article/details/132365224?spm=1001.2014.3001.5501">快捷键</a></h2><h2 id="QWIDGET"><a href="#QWIDGET" class="headerlink" title="QWIDGET"></a>QWIDGET</h2><img src="/post/2095ef6d/image-20230731110426486.png" class="" title="image-20230731110426486"><h2 id="Qdilog"><a href="#Qdilog" class="headerlink" title="Qdilog"></a>Qdilog</h2><img src="/post/2095ef6d/image-20230731111621860.png" class="" title="image-20230731111621860"><h2 id="Qmainwindow"><a href="#Qmainwindow" class="headerlink" title="Qmainwindow"></a>Qmainwindow</h2><p><strong>菜单栏和状态栏只能有一个工具栏可以有多个</strong></p><img src="/post/2095ef6d/image-20230731112301130.png" class="" title="image-20230731112301130"><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><img src="/post/2095ef6d/image-20230731201826875.png" class="" title="image-20230731201826875"><h2 id="Qbytearry"><a href="#Qbytearry" class="headerlink" title="Qbytearry"></a>Qbytearry</h2><img src="/post/2095ef6d/image-20230803095410076.png" class="" title="image-20230803095410076"><blockquote><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造空对象, 里边没有数据</span></span><br><span class="line">QByteArray::<span class="built_in">QByteArray</span>();</span><br><span class="line"><span class="comment">// 将data中的size个字符进行构造, 得到一个字节数组对象</span></span><br><span class="line"><span class="comment">// 如果 size==-1 函数内部自动计算字符串长度, 计算方式为: strlen(data)</span></span><br><span class="line">QByteArray::<span class="built_in">QByteArray</span>(<span class="type">const</span> <span class="type">char</span> *data, <span class="type">int</span> size = <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// 构造一个长度为size个字节, 并且每个字节值都为ch的字节数组</span></span><br><span class="line">QByteArray::<span class="built_in">QByteArray</span>(<span class="type">int</span> size, <span class="type">char</span> ch);</span><br></pre></td></tr></table></figure><blockquote><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在尾部追加数据</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::append</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::push_back</span><span class="params">(<span class="type">const</span> QByteArray &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头部添加数据</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::prepend</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::push_front</span><span class="params">(<span class="type">const</span> QByteArray &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据, 将ba插入到数组第 i 个字节的位置(从0开始)</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="comment">// 从大字符串中删除len个字符, 从第pos个字符的位置开始删除</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::remove</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符数组的尾部删除 n 个字节</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::chop</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字节数组的 pos 位置将数组截断 (前边部分留下, 后边部分被删除)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::truncate</span><span class="params">(<span class="type">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象中的数据清空, 使其为null</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串替换</span></span><br><span class="line"><span class="comment">// 将字节数组中的 子字符串 before 替换为 after</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::replace</span><span class="params">(<span class="type">const</span> QByteArray &amp;before, <span class="type">const</span> QByteArray &amp;after)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><h3 id="子字符串查找和判断"><a href="#子字符串查找和判断" class="headerlink" title="子字符串查找和判断"></a>子字符串查找和判断</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断字节数组中是否包含子字符串 ba, 包含返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::contains</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::contains</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 判断字节数组中是否包含字符 ch, 包含返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::contains</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字节数组是否以字符串 ba 开始, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::startsWith</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::startsWith</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 判断字节数组是否以字符 ch 开始, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::startsWith</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字节数组是否以字符串 ba 结尾, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::endsWith</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::endsWith</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 判断字节数组是否以字符 ch 结尾, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::endsWith</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">QByteArray::begin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">QByteArray::end</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组的方式进行遍历</span></span><br><span class="line"><span class="comment">// i的取值范围 0 &lt;= i &lt; size()</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">QByteArray::at</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="type">char</span> QByteArray::<span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arry1.<span class="built_in">size</span>();i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">qDebug</span>()&lt;&lt;arry1[i];</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="查看字节数"><a href="#查看字节数" class="headerlink" title="查看字节数"></a>查看字节数</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回字节数组对象中字符的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字节数组对象中 子字符串ba 出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::count</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::count</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回字节数组对象中 字符ch 出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::count</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将QByteArray类型的字符串 转换为 char* 类型</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">QByteArray::data</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">QByteArray::data</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">先搞个空对象</span><br><span class="line">    然后对象.set数据类型</span><br><span class="line"></span><br><span class="line"><span class="comment">// int, short, long, float, double -&gt; QByteArray</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(<span class="type">short</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(qlonglong n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(<span class="type">float</span> n, <span class="type">char</span> f = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> prec = <span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(<span class="type">double</span> n, <span class="type">char</span> f = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> prec = <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">[<span class="type">static</span>] <span class="function">QByteArray <span class="title">QByteArray::number</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QByteArray <span class="title">QByteArray::number</span><span class="params">(qlonglong n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QByteArray <span class="title">QByteArray::number</span><span class="params">(<span class="type">double</span> n, <span class="type">char</span> f = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> prec = <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QByteArray -&gt; int, short, long, float, double</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::toInt</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">short</span> <span class="title">QByteArray::toShort</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">QByteArray::toLong</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">QByteArray::toFloat</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">QByteArray::toDouble</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// std::string -&gt; QByteArray</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QByteArray <span class="title">QByteArray::fromStdString</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span>;</span><br><span class="line"><span class="comment">// QByteArray -&gt; std::string</span></span><br><span class="line"><span class="function">std::string <span class="title">QByteArray::toStdString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有字符转换为大写</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QByteArray::toUpper</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 所有字符转换为小写</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QByteArray::toLower</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><h2 id="QSTRING"><a href="#QSTRING" class="headerlink" title="QSTRING"></a>QSTRING</h2><img src="/post/2095ef6d/image-20230803095906153.png" class="" title="image-20230803095906153"><blockquote><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个空字符串对象</span></span><br><span class="line">QString::<span class="built_in">QString</span>();</span><br><span class="line"><span class="comment">// 将 char* 字符串 转换为 QString 类型</span></span><br><span class="line">QString::<span class="built_in">QString</span>(<span class="type">const</span> <span class="type">char</span> *str);</span><br><span class="line"><span class="comment">// 将 QByteArray 转换为 QString 类型</span></span><br><span class="line">QString::<span class="built_in">QString</span>(<span class="type">const</span> QByteArray &amp;ba);</span><br><span class="line"><span class="comment">// 其他重载的同名构造函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="数据操作-1"><a href="#数据操作-1" class="headerlink" title="数据操作"></a>数据操作</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尾部追加数据</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::append</span><span class="params">(<span class="type">const</span> QString &amp;str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::append</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::push_back</span><span class="params">(<span class="type">const</span> QString &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头部添加数据</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::prepend</span><span class="params">(<span class="type">const</span> QString &amp;str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::prepend</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::prepend</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::push_front</span><span class="params">(<span class="type">const</span> QString &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据, 将 str 插入到字符串第 position 个字符的位置(从0开始)</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::insert</span><span class="params">(<span class="type">int</span> position, <span class="type">const</span> QString &amp;str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::insert</span><span class="params">(<span class="type">int</span> position, <span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::insert</span><span class="params">(<span class="type">int</span> position, <span class="type">const</span> QByteArray &amp;str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="comment">// 从大字符串中删除len个字符, 从第pos个字符的位置开始删除</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::remove</span><span class="params">(<span class="type">int</span> position, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串的尾部删除 n 个字符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::chop</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 从字节串的 position 位置将字符串截断 (前边部分留下, 后边部分被删除)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::truncate</span><span class="params">(<span class="type">int</span> position)</span></span>;</span><br><span class="line"><span class="comment">// 将对象中的数据清空, 使其为null</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串替换</span></span><br><span class="line"><span class="comment">// 将字节数组中的 子字符串 before 替换为 after</span></span><br><span class="line"><span class="comment">// 参数 cs 为是否区分大小写, 默认区分大小写</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::replace</span><span class="params">(<span class="type">const</span> QString &amp;before, <span class="type">const</span> QString &amp;after, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="子字符串查找和判断-1"><a href="#子字符串查找和判断-1" class="headerlink" title="子字符串查找和判断"></a>子字符串查找和判断</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数 cs 为是否区分大小写, 默认区分大小写</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串中是否包含子字符串 str, 包含返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QString::contains</span><span class="params">(<span class="type">const</span> QString &amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串是否以字符串 ba 开始, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QString::startsWith</span><span class="params">(<span class="type">const</span> QString &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串是否以字符串 ba 结尾, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QString::endsWith</span><span class="params">(<span class="type">const</span> QString &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">QString::begin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">QString::end</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组的方式进行遍历</span></span><br><span class="line"><span class="comment">// i的取值范围 0 &lt;= position &lt; size()</span></span><br><span class="line"><span class="function"><span class="type">const</span> QChar <span class="title">QString::at</span><span class="params">(<span class="type">int</span> position)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> QChar QString::<span class="keyword">operator</span>[]<span class="params">(<span class="type">int</span> position)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><blockquote><h3 id="查看字节数-1"><a href="#查看字节数-1" class="headerlink" title="查看字节数"></a>查看字节数</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回字节数组对象中字符的个数 (字符个数和字节个数是不同的概念)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字节串对象中 子字符串 str 出现的次数</span></span><br><span class="line"><span class="comment">// 参数 cs 为是否区分大小写, 默认区分大小写</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::count</span><span class="params">(<span class="type">const</span> QStringRef &amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将int, short, long, float, double 转换为 QString 类型</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">short</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">float</span> n, <span class="type">char</span> format = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> precision = <span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">QString &amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">double</span> n, <span class="type">char</span> format = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> precision = <span class="number">6</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QString::number</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QString::number</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QString::number</span><span class="params">(<span class="type">double</span> n, <span class="type">char</span> format = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> precision = <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 QString 转换为 int, short, long, float, double 类型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::toInt</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">short</span> <span class="title">QString::toShort</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">QString::toLong</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">QString::toFloat</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">QString::toDouble</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将标准C++中的 std::string 类型 转换为 QString 类型</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QString::fromStdString</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span>;</span><br><span class="line"><span class="comment">// 将 QString 转换为 标准C++中的 std::string 类型</span></span><br><span class="line"><span class="function">std::string <span class="title">QString::toStdString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QString -&gt; QByteArray</span></span><br><span class="line"><span class="comment">// 转换为本地编码, 跟随操作系统</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QString::toLocal8Bit</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 转换为 Latin-1 编码的字符串 不支持中文</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QString::toLatin1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 转换为 utf8 编码格式的字符串 (常用)</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QString::toUtf8</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有字符转换为大写</span></span><br><span class="line"><span class="function">QString <span class="title">QString::toUpper</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 所有字符转换为小写</span></span><br><span class="line"><span class="function">QString <span class="title">QString::toLower</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="字符串格式"><a href="#字符串格式" class="headerlink" title="字符串格式"></a>字符串格式</h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString <span class="title">QString::arg</span><span class="params">(<span class="type">const</span> QString &amp;a, </span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">int</span> fieldWidth = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">          QChar fillChar = QLatin1Char( <span class="string">&#x27; &#x27;</span> ))</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QString <span class="title">QString::arg</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> fieldWidth = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">int</span> base = <span class="number">10</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">          QChar fillChar = QLatin1Char( <span class="string">&#x27; &#x27;</span> ))</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例程序</span></span><br><span class="line"><span class="type">int</span> i;                <span class="comment">// 假设该变量表示当前文件的编号</span></span><br><span class="line"><span class="type">int</span> total;            <span class="comment">// 假设该变量表示文件的总个数</span></span><br><span class="line">QString fileName;     <span class="comment">// 假设该变量表示当前文件的名字</span></span><br><span class="line"><span class="comment">// 使用以上三个变量拼接一个动态字符串</span></span><br><span class="line">QString status = <span class="built_in">QString</span>(<span class="string">&quot;Processing file %1 of %2: %3&quot;</span>)</span><br><span class="line">                  .<span class="built_in">arg</span>(i).<span class="built_in">arg</span>(total).<span class="built_in">arg</span>(fileName);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Qvariant"><a href="#Qvariant" class="headerlink" title="Qvariant"></a>Qvariant</h2><img src="/post/2095ef6d/image-20230803085428989.png" class="" title="image-20230803085428989"><img src="/post/2095ef6d/image-20230803085516873.png" class="" title="image-20230803085516873"><p>Qvariant(10+20),涉及到隐式转换，用构造函数或<strong>者,参数只能是标准数据类型</strong></p><p>现有一个QVariant空对象,,,,,,,,,,,,,,,,,,然后口对象.setvalue（10+20），就把实际计算的数据返回给了对象</p><p>T代表支持标准类型和我们自定义类型</p><img src="/post/2095ef6d/image-20230803085526477.png" class="" title="image-20230803085526477"><p>QVariant对象.type()</p><img src="/post/2095ef6d/image-20230803085534209.png" class="" title="image-20230803085534209"><p>QVariant对象.to 数据类型</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a=<span class="built_in">data</span>(<span class="number">10</span>,<span class="number">20</span>).<span class="built_in">toInt</span>();</span><br><span class="line">    QString str=<span class="built_in">data</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>).<span class="built_in">toString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;a;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">QVariant <span class="title">MainWindow::data</span><span class="params">(QVariant a,QVariant b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QVariant ret;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">type</span>()==QVariant::Int&amp;&amp;b.<span class="built_in">type</span>()==QVariant::Int)</span><br><span class="line">    &#123;</span><br><span class="line">        ret=<span class="built_in">QVariant</span>(a.<span class="built_in">toInt</span>()+b.<span class="built_in">toInt</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.<span class="built_in">type</span>()==QVariant::String&amp;&amp;b.<span class="built_in">type</span>()==QVariant::String)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        ret=QVariant(a.toString()+b.toString());</span></span><br><span class="line">        ret.<span class="built_in">setValue</span>(a.<span class="built_in">toString</span>()+b.<span class="built_in">toString</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Qvariant：：自定义数据类型"><a href="#Qvariant：：自定义数据类型" class="headerlink" title="Qvariant：：自定义数据类型"></a>Qvariant：：自定义数据类型</h2><img src="/post/2095ef6d/image-20230803090644987.png" class="" title="image-20230803090644987"><p>用Qvariant的</p><img src="/post/2095ef6d/image-20230803090805728.png" class="" title="image-20230803090805728"><img src="/post/2095ef6d/image-20230803090849381.png" class="" title="image-20230803090849381"><p><strong>———————————– ———————————- 使用方法——————————————————-</strong></p><img src="/post/2095ef6d/image-20230803091233080.png" class=""><img src="/post/2095ef6d/image-20230803091121738.png" class=""><p><strong>———————————————————下面取出数据—————————————————————————-</strong></p><blockquote><h3 id="c-value-返回里面的数据类型"><a href="#c-value-返回里面的数据类型" class="headerlink" title="c.value&lt;数据类型&gt;()返回&lt;&gt;里面的数据类型"></a><strong>c.value&lt;数据类型&gt;()返回&lt;&gt;里面的数据类型</strong></h3></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    Student xrb;</span><br><span class="line">    xrb.id=<span class="number">123</span>;</span><br><span class="line">    xrb.name=<span class="string">&quot;张大山&quot;</span>;</span><br><span class="line">    <span class="comment">//1//</span></span><br><span class="line">    QVariant c;</span><br><span class="line">    c.<span class="built_in">setValue</span>(xrb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2//</span></span><br><span class="line">    <span class="comment">//QVariant v=QVariant::fromValue(xrb);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c.<span class="built_in">canConvert</span>&lt;Student&gt;())</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Student temp=c.<span class="built_in">value</span>&lt;Student&gt;();</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;temp.id;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;temp.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230803085326234.png" class="" title="image-20230803085326234"><h2 id="QT位置和尺寸"><a href="#QT位置和尺寸" class="headerlink" title="QT位置和尺寸"></a>QT位置和尺寸</h2><img src="/post/2095ef6d/image-20230803140624518.png" class="" title="image-20230803140624518"><h3 id="QPOINT"><a href="#QPOINT" class="headerlink" title="QPOINT"></a>QPOINT</h3><img src="/post/2095ef6d/image-20230803140635397.png" class="" title="image-20230803140635397"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 构造一个坐标原点, 即(0, 0)</span></span><br><span class="line">QPoint::<span class="built_in">QPoint</span>();</span><br><span class="line"><span class="comment">// 参数为 x轴坐标, y轴坐标</span></span><br><span class="line">QPoint::<span class="built_in">QPoint</span>(<span class="type">int</span> xpos, <span class="type">int</span> ypos);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置x轴坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPoint::setX</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">// 设置y轴坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPoint::setY</span><span class="params">(<span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到x轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QPoint::x</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到x轴坐标的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">QPoint::rx</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 得到y轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QPoint::y</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到y轴坐标的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">QPoint::ry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接通过坐标对象进行算术运算: 加减乘除</span></span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>*=(<span class="type">float</span> factor);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>*=(<span class="type">double</span> factor);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>*=(<span class="type">int</span> factor);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>+=(<span class="type">const</span> QPoint &amp;point);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>-=(<span class="type">const</span> QPoint &amp;point);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>/=(qreal divisor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他API请自行查询Qt帮助文档, 不要犯懒哦哦哦哦哦......</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 创建坐标对象</span></span><br><span class="line">    QPoint p;</span><br><span class="line">    <span class="function">QPoint <span class="title">p1</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置x，y坐标</span></span><br><span class="line">    p.<span class="built_in">setX</span>(<span class="number">10</span>);</span><br><span class="line">    p.<span class="built_in">setY</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//2/2/2/2/2/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//得到x，y坐标</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p.<span class="built_in">x</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p.<span class="built_in">y</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p1.<span class="built_in">x</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p1.<span class="built_in">y</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到x，y坐标的引用</span></span><br><span class="line">    <span class="type">int</span> &amp;x1=p.<span class="built_in">rx</span>();</span><br><span class="line">    <span class="type">int</span> &amp;y1=p.<span class="built_in">ry</span>();</span><br><span class="line">    x1=<span class="number">100</span>;</span><br><span class="line">    y1=<span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> &amp;x2=p1.<span class="built_in">rx</span>();</span><br><span class="line">    <span class="type">int</span> &amp;y2=p1.<span class="built_in">ry</span>();</span><br><span class="line"></span><br><span class="line">    x2=<span class="number">1</span>;</span><br><span class="line">    y2=<span class="number">2</span>;</span><br><span class="line"><span class="comment">//再次得到通过引用修改后的坐标</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p.<span class="built_in">x</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p.<span class="built_in">y</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p1.<span class="built_in">x</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p1.<span class="built_in">y</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="QLINE"><a href="#QLINE" class="headerlink" title="QLINE"></a>QLINE</h3><img src="/post/2095ef6d/image-20230803141547493.png" class="" title="image-20230803141547493"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 构造一个空对象</span></span><br><span class="line">QLine::<span class="built_in">QLine</span>();</span><br><span class="line"><span class="comment">// 构造一条直线, 通过两个坐标点</span></span><br><span class="line">QLine::<span class="built_in">QLine</span>(<span class="type">const</span> QPoint &amp;p1, <span class="type">const</span> QPoint &amp;p2);</span><br><span class="line"><span class="comment">// 从点 (x1, y1) 到 (x2, y2)</span></span><br><span class="line">QLine::<span class="built_in">QLine</span>(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给直线对象设置坐标点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::setPoints</span><span class="params">(<span class="type">const</span> QPoint &amp;p1, <span class="type">const</span> QPoint &amp;p2)</span></span>;</span><br><span class="line"><span class="comment">// 起始点(x1, y1), 终点(x2, y2)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::setLine</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span>;</span><br><span class="line"><span class="comment">// 设置直线的起点坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::setP1</span><span class="params">(<span class="type">const</span> QPoint &amp;p1)</span></span>;</span><br><span class="line"><span class="comment">// 设置直线的终点坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::setP2</span><span class="params">(<span class="type">const</span> QPoint &amp;p2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回直线的起始点坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QLine::p1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回直线的终点坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QLine::p2</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值直线的中心点坐标, (p1() + p2()) / 2</span></span><br><span class="line"><span class="function">QPoint <span class="title">QLine::center</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值直线起点的 x 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::x1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值直线终点的 x 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::x2</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值直线起点的 y 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::y1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值直线终点的 y 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::y2</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用给定的坐标点平移这条直线</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::translate</span><span class="params">(<span class="type">const</span> QPoint &amp;offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::translate</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy)</span></span>;</span><br><span class="line"><span class="comment">// 用给定的坐标点平移这条直线, 返回平移之后的坐标点</span></span><br><span class="line"><span class="function">QLine <span class="title">QLine::translated</span><span class="params">(<span class="type">const</span> QPoint &amp;offset)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QLine <span class="title">QLine::translated</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直线对象进行比较</span></span><br><span class="line"><span class="type">bool</span> QLine::<span class="keyword">operator</span>!=(<span class="type">const</span> QLine &amp;line) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QLine::<span class="keyword">operator</span>==(<span class="type">const</span> QLine &amp;line) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他API请自行查询Qt帮助文档, 不要犯懒哦哦哦哦哦......</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function">QPoint <span class="title">p1</span><span class="params">(<span class="number">10</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">p2</span><span class="params">(<span class="number">20</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建直线，传入有参构造的时候直接传入两个点point</span></span><br><span class="line"> <span class="comment">//先创建一个空对象，然后空对象.setpoints</span></span><br><span class="line">    <span class="comment">//直接用四个参数的有参构造函数创建</span></span><br><span class="line">    <span class="function">QLine <span class="title">line</span><span class="params">(p1,p2)</span></span>;</span><br><span class="line">    <span class="function">QLine <span class="title">line1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    QLine line2;</span><br><span class="line">    line2.<span class="built_in">setPoints</span>(p1,p2);</span><br><span class="line"><span class="comment">//可以得到直线的坐标起点，中点，重点.四个坐标，x1,x2,y1,y2或者得到起/末点再 .x()</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;line.<span class="built_in">p1</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;line.<span class="built_in">p2</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;line.<span class="built_in">center</span>();</span><br><span class="line"><span class="comment">//    QPoint(10,20)</span></span><br><span class="line"><span class="comment">//    QPoint(20,40)</span></span><br><span class="line"><span class="comment">//    QPoint(15,30)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个是根据这个点平移后，修改直线相当于方法使用</span></span><br><span class="line">    <span class="comment">// 平移线段的起点和终点，偏移量为 (5, 5)</span></span><br><span class="line">    line.<span class="built_in">translate</span>(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; line.<span class="built_in">p1</span>(); <span class="comment">// 输出 (15, 15)</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; line.<span class="built_in">p2</span>(); <span class="comment">// 输出 (55, 55)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个是根据这个点平移后返回线段对象,相当于函数使用</span></span><br><span class="line">    QLine newline=line.<span class="built_in">translated</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; newline.<span class="built_in">p1</span>(); <span class="comment">// 输出 (15, 15)</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; newline.<span class="built_in">p2</span>(); <span class="comment">// 输出 (55, 55)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="QSIZE"><a href="#QSIZE" class="headerlink" title="QSIZE"></a>QSIZE</h3><img src="/post/2095ef6d/image-20230803143027470.png" class="" title="image-20230803143027470"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 构造空对象, 对象中的宽和高都是无效的</span></span><br><span class="line">QSize::<span class="built_in">QSize</span>();</span><br><span class="line"><span class="comment">// 使用宽和高构造一个有效对象</span></span><br><span class="line">QSize::<span class="built_in">QSize</span>(<span class="type">int</span> width, <span class="type">int</span> height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSize::setWidth</span><span class="params">(<span class="type">int</span> width)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 设置高度</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSize::setHeight</span><span class="params">(<span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QSize::width</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到宽度的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">QSize::rwidth</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 得到高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QSize::height</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到高度的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">QSize::rheight</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换高度和宽度的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSize::transpose</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 交换高度和宽度的值, 返回交换之后的尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">QSize::transposed</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行算法运算: 加减乘除</span></span><br><span class="line">QSize &amp;QSize::<span class="keyword">operator</span>*=(qreal factor);</span><br><span class="line">QSize &amp;QSize::<span class="keyword">operator</span>+=(<span class="type">const</span> QSize &amp;size);</span><br><span class="line">QSize &amp;QSize::<span class="keyword">operator</span>-=(<span class="type">const</span> QSize &amp;size);</span><br><span class="line">QSize &amp;QSize::<span class="keyword">operator</span>/=(qreal divisor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他API请自行查询Qt帮助文档, 不要犯懒哦哦哦哦哦......</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line"><span class="comment">//实例化对象，注意无参的时候千万不能有（）；</span></span><br><span class="line">    QSize p;</span><br><span class="line">    <span class="function">QSize <span class="title">p1</span><span class="params">(<span class="number">20</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动设置宽高</span></span><br><span class="line">    p.<span class="built_in">setWidth</span>(<span class="number">10</span>);</span><br><span class="line">    p.<span class="built_in">setHeight</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到宽和高</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p.<span class="built_in">width</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p.<span class="built_in">height</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p1.<span class="built_in">width</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p1.<span class="built_in">height</span>();</span><br><span class="line"><span class="comment">//得到宽和高的引用并且修改</span></span><br><span class="line">    <span class="type">int</span> &amp;w1=p.<span class="built_in">rwidth</span>();</span><br><span class="line">    <span class="type">int</span> &amp;w2=p1.<span class="built_in">rwidth</span>();</span><br><span class="line">    <span class="type">int</span> &amp;h1=p.<span class="built_in">rheight</span>();</span><br><span class="line">    <span class="type">int</span> &amp;h2=p1.<span class="built_in">rheight</span>();</span><br><span class="line"></span><br><span class="line">    w1=<span class="number">1</span>;</span><br><span class="line">    w2=<span class="number">1</span>;</span><br><span class="line">    h1=<span class="number">2</span>;</span><br><span class="line">    h2=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p.<span class="built_in">width</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p.<span class="built_in">height</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p1.<span class="built_in">width</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p1.<span class="built_in">height</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将宽和高反转</span></span><br><span class="line">    p.<span class="built_in">transpose</span>();</span><br><span class="line">    p1.<span class="built_in">transpose</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p.<span class="built_in">width</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p.<span class="built_in">height</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p1.<span class="built_in">width</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;p1.<span class="built_in">height</span>();</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;------------------&quot;</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    QSize newp=p.<span class="built_in">transposed</span>();</span><br><span class="line">    QSize newp1=p1.<span class="built_in">transposed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;newp.<span class="built_in">width</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;newp.<span class="built_in">height</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;newp1.<span class="built_in">width</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;newp1.<span class="built_in">height</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line">    </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">    </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">------------------</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="QRECT"><a href="#QRECT" class="headerlink" title="QRECT"></a>QRECT</h3><img src="/post/2095ef6d/image-20230803144048156.png" class="" title="image-20230803144048156"><p><strong>长&#x2F;宽是末减初+1</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 构造一个空对象</span></span><br><span class="line">QRect::<span class="built_in">QRect</span>();</span><br><span class="line"><span class="comment">// 基于左上角坐标, 和右下角坐标构造一个矩形对象</span></span><br><span class="line">QRect::<span class="built_in">QRect</span>(<span class="type">const</span> QPoint &amp;topLeft, <span class="type">const</span> QPoint &amp;bottomRight);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">默认是左上角和右下角的关系，如果穿了一个左下角和一个右上角的，顺序就相反了，避免</span><br><span class="line"><span class="comment">// 基于左上角坐标, 和 宽度, 高度构造一个矩形对象</span></span><br><span class="line">QRect::<span class="built_in">QRect</span>(<span class="type">const</span> QPoint &amp;topLeft, <span class="type">const</span> QSize &amp;size);</span><br><span class="line"></span><br><span class="line">长/宽是末减初+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 通过 左上角坐标(x, y), 和 矩形尺寸(width, height) 构造一个矩形对象</span></span><br><span class="line">QRect::<span class="built_in">QRect</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置矩形的尺寸信息, 左上角坐标不变</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::setSize</span><span class="params">(<span class="type">const</span> QSize &amp;size)</span></span>;</span><br><span class="line"><span class="comment">// 设置矩形左上角坐标为(x,y), 大小为(width, height)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::setRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="comment">// 设置矩形宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::setWidth</span><span class="params">(<span class="type">int</span> width)</span></span>;</span><br><span class="line"><span class="comment">// 设置矩形高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::setHeight</span><span class="params">(<span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值矩形左上角坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::topLeft</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形右上角坐标</span></span><br><span class="line"><span class="comment">// 该坐标点值为: QPoint(left() + width() -1, top())</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::topRight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形左下角坐标</span></span><br><span class="line"><span class="comment">// 该坐标点值为: QPoint(left(), top() + height() - 1)</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::bottomLeft</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形右下角坐标</span></span><br><span class="line"><span class="comment">// 该坐标点值为: QPoint(left() + width() -1, top() + height() - 1)</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::bottomRight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形中心点坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::center</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回矩形上边缘y轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::top</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::y</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值矩形下边缘y轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::bottom</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形左边缘 x轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::x</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::left</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形右边缘x轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::right</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回矩形的高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::width</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形的宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::height</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形的尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">QRect::size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><h3 id="QDATE"><a href="#QDATE" class="headerlink" title="QDATE"></a>QDATE</h3><p>需要引入头文件！</p><img src="/post/2095ef6d/image-20230804080321434.png" class="" title="image-20230804080321434"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QDate::<span class="built_in">QDate</span>();</span><br><span class="line">QDate::<span class="built_in">QDate</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 重新设置日期对象中的日期</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QDate::setDate</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span>;</span><br><span class="line"><span class="comment">// 给日期对象添加 ndays 天</span></span><br><span class="line"><span class="function">QDate <span class="title">QDate::addDays</span><span class="params">(qint64 ndays)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给日期对象添加 nmonths 月</span></span><br><span class="line"><span class="function">QDate <span class="title">QDate::addMonths</span><span class="params">(<span class="type">int</span> nmonths)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给日期对象添加 nyears 月</span></span><br><span class="line"><span class="function">QDate <span class="title">QDate::addYears</span><span class="params">(<span class="type">int</span> nyears)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到日期对象中的年/月/日</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QDate::year</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QDate::month</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QDate::day</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDate::getDate</span><span class="params">(<span class="type">int</span> *year, <span class="type">int</span> *month, <span class="type">int</span> *day)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期对象格式化</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    d    - The day as a number without a leading zero (1 to 31)</span></span><br><span class="line"><span class="comment">    dd   - The day as a number with a leading zero (01 to 31)</span></span><br><span class="line"><span class="comment">    ddd -  周四</span></span><br><span class="line"><span class="comment">    dddd - 星期四</span></span><br><span class="line"><span class="comment">    M    - The month as a number without a leading zero (1 to 12)</span></span><br><span class="line"><span class="comment">    MM   - The month as a number with a leading zero (01 to 12)</span></span><br><span class="line"><span class="comment">    MMM 9月</span></span><br><span class="line"><span class="comment">    MMMM 九月</span></span><br><span class="line"><span class="comment">    yy   - The year as a two digit number (00 to 99)</span></span><br><span class="line"><span class="comment">    yyyy - The year as a four digit number. If the year is negative, a minus sign is prepended, making five characters.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">QString <span class="title">QDate::toString</span><span class="params">(<span class="type">const</span> QString &amp;format)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符重载 ==&gt; 日期比较</span></span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>!=(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>&lt;(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="built_in">operator</span>&lt;=(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>==(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>&gt;(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态函数 -&gt; 得到本地的当前日期</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QDate <span class="title">QDate::currentDate</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDate&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function">QDate <span class="title">a</span><span class="params">(<span class="number">2023</span>,<span class="number">8</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    QDate b;</span><br><span class="line">    b.<span class="built_in">setDate</span>(<span class="number">2023</span>,<span class="number">8</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//////</span></span><br><span class="line">    QDate c=QDate::<span class="built_in">currentDate</span>();</span><br><span class="line">    <span class="comment">//////</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;c;</span><br><span class="line">    c=c.<span class="built_in">addDays</span>(<span class="number">10</span>);</span><br><span class="line">    c=c.<span class="built_in">addMonths</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;c;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;c.<span class="built_in">year</span>();</span><br><span class="line"></span><br><span class="line">    QString str=c.<span class="built_in">toString</span>(<span class="string">&quot;yy-MMM-ddd&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;str;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="QTIME"><a href="#QTIME" class="headerlink" title="QTIME"></a>QTIME</h3><img src="/post/2095ef6d/image-20230804082459651.png" class="" title="image-20230804082459651"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QTime::<span class="built_in">QTime</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    h ==&gt; 取值范围： 0 ~ 23</span></span><br><span class="line"><span class="comment">    m and s ==&gt; 取值范围： 0 ~ 59</span></span><br><span class="line"><span class="comment">    ms ==&gt; 取值范围： 0 ~ 999</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">QTime::<span class="built_in">QTime</span>(<span class="type">int</span> h, <span class="type">int</span> m, <span class="type">int</span> s = <span class="number">0</span>, <span class="type">int</span> ms = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// Returns true if the set time is valid; otherwise returns false.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTime::setHMS</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> m, <span class="type">int</span> s, <span class="type">int</span> ms = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">QTime <span class="title">QTime::addSecs</span><span class="params">(<span class="type">int</span> s)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QTime <span class="title">QTime::addMSecs</span><span class="params">(<span class="type">int</span> ms)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line">  <span class="function">QTime <span class="title">n</span><span class="params">(<span class="number">14</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;                <span class="comment">// n == 14:00:00</span></span><br><span class="line">  QTime t;</span><br><span class="line">  t = n.<span class="built_in">addSecs</span>(<span class="number">70</span>);                <span class="comment">// t == 14:01:10</span></span><br><span class="line">  t = n.<span class="built_in">addSecs</span>(<span class="number">-70</span>);               <span class="comment">// t == 13:58:50</span></span><br><span class="line">  t = n.<span class="built_in">addSecs</span>(<span class="number">10</span> * <span class="number">60</span> * <span class="number">60</span> + <span class="number">5</span>);  <span class="comment">// t == 00:00:05</span></span><br><span class="line">  t = n.<span class="built_in">addSecs</span>(<span class="number">-15</span> * <span class="number">60</span> * <span class="number">60</span>);     <span class="comment">// t == 23:00:00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从时间对象中取出 时/分/秒/毫秒</span></span><br><span class="line"><span class="comment">// Returns the hour part (0 to 23) of the time. Returns -1 if the time is invalid.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::hour</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// Returns the minute part (0 to 59) of the time. Returns -1 if the time is invalid.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::minute</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// Returns the second part (0 to 59) of the time. Returns -1 if the time is invalid.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::second</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// Returns the millisecond part (0 to 999) of the time. Returns -1 if the time is invalid.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::msec</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间格式化</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    -- 时 --</span></span><br><span class="line"><span class="comment">    h==&gt;The hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)</span></span><br><span class="line"><span class="comment">    hh==&gt;The hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)</span></span><br><span class="line"><span class="comment">    H==&gt;The hour without a leading zero (0 to 23, even with AM/PM display)</span></span><br><span class="line"><span class="comment">    HH==&gt;The hour with a leading zero (00 to 23, even with AM/PM display)</span></span><br><span class="line"><span class="comment">    -- 分 --</span></span><br><span class="line"><span class="comment">    m==&gt;The minute without a leading zero (0 to 59)</span></span><br><span class="line"><span class="comment">    mm==&gt;The minute with a leading zero (00 to 59)</span></span><br><span class="line"><span class="comment">    -- 秒 --</span></span><br><span class="line"><span class="comment">    s==&gt;The whole second, without any leading zero (0 to 59)</span></span><br><span class="line"><span class="comment">    ss==&gt;The whole second, with a leading zero where applicable (00 to 59)</span></span><br><span class="line"><span class="comment">    -- 毫秒 --</span></span><br><span class="line"><span class="comment">    zzz==&gt;The fractional part of the second, to millisecond precision, </span></span><br><span class="line"><span class="comment">including trailing zeroes where applicable (000 to 999).</span></span><br><span class="line"><span class="comment">    -- 上午或者下午</span></span><br><span class="line"><span class="comment">    AP or A==&gt;使用AM/PM(大写) 描述上下午, 中文系统显示汉字</span></span><br><span class="line"><span class="comment">    ap or a==&gt;使用am/pm(小写) 描述上下午, 中文系统显示汉字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">QString <span class="title">QTime::toString</span><span class="params">(<span class="type">const</span> QString &amp;format)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阶段性计时</span></span><br><span class="line"><span class="comment">// 过时的API函数</span></span><br><span class="line"><span class="comment">// 开始计时</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTime::start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 计时结束</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::elapsed</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 重新计时</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::restart</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐使用的API函数</span></span><br><span class="line"><span class="comment">// QElapsedTimer 类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QElapsedTimer::start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">qint64 <span class="title">QElapsedTimer::restart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">qint64 <span class="title">QElapsedTimer::elapsed</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符重载 ==&gt; 时间比较</span></span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>!=(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>&lt;(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="built_in">operator</span>&lt;=(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>==(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>&gt;(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态函数 -&gt; 得到当前时间</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QTime <span class="title">QTime::currentTime</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QElapsedTimer&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();</span><br><span class="line">    <span class="function">QTime <span class="title">a</span><span class="params">(<span class="number">8</span>,<span class="number">26</span>,<span class="number">40</span>,<span class="number">999</span>)</span></span>;</span><br><span class="line"><span class="comment">//    h 0~23</span></span><br><span class="line"><span class="comment">//    m 0~59</span></span><br><span class="line"><span class="comment">//    s 0~59</span></span><br><span class="line"><span class="comment">//    ms 0~999</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;a;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;a.<span class="built_in">hour</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;a.<span class="built_in">minute</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;a.<span class="built_in">second</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;a.<span class="built_in">msec</span>();</span><br><span class="line">    QTime b;</span><br><span class="line">    b.<span class="built_in">setHMS</span>(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;b;</span><br><span class="line">    QTime c=c.<span class="built_in">currentTime</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;c;</span><br><span class="line"><span class="comment">//    QTime(&quot;08:35:08.486&quot;)</span></span><br><span class="line">    qint64 time1=time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;time1;</span><br><span class="line"></span><br><span class="line">        QElapsedTimer timer;</span><br><span class="line"></span><br><span class="line">        timer.<span class="built_in">start</span>(); <span class="comment">// 开始计时</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行一些需要测量的代码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qint64 elapsedTime = timer.<span class="built_in">elapsed</span>(); <span class="comment">// 获取经过的时间（以毫秒为单位）</span></span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Elapsed Time:&quot;</span> &lt;&lt; elapsedTime &lt;&lt; <span class="string">&quot;ms&quot;</span>;</span><br><span class="line"><span class="comment">//        Elapsed Time: 7 ms</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QDATETIME"><a href="#QDATETIME" class="headerlink" title="QDATETIME"></a>QDATETIME</h3><img src="/post/2095ef6d/image-20230804084530792.png" class="" title="image-20230804084530792"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QDateTime::<span class="built_in">QDateTime</span>();</span><br><span class="line">QDateTime::<span class="built_in">QDateTime</span>(<span class="type">const</span> QDate &amp;date, <span class="type">const</span> QTime &amp;time, Qt::TimeSpec spec = Qt::LocalTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 设置日期</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDateTime::setDate</span><span class="params">(<span class="type">const</span> QDate &amp;date)</span></span>;</span><br><span class="line"><span class="comment">// 设置时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDateTime::setTime</span><span class="params">(<span class="type">const</span> QTime &amp;time)</span></span>;</span><br><span class="line"><span class="comment">// 给当前日期对象追加 年/月/日/秒/毫秒, 参数可以是负数</span></span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addYears</span><span class="params">(<span class="type">int</span> nyears)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addMonths</span><span class="params">(<span class="type">int</span> nmonths)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addDays</span><span class="params">(qint64 ndays)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addSecs</span><span class="params">(qint64 s)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addMSecs</span><span class="params">(qint64 msecs)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到对象中的日期</span></span><br><span class="line"><span class="function">QDate <span class="title">QDateTime::date</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到对象中的时间</span></span><br><span class="line"><span class="function">QTime <span class="title">QDateTime::time</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期和时间格式, 格式字符参考QDate 和 QTime 类的 toString() 函数</span></span><br><span class="line"><span class="function">QString <span class="title">QDateTime::toString</span><span class="params">(<span class="type">const</span> QString &amp;format)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符重载 ==&gt; 日期时间对象的比较</span></span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>!=(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>&lt;(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="built_in">operator</span>&lt;=(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>==(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>&gt;(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态函数</span></span><br><span class="line"><span class="comment">// 得到当前时区的日期和时间(本地设置的时区对应的日期和时间)</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QDateTime <span class="title">QDateTime::currentDateTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDate&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDateTime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function">QDate <span class="title">date</span><span class="params">(<span class="number">2023</span>,<span class="number">8</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">QTime <span class="title">time</span><span class="params">(<span class="number">8</span>,<span class="number">55</span>,<span class="number">30</span>,<span class="number">876</span>)</span></span>;</span><br><span class="line">    <span class="function">QDateTime <span class="title">datetime</span><span class="params">(date,time)</span></span>;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;datetime;</span><br><span class="line"></span><br><span class="line">    QDateTime newtime;</span><br><span class="line">    newtime.<span class="built_in">setDate</span>(date);</span><br><span class="line">    newtime.<span class="built_in">setTime</span>(time);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    newtime=newtime.<span class="built_in">addDays</span>(<span class="number">1</span>);</span><br><span class="line">    newtime=newtime.<span class="built_in">addSecs</span>(<span class="number">23</span>);</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;newtime;</span><br><span class="line">        </span><br><span class="line">    QDateTime now= QDateTime::<span class="built_in">currentDateTime</span>();</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;now;</span><br><span class="line">        </span><br><span class="line">   QString str=now.<span class="built_in">toString</span>(<span class="string">&quot;yyyy-MM-dddd hh:mm:ss ap&quot;</span>);</span><br><span class="line">   <span class="built_in">qDebug</span>()&lt;&lt;str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="QT坐标体系"><a href="#QT坐标体系" class="headerlink" title="QT坐标体系"></a>QT坐标体系</h2><img src="/post/2095ef6d/image-20230731112623738.png" class="" title="image-20230731112623738"><p>子窗口相对于父窗口的坐标原点来进行的</p><p>用的坐标体系不一样</p><p><code>MainWindow</code>类继承自<code>QMainWindow</code>，并且使用<code>Ui_MainWindow</code>类来进行界面的设置。所以在<code>MainWindow</code>构造函数中调用了<code>ui-&gt;setupUi(this)</code>方法，将<code>MainWindow</code>作为参数传递给它，从而创建和设置了界面。</p><img src="/post/2095ef6d/image-20230731114247952.png" class="" title="image-20230731114247952"><p>至于为什么按钮不需要调用<code>show()</code>方法就可以显示，是因为在<code>ui-&gt;setupUi(this)</code>方法中已经包括了按钮的初始化和显示设置。<code>setupUi()</code>方法会创建和设置窗口中所有的控件，并根据布局和样式等配置来显示它们。所以当你调用<code>this-&gt;show()</code>来显示窗口时，已经包含了按钮的显示。</p><img src="/post/2095ef6d/image-20230731114232016.png" class="" title="image-20230731114232016"><h2 id="QT内存回收机制"><a href="#QT内存回收机制" class="headerlink" title="QT内存回收机制"></a>QT内存回收机制</h2><blockquote><p>Qt的内存回收机制主要是基于对象树的概念。当<strong>你在Qt中创建一个对象并指定了父对象时，父对象会负责管理其子对象的生命周期。</strong>具体来说，<strong>当父对象被销毁时，它会自动销毁其所有子对象。</strong></p><p><strong>这种内存回收机制的优势在于，你无需手动释放子对象的内存，而是将其交给父对象去管理。这简化了内存管理的工作，并确保了对象之间的正确关系。</strong></p><p>在你提到的情况中，当你在堆区创建一个控件并将其指定为父窗口的子控件时，父窗口会成为该控件的父对象。<strong>当父窗口关闭时，它会自动销毁其所有子控件，包括在堆区创建的控件。这就利用了Qt的内存回收机制，确保了子控件的正确释放。</strong></p><p>需要注意的是，Qt的内存回收机制只适用于通过对象树进行管理的对象。如果你在堆区创建了一个对象，但没有设置其父对象，那么它将不会被自动释放，你需要手动管理其生命周期，确保在不再需要时进行释放。</p></blockquote><p><strong>qt机制非常的聪明，他会检测一个内存是否被释放，如果被释放了就不再释放。！！！！！！</strong></p><p>**<img src="/post/2095ef6d/image-20230808120713278.png" class="" title="image-20230808120713278"></p><img src="/post/2095ef6d/image-20230731114806690.png" class="" title="image-20230731114806690"><img src="/post/2095ef6d/image-20230731114857012.png" class="" title="image-20230731114857012"><img src="/post/2095ef6d/image-20230731115011091.png" class="" title="image-20230731115011091"><img src="/post/2095ef6d/image-20230731124251606.png" class="" title="image-20230731124251606"><img src="/post/2095ef6d/image-20230731195036189.png" class="" title="image-20230731195036189"><p>先析构自己后析构儿子</p><p>父类中创建子类 的话是，先构建儿子后构建父亲</p><p>设置父对象，父对象析构的时候会自动把儿子给析构掉</p><blockquote><ol><li>当类对象作为类成员的时候，先构造儿子后构造父亲，析构相反</li></ol></blockquote><h2 id="QT的基础类型"><a href="#QT的基础类型" class="headerlink" title="QT的基础类型"></a>QT的基础类型</h2><img src="/post/2095ef6d/image-20230731195225067.png" class="" title="image-20230731195225067"><h2 id="LOG输出"><a href="#LOG输出" class="headerlink" title="LOG输出"></a>LOG输出</h2><p>QDebug类</p><p>qDebug（）方法</p><img src="/post/2095ef6d/image-20230731201638457.png" class="" title="image-20230731201638457"><p>实现控制台 在外部</p><h2 id="信号和槽机制"><a href="#信号和槽机制" class="headerlink" title="信号和槽机制"></a>信号和槽机制</h2><img src="/post/2095ef6d/image-20230802140725492.png" class="" title="image-20230802140725492"><img src="/post/2095ef6d/image-20230802140908764.png" class="" title="image-20230802140908764"><p>四个参数</p><p>1.信号发送者</p><p>2，发送的信号</p><p>3，接收者</p><p>4，接收者的行为</p><p><code>connect</code>函数的连接参数应该是函数指针或者函数对象，并且需要使用信号槽机制进行连接。</p><blockquote><h4 id="connect函数的连接参数应该是函数指针或者函数对象，并且需要使用信号槽机制进行连接。"><a href="#connect函数的连接参数应该是函数指针或者函数对象，并且需要使用信号槽机制进行连接。" class="headerlink" title="connect函数的连接参数应该是函数指针或者函数对象，并且需要使用信号槽机制进行连接。"></a>connect函数的连接参数应该是函数指针或者函数对象，并且需要使用信号槽机制进行连接。</h4><h4 id="connect-btn-QPushButton-clicked-this-MainWindow-close"><a href="#connect-btn-QPushButton-clicked-this-MainWindow-close" class="headerlink" title="connect(btn,&amp;QPushButton::clicked,this,&amp;MainWindow::close);"></a>connect(btn,&amp;QPushButton::clicked,this,&amp;MainWindow::close);</h4></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    QPushButton*btn=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">show</span>();</span><br><span class="line">    btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;第一个按钮&quot;</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">setFixedSize</span>(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">move</span>(<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//connect函数的连接参数应该是函数指针或者函数对象，并且需要使用信号槽机制进行连接。</span></span><br><span class="line">    <span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;MainWindow::close);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><img src="/post/2095ef6d/image-20230802143040664.png" class="" title="image-20230802143040664"><img src="/post/2095ef6d/image-20230802143003435.png" class="" title="image-20230802143003435"><img src="/post/2095ef6d/image-20230802143021118.png" class="" title="image-20230802143021118"><img src="/post/2095ef6d/image-20230802143124345.png" class="" title="image-20230802143124345"><img src="/post/2095ef6d/image-20230802143142947.png" class="" title="image-20230802143142947"><img src="/post/2095ef6d/image-20230802143158612.png" class="" title="image-20230802143158612"><img src="/post/2095ef6d/image-20230802143235656.png" class="" title="image-20230802143235656"><img src="/post/2095ef6d/image-20230802143313999.png" class="" title="image-20230802143313999"><blockquote><h2 id="找的时候，如果没有，就去找他的基类！！！！！"><a href="#找的时候，如果没有，就去找他的基类！！！！！" class="headerlink" title="找的时候，如果没有，就去找他的基类！！！！！"></a><strong>找的时候，如果没有，就去找他的基类！！！！！</strong></h2><h4 id="1-确定，信号发出者和信号接收者的类型-！！！"><a href="#1-确定，信号发出者和信号接收者的类型-！！！" class="headerlink" title="1.确定，信号发出者和信号接收者的类型 ！！！"></a>1.确定，信号发出者和信号接收者的类型 ！！！</h4><h4 id="2-确定-对应的信号和槽函数，传入函数的地址，-信号发出者-对应的信号函数-信号接受者-对应的槽函数"><a href="#2-确定-对应的信号和槽函数，传入函数的地址，-信号发出者-对应的信号函数-信号接受者-对应的槽函数" class="headerlink" title="2,确定 对应的信号和槽函数，传入函数的地址，&amp;信号发出者::对应的信号函数,&amp;信号接受者::对应的槽函数,"></a>2,确定 对应的信号和槽函数，传入函数的地址，&amp;信号发出者::对应的信号函数,&amp;信号接受者::对应的槽函数,</h4></blockquote><img src="/post/2095ef6d/image-20230802143351803.png" class="" title="image-20230802143351803"><img src="/post/2095ef6d/image-20230802161504786.png" class="" title="image-20230802161504786"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">功能实现： 点击窗口上的按钮, 关闭窗口</span><br><span class="line">功能分析:</span><br><span class="line">- 按钮: 信号发出者          -&gt; QPushButton 类型</span><br><span class="line">- 窗口: 信号的接收者和处理者  -&gt; QWidget 类型</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230802143600142.png" class="" title="image-20230802143600142"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 单击按钮发出的信号</span><br><span class="line">[signal] void QAbstractButton::clicked(bool checked = false)</span><br><span class="line">// 关闭窗口的槽函数</span><br><span class="line">[slot] bool QWidget::close();</span><br></pre></td></tr></table></figure><p>最终连接起来</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 单击按钮关闭窗口</span><br><span class="line">connect(btn, &amp;QPushButton::clicked, this, &amp;MainWindow::close);</span><br></pre></td></tr></table></figure><p>★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★</p><blockquote><p>connect()操作一般写在<strong>窗口的构造函数中</strong>，相当于在<em><strong>事件产生之前在qt框架中先进行注册</strong></em>，这样在程序运行过程中<strong>假设产生了按钮的点击事件，框架就会调用信号接收者对象对应的槽函数了，如果信号不产生，槽函数也就一直不会被调用。</strong>可不是connect一调用就发生了</p></blockquote><p>★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★</p><h2 id="自定义信号和槽"><a href="#自定义信号和槽" class="headerlink" title="自定义信号和槽"></a>自定义信号和槽</h2><img src="/post/2095ef6d/image-20230802143851525.png" class="" title="image-20230802143851525"><h3 id="创建新的类的注意事项：：：：：：：：：："><a href="#创建新的类的注意事项：：：：：：：：：：" class="headerlink" title="创建新的类的注意事项：：：：：：：：：："></a><strong>创建新的类的注意事项</strong>：：：：：：：：：：</h3><hr><p>在Qt中，创建新的类来定义自定义信号和槽时，有以下要求：</p><p><strong>如果要继承QObject和使用Q_OBJECT宏的时候就要引入对应的文件</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;QObject&gt;</span><br></pre></td></tr></table></figure><ol><li><p><strong>继承自QObject类：</strong>或者继承QObject的子类也就是间接继承QObject<br><strong>新的类必须继承&#x2F;间接继承自QObject类，以便能够使用Qt的信号和槽机制。</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加Q_OBJECT宏</strong>：<br>在新的类的声明中，需要添加Q_OBJECT宏。<strong>这个宏告诉Qt元对象编译器（MOC）生成必要的代码，以支持信号和槽的使用。</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>声明信号和槽函数：</strong><br>在新的类中，可以声明自定义的信号和槽函数。<strong>信号函数声明在<code>signals</code>关键字下，槽函数声明在<code>public slots</code>关键字下。</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySignal</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySlot</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>实现信号和槽函数：</strong><br>在新的类的实现中，可以实现自定义的信号和槽函数。<strong>信号函数使用<code>emit</code>关键字来发出信号，槽函数用于接收信号并进行相应的处理。</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyClass::<span class="built_in">MyClass</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::mySlot</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理槽函数的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::mySignal</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">mySignal</span><span class="params">(value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="信号和槽函数的要求"><a href="#信号和槽函数的要求" class="headerlink" title="信号和槽函数的要求"></a><strong>信号和槽函数的要求</strong></h3><p>信号L:::::::::::</p><img src="/post/2095ef6d/image-20230802145005632.png" class="" title="image-20230802145005632"><p>槽函数::”:”:”::””::””:</p><img src="/post/2095ef6d/image-20230802145635876.png" class="" title="image-20230802145635876"><hr><p><strong><code>explicit</code> 是一个关键字，用于指示该构造函数是显式的，即只能显式地调用该构造函数来创建对象，不能通过隐式转换进行对象的创建。</strong></p><img src="/post/2095ef6d/image-20230802150120972.png" class="" title="image-20230802150120972"><img src="/post/2095ef6d/image-20230802150135749.png" class="" title="image-20230802150135749"><img src="/post/2095ef6d/image-20230802211915437.png" class="" title="image-20230802211915437"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">connect(const QObject *sender, &amp;QObject::signal, </span><br><span class="line">        const QObject *receiver, &amp;QObject::siganl-new);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>信号和槽是可以断开的！</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">disconnect(const QObject *sender, &amp;QObject::signal, </span><br><span class="line">        const QObject *receiver, &amp;QObject::method);</span><br></pre></td></tr></table></figure><p>信号和槽的链接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 信号和槽函数也就是第2,4个参数传递的是地址, 编译器在编译过程中会对数据的正确性进行检测</span><br><span class="line">connect(const QObject *sender, &amp;QObject::signal, </span><br><span class="line">        const QObject *receiver, &amp;QObject::method);</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230804165512586.png" class="" title="image-20230804165512586"><img src="/post/2095ef6d/image-20230804170500811.png" class="" title="image-20230804170500811"><h3 id="连接自定义的信号和槽"><a href="#连接自定义的信号和槽" class="headerlink" title="连接自定义的信号和槽"></a>连接自定义的信号和槽</h3><p>在这个表达式中，<code>void (Me::*mysignal)(QString)</code> 定义了一个函数指针类型，该函数指针可以指向 Me 类的成员函数，该成员函数的返回类型为 <code>void</code>，接受一个 <code>QString</code> 类型的参数。</p><p><code>&amp;Me::eat</code> 是一个成员函数的指针，它指向 Me 类的 <code>eat</code> 成员函数。</p><p>通过将 <code>&amp;Me::eat</code> 赋值给 <code>mysignal</code>，将 <code>mysignal</code> 指向了 Me 类的 <code>eat</code> 成员函数。</p><p>这样，<code>mysignal</code> 就可以被用作函数指针，可以通过它来调用 Me 类的 <code>eat</code> 成员函数。</p><img src="/post/2095ef6d/image-20230802152316588.png" class="" title="image-20230802152316588"><img src="/post/2095ef6d/image-20230802152322169.png" class="" title="image-20230802152322169"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 举例：</span><br><span class="line">void (类名::*func1)(QString) = &amp;Me::eat;// func1指向带参的信号</span><br><span class="line">void (Me::*func2)() = &amp;Me::hungury;// func2指向不带参的槽函数</span><br></pre></td></tr></table></figure><blockquote><p>class Me : public QObject<br>{<br> Q_OBJECT<br> &#x2F;&#x2F; Qt4中的槽函数必须这样声明, qt5中的关键字 slots 可以被省略<br>public slots:<br> void eat();<br> void eat(QString somthing);<br> signals:<br> void hungury();<br> void hungury(QString somthing);<br>};</p><p>&#x2F;&#x2F; 基于上边的类写出解决方案<br>&#x2F;&#x2F; 处理如下逻辑: 我饿了, 我要吃东西<br>&#x2F;&#x2F; 分析: 信号的发出者是我自己, 信号的接收者也是我自己<br>Me m;<br>&#x2F;&#x2F; Qt4处理方式<br>connect(&amp;m, SIGNAL(eat()), &amp;m, SLOT(hungury()));<br>connect(&amp;m, SIGNAL(eat(QString)), &amp;m, SLOT(hungury(QString)));</p><p>&#x2F;&#x2F; Qt5处理方式<br>connect(&amp;m, &amp;Me::eat, &amp;m, &amp;Me::hungury);&#x2F;&#x2F; error</p><p>因为发生了重载</p><p>&#x2F;&#x2F;两个函数指针代替<br> &#x2F;&#x2F;函数指针<br>&#x2F;&#x2F;    void (Student::*myslot)(QString)&#x3D;&amp;Student::treat_special;<br>&#x2F;&#x2F;    void (Teacher::*mysignal)(QString)&#x3D;&amp;Teacher::Teacher_is_hungery_but;<br>&#x2F;&#x2F;    connect(teacher,mysignal,student,myslot);</p></blockquote><img src="/post/2095ef6d/image-20230804102156503.png" class="" title="image-20230804102156503"><p><strong>成员函数指针是一个与类相关联的指针</strong>，它可以用来调用该类的成员函数。它不需要特定的对象实例来初始化，只需要指定成员函数的类型和类的名称即可。</p><p>按钮触发下课</p><p>下课触发老师饿了</p><p>老师饿了触发学生请吃饭</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;student.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;teacher.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//    创建对象</span></span><br><span class="line">    teacher=<span class="keyword">new</span> Teacher;</span><br><span class="line">    student=<span class="keyword">new</span> Student;</span><br><span class="line"><span class="comment">//两个函数指针代替</span></span><br><span class="line">    <span class="comment">//函数指针</span></span><br><span class="line"><span class="comment">//    void (Student::*myslot)(QString)=&amp;Student::treat_special;</span></span><br><span class="line"><span class="comment">//    void (Teacher::*mysignal)(QString)=&amp;Teacher::Teacher_is_hungery_but;</span></span><br><span class="line"><span class="comment">//    connect(teacher,mysignal,student,myslot);</span></span><br><span class="line"><span class="comment">//    --------------</span></span><br><span class="line"><span class="comment">//    原始写法，函数名的地址</span></span><br><span class="line">    <span class="built_in">connect</span>(teacher,&amp;Teacher::Teacher_is_hungery_but,student,&amp;Student::treat_special);</span><br><span class="line"><span class="comment">//创建一个按钮</span></span><br><span class="line">    QPushButton *btn=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">setFixedSize</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;老师饿了&quot;</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">move</span>(<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//#点击按钮触发下课函数</span></span><br><span class="line">     <span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;MainWindow::classover);</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的写法</span></span><br><span class="line"><span class="comment">//     connect(btn,&amp;QPushButton::clicked,teacher,&amp;Teacher::Teacher_is_hungery_but(&quot;大竹比&quot;));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    信号连接信号,点击按钮触发老师饿了</span></span><br><span class="line"><span class="comment">//     connect(btn,&amp;QPushButton::clicked,teacher,&amp;Teacher::Teacher_is_hungery);</span></span><br><span class="line"><span class="comment">//     connect(btn,&amp;QPushButton::clicked,std::bind(&amp;Teacher::Teacher_is_hungery_but,teacher,&quot;大竹比&quot;));</span></span><br><span class="line"><span class="comment">//      connect(btn, &amp;QPushButton::clicked, std::bind(&amp;Teacher::Teacher_is_hungery_but, teacher, &quot;大苏打&quot;));</span></span><br><span class="line">     <span class="built_in">classover</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//////////////////</span></span><br><span class="line">    <span class="built_in">void</span> (QToolBox::*s)(<span class="type">int</span>)=&amp;QToolBox::currentChanged;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(tb,s,<span class="keyword">this</span>,[=](<span class="type">int</span> index)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;新年好&quot;</span>&lt;&lt;index;</span><br><span class="line">    &#125;);</span><br><span class="line">        <span class="comment">////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="built_in">connect</span>(ui-&gt;closebtn,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;MainWindow::close);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下课函数触发老师饿了</span></span><br><span class="line"><span class="type">void</span> MainWindow:: <span class="built_in">classover</span>()&#123;</span><br><span class="line">    <span class="comment">//下课函数出发老师饿了的信号</span></span><br><span class="line"><span class="comment">//    emit zt-&gt;hungery();</span></span><br><span class="line">    emit teacher-&gt;<span class="built_in">Teacher_is_hungery_but</span>(<span class="string">&quot;宫保鸡丁&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;<strong>EMIT只是帮助程序员一眼看出这是在发出信号。。。。。不写也是ok的。</strong>&#x3D;&#x3D;</p><h2 id="自定义类！继承"><a href="#自定义类！继承" class="headerlink" title="自定义类！继承"></a>自定义类！继承</h2><p>先添加一个继承自 <code>QObject</code> 的类，然后将其修改为继承自&#x3D;&#x3D;&#x3D; <code>QTextEdit</code>&#x3D;&#x3D;。修改类的继承关系后，还需要在 <code>.cpp</code> 文件中做一些相应的修改。</p><p>首先，你需要将类的声明中的 <code>Qobject</code> 修改为 <code>QTextEdit</code>，如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTextEdit</span> : <span class="keyword">public</span> <span class="comment">////QTextEdit///</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyTextEdit</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来，在 <code>.cpp</code> 文件中，你需要修改构造函数的定义，将 <code>Qobject</code> 修改为 <code>QTextEdit</code>，并将函数名改为 <code>MyTextEdit::MyTextEdit(QWidget *parent)</code>，如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyTextEdit::<span class="built_in">MyTextEdit</span>(QWidget *parent)</span><br><span class="line">    : <span class="comment">//QTextEdit//(parent)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ui控件的使用"><a href="#ui控件的使用" class="headerlink" title="ui控件的使用"></a>ui控件的使用</h2><img src="/post/2095ef6d/image-20230802162620319.png" class="" title="image-20230802162620319"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;closebtn,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;MainWindow::close);</span><br></pre></td></tr></table></figure><h2 id="添加新的类"><a href="#添加新的类" class="headerlink" title="添加新的类"></a>添加新的类</h2><p>直接继承QOBject 巨好用</p><img src="/post/2095ef6d/image-20230802210658189.png" class="" title="image-20230802210658189"><h2 id="LAMBDA表达式"><a href="#LAMBDA表达式" class="headerlink" title="LAMBDA表达式"></a>LAMBDA表达式</h2><img src="/post/2095ef6d/image-20230804102405111.png" class="" title="image-20230804102405111"><img src="/post/2095ef6d/image-20230804102428896.png" class="" title="image-20230804102428896"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture](params) opt -&gt; ret &#123;body;&#125;;</span><br><span class="line">    - capture: 捕获列表</span><br><span class="line">    - params: 参数列表</span><br><span class="line">    - opt: 函数选项</span><br><span class="line">    - ret: 返回值类型</span><br><span class="line">    - body: 函数体</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230804102818196.png" class="" title="image-20230804102818196"><img src="/post/2095ef6d/image-20230804103654121.png" class="" title="image-20230804103654121"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="comment">//    []()&#123;</span></span><br><span class="line"><span class="comment">//        qDebug()&lt;&lt;&quot;你好啊草&quot;;</span></span><br><span class="line"><span class="comment">//    &#125;;</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">//    []()&#123;</span></span><br><span class="line"><span class="comment">//        qDebug()&lt;&lt;&quot;你好啊草&quot;;</span></span><br><span class="line"><span class="comment">//    &#125;();</span></span><br><span class="line">        <span class="comment">//()</span></span><br><span class="line"><span class="comment">/// /  ////   /  //相当于调用了这个函数//</span></span><br><span class="line">    <span class="type">int</span> a=[](<span class="type">int</span> a)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;你好啊&quot;</span>&lt;&lt;a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230804103725913.png" class="" title="image-20230804103725913"><blockquote><p>就是说如果[&#x3D;]</p><p>把外部变量都捕获了，但只是可读的状态。</p><p>可以opt加上mutable，是可以修改了，但是修改的是拷贝过来的副本</p><p>而[&amp;]</p><p>也是把外部所有的变量以引用的形式拷贝过来，但是可以修改，因为操作的是内存地址</p><p>[this]指代表我们只能访问我们类内的成员变量</p><p>[&#x3D;]&#x2F;[&amp;]，代表我们可以访问匿名函数体以外的所有外部变量，相当于是[this]的超集</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    []()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;你好啊草&quot;</span>;</span><br><span class="line">    &#125;();</span><br><span class="line">    <span class="type">int</span> a=[](<span class="type">int</span> a)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;你好啊&quot;</span>&lt;&lt;a;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [&amp;]()&#123;</span><br><span class="line">        b=<span class="number">200</span>;</span><br><span class="line">    &#125;();</span><br><span class="line"></span><br><span class="line">    [=]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">        b=<span class="number">300</span>;</span><br><span class="line">    &#125;();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;你好啊&quot;</span>&lt;&lt;b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, std::<span class="built_in">bind</span>(&amp;Teacher::Teacher_is_hungery_but, teacher, <span class="string">&quot;大苏打&quot;</span>));</span><br><span class="line"><span class="comment">////////////////////////////////////</span></span><br><span class="line"><span class="built_in">connect</span>(btn, &amp;QPushButton::clicked,teacher,[=]()&#123;</span><br><span class="line">   emit teacher-&gt;<span class="built_in">Teacher_is_hungery_but</span>(<span class="string">&quot;意大dasdadasdad利面&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="QTIMER"><a href="#QTIMER" class="headerlink" title="QTIMER"></a>QTIMER</h2><img src="/post/2095ef6d/image-20230804140750932.png" class="" title="image-20230804140750932"><blockquote><h5 id="启动器在启动的同时需要指定对应的时间间隔"><a href="#启动器在启动的同时需要指定对应的时间间隔" class="headerlink" title="启动器在启动的同时需要指定对应的时间间隔."></a>启动器在启动的同时需要指定对应的时间间隔.</h5></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 如果指定了父对象, 创建的堆内存可以自动析构</span></span><br><span class="line">QTimer::<span class="built_in">QTimer</span>(QObject *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置定时器时间间隔为 msec 毫秒</span></span><br><span class="line"><span class="comment">// 默认值是0，一旦窗口系统事件队列中的所有事件都已经被处理完，一个时间间隔为0的QTimer就会触发</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::setInterval</span><span class="params">(<span class="type">int</span> msec)</span></span>;</span><br><span class="line"><span class="comment">// 获取定时器的时间间隔, 返回值单位: 毫秒</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTimer::interval</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定的时间间隔启动或者重启定时器, 需要调用 setInterval() 设置时间间隔</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QTimer::start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动或重新启动定时器，超时间隔为msec毫秒。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QTimer::start</span><span class="params">(<span class="type">int</span> msec)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止定时器。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QTimer::stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置定时器精度</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数: </span></span><br><span class="line"><span class="comment">    - Qt::PreciseTimer -&gt; 精确的精度, 毫秒级</span></span><br><span class="line"><span class="comment">    - Qt::CoarseTimer  -&gt; 粗糙的精度, 和1毫秒的误差在5%的范围内, 默认精度</span></span><br><span class="line"><span class="comment">    - Qt::VeryCoarseTimer -&gt; 非常粗糙的精度, 精度在1秒左右</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::setTimerType</span><span class="params">(Qt::TimerType atype)</span></span>;</span><br><span class="line"><span class="function">Qt::TimerType <span class="title">QTimer::timerType</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">// 获取当前定时器的精度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果定时器正在运行，返回true; 否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTimer::isActive</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断定时器是否只触发一次</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTimer::isSingleShot</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置定时器是否只触发一次, 参数为true定时器只触发一次, 为false定时器重复触发, 默认为false</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimer::setSingleShot</span><span class="params">(<span class="type">bool</span> singleShot)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230804173619288.png" class="" title="image-20230804173619288"><blockquote><ol><li><h5 id="首先要创建定时器"><a href="#首先要创建定时器" class="headerlink" title="首先要创建定时器"></a>首先要创建定时器</h5></li><li><h5 id="设置好时间间隔-这是必要的"><a href="#设置好时间间隔-这是必要的" class="headerlink" title="设置好时间间隔,这是必要的"></a>设置好时间间隔,这是必要的</h5></li><li><p>其次可以设置无关紧要的定时器类型</p></li><li><p>有两个状态is</p></li><li><p>有个静态函数，返回值为void,可以搞一个几秒钟发射信号给谁，谁在做出具体的行为</p></li><li><img src="/post/2095ef6d/image-20230804165526274.png" class="" title="image-20230804165526274"></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//创建定时器对象，默认是粗糙的定时器</span></span><br><span class="line">    <span class="function">QTimer <span class="title">timer</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="comment">//    设置定时器的类型</span></span><br><span class="line">    timer.<span class="built_in">setTimerType</span>(Qt::PreciseTimer);</span><br><span class="line">    timer.<span class="built_in">start</span>(<span class="number">3000</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;timer.<span class="built_in">isActive</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;timer.<span class="built_in">isSingleShot</span>();</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;closebtn,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;MainWindow::close);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;timer.<span class="built_in">timerType</span>();</span><br><span class="line">    <span class="comment">//静态函数,返回为void，设置有几秒发射一次信号,谁来接受，以及行为</span></span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(<span class="number">3000</span>,<span class="keyword">this</span>,&amp;MainWindow::close);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个</span></span><br><span class="line"> <span class="comment">///////////////////////////////</span></span><br><span class="line">    <span class="built_in">connect</span>(&amp;timer,&amp;QTimer::timeout,<span class="keyword">this</span>,&amp;MainWindow::close);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h5 id="周期性定时器"><a href="#周期性定时器" class="headerlink" title="周期性定时器"></a>周期性定时器</h5></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建定时器对象</span></span><br><span class="line">QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改定时器对象的精度</span></span><br><span class="line">timer-&gt;<span class="built_in">setTimerType</span>(Qt::PreciseTimer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮 loopBtn 的点击事件</span></span><br><span class="line"><span class="comment">// 点击按钮启动或者关闭定时器, 定时器启动, 周期性得到当前时间</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;loopBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 启动定时器</span></span><br><span class="line">    <span class="keyword">if</span>(timer-&gt;<span class="built_in">isActive</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        timer-&gt;<span class="built_in">stop</span>();  <span class="comment">// 关闭定时器</span></span><br><span class="line">        ui-&gt;loopBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;loopBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;关闭&quot;</span>);</span><br><span class="line">        timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>); <span class="comment">// 1000ms == 1s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, [=]()</span><br><span class="line">&#123;</span><br><span class="line">    QTime tm = QTime::<span class="built_in">currentTime</span>();</span><br><span class="line">    <span class="comment">// 格式化当前得到的系统时间</span></span><br><span class="line">    QString tmstr = tm.<span class="built_in">toString</span>(<span class="string">&quot;hh:mm:ss.zzz&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置要显示的时间</span></span><br><span class="line">    ui-&gt;curTime-&gt;<span class="built_in">setText</span>(tmstr);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><h5 id="一次性定时器"><a href="#一次性定时器" class="headerlink" title="一次性定时器"></a>一次性定时器</h5></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点击按钮 onceBtn 只发射一次信号</span></span><br><span class="line"><span class="comment">// 点击按钮一次, 发射一个信号, 得到某一个时间点的时间</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;onceBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 获取2s以后的系统时间, 不创建定时器对象, 直接使用类的静态方法</span></span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(<span class="number">2000</span>, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        QTime tm = QTime::<span class="built_in">currentTime</span>();</span><br><span class="line">        <span class="comment">// 格式化当前得到的系统时间</span></span><br><span class="line">        QString tmstr = tm.<span class="built_in">toString</span>(<span class="string">&quot;hh:mm:ss.zzz&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置要显示的时间</span></span><br><span class="line">        ui-&gt;onceTime-&gt;<span class="built_in">setText</span>(tmstr);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="QWIDGET-1"><a href="#QWIDGET-1" class="headerlink" title="QWIDGET"></a>QWIDGET</h2><img src="/post/2095ef6d/image-20230805083036843.png" class="" title="image-20230805083036843"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>,&amp;MainWindow::windowIconChanged,<span class="keyword">this</span>,[=](<span class="type">const</span> QIcon &amp;icon)&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;窗口的图标被修改了&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>,&amp;QMainWindow::windowTitleChanged,<span class="keyword">this</span>,[=](<span class="type">const</span> QString &amp;title)&#123;</span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;窗口的标题被修改了&quot;</span>&lt;&lt;title;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setContextMenuPolicy</span>(Qt::CustomContextMenu);</span><br><span class="line"><span class="comment">//设置菜单策略</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>,&amp;QMainWindow::customContextMenuRequested,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">    QMenu a;</span><br><span class="line">    a.<span class="built_in">addAction</span>(<span class="string">&quot;茄子&quot;</span>);</span><br><span class="line">    a.<span class="built_in">addAction</span>(<span class="string">&quot;西红花是&quot;</span>);</span><br><span class="line">    a.<span class="built_in">addAction</span>(<span class="string">&quot;牛马&quot;</span>);</span><br><span class="line">    a.<span class="built_in">addAction</span>(<span class="string">&quot;Odasd&quot;</span>);</span><br><span class="line">    a.<span class="built_in">exec</span>(QCursor::<span class="built_in">pos</span>());</span><br><span class="line">    <span class="comment">//显示在当前光标所在的一个全局坐标。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><h4 id="设置父对象"><a href="#设置父对象" class="headerlink" title="设置父对象"></a>设置父对象</h4></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QWidget::<span class="built_in">QWidget</span>(QWidget *parent = <span class="literal">nullptr</span>, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 给当前窗口设置父对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setParent</span><span class="params">(QWidget *parent)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setParent</span><span class="params">(QWidget *parent, Qt::WindowFlags f)</span></span>;</span><br><span class="line"><span class="comment">//Qt::WindowFlags f 一般不用</span></span><br><span class="line"><span class="comment">// 获取当前窗口的父对象, 没有父对象返回 nullptr</span></span><br><span class="line"><span class="comment">/////////////////////////////////</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QWidget::parentWidget</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>setparent,<strong>parentwidget</strong></p><blockquote><h4 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h4></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------- 窗口位置 -------------</span></span><br><span class="line"><span class="comment">// 得到相对于当前窗口父窗口的几何信息, 边框也被计算在内</span></span><br><span class="line"><span class="function">QRect <span class="title">QWidget::frameGeometry</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到相对于当前窗口父窗口的几何信息, 不包括边框</span></span><br><span class="line"><span class="function"><span class="type">const</span> QRect &amp;<span class="title">geometry</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">frameGeometry</span>()返回的是包括窗口边框的完整几何信息，而<span class="built_in">geometry</span>()返回的是不包括窗口边框的几何信息。</span><br><span class="line">    都是相对于父窗口</span><br><span class="line"><span class="comment">// 设置当前窗口的几何信息(位置和尺寸信息), 不包括边框</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGeometry</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGeometry</span><span class="params">(<span class="type">const</span> QRect &amp;)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 移动窗口, 重新设置窗口的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">const</span> QPoint &amp;)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>当指定了父亲，show之后被内嵌在父亲里面</strong></p><p><strong>不指定父亲show，就会独立显示</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSize&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRect&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QWidget *widget=<span class="keyword">new</span> QWidget;</span><br><span class="line">    widget-&gt;<span class="built_in">show</span>();</span><br><span class="line">    widget-&gt;<span class="built_in">frameSize</span>();</span><br><span class="line"><span class="comment">//    qDebug()&lt;&lt;widget-&gt;parentWidget();</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;widget-&gt;<span class="built_in">frameSize</span>();</span><br><span class="line"><span class="comment">//    qDebug()&lt;&lt;this-&gt;frameSize();</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;widget-&gt;<span class="built_in">geometry</span>();</span><br><span class="line">    widget-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;你好啊&quot;</span>);</span><br><span class="line">    widget-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>,<span class="number">46</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;widget-&gt;<span class="built_in">geometry</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">QSize <span class="title">a</span><span class="params">(<span class="number">250</span>,<span class="number">250</span>)</span></span>;</span><br><span class="line">    <span class="function">QRect <span class="title">b</span><span class="params">(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line">    widget-&gt;<span class="built_in">setGeometry</span>(b);</span><br><span class="line"><span class="comment">//    widget-&gt;showFullScreen();</span></span><br><span class="line"><span class="comment">//    this-&gt;showFullScreen();</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">showMaximized</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line">    widget-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line">   <span class="keyword">this</span>-&gt;<span class="built_in">setWindowIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;C:/Users/许闰博/Desktop/新建文件夹/1.png&quot;</span>));</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="keyword">this</span>-&gt;<span class="built_in">windowIcon</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h4 id="窗口尺寸"><a href="#窗口尺寸" class="headerlink" title="窗口尺寸"></a>窗口尺寸</h4></blockquote><p>设置的尺寸不包含上面那个</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------- 窗口尺寸 -------------</span></span><br><span class="line"><span class="comment">// 获取当前窗口的尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="comment">// 重新设置窗口的尺寸信息</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">const</span> QSize &amp;)</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最大尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">maximumSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最小尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">minimumSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口固定的尺寸信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedSize</span><span class="params">(<span class="type">const</span> QSize &amp;s)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedSize</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口的最大尺寸信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaximumSize</span><span class="params">(<span class="type">const</span> QSize &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaximumSize</span><span class="params">(<span class="type">int</span> maxw, <span class="type">int</span> maxh)</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口的最小尺寸信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMinimumSize</span><span class="params">(<span class="type">const</span> QSize &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMinimumSize</span><span class="params">(<span class="type">int</span> minw, <span class="type">int</span> minh)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前窗口的高度    </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最小高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumHeight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最大高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximumHeight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置固定的高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedHeight</span><span class="params">(<span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置最大高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaximumHeight</span><span class="params">(<span class="type">int</span> maxh)</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置最小高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMinimumHeight</span><span class="params">(<span class="type">int</span> minh)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前窗口的宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">width</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最小宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumWidth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前窗口的最大宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximumWidth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置固定宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedWidth</span><span class="params">(<span class="type">int</span> w)</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置最大宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaximumWidth</span><span class="params">(<span class="type">int</span> maxw)</span></span>;</span><br><span class="line"><span class="comment">// 给窗口设置最小宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMinimumWidth</span><span class="params">(<span class="type">int</span> minw)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><h4 id="窗口标题和图标icon"><a href="#窗口标题和图标icon" class="headerlink" title="窗口标题和图标icon"></a>窗口标题和图标icon</h4></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------- 窗口图标 -------------</span></span><br><span class="line"><span class="comment">// 得到当前窗口的图标</span></span><br><span class="line"><span class="function">QIcon <span class="title">windowIcon</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 构造图标对象, 参数为图片的路径</span></span><br><span class="line">QIcon::<span class="built_in">QIcon</span>(<span class="type">const</span> QString &amp;fileName);</span><br><span class="line"><span class="comment">// 设置当前窗口的图标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWindowIcon</span><span class="params">(<span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------- 窗口标题 -------------</span></span><br><span class="line"><span class="comment">// 得到当前窗口的标题</span></span><br><span class="line"><span class="function">QString <span class="title">windowTitle</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口的标题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWindowTitle</span><span class="params">(<span class="type">const</span> QString &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">现设置发射策略</span><br><span class="line"> QWidget::<span class="built_in">setContextMenuPolicy</span>(Qt::ContextMenuPolicy policy);</span><br><span class="line"> 窗口的右键菜单策略 <span class="built_in">contextMenuPolicy</span>() 参数设置为 Qt::CustomContextMenu, 按下鼠标右键发射该信号</span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QWidget::customContextMenuRequested</span><span class="params">(<span class="type">const</span> QPoint &amp;pos)</span></span>;</span><br><span class="line"></span><br><span class="line">pos得到的是相对父窗口的坐标</span><br><span class="line">    QCursor::<span class="built_in">pos</span>()是相对于屏幕的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口图标发生变化, 发射此信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QWidget::windowIconChanged</span><span class="params">(<span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"><span class="comment">// 窗口标题发生变化, 发射此信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QWidget::windowTitleChanged</span><span class="params">(<span class="type">const</span> QString &amp;title)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h4 id="槽函数"><a href="#槽函数" class="headerlink" title="槽函数"></a>槽函数</h4></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------- 窗口显示 -------------</span></span><br><span class="line"><span class="comment">// 关闭当前窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">bool</span> <span class="title">QWidget::close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏当前窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::hide</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示当前创建以及其子窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::show</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全屏显示当前窗口, 只对windows有效</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::showFullScreen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口最大化显示, 只对windows有效</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::showMaximized</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 窗口最小化显示, 只对windows有效</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::showMinimized</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 将窗口回复为最大化/最小化之前的状态, 只对windows有效</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::showNormal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------- 窗口状态 -------------</span></span><br><span class="line"><span class="comment">// 判断窗口是否可用</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QWidget::isEnabled</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 非槽函数</span></span><br><span class="line"><span class="comment">// 设置窗口是否可用, 不可用窗口无法接收和处理窗口事件</span></span><br><span class="line"><span class="comment">// 参数true-&gt;可用, false-&gt;不可用</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::setEnabled</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"><span class="comment">// 设置窗口是否可用, 不可用窗口无法接收和处理窗口事件</span></span><br><span class="line"><span class="comment">// 参数true-&gt;不可用, false-&gt;可用</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QWidget::setDisabled</span><span class="params">(<span class="type">bool</span> disable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置窗口是否可见, 参数为true-&gt;可见, false-&gt;不可见</span></span><br><span class="line">对于父亲来说没用</span><br><span class="line">[slot] <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">QWidget::setVisible</span><span class="params">(<span class="type">bool</span> visible)</span></span>;。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setContextMenuPolicy</span>(Qt::CustomContextMenu);</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>,&amp;QMainWindow::customContextMenuRequested,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        QMenu a;</span><br><span class="line">        a.<span class="built_in">addAction</span>(<span class="string">&quot;茄子&quot;</span>);</span><br><span class="line">        a.<span class="built_in">addAction</span>(<span class="string">&quot;西红花是&quot;</span>);</span><br><span class="line">        a.<span class="built_in">addAction</span>(<span class="string">&quot;牛马&quot;</span>);</span><br><span class="line">        a.<span class="built_in">addAction</span>(<span class="string">&quot;Odasd&quot;</span>);</span><br><span class="line">        a.<span class="built_in">exec</span>(QCursor::<span class="built_in">pos</span>());</span><br><span class="line">        <span class="comment">//显示在当前光标所在的一个全局坐标。</span></span><br><span class="line">    &#125;);详细的解释一下</span><br></pre></td></tr></table></figure><blockquote><p>首先，设置了触发策略(自定义的)</p><p><code>this-&gt;setContextMenuPolicy(Qt::CustomContextMenu)</code> <strong>设置了窗口的上下文菜单策略为自定义菜单。这意味着当用户右键单击窗口时，不会显示默认的上下文菜单，而是使用自定义的菜单。</strong></p><p>接下来，连接信号,QMainWindow::customContextMenuRequested</p><p><code>connect(this, &amp;QMainWindow::customContextMenuRequested, this, [=]() &#123; ... &#125;)</code> 用于连接 <code>customContextMenuRequested</code> 信号和一个 lambda 表达式。当用户请求上下文菜单时，即右键单击窗口时，该 lambda 表达式将被执行。</p><p>在 lambda 表达式中，首先创建了一个 <code>QMenu</code> 对象 <code>a</code>。然后，使用 <code>a.addAction(&quot;...&quot;)</code> 添加了多个动作（菜单项）。每个 <code>addAction</code> 调用都会创建一个新的 <code>QAction</code> 对象，并将其添加到菜单中。</p><p><strong>接下来，使用 <code>a.exec(QCursor::pos())</code> 显示菜单。<code>QCursor::pos()</code> 返回当前鼠标光标的全局坐标位置，这样菜单就会显示在光标所在的位置。</strong></p><p>总结起来，这段代码的作用是：当用户右键单击窗口时，显示一个自定义的上下文菜单，菜单中包含了多个动作（菜单项）。菜单显示在当前鼠标光标的位置。</p></blockquote><h2 id="QDILAG"><a href="#QDILAG" class="headerlink" title="QDILAG"></a>QDILAG</h2><img src="/post/2095ef6d/image-20230805113458609.png" class="" title="image-20230805113458609"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QDialog::<span class="built_in">QDialog</span>(QWidget *parent = <span class="literal">nullptr</span>, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模态显示窗口</span></span><br><span class="line">[<span class="keyword">virtual</span> slot] <span class="function"><span class="type">int</span> <span class="title">QDialog::exec</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏模态窗口, 并且解除模态窗口的阻塞, 将 exec() 的返回值设置为 QDialog::Accepted1</span></span><br><span class="line">[<span class="keyword">virtual</span> slot] <span class="function"><span class="type">void</span> <span class="title">QDialog::accept</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏模态窗口, 并且解除模态窗口的阻塞, 将 exec() 的返回值设置为 QDialog::Rejected0</span></span><br><span class="line">[<span class="keyword">virtual</span> slot] <span class="function"><span class="type">void</span> <span class="title">QDialog::reject</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭对话框并将其结果代码设置为r。finished()信号将发出r;</span></span><br><span class="line"><span class="comment">// 如果r是QDialog::Accepted 或 QDialog::Rejected，则还将分别发出accept()或Rejected()信号。</span></span><br><span class="line">[<span class="keyword">virtual</span> slot] <span class="function"><span class="type">void</span> <span class="title">QDialog::done</span><span class="params">(<span class="type">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QDialog::accepted</span><span class="params">()</span></span>;</span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QDialog::rejected</span><span class="params">()</span></span>;</span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QDialog::finished</span><span class="params">(<span class="type">int</span> result)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mydialog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyDialog dig;</span><br><span class="line">    <span class="built_in">connect</span>(&amp;dig,&amp;QDialog::accepted,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;accepted信号发射了&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(&amp;dig,&amp;QDialog::rejected,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;rejected信号发射了&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(&amp;dig,&amp;QDialog::finished,<span class="keyword">this</span>,[=](<span class="type">int</span> result)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;finished信号发射了，且返回了&quot;</span>&lt;&lt;result;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///////////////////////////////////////////</span></span><br><span class="line">    <span class="type">int</span> ret=dig.<span class="built_in">exec</span>();</span><br><span class="line">    <span class="comment">//会有一个返回值，如果你点击的是accept会返回1,reject是0 done是对应的参数</span></span><br><span class="line">    <span class="comment">//就是在设置被点击的时候对象.done(r)</span></span><br><span class="line">    <span class="comment">//点击accept或者reject会发射两个信号，一个是对应自己的信号，另一个是finshed信号</span></span><br><span class="line">    <span class="comment">//finshed信号会知道返回的是多少</span></span><br><span class="line">    <span class="keyword">if</span>(ret==QDialog::Accepted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;accepted clicked.....返回值为1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret==QDialog::Rejected) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Rejected clicked.....返回值为0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Done clicked.....返回值为&quot;</span>&lt;&lt;ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>void QDialog::finished(int <em>result</em>)</p><p>这个信号 <code>finished(int result)</code> 是 <code>QDialog</code> 类的一个信号。当对话框的结果代码被设置时，无论是由用户操作还是通过调用 <code>done()</code>、<code>accept()</code> 或 <code>reject()</code> 方法设置，都会发出这个信号。</p><p>需要注意的是，当使用 <code>hide()</code> 或 <code>setVisible(false)</code> 隐藏对话框时，不会发出这个信号。这也包括在对话框可见时删除对话框。</p><p>换句话说，只有在对话框的结果代码被设置时，才会发出 <code>finished(int result)</code> 信号。</p><p>这个信号可以用于在对话框关闭后执行一些特定的操作，比如处理对话框的结果、清理资源等。</p><p><strong>在 <code>connect</code> 函数中，通过指定 <code>&amp;QDialog::finished</code> 作为信号参数，告诉 Qt 连接的信号是 <code>QDialog</code> 的 <code>finished</code> 信号。</strong></p><p>当 <code>finished</code> 信号被触发时，<strong>Qt 会自动将信号的参数传递给槽函数。在这种情况下，<code>finished</code> 信号的参数是 <code>int result</code>，表示对话框的结果代码。</strong></p><p>在 lambda 表达式中，<strong>通过声明 <code>[=](int result)</code> 来接收这个参数。<code>[=]</code> 表示以值捕获的方式捕获所有外部变量，包括 <code>result</code> 参数。因此，当 <code>finished</code> 信号被触发时，<code>result</code> 参数会被传递给 lambda 表达式，你就可以在 lambda 表达式中使用它了</strong>。</p></blockquote><h3 id="QDILAG-》qmessagebox"><a href="#QDILAG-》qmessagebox" class="headerlink" title="QDILAG-》qmessagebox"></a>QDILAG-》qmessagebox</h3><p><strong>参数依次是父对象、标题、主要文本和按钮参数。</strong></p><img src="/post/2095ef6d/image-20230807133721830.png" class="" title="image-20230807133721830"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示一个模态对话框, 将参数 text 的信息展示到窗口中</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">QMessageBox::about</span><span class="params">(QWidget *parent, <span class="type">const</span> QString &amp;title, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">- parent: 对话框窗口的父窗口</span></span><br><span class="line"><span class="comment">- title: 对话框窗口的标题</span></span><br><span class="line"><span class="comment">- text: 对话框窗口中显示的提示信息</span></span><br><span class="line"><span class="comment">- buttons: 对话框窗口中显示的按钮(一个或多个)</span></span><br><span class="line"><span class="comment">- defaultButton</span></span><br><span class="line"><span class="comment">    1. defaultButton指定按下Enter键时使用的按钮。</span></span><br><span class="line"><span class="comment">    2. defaultButton必须引用在参数 buttons 中给定的按钮。</span></span><br><span class="line"><span class="comment">    3. 如果defaultButton是QMessageBox::NoButton, QMessageBox会自动选择一个合适的默认值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 显示一个信息模态对话框</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QMessageBox::StandardButton <span class="title">QMessageBox::information</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">           QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> QString &amp;text, </span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButtons buttons = Ok,</span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButton defaultButton = NoButton)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示一个错误模态对话框</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QMessageBox::StandardButton <span class="title">QMessageBox::critical</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">           QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> QString &amp;text, </span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButtons buttons = Ok,</span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButton defaultButton = NoButton)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示一个问题模态对话框</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QMessageBox::StandardButton <span class="title">QMessageBox::question</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">           QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> QString &amp;text, </span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButtons buttons = StandardButtons(Yes | No), </span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButton defaultButton = NoButton)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示一个警告模态对话框</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QMessageBox::StandardButton <span class="title">QMessageBox::warning</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">           QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> QString &amp;text, </span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButtons buttons = Ok,</span></span></span><br><span class="line"><span class="params"><span class="function">           QMessageBox::StandardButton defaultButton = NoButton)</span></span>;</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230807143709141.png" class="" title="image-20230807143709141"><p>不同按钮对应的枚举值，然后ifelse提示不同的信息。</p><img src="/post/2095ef6d/image-20230807143743669.png" class="" title="image-20230807143743669"><p>举例QDIALOG</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_msg_about_btn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            QMessageBox::<span class="built_in">about</span>(<span class="keyword">this</span>,<span class="string">&quot;你好&quot;</span>,<span class="string">&quot;我真的超级喜欢你啊草&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_msg_about_QTbtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            QMessageBox::<span class="built_in">aboutQt</span>(<span class="keyword">this</span>,<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_msg_critical_btn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">           QMessageBox::<span class="built_in">critical</span>(<span class="keyword">this</span>,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;这是违法行为！！！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_msg_information_btn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>,<span class="string">&quot;information&quot;</span>,<span class="string">&quot;你要噶那么&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_msg_warning_btn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>,<span class="string">&quot;warning&quot;</span>,<span class="string">&quot;吃屎是不对的!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_msg_question_btn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    int ret=QMessageBox::question(this,&quot;牛牛牛&quot;,&quot;你确定要吃屎吗？&quot;);</span></span><br><span class="line"><span class="comment">//    yes no</span></span><br><span class="line">    <span class="type">int</span> ret1=QMessageBox::<span class="built_in">question</span>(<span class="keyword">this</span>,<span class="string">&quot;question&quot;</span>,<span class="string">&quot;你确定要吃屎吗？&quot;</span>,QMessageBox::Ok|QMessageBox::No);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret1==QMessageBox::Ok)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;你可太牛了&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;你shi都不敢吃，太胆小了&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230807170048759.png" class="" title="image-20230807170048759"><hr><h3 id="QFILEDIALOG"><a href="#QFILEDIALOG" class="headerlink" title="QFILEDIALOG"></a>QFILEDIALOG</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通用参数:</span></span><br><span class="line"><span class="comment">  - parent: 当前对话框窗口的父对象也就是父窗口</span></span><br><span class="line"><span class="comment">  - caption: 当前对话框窗口的标题</span></span><br><span class="line"><span class="comment">  - dir: 当前对话框窗口打开的默认目录 e:\\dsad\\das</span></span><br><span class="line"><span class="comment">  - options: 当前对话框窗口的一些可选项,枚举类型, 一般不需要进行设置, 使用默认值即可</span></span><br><span class="line"><span class="comment">  - filter: 过滤器, 在对话框中只显示满足条件的文件, 可以指定多个过滤器, 使用 ;; 分隔</span></span><br><span class="line"><span class="comment">    - 样式举例: </span></span><br><span class="line"><span class="comment">- Images (*.png *.jpg)</span></span><br><span class="line"><span class="comment">- Images (*.png *.jpg);;Text files (*.txt)</span></span><br><span class="line"><span class="comment">  - selectedFilter: 如果指定了多个过滤器, 通过该参数指定默认使用哪一个, 不指定默认使用第一个过滤器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 打开一个目录, 得到这个目录的绝对路径</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QFileDialog::getExistingDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                  QWidget *parent = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;caption = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;dir = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  QFileDialog::Options options = ShowDirsOnly)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开一个文件, 得到这个文件的绝对路径</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QFileDialog::getOpenFileName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">              QWidget *parent = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> QString &amp;caption = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;dir = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;filter = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  QString *selectedFilter = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  QFileDialog::Options options = Options())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开多个文件, 得到这多个文件的绝对路径</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QStringList <span class="title">QFileDialog::getOpenFileNames</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">              QWidget *parent = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;caption = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;dir = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;filter = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  QString *selectedFilter = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  QFileDialog::Options options = Options())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开一个目录, 使用这个目录来保存指定的文件</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QFileDialog::getSaveFileName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      QWidget *parent = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;caption = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;dir = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> QString &amp;filter = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">                  QString *selectedFilter = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                  QFileDialog::Options options = Options())</span></span>;</span><br><span class="line">不能帮我们弄创建一个新的文件，需要用open，打开然后w</span><br></pre></td></tr></table></figure><p>自己的项目QFILEDIALOG</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFileDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//tr()的介绍</span></span><br><span class="line"><span class="comment">//    如果你的应用程序需要支持多种语言，并且你希望在不同的语言环境下显示不同的翻译，</span></span><br><span class="line"><span class="comment">//    那么你需要在应用程序中配置相应的翻译文件，并使用 tr() 函数对需要翻译的文本进行标记。</span></span><br><span class="line"><span class="comment">//    这样，Qt会根据当前的语言环境自动加载相应的翻译文件，并将文本翻译为适当的语言。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    单个过滤器tr(选择名(*.h *.c))       tr(&quot;yuan(*.c *.h)&quot;)</span></span><br><span class="line"><span class="comment">//    多个过滤器   tr(&quot;yuan(*.c *.h);;ok(*.txt)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    默认会选择第一种过滤器，如果要想默认选择某个过滤器的话，就要传入对应的字符串指针</span></span><br><span class="line"><span class="comment">//    QString *se1ectedFilter = nullptr,</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    QString filename= QFileDialog::<span class="built_in">getExistingDirectory</span>(<span class="keyword">this</span>,<span class="string">&quot;选撒大苏打&quot;</span>,<span class="string">&quot;E:/QTPROJECT&quot;</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>,<span class="string">&quot;提示&quot;</span>,<span class="string">&quot;你选择的路径是\n&quot;</span>+filename);</span><br><span class="line">    <span class="comment">//找的是目录</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_2_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="function">QString <span class="title">a</span><span class="params">(<span class="string">&quot;ok(*.txt)&quot;</span>)</span></span>;</span><br><span class="line">     QString filename= QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>,<span class="string">&quot;选择文件&quot;</span>,<span class="string">&quot;E:/QTPROJECT&quot;</span>,<span class="string">&quot;yuan(*.txt);;ok(*.c *.h)&quot;</span>,&amp;a);</span><br><span class="line">     QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>,<span class="string">&quot;提示&quot;</span>,<span class="string">&quot;你选择的路径是\n&quot;</span>+filename);</span><br><span class="line">     <span class="comment">//找的是文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_3_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QString <span class="title">a</span><span class="params">(<span class="string">&quot;ok(*.txt)&quot;</span>)</span></span>;</span><br><span class="line">    QStringList filename=QFileDialog::<span class="built_in">getOpenFileNames</span>(<span class="keyword">this</span>,<span class="string">&quot;路径&quot;</span>,<span class="string">&quot;E:/QTPROJECT&quot;</span>,<span class="string">&quot;源件(*.c *.h)&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;filename.<span class="built_in">length</span>();i++) &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>,<span class="string">&quot;提示&quot;</span>,<span class="string">&quot;你选择的路径是\n&quot;</span>+filename[i]+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找的是多个文件</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;filename.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="QFONTDIALOG"><a href="#QFONTDIALOG" class="headerlink" title="QFONTDIALOG!!!"></a>QFONTDIALOG!!!</h3><p>先引入Qfont</p><blockquote><p><strong>在 <code>QFont</code> 构造函数中，中间两个参数 <code>pointSize</code> 和 <code>weight</code> 的范围如下：</strong></p><ul><li><strong><code>pointSize</code>：表示字体的大小，是一个整数参数。它的范围是正整数，表示字体的点大小。例如，<code>pointSize</code> 为 18 表示字体大小为 18 点。</strong></li><li><strong><code>weight</code>：表示字体的粗细程度，是一个整数参数。它的范围是 <code>QFont::Thin</code>（0）到 <code>QFont::Black</code>（99）之间的整数值。其中，<code>QFont::Thin</code> 表示最细的字体，<code>QFont::Black</code> 表示最粗的字体。Qt 提供了一些预定义的 <code>QFont::Weight</code> 值，如 <code>QFont::Light</code>、<code>QFont::Normal</code>、<code>QFont::Bold</code> 等，它们对应着不同的粗细程度。</strong></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFont&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function">QFont <span class="title">f</span><span class="params">(<span class="string">&quot;你好啊&quot;</span>,<span class="number">38</span>,QFont::Black,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setFont</span>(f);</span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">  QFont::<span class="built_in">QFont</span>();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  参数:</span></span><br><span class="line"><span class="comment">    - family: 本地字库中的字体名, 通过 office 等文件软件可以查看</span></span><br><span class="line"><span class="comment">    - pointSize: 字体的字号</span></span><br><span class="line"><span class="comment">    - weight: 字体的粗细, 有效范围为 0 ~ 99</span></span><br><span class="line"><span class="comment">    - italic: 字体是否倾斜显示, 默认不倾斜</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  QFont::<span class="built_in">QFont</span>(<span class="type">const</span> QString &amp;family, <span class="type">int</span> pointSize = <span class="number">-1</span>, <span class="type">int</span> weight = <span class="number">-1</span>, <span class="type">bool</span> italic = <span class="literal">false</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置字体</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setFamily</span><span class="params">(<span class="type">const</span> QString &amp;family)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据字号设置字体大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setPointSize</span><span class="params">(<span class="type">int</span> pointSize)</span></span>;</span><br><span class="line">  <span class="comment">// 根据像素设置字体大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setPixelSize</span><span class="params">(<span class="type">int</span> pixelSize)</span></span>;</span><br><span class="line">  <span class="comment">// 设置字体的粗细程度, 有效范围: 0 ~ 99</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setWeight</span><span class="params">(<span class="type">int</span> weight)</span></span>;</span><br><span class="line">  <span class="comment">// 设置字体是否加粗显示</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setBold</span><span class="params">(<span class="type">bool</span> enable)</span></span>;</span><br><span class="line">  <span class="comment">// 设置字体是否要倾斜显示</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">QFont::setItalic</span><span class="params">(<span class="type">bool</span> enable)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取字体相关属性(一般规律: 去掉设置函数的 set 就是获取相关属性对应的函数名)</span></span><br><span class="line">  <span class="function">QString <span class="title">QFont::family</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">QFont::italic</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">QFont::pixelSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">QFont::pointSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">QFont::bold</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">QFont::weight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230807172557719.png" class="" title="image-20230807172557719"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否获得了有效字体信息, 指定一个布尔类型变量地址</span></span><br><span class="line"><span class="comment">  ,如果我们点击了选择了字体就是true，点击了cancle就是false</span></span><br><span class="line"><span class="comment">  - initial: 字体对话框中默认选中并显示该字体信息, 用于对话框的初始化</span></span><br><span class="line"><span class="comment">  - parent: 字体对话框窗口的父对象</span></span><br><span class="line"><span class="comment">  - title: 字体对话框的窗口标题</span></span><br><span class="line"><span class="comment">  - options: 字体对话框选项, 使用默认属性即可, 一般不设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  [<span class="type">static</span>] <span class="function">QFont <span class="title">QFontDialog::getFont</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">bool</span> *ok, <span class="type">const</span> QFont &amp;initial, </span></span></span><br><span class="line"><span class="params"><span class="function">QWidget *parent = <span class="literal">nullptr</span>, <span class="type">const</span> QString &amp;title = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">QFontDialog::FontDialogOptions options = FontDialogOptions())</span></span>;</span><br><span class="line">  </span><br><span class="line">  [<span class="type">static</span>] <span class="function">QFont <span class="title">QFontDialog::getFont</span><span class="params">(<span class="type">bool</span> *ok, QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230807172626468.png" class="" title="image-20230807172626468"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">    QFont f=QFontDialog::<span class="built_in">getFont</span>(&amp;ok,<span class="built_in">QFont</span>(<span class="string">&quot;微软雅黑&quot;</span>,<span class="number">30</span>,<span class="number">70</span>),<span class="keyword">this</span>,<span class="string">&quot;设置字体&quot;</span>);</span><br><span class="line"><span class="comment">//    QFont f=QFontDialog::getFont(NULL);</span></span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setFont</span>(f);</span><br><span class="line">&#125;</span><br><span class="line">不指定的话也能实现设置字体。</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230807173444450.png" class="" title="image-20230807173444450"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">    QFont f=QFontDialog::<span class="built_in">getFont</span>(&amp;ok,<span class="built_in">QFont</span>(<span class="string">&quot;微软雅黑&quot;</span>,<span class="number">30</span>,<span class="number">70</span>),<span class="keyword">this</span>,<span class="string">&quot;设置字体&quot;</span>);</span><br><span class="line"><span class="comment">//    QFont f=QFontDialog::getFont(NULL);</span></span><br><span class="line">    QApplication::<span class="built_in">setFont</span>(f);</span><br><span class="line">    <span class="comment">//设置给当前应用程序的所有窗口的字体都一样</span></span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setFont</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QCOLORDIALOG"><a href="#QCOLORDIALOG" class="headerlink" title="QCOLORDIALOG"></a>QCOLORDIALOG</h3><p>QCOLOR</p><img src="/post/2095ef6d/image-20230807174210005.png" class="" title="image-20230807174210005"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QColor::<span class="built_in">QColor</span>(Qt::GlobalColor color);</span><br><span class="line">QColor::<span class="built_in">QColor</span>(<span class="type">int</span> r, <span class="type">int</span> g, <span class="type">int</span> b, <span class="type">int</span> a = ...);</span><br><span class="line">QColor::<span class="built_in">QColor</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数设置 red, green, blue, alpha, 取值范围都是 0-255</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::setRed</span><span class="params">(<span class="type">int</span> red)</span></span>;<span class="comment">// 红色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::setGreen</span><span class="params">(<span class="type">int</span> green)</span></span>;<span class="comment">// 绿色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::setBlue</span><span class="params">(<span class="type">int</span> blue)</span></span>;<span class="comment">// 蓝色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::setAlpha</span><span class="params">(<span class="type">int</span> alpha)</span></span>;<span class="comment">// 透明度, 默认不透明(255)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::setRgb</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> g, <span class="type">int</span> b, <span class="type">int</span> a = <span class="number">255</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QColor::red</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QColor::green</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QColor::blue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QColor::alpha</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">//都是传出参数，把参数作为返回值.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QColor::getRgb</span><span class="params">(<span class="type">int</span> *r, <span class="type">int</span> *g, <span class="type">int</span> *b, <span class="type">int</span> *a = <span class="literal">nullptr</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用方法，就相当于之前函数有一个指针类型的参数我们要传入一个地址进去，的逆过程！！！能够的包原来的变量，</span><br><span class="line">    原来是<span class="type">int</span>....-&gt;<span class="type">int</span>*</span><br><span class="line">    现在是<span class="type">int</span>*-&gt;<span class="type">int</span></span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function">QColor <span class="title">color</span><span class="params">(<span class="number">234</span>,<span class="number">22</span>,<span class="number">13</span>,<span class="number">150</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">int</span> g;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    color.<span class="built_in">getRgb</span>(&amp;r,&amp;g,&amp;b,&amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;r&lt;&lt;g&lt;&lt;b&lt;&lt;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    234 22 13 150</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>qcolordialog</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 弹出颜色选择对话框, 并返回选中的颜色信息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">    - initial: 对话框中默认选中的颜色, 用于窗口初始化</span></span><br><span class="line"><span class="comment">    - parent: 给对话框窗口指定父对象</span></span><br><span class="line"><span class="comment">    - title: 对话框窗口的标题</span></span><br><span class="line"><span class="comment">    - options: 颜色对话框窗口选项, 使用默认属性即可, 一般不需要设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  [<span class="type">static</span>] <span class="function">QColor <span class="title">QColorDialog::getColor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> QColor &amp;initial = Qt::white, </span></span></span><br><span class="line"><span class="params"><span class="function">QWidget *parent = <span class="literal">nullptr</span>, <span class="type">const</span> QString &amp;title = QString(), </span></span></span><br><span class="line"><span class="params"><span class="function">QColorDialog::ColorDialogOptions options = ColorDialogOptions())</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QColor&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QColorDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function">QColor <span class="title">color</span><span class="params">(<span class="number">234</span>,<span class="number">22</span>,<span class="number">13</span>,<span class="number">150</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">int</span> g;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    color.<span class="built_in">getRgb</span>(&amp;r,&amp;g,&amp;b,&amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;r&lt;&lt;g&lt;&lt;b&lt;&lt;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    234 22 13 150</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     QColor c= QColorDialog::<span class="built_in">getColor</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="static-QColor-qcolor-53-200-255-254"><a href="#static-QColor-qcolor-53-200-255-254" class="headerlink" title="static QColor qcolor(53,200,255,254);"></a>static QColor qcolor(53,200,255,254);</h3></blockquote><p>这样就是全局变量！！！</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString color_str=<span class="built_in">QString</span>(<span class="string">&quot;color:%1&quot;</span>).<span class="built_in">arg</span>(color.<span class="built_in">name</span>());</span><br><span class="line">ui-&gt;groupBox-&gt;<span class="built_in">setStyleSheet</span>(c);</span><br><span class="line">color.name方法得到颜色对应的<span class="number">16</span>进制数据，然后设置css属性.</span><br></pre></td></tr></table></figure><h3 id="qinputdialog"><a href="#qinputdialog" class="headerlink" title="qinputdialog"></a>qinputdialog</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到一个可以输入浮点数的对话框窗口, 返回对话框窗口中输入的浮点数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - parent: 对话框窗口的父窗口</span></span><br><span class="line"><span class="comment">  - title: 对话框窗口显示的标题信息</span></span><br><span class="line"><span class="comment">  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)</span></span><br><span class="line"><span class="comment">  - value: 对话框窗口中显示的浮点值, 默认为 0</span></span><br><span class="line"><span class="comment">  - min: 对话框窗口支持显示的最小数值</span></span><br><span class="line"><span class="comment">  - max: 对话框窗口支持显示的最大数值</span></span><br><span class="line"><span class="comment">  - decimals: 浮点数的精度, 默认保留小数点以后1位</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数</span></span><br><span class="line"><span class="comment">  - flags: 对话框窗口的窗口属性, 使用默认值即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">double</span> <span class="title">QInputDialog::getDouble</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString &amp;label, <span class="type">double</span> value = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> min = <span class="number">-2147483647</span>, <span class="type">double</span> max = <span class="number">2147483647</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> decimals = <span class="number">1</span>, <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::WindowFlags flags = Qt::WindowFlags())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个可以输入整形数的对话框窗口, 返回对话框窗口中输入的整形数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - parent: 对话框窗口的父窗口</span></span><br><span class="line"><span class="comment">  - title: 对话框窗口显示的标题信息</span></span><br><span class="line"><span class="comment">  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)</span></span><br><span class="line"><span class="comment">  - value: 对话框窗口中显示的整形值, 默认为 0</span></span><br><span class="line"><span class="comment">  - min: 对话框窗口支持显示的最小数值</span></span><br><span class="line"><span class="comment">  - max: 对话框窗口支持显示的最大数值</span></span><br><span class="line"><span class="comment">  - step: 步长, 通过对话框提供的按钮调节数值每次增长/递减的量</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数</span></span><br><span class="line"><span class="comment">  - flags: 对话框窗口的窗口属性, 使用默认值即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">int</span> <span class="title">QInputDialog::getInt</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString &amp;label, <span class="type">int</span> value = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> min = <span class="number">-2147483647</span>, <span class="type">int</span> max = <span class="number">2147483647</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> step = <span class="number">1</span>, <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::WindowFlags flags = Qt::WindowFlags())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个带下来菜单的对话框窗口, 返回选择的菜单项上边的文本信息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - parent: 对话框窗口的父窗口</span></span><br><span class="line"><span class="comment">  - title: 对话框窗口显示的标题信息</span></span><br><span class="line"><span class="comment">  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)</span></span><br><span class="line"><span class="comment">  - items: 字符串列表, 用于初始化窗口中的下拉菜单, 每个字符串对应一个菜单项</span></span><br><span class="line"><span class="comment">  - current: 通过菜单项的索引指定显示下拉菜单中的哪个菜单项, 默认显示第一个(编号为0)</span></span><br><span class="line"><span class="comment">  - editable: 设置菜单项上的文本信息是否可以进行编辑, 默认为true, 即可以编辑</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数</span></span><br><span class="line"><span class="comment">  - flags: 对话框窗口的窗口属性, 使用默认值即可</span></span><br><span class="line"><span class="comment">  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串</span></span><br><span class="line"><span class="comment">    - 如果有特殊需求, 可以参数帮助文档进行相关设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QInputDialog::getItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    QWidget *parent, <span class="type">const</span> QString &amp;title, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString &amp;label, <span class="type">const</span> QStringList &amp;items, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> current = <span class="number">0</span>, <span class="type">bool</span> editable = <span class="literal">true</span>, <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::WindowFlags flags = Qt::WindowFlags(), </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::InputMethodHints inputMethodHints = Qt::ImhNone)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个可以输入多行数据的对话框窗口, 返回用户在窗口中输入的文本信息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - parent: 对话框窗口的父窗口</span></span><br><span class="line"><span class="comment">  - title: 对话框窗口显示的标题信息</span></span><br><span class="line"><span class="comment">  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)</span></span><br><span class="line"><span class="comment">  - text: 指定显示到多行输入框中的文本信息, 默认是空字符串</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数</span></span><br><span class="line"><span class="comment">  - flags: 对话框窗口的窗口属性, 使用默认值即可</span></span><br><span class="line"><span class="comment">  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串</span></span><br><span class="line"><span class="comment">    - 如果有特殊需求, 可以参数帮助文档进行相关设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QInputDialog::getMultiLineText</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    QWidget *parent, <span class="type">const</span> QString &amp;title, <span class="type">const</span> QString &amp;label, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString &amp;text = QString(), <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::WindowFlags flags = Qt::WindowFlags(), </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::InputMethodHints inputMethodHints = Qt::ImhNone)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一个可以输入单行信息的对话框窗口, 返回用户在窗口中输入的文本信息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - parent: 对话框窗口的父窗口 </span></span><br><span class="line"><span class="comment">  - title: 对话框窗口显示的标题信息</span></span><br><span class="line"><span class="comment">  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)</span></span><br><span class="line"><span class="comment">  - mode: 指定单行编辑框中数据的反馈模式, 是一个 QLineEdit::EchoMode 类型的枚举值</span></span><br><span class="line"><span class="comment">    - QLineEdit::Normal: 显示输入的字符。这是默认值</span></span><br><span class="line"><span class="comment">    - QLineEdit::NoEcho: 不要展示任何东西。这可能适用于连密码长度都应该保密的密码。</span></span><br><span class="line"><span class="comment">    - QLineEdit::Password: 显示与平台相关的密码掩码字符，而不是实际输入的字符。</span></span><br><span class="line"><span class="comment">    - QLineEdit::PasswordEchoOnEdit: 在编辑时按输入显示字符，否则按密码显示字符。</span></span><br><span class="line"><span class="comment">  - text: 指定显示到单行输入框中的文本信息, 默认是空字符串</span></span><br><span class="line"><span class="comment">  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数</span></span><br><span class="line"><span class="comment">  - flags: 对话框窗口的窗口属性, 使用默认值即可</span></span><br><span class="line"><span class="comment">  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串</span></span><br><span class="line"><span class="comment">     - 如果有特殊需求, 可以参数帮助文档进行相关设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QInputDialog::getText</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    QWidget *parent, <span class="type">const</span> QString &amp;title, <span class="type">const</span> QString &amp;label,</span></span></span><br><span class="line"><span class="params"><span class="function">    QLineEdit::EchoMode mode = QLineEdit::Normal, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QString &amp;text = QString(), <span class="type">bool</span> *ok = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::WindowFlags flags = Qt::WindowFlags(), </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::InputMethodHints inputMethodHints = Qt::ImhNone)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>qinputdialog</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QInputDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">    <span class="type">int</span> a=QInputDialog::<span class="built_in">getInt</span>(<span class="keyword">this</span>,<span class="string">&quot;输入&quot;</span>,<span class="string">&quot;输入你的年龄&quot;</span>,<span class="number">18</span>,<span class="number">0</span>,<span class="number">20</span>,<span class="number">1</span>,&amp;ok);</span><br><span class="line">    <span class="comment">//不能跳跃参数</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_2_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">    <span class="type">double</span> a=QInputDialog::<span class="built_in">getDouble</span>(<span class="keyword">this</span>,<span class="string">&quot;inputdouble&quot;</span>,<span class="string">&quot;请输入你的长度&quot;</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,&amp;ok);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_5_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QStringList strlist=&#123;<span class="string">&quot;小红&quot;</span>,<span class="string">&quot;小绿&quot;</span>,<span class="string">&quot;小紫&quot;</span>&#125;;</span><br><span class="line">    QString text=QInputDialog::<span class="built_in">getItem</span>(<span class="keyword">this</span>,<span class="string">&quot;输入item&quot;</span>,<span class="string">&quot;选择输入喜欢的人&quot;</span>,strlist,<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_3_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">    QString text= QInputDialog::<span class="built_in">getText</span>(<span class="keyword">this</span>,<span class="string">&quot;gettext&quot;</span>,<span class="string">&quot;输入你喜欢的书&quot;</span>,QLineEdit::NoEcho,<span class="string">&quot;活着&quot;</span>,&amp;ok);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_4_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">    QString text= QInputDialog::<span class="built_in">getMultiLineText</span>(<span class="keyword">this</span>,<span class="string">&quot;getmultiline&quot;</span>,<span class="string">&quot;输入多行&quot;</span>,<span class="string">&quot;大笨猪666&quot;</span>,&amp;ok);</span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="qprogressdialog"><a href="#qprogressdialog" class="headerlink" title="qprogressdialog"></a>qprogressdialog</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - labelText: 对话框中显示的提示信息</span></span><br><span class="line"><span class="comment">  - cancelButtonText: 取消按钮上显示的文本信息</span></span><br><span class="line"><span class="comment">  - minimum: 进度条最小值</span></span><br><span class="line"><span class="comment">  - maximum: 进度条最大值</span></span><br><span class="line"><span class="comment">  - parent: 当前窗口的父对象</span></span><br><span class="line"><span class="comment">  - f: 当前进度窗口的flag属性, 使用默认属性即可, 无需设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QProgressDialog::<span class="built_in">QProgressDialog</span>(</span><br><span class="line">QWidget *parent = <span class="literal">nullptr</span>, </span><br><span class="line">Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"></span><br><span class="line">QProgressDialog::<span class="built_in">QProgressDialog</span>(</span><br><span class="line"><span class="type">const</span> QString &amp;labelText, <span class="type">const</span> QString &amp;cancelButtonText, </span><br><span class="line"><span class="type">int</span> minimum, <span class="type">int</span> maximum, QWidget *parent = <span class="literal">nullptr</span>,</span><br><span class="line">Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置取消按钮显示的文本信息</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setCancelButtonText</span><span class="params">(<span class="type">const</span> QString &amp;cancelButtonText)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数和槽函数</span></span><br><span class="line"><span class="function">QString <span class="title">QProgressDialog::labelText</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setLabelText</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到进度条最小值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QProgressDialog::minimum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置进度条最小值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setMinimum</span><span class="params">(<span class="type">int</span> minimum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到进度条最大值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QProgressDialog::maximum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置进度条最大值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setMaximum</span><span class="params">(<span class="type">int</span> maximum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置进度条范围(最大和最小值)</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setRange</span><span class="params">(<span class="type">int</span> minimum, <span class="type">int</span> maximum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到进度条当前的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QProgressDialog::value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置进度条当前的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setValue</span><span class="params">(<span class="type">int</span> progress)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QProgressDialog::autoReset</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 当value() = maximum()时，进程对话框是否调用reset()，此属性默认为true。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setAutoReset</span><span class="params">(<span class="type">bool</span> reset)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QProgressDialog::autoClose</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 当value() = maximum()时，进程对话框是否调用reset()并且隐藏，此属性默认为true。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QProgressDialog::setAutoClose</span><span class="params">(<span class="type">bool</span> close)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断用户是否按下了取消键, 按下了返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wasCanceled</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置进度条</span></span><br><span class="line"><span class="comment">// 重置进度对话框。wascancelled()变为true，直到进程对话框被重置。进度对话框被隐藏。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QProgressDialog::cancel</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 重置进度对话框。如果autoClose()为真，进程对话框将隐藏。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QProgressDialog::reset</span><span class="params">()</span></span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号</span></span><br><span class="line"><span class="comment">// 当单击cancel按钮时，将发出此信号。默认情况下，它连接到cancel()槽。</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QProgressDialog::canceled</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">这是他的积累的组件函数，基类！！！！！</span><br><span class="line"><span class="comment">// 设置窗口的显示状态(模态, 非模态)</span></span><br><span class="line">    需要写在show之前！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span><br><span class="line">    需要写在show之前！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span><br><span class="line">    需要写在show之前！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span><br><span class="line">    需要写在show之前！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">Qt::NonModal  -&gt; 非模态</span></span><br><span class="line"><span class="comment">Qt::WindowModal-&gt; 模态, 阻塞父窗口</span></span><br><span class="line"><span class="comment">Qt::ApplicationModal -&gt; 模态, 阻塞应用程序中的所有窗口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setWindowModality</span><span class="params">(Qt::WindowModality windowModality)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QProgressDialog *progress=<span class="keyword">new</span> <span class="built_in">QProgressDialog</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//    指定了父亲，当大窗口关闭的时候，progress就被释放 了！！！</span></span><br><span class="line">    progress-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;更新中&quot;</span>);</span><br><span class="line">    progress-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    QTimer *tmer=<span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//    指定了父亲，当大窗口关闭的时候，tmer就被释放 了！！！</span></span><br><span class="line">    tmer-&gt;<span class="built_in">start</span>();</span><br><span class="line">    tmer-&gt;<span class="built_in">setInterval</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value=<span class="number">0</span>;</span><br><span class="line">    progress-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(tmer,&amp;QTimer::timeout,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line"></span><br><span class="line">        progress-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line">        value++;</span><br><span class="line">        <span class="keyword">if</span>(value&gt;progress-&gt;<span class="built_in">maximum</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            value=<span class="number">0</span>;</span><br><span class="line">            tmer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(progress-&gt;<span class="built_in">wasCanceled</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        value=<span class="number">0</span>;</span><br><span class="line">        tmer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    connect(progress,&amp;QProgressDialog::canceled,this,[=]()&#123;</span></span><br><span class="line"><span class="comment">//        value=0;</span></span><br><span class="line"><span class="comment">//        tmer-&gt;stop();</span></span><br><span class="line"><span class="comment">//    &#125;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己手动释放的话</p><p>一般都配合着定时器使用</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QProgressDialog *progress=<span class="keyword">new</span> <span class="built_in">QProgressDialog</span>();</span><br><span class="line"><span class="comment">//    指定了父亲，当大窗口关闭的时候，progress就被释放 了！！！</span></span><br><span class="line">    progress-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;更新中&quot;</span>);</span><br><span class="line">    progress-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    QTimer *tmer=<span class="keyword">new</span> <span class="built_in">QTimer</span>();</span><br><span class="line">    <span class="comment">//    指定了父亲，当大窗口关闭的时候，tmer就被释放 了！！！</span></span><br><span class="line">    tmer-&gt;<span class="built_in">start</span>();</span><br><span class="line">    tmer-&gt;<span class="built_in">setInterval</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value=<span class="number">0</span>;</span><br><span class="line">    progress-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(tmer,&amp;QTimer::timeout,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line"></span><br><span class="line">        progress-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line">        value++;</span><br><span class="line">        <span class="keyword">if</span>(value&gt;progress-&gt;<span class="built_in">maximum</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            value=<span class="number">0</span>;</span><br><span class="line">            tmer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">            <span class="keyword">delete</span>  progress;</span><br><span class="line">            <span class="keyword">delete</span> tmer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(progress-&gt;<span class="built_in">wasCanceled</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        value=<span class="number">0</span>;</span><br><span class="line">        tmer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">        <span class="keyword">delete</span>  progress;</span><br><span class="line">        <span class="keyword">delete</span> tmer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    connect(progress,&amp;QProgressDialog::canceled,this,[=]()&#123;</span></span><br><span class="line"><span class="comment">//        value=0;</span></span><br><span class="line"><span class="comment">//        tmer-&gt;stop();</span></span><br><span class="line"><span class="comment">//    &#125;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Qmainwindow-1"><a href="#Qmainwindow-1" class="headerlink" title="Qmainwindow"></a>Qmainwindow</h2><img src="/post/2095ef6d/image-20230808160356220.png" class="" title="image-20230808160356220"><img src="/post/2095ef6d/image-20230808160406271.png" class="" title="image-20230808160406271"><h3 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h3><img src="/post/2095ef6d/image-20230808161932543.png" class="" title="image-20230808161932543"><img src="/post/2095ef6d/image-20230808161945774.png" class="" title="image-20230808161945774"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给菜单栏添加菜单</span></span><br><span class="line"><span class="function">QAction *<span class="title">QMenuBar::addMenu</span><span class="params">(QMenu *menu)</span></span>;</span><br><span class="line"><span class="function">QMenu *<span class="title">QMenuBar::addMenu</span><span class="params">(<span class="type">const</span> QString &amp;title)</span></span>;</span><br><span class="line"><span class="function">QMenu *<span class="title">QMenuBar::addMenu</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;title)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给菜单对象添加菜单项(QAction)</span></span><br><span class="line"><span class="function">QAction *<span class="title">QMenu::addAction</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="function">QAction *<span class="title">QMenu::addAction</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加分割线</span></span><br><span class="line"><span class="function">QAction *<span class="title">QMenu::addSeparator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>&#x2F;&#x2F; 点击QAction对象发出该信号</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAction::triggered</span><span class="params">(<span class="type">bool</span> checked = <span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// save_action 是某个菜单项对象名, 点击这个菜单项会弹出一个对话框</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;save_action, &amp;QAction::triggered, <span class="keyword">this</span>, [=]()</span><br><span class="line">&#123;</span><br><span class="line">   QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;Triggered&quot;</span>, <span class="string">&quot;我是菜单项, 你不要调戏我...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><p>对应的方法就是set神马神马！</p><img src="/post/2095ef6d/image-20230808163239944.png" class="" title="image-20230808163239944"><img src="/post/2095ef6d/image-20230808163310859.png" class="" title="image-20230808163310859"><img src="/post/2095ef6d/image-20230808163320921.png" class="" title="image-20230808163320921"><img src="/post/2095ef6d/image-20230808163338503.png" class="" title="image-20230808163338503"><h3 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h3><img src="/post/2095ef6d/image-20230808163405209.png" class="" title="image-20230808163405209"><img src="/post/2095ef6d/image-20230808163440189.png" class="" title="image-20230808163440189"><h2 id="有的控件我们不给他设置父对象的时候，他为谁服务谁就是他的父亲！"><a href="#有的控件我们不给他设置父对象的时候，他为谁服务谁就是他的父亲！" class="headerlink" title="有的控件我们不给他设置父对象的时候，他为谁服务谁就是他的父亲！"></a><strong>有的控件我们不给他设置父对象的时候，他为谁服务谁就是他的父亲！</strong></h2><img src="/post/2095ef6d/image-20230808172503102.png" class="" title="image-20230808172503102"><p>状态栏</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    ui-&gt;toolBar-&gt;<span class="built_in">setFixedSize</span>(<span class="number">800</span>,<span class="number">50</span>);</span><br><span class="line">    ui-&gt;toolBar-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;点击&quot;</span>,<span class="keyword">this</span>));</span><br><span class="line">    ui-&gt;toolBar-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QLineEdit</span>(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addToolBar</span>(<span class="string">&quot;打住&quot;</span>);</span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">showMessage</span>(<span class="string">&quot;我是状态栏的message&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">    <span class="comment">//第二个参数指定多少毫秒后消失</span></span><br><span class="line">    <span class="comment">//虽然但是这样就把覆盖了，那些还不现实</span></span><br><span class="line">    QPushButton *btn= <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮&quot;</span>);</span><br><span class="line">    QLabel *lb =<span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;不教胡马度阴山！&quot;</span>);</span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(btn);</span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(lb);</span><br><span class="line"></span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(<span class="number">10000</span>,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        btn-&gt;<span class="built_in">show</span>();</span><br><span class="line">        lb-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ui-&gt;statusbar-&gt;<span class="built_in">clearMessage</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="停靠面板"><a href="#停靠面板" class="headerlink" title="停靠面板"></a>停靠面板</h2><img src="/post/2095ef6d/image-20230808180716646.png" class="" title="image-20230808180716646"><img src="/post/2095ef6d/image-20230808180848021.png" class="" title="image-20230808180848021"><h2 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h2><img src="/post/2095ef6d/image-20230808182015037.png" class="" title="image-20230808182015037"><p>资源放在和pro文件相同路静或者更深了</p><img src="/post/2095ef6d/image-20230808181951630.png" class="" title="image-20230808181951630"><img src="/post/2095ef6d/image-20230808182000941.png" class="" title="image-20230808182000941"><img src="/post/2095ef6d/image-20230808182047360.png" class="" title="image-20230808182047360"><h2 id="layout布局"><a href="#layout布局" class="headerlink" title="layout布局"></a>layout布局</h2><img src="/post/2095ef6d/image-20230809102850405.png" class="" title="image-20230809102850405"><blockquote><p>有问有答:<br>    1. 控件的位置可以通过坐标指定, 为什么还要使用布局?<br>        - 坐标指定的位置是固定的, 当窗口大小发生改变, 子窗口位置不会变化<br>            - 使用坐标指定子窗口位置, 这个控件可能会被其他控件覆盖导致无法显示出来<br>            - 使用布局的方式可以完美解决以上的问题<br>                <strong>- 一般在制作窗口的过程中都是给子控件进行布局, 而不是指定固定坐标位置</strong><br>    2. 布局有局限性吗, 窗口结构复杂如何解决呢?<br>        - 没有局限性, 并且布局的使用是非常灵活的<br>        - 各种布局是可以无限嵌套使用的, 这样就可以制作成非常复杂的窗口了<br>            - 思路是这样的: <strong>给窗口设置</strong>布局, 在布局中添加窗口, 子窗口中再设置布局,**<br>              在子窗口布局中再次添加窗口, ……(无限循环)**</p></blockquote><img src="/post/2095ef6d/image-20230809103824470.png" class="" title="image-20230809103824470"><img src="/post/2095ef6d/image-20230809103831288.png" class="" title="image-20230809103831288"><img src="/post/2095ef6d/image-20230809103837334.png" class="" title="image-20230809103837334"><img src="/post/2095ef6d/image-20230809103851464.png" class="" title="image-20230809103851464"><img src="/post/2095ef6d/image-20230809103859157.png" class="" title="image-20230809103859157"><img src="/post/2095ef6d/image-20230809103906937.png" class="" title="image-20230809103906937"><img src="/post/2095ef6d/image-20230816131302850.png" class="" title="image-20230816131302850"><h3 id="通过aPI布局"><a href="#通过aPI布局" class="headerlink" title="通过aPI布局"></a>通过aPI布局</h3><img src="/post/2095ef6d/image-20230816131335828.png" class="" title="image-20230816131335828"><img src="/post/2095ef6d/image-20230816131357522.png" class="" title="image-20230816131357522"><img src="/post/2095ef6d/image-20230816131407076.png" class="" title="image-20230816131407076"><h3 id="Qlayout"><a href="#Qlayout" class="headerlink" title="Qlayout"></a>Qlayout</h3><img src="/post/2095ef6d/image-20230816131446315.png" class="" title="image-20230816131446315"><h3 id="Qhboxlayout"><a href="#Qhboxlayout" class="headerlink" title="Qhboxlayout"></a>Qhboxlayout</h3><img src="/post/2095ef6d/image-20230816131604164.png" class="" title="image-20230816131604164"><img src="/post/2095ef6d/image-20230816131615468.png" class="" title="image-20230816131615468"><blockquote><p>先创建布局对象</p><p>然后addwidget往布局里面放东西</p><p>然后再把布局setlayout给父亲窗口</p><p>这样父亲窗口就有这个布局了且是内嵌，</p><h4 id="直接初始化的时候指定父亲和布局后再指定父亲的内嵌效果是有区别的"><a href="#直接初始化的时候指定父亲和布局后再指定父亲的内嵌效果是有区别的" class="headerlink" title="直接初始化的时候指定父亲和布局后再指定父亲的内嵌效果是有区别的"></a>直接初始化的时候指定父亲和布局后再指定父亲的内嵌效果是有区别的</h4></blockquote><h3 id="QVboxlayout"><a href="#QVboxlayout" class="headerlink" title="QVboxlayout"></a>QVboxlayout</h3><img src="/post/2095ef6d/image-20230816133128199.png" class="" title="image-20230816133128199"><img src="/post/2095ef6d/image-20230816133211794.png" class="" title="image-20230816133211794"><h3 id="qgridboxlayout"><a href="#qgridboxlayout" class="headerlink" title="qgridboxlayout"></a>qgridboxlayout</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QGridLayout::<span class="built_in">QGridLayout</span>();</span><br><span class="line">QGridLayout::<span class="built_in">QGridLayout</span>(QWidget *parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加窗口对象到网格布局中</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - widget: 添加到布局中的窗口对象</span></span><br><span class="line"><span class="comment">  - row: 添加到布局中的窗口对象位于第几行 (从0开始)</span></span><br><span class="line"><span class="comment">  - column: 添加到布局中的窗口对象位于第几列 (从0开始)</span></span><br><span class="line"><span class="comment">  - alignment: 窗口在布局中的对齐方式, 没有特殊需求使用默认值即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGridLayout::addWidget</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">QWidget *widget, <span class="type">int</span> row, <span class="type">int</span> column, </span></span></span><br><span class="line"><span class="params"><span class="function">Qt::Alignment alignment = Qt::Alignment())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  - widget: 添加到布局中的窗口对象</span></span><br><span class="line"><span class="comment">  - fromRow: 添加到布局中的窗口对象位于第几行 (从0开始)</span></span><br><span class="line"><span class="comment">  - fromColumn: 添加到布局中的窗口对象位于第几列 (从0开始)</span></span><br><span class="line"><span class="comment">  - rowSpan: 添加的窗口从 fromRow 行开始跨越的行数</span></span><br><span class="line"><span class="comment">  - columnSpan: 添加的窗口从 fromColumn 列开始跨越的列数</span></span><br><span class="line"><span class="comment">  - alignment: 窗口在布局中的对齐方式, 没有特殊需求使用默认值即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGridLayout::addWidget</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">QWidget *widget, <span class="type">int</span> fromRow, <span class="type">int</span> fromColumn, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> rowSpan, <span class="type">int</span> columnSpan, </span></span></span><br><span class="line"><span class="params"><span class="function">Qt::Alignment alignment = Qt::Alignment())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 column 对应的列的最新宽度, 单位: 像素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGridLayout::setColumnMinimumWidth</span><span class="params">(<span class="type">int</span> column, <span class="type">int</span> minSize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置布局中水平方向窗口之间间隔的宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGridLayout::setHorizontalSpacing</span><span class="params">(<span class="type">int</span> spacing)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置布局中垂直方向窗口之间间隔的宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGridLayout::setVerticalSpacing</span><span class="params">(<span class="type">int</span> spacing)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//    qDebug()&lt;&lt;area-&gt;takeWidget();</span></span><br><span class="line"><span class="comment">//    area-&gt;setWidgetResizable(true);</span></span><br><span class="line"><span class="comment">//    area-&gt;setAlignment(Qt::AlignHCenter);</span></span><br><span class="line"><span class="comment">//    ui-&gt;scrollArea_2-&gt;setAlignment(Qt::AlignHCenter);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建父窗口对象</span></span><br><span class="line">    QWidget* window = <span class="keyword">new</span> QWidget;</span><br><span class="line">    <span class="comment">// 创建子窗口对象</span></span><br><span class="line">    QPushButton *button1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;One&quot;</span>);</span><br><span class="line">    QPushButton *button2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Two&quot;</span>);</span><br><span class="line">    QPushButton *button3 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Three&quot;</span>);</span><br><span class="line">    QPushButton *button4 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Four&quot;</span>);</span><br><span class="line">    QPushButton *button5 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Five&quot;</span>);</span><br><span class="line">    QPushButton *button6 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Six&quot;</span>);</span><br><span class="line">    <span class="comment">// 多行文本编辑框</span></span><br><span class="line">    QTextEdit* txedit = <span class="keyword">new</span> QTextEdit;</span><br><span class="line">    txedit-&gt;<span class="built_in">setText</span>(<span class="string">&quot;我占用了两行两列的空间哦。&quot;</span>);</span><br><span class="line"></span><br><span class="line">    QGridLayout* layout = <span class="keyword">new</span> QGridLayout;</span><br><span class="line">    <span class="comment">// 按钮起始位置: 第1行, 第1列, 该按钮占用空间情况为1行1列</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 按钮起始位置: 第1行, 第2列, 该按钮占用空间情况为1行1列</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button2, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 按钮起始位置: 第1行, 第3列, 该按钮占用空间情况为1行1列</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button3, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 编辑框起始位置: 第2行, 第1列, 该按钮占用空间情况为2行2列</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(txedit, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 按钮起始位置: 第2行, 第3列, 该按钮占用空间情况为1行1列</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button4, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 按钮起始位置: 第3行, 第3列, 该按钮占用空间情况为1行1列</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button5, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 按钮起始位置: 第4行, 第1列, 该按钮占用空间情况为1行3列</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button6, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 网格布局设置给父窗口对象</span></span><br><span class="line">    window-&gt;<span class="built_in">setLayout</span>(layout);</span><br><span class="line">    <span class="comment">// 显示父窗口</span></span><br><span class="line">    window-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230816133845787.png" class="" title="image-20230816133845787"><h2 id="———————————"><a href="#———————————" class="headerlink" title="———————————-"></a>———————————-</h2><h2 id="qt窗口实现右键菜单8-14"><a href="#qt窗口实现右键菜单8-14" class="headerlink" title="qt窗口实现右键菜单8.14"></a>qt窗口实现右键菜单8.14</h2><p>学习目标：会熟练使用自定义信号来实现右键的时候弹出自己设置的menu菜单.,区别这四种方法</p><p>实现方法:</p><blockquote><ol><li><h4 id="通过鼠标事件实现"><a href="#通过鼠标事件实现" class="headerlink" title="通过鼠标事件实现"></a>通过鼠标事件实现</h4><blockquote><ol><li><p><code>QWidget</code>是Qt框架中的一个基类，用于创建用户界面的窗口部件。它提供了许多事件处理函数，其中包括<code>mousePressEvent</code>和<code>mouseReleaseEvent</code>。</p><p>这两个函数都是<code>virtual</code>和<code>protected</code>的，意味着它们<strong>可以被子类重写</strong>，并且<strong>只能在类内部或其子类中访问</strong>。</p><p><code>mousePressEvent</code>函数在鼠标按下事件发生时被调用。它接收一个<code>QMouseEvent</code>类型的指针参数<code>event</code>，该参数包含有关鼠标事件的信息，如鼠标位置、按下的按钮等。你可以在重写的<code>mousePressEvent</code>函数中编写自定义的处理代码，以响应鼠标按下事件。</p><p><strong>qDebug()&lt;<event->position();</strong></p><p><code>mouseReleaseEvent</code>函数在<strong>鼠标释放事件发生时被调用</strong>。它也接收一个<code>QMouseEvent</code>类型的指针参数<code>event</code>，该参数包含有关鼠标事件的信息。你可以在重写的<code>mouseReleaseEvent</code>函数中编写自定义的处理代码，以响应鼠标释放事件。</p><p>通过重写这两个函数，你可以在<code>QWidget</code>的子类中实现自定义的鼠标交互行为。例如，你可以捕获鼠标按下和释放事件，并根据需要执行一些操作，如移动窗口、绘制图形等。</p></li><li><pre><code class="c++">//重写这个函数void MainWindow::mousePressEvent(QMouseEvent*event)&#123;    if(event-&gt;button()==Qt::RightButton)    &#123;        qDebug()&lt;&lt;event-&gt;position();        //设置一个菜单栏menu!+menubar        QMenu *bar=new QMenu(this);        bar-&gt;addAction(new QAction(&quot;C++&quot;));        bar-&gt;addAction(new QAction(&quot;Python&quot;));        bar-&gt;addAction(new QAction(&quot;Javascript&quot;));        //        bar-&gt;show();        //设置显示的位置，点击位置的右下角！       // QAction：QAction是一个表示菜单项的类。        QAction对象可以被添加到QMenu中，以在菜单中显示对应的菜单项。            QMenu是一个用于创建菜单的类。它可以包含多个菜单项（QAction对象）或子菜单（QMenu对象）。        bar-&gt;exec(QCursor::pos());    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. &#123;% asset_img image-20230814171018243.png image-20230814171018243 %&#125;</span><br><span class="line"></span><br><span class="line">   ---</span><br><span class="line"></span><br><span class="line">   ```c++</span><br><span class="line">   // 函数原型:</span><br><span class="line">   上下文菜单策略用于定义在用户右键单击控件时如何显示上下文菜单。</span><br><span class="line">       上下文菜单策略只会影响右键单击事件。如果你想在其他事件（如鼠标中键单击、双击等）上显示上下文菜单，你需要根据具体的需求来处理。</span><br><span class="line">   void QWidget::setContextMenuPolicy(Qt::ContextMenuPolicy policy);</span><br><span class="line">   参数: </span><br><span class="line">     - Qt::NoContextMenu     --&gt; 不能实现右键菜单</span><br><span class="line">     - Qt::PreventContextMenu   --&gt; 不能实现右键菜单</span><br><span class="line">     - Qt::DefaultContextMenu   --&gt; 基于事件处理器函数 QWidget::contextMenuEvent() 实现</span><br><span class="line">     - Qt::ActionsContextMenu   --&gt; 添加到当前窗口中所有 QAction 都会作为右键菜单项显示出来</span><br><span class="line">     - Qt::CustomContextMenu    --&gt; 基于 QWidget::customContextMenuRequested() 信号实现</span><br></pre></td></tr></table></figure></code></pre></li></ol></blockquote><hr></li><li><h4 id="通过Qt-CustomContextMenu菜单策略实现"><a href="#通过Qt-CustomContextMenu菜单策略实现" class="headerlink" title="通过Qt::CustomContextMenu菜单策略实现"></a>通过Qt::CustomContextMenu菜单策略实现</h4><blockquote><ol><li><p><code>Qt::CustomContextMenu</code>策略会在用户右键单击控件时发射<code>QWidget::customContextMenuRequested()</code>信号。这个信号可以用于自定义处理右键菜单的显示和操作。</p></li><li><p>使<strong>用这个策略实现右键菜单, 当点击鼠标右键，窗口会产生一个 QWidget::customContextMenuRequested() 信号，注意仅仅只是发射信号，意味着要自己写显示右键菜单的槽函数（slot），这个信号是QWidget唯一与右键菜单有关的信号。</strong></p></li><li><p><strong>大家一定要注意这个坐标是当前窗口的窗口坐标, 不是屏幕坐标, 显示右键菜单需要使用屏幕坐标</strong></p></li><li><pre><code class="c++">    this-&gt;setContextMenuPolicy(Qt::DefaultContextMenu);      //Qt::CustomContextMenu策略会在用户右键单击控件时发射QWidget::customContextMenuRequested()信号。    //这个信号可以用于自定义处理右键菜单的显示和操作。    connect(this,&amp;MainWindow::customContextMenuRequested,this,[=]()&#123;        QMenu *bar=new QMenu(this);        bar-&gt;addAction(new QAction(&quot;C++&quot;));        bar-&gt;addAction(&quot;铸币&quot;);        bar-&gt;addAction(new QAction(&quot;Python&quot;));        bar-&gt;addAction(new QAction(&quot;Javascript&quot;));        //        bar-&gt;show();        //设置显示的位置，点击位置的右下角！        bar-&gt;exec(QCursor::pos());    &#125;);<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. &#123;% asset_img image-20230814173017444.png image-20230814173017444 %&#125;</span><br><span class="line"></span><br><span class="line">3. #### 通过 Qt::DefaultContextMenu菜单策略实现</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  ```c++</span><br><span class="line">  重写函数</span><br><span class="line">    this-&gt;setContextMenuPolicy(Qt::DefaultContextMenu);</span><br><span class="line">  void MainWindow::contextMenuEvent(QContextMenuEvent *event)</span><br><span class="line">  &#123;</span><br><span class="line">  </span><br><span class="line">   //设置一个菜单栏menu!+menubar</span><br><span class="line">   QMenu *bar=new QMenu(this);</span><br><span class="line">   bar-&gt;addAction(new QAction(&quot;C++&quot;));</span><br><span class="line">   bar-&gt;addAction(new QAction(&quot;Python&quot;));</span><br><span class="line">   bar-&gt;addAction(new QAction(&quot;Javascript&quot;));</span><br><span class="line">   //        bar-&gt;show();</span><br><span class="line">   //设置显示的位置，点击位置的右下角！</span><br><span class="line">   bar-&gt;exec(QCursor::pos());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol></blockquote></li><li><h4 id="通过-Qt-ActionsContextMenu菜单策略实现（z最简单的）"><a href="#通过-Qt-ActionsContextMenu菜单策略实现（z最简单的）" class="headerlink" title="通过 Qt::ActionsContextMenu菜单策略实现（z最简单的）"></a>通过 Qt::ActionsContextMenu菜单策略实现（z最简单的）</h4><p><strong>使用这个策略实现右键菜单, 是最简单的一种, 我们只需要创建一些 QAction类型的对象并且将他们添加到当前的窗口中, 当我们在窗口中点击鼠标右键这些QAction类型的菜单项就可以显示出来了。</strong></p><p><strong>但是它有一定的局限性，就是在一个窗口中不能根据不同的需求制作不同的右键菜单，这种方式只能得到一个唯一的右键菜单。</strong></p><p>直接在构造函数里面写！</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setContextMenuPolicy</span>(Qt::ActionsContextMenu);</span><br><span class="line">   </span><br><span class="line">QAction* act1  = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">QAction* act2 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">QAction* act3  = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">addAction</span>(act1);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">addAction</span>(act2);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">addAction</span>(act3);</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>注意:</p><ol><li><p>默认的菜单策略是Qt::NoContextMenu     –&gt; 不能实现右键菜单</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    QMenu *bar=<span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//    bar.setParent(this);</span></span><br><span class="line">    bar-&gt;<span class="built_in">resize</span>(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">    bar-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;野猪&quot;</span>);</span><br><span class="line">    bar-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure><p>是无效的，要想生效得设置后两张菜单策略</p></li><li><p>加一些对应的处理操作qaction有对应的信号</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(act1, &amp;QAction::triggered, <span class="keyword">this</span>, [=]()</span><br><span class="line">&#123;</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;您选择的是C++...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>tri ggered触发</p><p>最后如果想要让自己的右键菜单项显示图标, 可以调用这个函数</p></li><li><pre><code>// 只显示文本字符串QAction *QMenu::addAction(const QString &amp;text);// 可以显示图标 + 文本字符串QAction *QMenu::addAction(const QIcon &amp;icon, const QString &amp;text);<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## qt的按钮控件8.15</span><br><span class="line"></span><br><span class="line">&gt; 菜单类：</span><br><span class="line">&gt;</span><br><span class="line">&gt; ```c++</span><br><span class="line">&gt;      QMenu *m=new QMenu(this);</span><br><span class="line">&gt;      QAction *act1=m-&gt;addAction(&quot;1&quot;);</span><br><span class="line">&gt;      m-&gt;addAction(&quot;2&quot;);</span><br><span class="line">&gt;      m-&gt;addAction(&quot;3&quot;);</span><br><span class="line">&gt; </span><br><span class="line">&gt;      QMenu *n=new QMenu(this);</span><br><span class="line">&gt;      n-&gt;addAction(&quot;1&quot;);</span><br><span class="line">&gt;      n-&gt;addAction(&quot;2&quot;);</span><br><span class="line">&gt;      QAction*act=n-&gt;addAction(&quot;3&quot;);</span><br><span class="line">&gt;      //设置标题</span><br><span class="line">&gt;      n-&gt;setTitle(&quot;adsds&quot;);</span><br><span class="line">&gt; </span><br><span class="line">&gt;      m-&gt;addMenu(n);</span><br><span class="line">&gt; //给原来的菜单加了一个子菜单，当鼠标放到上面的时候会出现子菜单的内容，但是要手动设置那个标题</span><br><span class="line">&gt;      connect(act,&amp;QAction::triggered,this,[=]()&#123;</span><br><span class="line">&gt; //            n-&gt;exec(QCursor::pos());</span><br><span class="line">&gt;          QMessageBox::about(this,&quot;提示&quot;,&quot;去去去&quot;);</span><br><span class="line">&gt;      &#125;);</span><br><span class="line">&gt;      m-&gt;exec(QCursor::pos());</span><br></pre></td></tr></table></figure>&gt;&gt; &#123;% asset_img image-20230902094949570.png image-20230902094949570 %&#125;</code></pre></li></ol><h3 id="1-按钮基类-QAbstractButton"><a href="#1-按钮基类-QAbstractButton" class="headerlink" title="1. 按钮基类 QAbstractButton"></a>1. 按钮基类 QAbstractButton</h3><img src="/post/2095ef6d/image-20230815090815132.png" class="" title="image-20230815090815132"><p>后两个基本不需要使用</p><blockquote><p>继承关系</p></blockquote><img src="/post/2095ef6d/image-20230815090855947.png" class="" title="image-20230815090855947"><blockquote><p>常用的api</p></blockquote><ol><li><p>标题和图标</p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数text的内容显示到按钮上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QAbstractButton::setText</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="comment">// 得到按钮上显示的文本内容, 函数的返回就是</span></span><br><span class="line"><span class="function">QString <span class="title">QAbstractButton::text</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到按钮设置的图标</span></span><br><span class="line"><span class="function">QIcon <span class="title">icon</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给按钮设置图标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setIcon</span><span class="params">(<span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到按钮图标大小</span></span><br><span class="line"><span class="function">QSize <span class="title">iconSize</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="comment">// 设置按钮图标的大小</span></span></span><br><span class="line"><span class="function">[slot]<span class="type">void</span> <span class="title">setIconSize</span><span class="params">(<span class="type">const</span> QSize &amp;size)</span></span>;</span><br></pre></td></tr></table></figure><p>对应实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"> QPushButton *btn=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line"> btn-&gt;<span class="built_in">show</span>();</span><br><span class="line"> <span class="comment">//    ---继承自qabstructbutton</span></span><br><span class="line"> btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;按钮&quot;</span>);</span><br><span class="line"> btn-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/D:/icon/img.png&quot;</span>));</span><br><span class="line"></span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;btn-&gt;<span class="built_in">text</span>();</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;btn-&gt;<span class="built_in">icon</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>result</p><img src="/post/2095ef6d/image-20230815092044094.png" class="" title="image-20230815092044094"><p>总结:资源文件里的路径也不要有中文！！！！！</p></blockquote></li><li><img src="/post/2095ef6d/image-20230815092223821.png" class="" title="image-20230815092223821"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断按钮是否设置了checkable属性, 如果设置了点击按钮, 按钮一直处于选中状态</span></span><br><span class="line"><span class="comment">// 默认这个属性是关闭的, not checkable</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QAbstractButton::isCheckable</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置按钮的checkable属性</span></span><br><span class="line"><span class="comment">// 参数为true: 点击按钮, 按钮被选中, 松开鼠标, 按钮不弹起</span></span><br><span class="line"><span class="comment">// 参数为false: 点击按钮, 按钮被选中, 松开鼠标, 按钮弹起</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QAbstractButton::setCheckable</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line">-------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断按钮是不是被按下的选中状态</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QAbstractButton::isChecked</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置按钮的选中状态: true-选中, false-没选中</span></span><br><span class="line"><span class="comment">// 设置该属性前, 必须先进行 checkable属性的设置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QAbstractButton::setChecked</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line">btn-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);<span class="comment">//设置按钮也可以check，默认是不可以的.</span></span><br><span class="line"></span><br><span class="line">btn-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);<span class="comment">//设置默认是选中状态</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;btn-&gt;<span class="built_in">isChecked</span>();<span class="comment">//true</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;btn-&gt;<span class="built_in">isCheckable</span>();<span class="comment">//true</span></span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230815092710333.png" class="" title="image-20230815092710333"></li><li><img src="/post/2095ef6d/image-20230815092840907.png" class="" title="image-20230815092840907"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当按钮被激活时(即，当鼠标光标在按钮内时按下然后释放)，当键入快捷键时，或者当click()或animateClick()被调用时，这个信号被发出。值得注意的是，如果调用setDown()、setChecked()或toggle()，则不会触发此信号。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::clicked</span><span class="params">(<span class="type">bool</span> checked = <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="comment">// 在按下按钮的时候发射这个信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::pressed</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 在释放这个按钮的时候发射直观信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::released</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 每当可检查按钮改变其状态时，就会发出此信号。checked在选中按钮时为true，在未选中按钮时为false。</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::toggled</span><span class="params">(<span class="type">bool</span> checked)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>槽函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行一个动画点击:按钮被立即按下，并在毫秒后释放(默认是100毫秒)。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::animateClick</span><span class="params">(<span class="type">int</span> msec = <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="comment">// 执行一次按钮点击, 相当于使用鼠标点击了按钮</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::click</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参考 1.2 中的函数介绍</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::setChecked</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"><span class="comment">// 设置按钮上图标大小</span></span><br><span class="line">[slot]<span class="function"><span class="type">void</span> <span class="title">setIconSize</span><span class="params">(<span class="type">const</span> QSize &amp;size)</span></span>;<span class="comment">//15/15</span></span><br><span class="line"><span class="comment">// 切换可检查按钮的状态。 checked &lt;==&gt; unchecked</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::toggle</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-QPushButton"><a href="#2-QPushButton" class="headerlink" title="2.QPushButton"></a>2.QPushButton</h3><img src="/post/2095ef6d/image-20230815101543434.png" class="" title="image-20230815101543434"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">    - icon: 按钮上显示的图标</span></span><br><span class="line"><span class="comment">    - text: 按钮上显示的标题</span></span><br><span class="line"><span class="comment">    - parent: 按钮的父对象, 可以不指定,默认是不指定的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QPushButton::<span class="built_in">QPushButton</span>(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;text, QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">QPushButton::<span class="built_in">QPushButton</span>(<span class="type">const</span> QString &amp;text, QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">QPushButton::<span class="built_in">QPushButton</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断按钮是不是默认按钮</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDefault</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 一般在对话框窗口中使用, 将按钮设置为默认按钮, 自动关联 Enter 键 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setDefault</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将弹出菜单菜单与此按钮关联起来。这将把按钮变成一个菜单按钮，</span></span><br><span class="line"><span class="comment">在某些样式中会在按钮文本的右边产生一个小三角形。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPushButton::setMenu</span><span class="params">(QMenu *menu)</span></span>;</span><br><span class="line"><span class="comment">////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">显示(弹出)相关的弹出菜单。如果没有这样的菜单，这个函数什么也不做。</span></span><br><span class="line"><span class="comment">这个函数直到弹出菜单被用户关闭后才返回。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QPushButton::showMenu</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,btn1,&amp;QPushButton::showMenu);</span><br><span class="line">实现点击别的按钮，实现由带小三角的按钮，打开她的菜单。</span><br><span class="line">    前提是这个按钮得setmenu</span><br><span class="line">    槽函数其实就是行为函数，可以单独使用，也可以连接信号使用</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMenu *menu=<span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="function">QAction <span class="title">action</span><span class="params">(<span class="string">&quot;铸币&quot;</span>,<span class="keyword">this</span>)</span></span>;</span><br><span class="line">   QAction* act1  = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">   QAction* act2 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">   QAction* act3  = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">   menu-&gt;<span class="built_in">addAction</span>(act1);</span><br><span class="line">   menu-&gt;<span class="built_in">addAction</span>(act2);</span><br><span class="line">   menu-&gt;<span class="built_in">addAction</span>(act3);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">connect</span>(act3,&amp;QAction::triggered ,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">     QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>,<span class="string">&quot;提示&quot;</span>,<span class="string">&quot;你选择了铸币&quot;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="comment">//把菜单给关联起来</span></span><br><span class="line">btn1-&gt;<span class="built_in">setMenu</span>(menu);</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230815105246763.png" class="" title="image-20230815105246763"><blockquote><ol><li>普通按钮</li><li>带菜单的按钮</li><li>可以设置选中的按钮</li></ol></blockquote><p>注意:</p><blockquote><p>[signal] void QAbstractButton::toggled(bool checked)</p><p>该信号的参数checked表示QAction的状态是否被切换为选中状态。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;checkedBtn, &amp;QPushButton::toggled, <span class="keyword">this</span>, [=](<span class="type">bool</span> bl)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;我是一个checked按钮, 当前状态为:&quot;</span> &lt;&lt; bl;</span><br><span class="line">     &#125;);意思是匿名函数可以捕获信号函数的参数。</span><br></pre></td></tr></table></figure></blockquote><h3 id="3Qtoolbutton"><a href="#3Qtoolbutton" class="headerlink" title="3Qtoolbutton"></a>3Qtoolbutton</h3><img src="/post/2095ef6d/image-20230815140257037.png" class="" title="image-20230815140257037"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///////////////////////////// 构造函数 /////////////////////////////</span></span><br><span class="line">QToolButton::<span class="built_in">QToolButton</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////// 公共成员函数 ///////////////////////////</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 将给定的菜单与此工具按钮相关联。</span></span><br><span class="line"><span class="comment">    2. 菜单将根据按钮的弹出模式显示。</span></span><br><span class="line"><span class="comment">    3. 菜单的所有权没有转移到“工具”按钮(不能建立父子关系)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QToolButton::setMenu</span><span class="params">(QMenu *menu)</span></span>;</span><br><span class="line"><span class="comment">// 返回关联的菜单，如果没有定义菜单，则返回nullptr。</span></span><br><span class="line"><span class="function">QMenu *<span class="title">QToolButton::menu</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">弹出菜单的弹出模式是一个枚举类型: QToolButton::ToolButtonPopupMode, 取值如下:</span></span><br><span class="line"><span class="comment">    - QToolButton::DelayedPopup: </span></span><br><span class="line"><span class="comment">        - 延时弹出, 按压工具按钮一段时间后才能弹出, 比如:浏览器的返回按钮</span></span><br><span class="line"><span class="comment">        - 长按按钮菜单弹出, 但是按钮的 clicked 信号不会被发射</span></span><br><span class="line"><span class="comment">    - QToolButton::MenuButtonPopup: </span></span><br><span class="line"><span class="comment">        - 在这种模式下，工具按钮会显示一个特殊的箭头，表示有菜单。</span></span><br><span class="line"><span class="comment">- 当按下按钮的箭头部分时，将显示菜单。按下按钮部分发射 clicked 信号</span></span><br><span class="line"><span class="comment">    - QToolButton::InstantPopup: </span></span><br><span class="line"><span class="comment">        - 当按下工具按钮时，菜单立即显示出来。</span></span><br><span class="line"><span class="comment">        - 在这种模式下，按钮本身的动作不会被触发(不会发射clicked信号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 设置弹出菜单的弹出方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setPopupMode</span><span class="params">(QToolButton::ToolButtonPopupMode mode)</span></span>;</span><br><span class="line"><span class="comment">// 获取弹出菜单的弹出方式</span></span><br><span class="line"><span class="function">QToolButton::ToolButtonPopupMode <span class="title">popupMode</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">QToolButton可以帮助我们在按钮上绘制箭头图标, 是一个枚举类型, 取值如下: </span></span><br><span class="line"><span class="comment">    - Qt::NoArrow: 没有箭头</span></span><br><span class="line"><span class="comment">    - Qt::UpArrow: 箭头向上</span></span><br><span class="line"><span class="comment">    - Qt::DownArrow: 箭头向下</span></span><br><span class="line"><span class="comment">    - Qt::LeftArrow: 箭头向左</span></span><br><span class="line"><span class="comment">    - Qt::RightArrow: 箭头向右</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 显示一个箭头作为QToolButton的图标。默认情况下，这个属性被设置为Qt::NoArrow。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setArrowType</span><span class="params">(Qt::ArrowType type)</span></span>;</span><br><span class="line"><span class="comment">// 获取工具按钮上显示的箭头图标样式</span></span><br><span class="line"><span class="function">Qt::ArrowType <span class="title">arrowType</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////// 槽函数 /////////////////////////////</span></span><br><span class="line"><span class="comment">// 给按钮关联一个QAction对象, 主要目的是美化按钮</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QToolButton::setDefaultAction</span><span class="params">(QAction *action)</span></span>;</span><br><span class="line"><span class="comment">// 返回给按钮设置的QAction对象</span></span><br><span class="line"><span class="function">QAction *<span class="title">QToolButton::defaultAction</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">图标的显示样式是一个枚举类型-&gt;Qt::ToolButtonStyle, 取值如下:</span></span><br><span class="line"><span class="comment">    - Qt::ToolButtonIconOnly: 只有图标, 不显示文本信息</span></span><br><span class="line"><span class="comment">    - Qt::ToolButtonTextOnly: 不显示图标, 只显示文本信息</span></span><br><span class="line"><span class="comment">    - Qt::ToolButtonTextBesideIcon: 文本信息在图标的后边显示</span></span><br><span class="line"><span class="comment">    - Qt::ToolButtonTextUnderIcon: 文本信息在图标的下边显示</span></span><br><span class="line"><span class="comment">    - Qt::ToolButtonFollowStyle: 跟随默认样式(只显示图标)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 设置的这个属性决定工具按钮是只显示一个图标、只显示文本，还是在图标旁边/下面显示文本。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QToolButton::setToolButtonStyle</span><span class="params">(Qt::ToolButtonStyle style)</span></span>;</span><br><span class="line"><span class="comment">// 返回工具按钮设置的图标显示模式</span></span><br><span class="line"><span class="function">Qt::ToolButtonStyle <span class="title">toolButtonStyle</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示相关的弹出菜单。如果没有这样的菜单，这个函数将什么也不做。这个函数直到弹出菜单被用户关闭才会返回。</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QToolButton::showMenu</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QToolButton *tbtn=<span class="keyword">new</span> <span class="built_in">QToolButton</span>(<span class="keyword">this</span>);</span><br><span class="line">    QToolButton *tbtn1=<span class="keyword">new</span> <span class="built_in">QToolButton</span>(<span class="keyword">this</span>);</span><br><span class="line">    tbtn-&gt;<span class="built_in">show</span>();</span><br><span class="line">     tbtn1-&gt;<span class="built_in">show</span>();</span><br><span class="line">     tbtn1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;toolbtn普通&quot;</span>);</span><br><span class="line">     QToolButton *tbtn2=<span class="keyword">new</span> <span class="built_in">QToolButton</span>(<span class="keyword">this</span>);</span><br><span class="line">     tbtn2-&gt;<span class="built_in">show</span>();</span><br><span class="line">     tbtn2-&gt;<span class="built_in">setText</span>(<span class="string">&quot;check&quot;</span>);</span><br><span class="line">     tbtn2-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line">     tbtn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     tbtn1-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    tbtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;toolbtn&quot;</span>);</span><br><span class="line">    tbtn-&gt;<span class="built_in">setPopupMode</span>(QToolButton::InstantPopup);</span><br><span class="line"></span><br><span class="line">    QMenu *menu=<span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="keyword">this</span>);</span><br><span class="line">    QAction *act1=<span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;牛&quot;</span>);</span><br><span class="line">    QAction *act2=<span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;比&quot;</span>);</span><br><span class="line">    QAction *act3=<span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;奶&quot;</span>);</span><br><span class="line">    QAction *act4=<span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;嘴&quot;</span>);</span><br><span class="line">    QAction *act5=<span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;嘴sdasdasd&quot;</span>);</span><br><span class="line"><span class="comment">//tbtn-&gt;setArrowType(Qt::RightArrow);</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;tbtn-&gt;<span class="built_in">popupMode</span>();</span><br><span class="line">    tbtn-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;D:/icon/img.png&quot;</span>));</span><br><span class="line">    menu-&gt;<span class="built_in">addAction</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;D:/icon/img.png&quot;</span>),<span class="string">&quot;牛逼&quot;</span>);</span><br><span class="line">    menu-&gt;<span class="built_in">addAction</span>(act2);</span><br><span class="line">    menu-&gt;<span class="built_in">addAction</span>(act3);</span><br><span class="line">    menu-&gt;<span class="built_in">addAction</span>(act4);</span><br><span class="line">    menu-&gt;<span class="built_in">setDefaultAction</span>(act3);</span><br><span class="line"></span><br><span class="line">    tbtn-&gt;<span class="built_in">setMenu</span>(menu);</span><br><span class="line">    <span class="comment">//设置是菜单里某个加粗，相当于默认选择</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置的是toolbutton按钮上的字体</span></span><br><span class="line"><span class="comment">//    connect(ui-&gt;pushButton,&amp;QPushButton::clicked,std::bind(&amp;QToolButton::setDefaultAction,tbtn,(act1)));</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton,&amp;QPushButton::clicked,std::<span class="built_in">bind</span>(&amp;QToolButton::setToolButtonStyle,tbtn,(Qt::ToolButtonTextBesideIcon)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230815151439198.png" class="" title="image-20230815151439198"><h3 id="4Qradiobutton"><a href="#4Qradiobutton" class="headerlink" title="4Qradiobutton"></a>4Qradiobutton</h3><img src="/post/2095ef6d/image-20230815153818178.png" class="" title="image-20230815153818178"><img src="/post/2095ef6d/image-20230815153919464.png" class="" title="image-20230815153919464"><img src="/post/2095ef6d/image-20230815154156522.png" class="" title="image-20230815154156522"><img src="/post/2095ef6d/image-20230815154634875.png" class="" title="image-20230815154634875"><p><strong>分组后，互相不打扰不干涉</strong></p><img src="/post/2095ef6d/image-20230815154725203.png" class="" title="image-20230815154725203"><p>测试是否发出clicked信号</p><img src="/post/2095ef6d/image-20230815154751505.png" class="" title="image-20230815154751505"><h3 id="5Qcheckbox"><a href="#5Qcheckbox" class="headerlink" title="5Qcheckbox"></a>5Qcheckbox</h3><img src="/post/2095ef6d/image-20230815154936709.png" class="" title="image-20230815154936709"><p>常用的API函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">    - text: 按钮上显示的文本信息</span></span><br><span class="line"><span class="comment">    - parent: 按钮的父对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QCheckBox::<span class="built_in">QCheckBox</span>(<span class="type">const</span> QString &amp;text, QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">QCheckBox::<span class="built_in">QCheckBox</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前复选框是否为三态复选框, 默认情况下为两种状态: 未选中, 选中</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isTristate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">tri state</span><br><span class="line"><span class="comment">// 设置当前复选框为三态复选框: 未选中, 选中, 半选中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTristate</span><span class="params">(<span class="type">bool</span> y = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数 state, 枚举类型 Qt::CheckState:</span></span><br><span class="line"><span class="comment">    - Qt::Unchecked      --&gt; 当前复选框没有被选中</span></span><br><span class="line"><span class="comment">    - Qt::PartiallyChecked    --&gt; 当前复选框处于半选中状态, 部分被选中(三态复选框)</span></span><br><span class="line"><span class="comment">    - Qt::Checked      --&gt; 当前复选框处于选中状态</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 设置复选框按钮的状态</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QCheckBox::setCheckState</span><span class="params">(Qt::CheckState state)</span></span>;</span><br><span class="line"><span class="comment">// 获取当前复选框的状态</span></span><br><span class="line"><span class="function">Qt::CheckState <span class="title">QCheckBox::checkState</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>信号signal</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当复选框的状态改变时，即当用户选中或取消选中复选框时，他的信号就会发出。</span></span><br><span class="line"><span class="comment">// 参数 state 表示的是复选框的三种状态中某一种, 可参考 Qt::CheckState</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QCheckBox::stateChanged</span><span class="params">(<span class="type">int</span> state)</span></span>;</span><br><span class="line">利用槽函数去捕捉这个参数</span><br><span class="line">    执行对应的操作</span><br><span class="line">    是一个枚举值，对应着不同的状态！</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QCheckBox  *cb1=<span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;性感&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    QCheckBox  *cb2=<span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;性感1&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    QCheckBox  *cb3=<span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;性感2&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    cb1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cb2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cb3-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cb2-&gt;<span class="built_in">move</span>(<span class="number">0</span>,<span class="number">40</span>);</span><br><span class="line">    cb3-&gt;<span class="built_in">move</span>(<span class="number">0</span>,<span class="number">80</span>);</span><br><span class="line">    cb3-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;D:/icon/img.png&quot;</span>));</span><br><span class="line">    <span class="comment">//开启三选功能</span></span><br><span class="line">    cb3-&gt;<span class="built_in">setTristate</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//是否开启了三选功能</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;cb3-&gt;<span class="built_in">isTristate</span>();</span><br><span class="line">    <span class="comment">//设置默认的选择状态</span></span><br><span class="line">    cb3-&gt;<span class="built_in">setCheckState</span>(Qt::Unchecked);</span><br><span class="line"><span class="comment">//信号</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;cb3-&gt;<span class="built_in">checkState</span>();</span><br><span class="line">    <span class="built_in">connect</span>(cb3,&amp;QCheckBox::stateChanged,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;复选框的状态发生了改变！&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现完美的多选功能</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="built_in">connect</span>(ui-&gt;checkBox_5,&amp;QCheckBox::stateChanged,<span class="keyword">this</span>,&amp;MainWindow::statenum);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;checkBox_6,&amp;QCheckBox::stateChanged,<span class="keyword">this</span>,&amp;MainWindow::statenum);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;checkBox_7,&amp;QCheckBox::stateChanged,<span class="keyword">this</span>,&amp;MainWindow::statenum);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;checkBox_8,&amp;QCheckBox::stateChanged,<span class="keyword">this</span>,&amp;MainWindow::statenum);</span><br><span class="line"><span class="comment">//自定义个槽函数，当子选项的状态修改的时候，就利用我们自己的槽函数记录一下操作数,4个子选项</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;checkBox_9,&amp;QCheckBox::stateChanged,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ui-&gt;checkBox_9-&gt;<span class="built_in">checkState</span>()==Qt::Checked)</span><br><span class="line">        &#123;</span><br><span class="line">            ui-&gt;checkBox_5-&gt;<span class="built_in">setCheckState</span>(Qt::Checked);</span><br><span class="line">            ui-&gt;checkBox_6-&gt;<span class="built_in">setCheckState</span>(Qt::Checked);</span><br><span class="line">            ui-&gt;checkBox_7-&gt;<span class="built_in">setCheckState</span>(Qt::Checked);</span><br><span class="line">            ui-&gt;checkBox_8-&gt;<span class="built_in">setCheckState</span>(Qt::Checked);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ui-&gt;checkBox_9-&gt;<span class="built_in">checkState</span>()==Qt::Unchecked)</span><br><span class="line">        &#123;</span><br><span class="line">            ui-&gt;checkBox_5-&gt;<span class="built_in">setCheckState</span>(Qt::Unchecked);</span><br><span class="line">            ui-&gt;checkBox_6-&gt;<span class="built_in">setCheckState</span>(Qt::Unchecked);</span><br><span class="line">            ui-&gt;checkBox_7-&gt;<span class="built_in">setCheckState</span>(Qt::Unchecked);</span><br><span class="line">            ui-&gt;checkBox_8-&gt;<span class="built_in">setCheckState</span>(Qt::Unchecked);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//实现父选项对子选项的控制</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MainWindow::statenum</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==Qt::Checked)</span><br><span class="line">    &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s==Qt::Unchecked)</span><br><span class="line">    &#123;</span><br><span class="line">        num--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;checkBox_9-&gt;<span class="built_in">setCheckState</span>(Qt::Checked);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;checkBox_9-&gt;<span class="built_in">setCheckState</span>(Qt::Unchecked);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ui-&gt;checkBox_9-&gt;<span class="built_in">setCheckState</span>(Qt::PartiallyChecked);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自己的槽函数，记录一个数，执行对应的操作！！！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230815175052198.png" class="" title="image-20230815175052198"><p>完美实现！</p><h2 id="qt中容器类型的控件"><a href="#qt中容器类型的控件" class="headerlink" title="qt中容器类型的控件"></a>qt中容器类型的控件</h2><img src="/post/2095ef6d/image-20230816102149246.png" class="" title="image-20230816102149246"><h3 id="Qwidget"><a href="#Qwidget" class="headerlink" title="Qwidget"></a>Qwidget</h3><img src="/post/2095ef6d/image-20230816101851752.png" class="" title="image-20230816101851752"><img src="/post/2095ef6d/image-20230816102059469.png" class="" title="image-20230816102059469"><img src="/post/2095ef6d/image-20230816102113462.png" class="" title="image-20230816102113462"><h3 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h3><img src="/post/2095ef6d/image-20230816102258664.png" class="" title="image-20230816102258664"><p>常用api</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">边框形状为布尔类型, 可选项为:</span></span><br><span class="line"><span class="comment">    - QFrame::NoFrame: 没有边框</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    - QFrame::Box: 绘制一个框</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    - QFrame::Panel: 绘制一个面板，使内容显示为凸起或凹陷</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    - QFrame::StyledPanel: 绘制一个外观取决于当前GUI样式的矩形面板。它可以上升也可以下沉。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    - QFrame::HLine: 画一条没有边框的水平线(用作分隔符)</span></span><br><span class="line"><span class="comment">    - QFrame::VLine: 画一条没有边框的垂直线(用作分隔符)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    - QFrame::WinPanel: 绘制一个矩形面板，可以像Windows 2000那样向上或向下移动。</span></span><br><span class="line"><span class="comment">                指定此形状将线宽设置为2像素。WinPanel是为了兼容而提供的。</span></span><br><span class="line"><span class="comment">                对于GUI风格的独立性，我们建议使用StyledPanel代替。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 获取边框形状</span></span><br><span class="line"><span class="function">Shape <span class="title">frameShape</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置边框形状</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setFrameShape</span><span class="params">(Shape)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Qt中关于边框的阴影(QFrame::Shadow)提供了3种样式, 分别为: </span></span><br><span class="line"><span class="comment">    - QFrame::Plain: 简单的,朴素的, 框架和内容与周围环境显得水平;</span></span><br><span class="line"><span class="comment">             使用调色板绘制QPalette::WindowText颜色(没有任何3D效果)</span></span><br><span class="line"><span class="comment">    - QFrame::Raised: 框架和内容出现凸起;使用当前颜色组的明暗颜色绘制3D凸起线</span></span><br><span class="line"><span class="comment">    - QFrame::Sunken: 框架及内容物凹陷;使用当前颜色组的明暗颜色绘制3D凹线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取边框阴影样式</span></span><br><span class="line"><span class="function">Shadow <span class="title">frameShadow</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置边框阴影样式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setFrameShadow</span><span class="params">(Shadow)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到边框线宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lineWidth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置边框线宽度, 默认值为1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setLineWidth</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到中线的宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">midLineWidth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置中线宽度, 默认值为0, 这条线会影响边框阴影的显示</span></span><br><span class="line">设置边框线的宽度。中线的宽度大了，那么边框也就变厚了！</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMidLineWidth</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;ui-&gt;frame-&gt;<span class="built_in">frameShape</span>();</span><br><span class="line">    ui-&gt;frame-&gt;<span class="built_in">setFrameShape</span>(QFrame::Box);</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;ui-&gt;frame-&gt;<span class="built_in">frameShape</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;ui-&gt;frame-&gt;<span class="built_in">frameShadow</span>();</span><br><span class="line">        ui-&gt;frame-&gt;<span class="built_in">setFrameShadow</span>(QFrame::Raised);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;ui-&gt;frame-&gt;<span class="built_in">frameWidth</span>();</span><br><span class="line">        <span class="comment">///////是setlinwidth不是setframwidth</span></span><br><span class="line"><span class="comment">//    ui-&gt;frame-&gt;setLineWidth(10);</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;ui-&gt;frame-&gt;<span class="built_in">midLineWidth</span>();</span><br><span class="line">    ui-&gt;frame-&gt;<span class="built_in">setMidLineWidth</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230816103505118.png" class="" title="image-20230816103505118"><img src="/post/2095ef6d/image-20230816103629504.png" class="" title="image-20230816103629504"><img src="/post/2095ef6d/image-20230816103636361.png" class="" title="image-20230816103636361"><h3 id="Groupbox不常用"><a href="#Groupbox不常用" class="headerlink" title="Groupbox不常用"></a>Groupbox不常用</h3><img src="/post/2095ef6d/image-20230816103720552.png" class="" title="image-20230816103720552"><img src="/post/2095ef6d/image-20230816103730019.png" class="" title="image-20230816103730019"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QGroupBox::<span class="built_in">QGroupBox</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line">第二种食用</span><br><span class="line">QGroupBox::<span class="built_in">QGroupBox</span>(<span class="type">const</span> QString &amp;title, QWidget *parent = Q_NULLPTR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QGroupBox::isCheckable</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置是否在组框中显示一个复选框</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGroupBox::setCheckable</span><span class="params">(<span class="type">bool</span> checkable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于对齐方式需要使用枚举类型 Qt::Alignment, 其可选项为:</span></span><br><span class="line"><span class="comment">    - Qt::AlignLeft: 左对齐(水平方向)</span></span><br><span class="line"><span class="comment">    - Qt::AlignRight: 右对齐(水平方向)</span></span><br><span class="line"><span class="comment">    - Qt::AlignHCenter: 水平居中</span></span><br><span class="line"><span class="comment">    - Qt::AlignJustify: 在可用的空间内调整文本(水平方向)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    - Qt::AlignTop: 上对齐(垂直方向)</span></span><br><span class="line"><span class="comment">    - Qt::AlignBottom: 下对齐(垂直方向)</span></span><br><span class="line"><span class="comment">    - Qt::AlignVCenter: 垂直居中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Qt::Alignment <span class="title">QGroupBox::alignment</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置组框标题的对其方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGroupBox::setAlignment</span><span class="params">(<span class="type">int</span> alignment)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">QGroupBox::title</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置组框的标题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QGroupBox::setTitle</span><span class="params">(<span class="type">const</span> QString &amp;title)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QGroupBox::isChecked</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置组框中复选框的选中状态</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QGroupBox::setChecked</span><span class="params">(<span class="type">bool</span> checked)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QGroupBox*box=<span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="string">&quot;我是牛马&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">box-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">box-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;box-&gt;<span class="built_in">isCheckable</span>();</span><br><span class="line">box-&gt;<span class="built_in">setChecked</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;box-&gt;<span class="built_in">isChecked</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;box-&gt;<span class="built_in">title</span>();</span><br><span class="line"></span><br><span class="line">box-&gt;<span class="built_in">setAlignment</span>(Qt::AlignVCenter);</span><br><span class="line">肥肠简单奥</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230816105613333.png" class="" title="image-20230816105613333"><blockquote><p>flat间接的，平原</p><p>只能在属性窗口中设置，设置后组件的边框就没有了</p></blockquote><img src="/post/2095ef6d/image-20230816110011195.png" class="" title="image-20230816110011195"><h3 id="Scroll-Area"><a href="#Scroll-Area" class="headerlink" title="Scroll Area"></a>Scroll Area</h3><p>scroll滚筒，画卷</p><img src="/post/2095ef6d/image-20230816110150076.png" class="" title="image-20230816110150076"><img src="/post/2095ef6d/image-20230816110245793.png" class="" title="image-20230816110245793"><img src="/post/2095ef6d/image-20230816110321930.png" class="" title="image-20230816110321930"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QScrollArea::<span class="built_in">QScrollArea</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 给滚动区域设置要显示的子窗口widget</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QScrollArea::setWidget</span><span class="params">(QWidget *widget)</span></span>;</span><br><span class="line"><span class="comment">// 删除滚动区域中的子窗口, 并返回被删除的子窗口对象</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QScrollArea::takeWidget</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于显示位置的设定, 是一个枚举类型, 可选项为:</span></span><br><span class="line"><span class="comment">    - Qt::AlignLeft: 左对齐</span></span><br><span class="line"><span class="comment">    - Qt::AlignHCenter: 水平居中</span></span><br><span class="line"><span class="comment">    - Qt::AlignRight: 右对齐</span></span><br><span class="line"><span class="comment">    - Qt::AlignTop: 顶部对齐</span></span><br><span class="line"><span class="comment">    - Qt::AlignVCenter: 垂直对其</span></span><br><span class="line"><span class="comment">    - Qt::AlignBottom: 底部对其</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 获取子窗口在滚动区域中的显示位置</span></span><br><span class="line"><span class="function">Qt::Alignment <span class="title">alignment</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置滚动区域中子窗口的对其方式, 默认显示的位置是右上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAlignment</span><span class="params">(Qt::Alignment)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断滚动区域是否有自动调节小部件大小的属性</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">widgetResizable</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 设置滚动区域是否应该调整视图小部件的大小, 该属性默认为false, 滚动区域按照小部件的默认大小进行显示。</span></span><br><span class="line"><span class="comment">2. 如果该属性设置为true，滚动区域将自动调整小部件的大小，避免滚动条出现在本可以避免的地方，</span></span><br><span class="line"><span class="comment">   或者利用额外的空间。</span></span><br><span class="line"><span class="comment">3. 不管这个属性是什么，我们都可以使用widget()-&gt;resize()以编程方式调整小部件的大小，</span></span><br><span class="line"><span class="comment">   滚动区域将自动调整自己以适应新的大小。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWidgetResizable</span><span class="params">(<span class="type">bool</span> resizable)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QScrollArea *area=<span class="keyword">new</span> <span class="built_in">QScrollArea</span>(<span class="keyword">this</span>);</span><br><span class="line">    area-&gt;<span class="built_in">setFixedHeight</span>(<span class="number">200</span>);</span><br><span class="line">    ui-&gt;groupBox-&gt;<span class="built_in">setFixedSize</span>(<span class="number">1000</span>,<span class="number">1000</span>);</span><br><span class="line">    area-&gt;<span class="built_in">setWidget</span>(ui-&gt;groupBox);</span><br><span class="line"><span class="comment">//    QWidget *a=area-&gt;takeWidget();</span></span><br><span class="line"><span class="comment">//    a-&gt;setFixedSize(100,100);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    qDebug()&lt;&lt;area-&gt;takeWidget();</span></span><br><span class="line">    area-&gt;<span class="built_in">setWidgetResizable</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230816125045128.png" class="" title="image-20230816125045128"><img src="/post/2095ef6d/image-20230816140215909.png" class="" title="image-20230816140215909"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个垂直布局对象</span></span><br><span class="line">    QVBoxLayout* vlayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">11</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建标签对象</span></span><br><span class="line">        QLabel* pic = <span class="keyword">new</span> QLabel;</span><br><span class="line">        <span class="comment">// 拼接图片在资源文件中的路径</span></span><br><span class="line">        QString name = <span class="built_in">QString</span>(<span class="string">&quot;:/images/%1.png&quot;</span>).<span class="built_in">arg</span>(i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 给标签对象设置显示的图片</span></span><br><span class="line">        pic-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(name));</span><br><span class="line">        <span class="comment">// 设置图片在便签内部的对其方式</span></span><br><span class="line">        pic-&gt;<span class="built_in">setAlignment</span>(Qt::AlignHCenter);</span><br><span class="line">        <span class="comment">// 将标签添加到垂直布局中</span></span><br><span class="line">        vlayout-&gt;<span class="built_in">addWidget</span>(pic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个窗口对象</span></span><br><span class="line">    QWidget* wg = <span class="keyword">new</span> QWidget;</span><br><span class="line">    <span class="comment">// 将垂直布局设置给窗口对象</span></span><br><span class="line">    wg-&gt;<span class="built_in">setLayout</span>(vlayout);</span><br><span class="line">    <span class="comment">// 将带有垂直布局的窗口设置到滚动区域中</span></span><br><span class="line">    ui-&gt;scrollArea-&gt;<span class="built_in">setWidget</span>(wg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230816140310271.png" class="" title="image-20230816140310271"><h3 id="Toolbox（item）"><a href="#Toolbox（item）" class="headerlink" title="Toolbox（item）"></a>Toolbox（item）</h3><img src="/post/2095ef6d/image-20230816221109227.png" class="" title="image-20230816221109227"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QToolBox::<span class="built_in">QToolBox</span>(QWidget *parent = Q_NULLPTR, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">addItem(), insertItem()函数相关参数:</span></span><br><span class="line"><span class="comment">    - widget: 添加到工具箱中的选项卡对应的子窗口对象</span></span><br><span class="line"><span class="comment">    - icon: 工具箱新的选项卡上显示的图标</span></span><br><span class="line"><span class="comment">    - text: 工具箱新的选项卡上显示的标题</span></span><br><span class="line"><span class="comment">    - index: 指定在工具箱中插入的新的选项卡的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 给工具箱尾部添加一个选项卡, 每个选项卡在工具箱中就是一个子窗口, 即参数widget</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::addItem</span><span class="params">(QWidget *widget, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::addItem</span><span class="params">(QWidget *widget, <span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="comment">// 在工具箱的指定位置添加一个选项卡, 即添加一个子窗口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::insertItem</span><span class="params">(<span class="type">int</span> index, QWidget *widget, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::insertItem</span><span class="params">(<span class="type">int</span> index, QWidget *widget, <span class="type">const</span> QIcon &amp;icon, </span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> QString &amp;text )</span></span>;</span><br><span class="line"><span class="comment">// 移除工具箱中索引index位置对应的选项卡, 注意: 只是移除对应的窗口对象并没有被销毁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QToolBox::removeItem</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置索引index位置的选项卡是否可用, 参数 enabled=true为可用, enabled=false为禁用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QToolBox::setItemEnabled</span><span class="params">(<span class="type">int</span> index, <span class="type">bool</span> enabled)</span></span>;</span><br><span class="line"><span class="comment">// 设置工具箱中index位置选项卡的图标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QToolBox::setItemIcon</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"><span class="comment">// 设置工具箱中index位置选项卡的标题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QToolBox::setItemText</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置工具箱中index位置选项卡的提示信息(需要鼠标在选项卡上悬停一定时长才能显示)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QToolBox::setItemToolTip</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> QString &amp;toolTip)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果位置索引的项已启用，则返回true;否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QToolBox::isItemEnabled</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回位置索引处项目的图标，如果索引超出范围，则返回空图标。</span></span><br><span class="line"><span class="function">QIcon <span class="title">QToolBox::itemIcon</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回位于位置索引处的项的文本，如果索引超出范围，则返回空字符串。</span></span><br><span class="line"><span class="function">QString <span class="title">QToolBox::itemText</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回位于位置索引处的项的工具提示，如果索引超出范围，则返回空字符串。</span></span><br><span class="line"><span class="function">QString <span class="title">QToolBox::itemToolTip</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到当前工具箱中显示的选项卡对应的索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::currentIndex</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回指向当前选项卡对应的子窗口的指针，如果没有这样的项，则返回0。</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QToolBox::currentWidget</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回工具箱中子窗口的索引，如果widget对象不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::indexOf</span><span class="params">(QWidget *widget)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回工具箱中包含的项的数量。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QToolBox::count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号</span></span><br><span class="line"><span class="comment">// 工具箱中当前显示的选项卡发生变化, 该信号被发射, index为当前显示的新的选项卡的对应的索引</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QToolBox::currentChanged</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 槽函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过工具箱中选项卡对应的索引设置当前要显示哪一个选项卡中的子窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QToolBox::setCurrentIndex</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过工具箱中选项卡对应的子窗口对象设置当前要显示哪一个选项卡中的子窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QToolBox::setCurrentWidget</span><span class="params">(QWidget *widget)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QToolBox *tb=<span class="keyword">new</span> <span class="built_in">QToolBox</span>(<span class="keyword">this</span>);</span><br><span class="line">    QWidget *w1=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    QHBoxLayout *bj=<span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>(<span class="keyword">this</span>);</span><br><span class="line">    QPushButton *btn1=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮1&quot;</span>);</span><br><span class="line">    QPushButton *btn2=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮2&quot;</span>);</span><br><span class="line">    QPushButton *btn3=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮3&quot;</span>);</span><br><span class="line">    bj-&gt;<span class="built_in">addWidget</span>(btn1);</span><br><span class="line">    bj-&gt;<span class="built_in">addWidget</span>(btn2);</span><br><span class="line">    bj-&gt;<span class="built_in">addWidget</span>(btn3);</span><br><span class="line">    w1-&gt;<span class="built_in">setLayout</span>(bj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QWidget *w2=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">    QWidget *w3=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">    QWidget *w4=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选项卡就是一个子窗口，通过布局设置自定义窗口</span></span><br><span class="line">    tb-&gt;<span class="built_in">addItem</span>(w1,<span class="string">&quot;选项卡1&quot;</span>);</span><br><span class="line">    tb-&gt;<span class="built_in">addItem</span>(w2,<span class="string">&quot;选项卡2&quot;</span>);</span><br><span class="line">    tb-&gt;<span class="built_in">addItem</span>(w3,<span class="string">&quot;选项卡3&quot;</span>);</span><br><span class="line">    <span class="comment">//插入在index的位置</span></span><br><span class="line">    tb-&gt;<span class="built_in">insertItem</span>(<span class="number">0</span>,w4,<span class="string">&quot;我是插入进来的&quot;</span>);</span><br><span class="line">    <span class="comment">//移除index位置的选项卡，但是并没有销毁这个选项卡。</span></span><br><span class="line">    tb-&gt;<span class="built_in">removeItem</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span> w1;</span><br><span class="line">    <span class="comment">//Qt 使用了自动内存管理机制，即对象树（object tree）机制。根据对象树机制，当一个对象作为另一个对象的子对象时，父对象负责管理子对象的生命周期。当父对象被销毁时，它会自动销毁其所有子对象。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在你的代码中，bj 布局的父对象对象是 w1 ，因此在 w1 被销毁时，bj 会负责销毁其中的按钮对象 btn1、btn2 和 btn3。这意味着你不需要手动删除这些按钮对象，它们会在适当的时候自动被销毁。</span></span><br><span class="line"></span><br><span class="line">    tb-&gt;<span class="built_in">setFixedSize</span>(<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全部都不能用了</span></span><br><span class="line"><span class="comment">//    tb-&gt;setEnabled(false);</span></span><br><span class="line">    <span class="comment">//限制具体的选项卡</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    tb-&gt;setItemEnabled(1,false);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    tb-&gt;setItemIcon();</span></span><br><span class="line"><span class="comment">//    tb-&gt;setItemText();</span></span><br><span class="line">    tb-&gt;<span class="built_in">setItemToolTip</span>(<span class="number">2</span>,<span class="string">&quot;我是牛马&quot;</span>);</span><br><span class="line">    tb-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//获取默认打开的选项卡的对象和下标</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;tb-&gt;<span class="built_in">currentWidget</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;tb-&gt;<span class="built_in">currentIndex</span>();</span><br><span class="line">    <span class="comment">//得到子窗口的下标</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;tb-&gt;<span class="built_in">indexOf</span>(w3);</span><br><span class="line">    <span class="comment">//得到现存的选项卡的数量</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;tb-&gt;<span class="built_in">count</span>();</span><br><span class="line"><span class="comment">//    QToolBox::currentChanged(int)</span></span><br><span class="line">    <span class="built_in">void</span> (QToolBox::*s)(<span class="type">int</span>)=&amp;QToolBox::currentChanged;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(tb,s,<span class="keyword">this</span>,[=](<span class="type">int</span> index)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;新年好&quot;</span>&lt;&lt;index;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Qt 使用了自动内存管理机制，即对象树（object tree）机制。根据对象树机制，当一个对象作为另一个对象的子对象时，父对象负责管理子对象的生命周期。当父对象被销毁时，它会自动销毁其所有子对象。</p><p>在你的代码中，<code>bj</code> 布局对象是 <code>w1</code> 的父对象，因此在 <code>w1</code> 被销毁时，<code>bj</code> 会负责销毁其中的按钮对象 <code>btn1</code>、<code>btn2</code> 和 <code>btn3</code>。这意味着你不需要手动删除这些按钮对象，它们会在适当的时候自动被销毁。</p><p>qtool属性设置</p><img src="/post/2095ef6d/image-20230817105510340.png" class="" title="image-20230817105510340"><h3 id="Tabwidget-tab"><a href="#Tabwidget-tab" class="headerlink" title="Tabwidget(tab)"></a>Tabwidget(tab)</h3><img src="/post/2095ef6d/image-20230817105534856.png" class="" title="image-20230817105534856"><img src="/post/2095ef6d/image-20230817105556763.png" class="" title="image-20230817105556763"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QTabWidget::<span class="built_in">QTabWidget</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">添加选项卡addTab()或者插入选项卡insertTab()函数相关的参数如下:</span></span><br><span class="line"><span class="comment">    - page: 添加或者插入的选项卡对应的窗口实例对象</span></span><br><span class="line"><span class="comment">    - label: 添加或者插入的选项卡的标题</span></span><br><span class="line"><span class="comment">    - icon: 添加或者插入的选项卡的图标</span></span><br><span class="line"><span class="comment">    - index: 将新的选项卡插入到索引index的位置上</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTabWidget::addTab</span><span class="params">(QWidget *page, <span class="type">const</span> QString &amp;label)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTabWidget::addTab</span><span class="params">(QWidget *page, <span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;label)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTabWidget::insertTab</span><span class="params">(<span class="type">int</span> index, QWidget *page, <span class="type">const</span> QString &amp;label)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTabWidget::insertTab</span><span class="params">(<span class="type">int</span> index, QWidget *page, </span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;label)</span></span>;</span><br><span class="line"><span class="comment">// 删除index位置的选项卡</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::removeTab</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到选项卡栏中的选项卡的数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 从窗口中移除所有页面，但不删除它们。调用这个函数相当于调用removeTab()，直到选项卡小部件为空为止。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取当前选项卡对应的索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTabWidget::currentIndex</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取当前选项卡对应的窗口对象地址</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QTabWidget::currentWidget</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回索引位置为index的选项卡页，如果索引超出范围则返回0。</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QTabWidget::widget</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">标签上显示的文本样式为枚举类型 Qt::TextElideMode, 可选项为:</span></span><br><span class="line"><span class="comment">    - Qt::ElideLeft: 省略号应出现在课文的开头，例如：.....是的,我很帅。</span></span><br><span class="line"><span class="comment">    - Qt::ElideRight: 省略号应出现在文本的末尾，例如：我帅吗.....。</span></span><br><span class="line"><span class="comment">    - Qt::ElideMiddle: 省略号应出现在文本的中间，例如：我帅.....很帅。</span></span><br><span class="line"><span class="comment">    - Qt::ElideNone: 省略号不应出现在文本中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 获取标签上显示的文本模式</span></span><br><span class="line"><span class="function">Qt::TextElideMode <span class="title">QTabWidget::elideMode</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 如何省略标签栏中的文本, 此属性控制在给定的选项卡栏大小没有足够的空间显示项时如何省略项。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setElideMode</span><span class="params">(Qt::TextElideMode)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 得到选项卡上图标的尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">QTabWidget::iconSize</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="comment">// 设置选项卡上显示的图标大小</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setIconSize</span><span class="params">(<span class="type">const</span> QSize &amp;size)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 判断用户是否可以在选项卡区域内移动选项卡, 可以返回true, 否则返回false</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTabWidget::isMovable</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 此属性用于设置用户是否可以在选项卡区域内移动选项卡。默认情况下，此属性为false;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setMovable</span><span class="params">(<span class="type">bool</span> movable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断选项卡是否可以自动隐藏, 如果可以自动隐藏返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTabWidget::tabBarAutoHide</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 如果为true，则当选项卡栏包含少于2个选项卡时，它将自动隐藏。默认情况下，此属性为false。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabBarAutoHide</span><span class="params">(<span class="type">bool</span> enabled)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断index对应的选项卡是否是被启用的, 如果是被启用的返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTabWidget::isTabEnabled</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 如果enable为true，则在索引位置的页面是启用的;否则，在位置索引处的页面将被禁用。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabEnabled</span><span class="params">(<span class="type">int</span> index, <span class="type">bool</span> enable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到index位置的标签对应的图标</span></span><br><span class="line"><span class="function">QIcon <span class="title">QTabWidget::tabIcon</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 在位置索引处设置标签的图标。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabIcon</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">选项卡标签的位置通过枚举值进行指定, 可使用的选项如下:</span></span><br><span class="line"><span class="comment">- QTabWidget::North: 北(上), 默认</span></span><br><span class="line"><span class="comment">- QTabWidget::South: 南(下)</span></span><br><span class="line"><span class="comment">- QTabWidget::West: 西(左)</span></span><br><span class="line"><span class="comment">- QTabWidget::East:  东(右)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 得到选项卡中显示的标签的位置, 即: 东, 西, 南, 北</span></span><br><span class="line"><span class="function">TabPosition <span class="title">QTabWidget::tabPosition</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置选项卡中标签显示的位置, 默认情况下，此属性设置为North。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabPosition</span><span class="params">(TabPosition)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">选项卡标签的形状通过枚举值进行指定, 可使用的选项如下:</span></span><br><span class="line"><span class="comment">- QTabWidget::Rounded: 标签以圆形的外观绘制。这是默认形状</span></span><br><span class="line"><span class="comment">- QTabWidget::Triangular: 选项卡以三角形外观绘制。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 获得选项卡标签的形状</span></span><br><span class="line"><span class="function">TabShape <span class="title">QTabWidget::tabShape</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置选项卡标签的形状</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabShape</span><span class="params">(TabShape s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到index位置的标签的标题</span></span><br><span class="line"><span class="function">QString <span class="title">QTabWidget::tabText</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置选项卡index位置的标签的标题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabText</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> QString &amp;label)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取index对应的标签页上设置的提示信息</span></span><br><span class="line"><span class="function">QString <span class="title">QTabWidget::tabToolTip</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置选项卡index位置的标签的提示信息(鼠标需要悬停在标签上一定时长才能显示)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabToolTip</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> QString &amp;tip)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断选项卡标签也上是否有关闭按钮, 如果有返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTabWidget::tabsClosable</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置选项卡的标签页上是否显示关闭按钮, 该属性默认情况下为false</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setTabsClosable</span><span class="params">(<span class="type">bool</span> closeable)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断选项卡栏中是否有滚动按钮, 如果有返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTabWidget::usesScrollButtons</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 设置选项卡栏有许多标签时，它是否应该使用按钮来滚动标签。</span></span><br><span class="line"><span class="comment">// 当一个选项卡栏有太多的标签时，选项卡栏可以选择扩大它的大小，或者添加按钮，让标签在选项卡栏中滚动。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setUsesScrollButtons</span><span class="params">(<span class="type">bool</span> useButtons)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断窗口是否设置了文档模式, 如果设置了返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTabWidget::documentMode</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 此属性保存选项卡小部件是否以适合文档页面的模式呈现。这与macOS上的文档模式相同。</span></span><br><span class="line"><span class="comment">// 不设置该属性, QTabWidget窗口是带边框的, 如果设置了该属性边框就没有了。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::setDocumentMode</span><span class="params">(<span class="type">bool</span> set)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QTabWidget *tw=<span class="keyword">new</span> <span class="built_in">QTabWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">    tw-&gt;<span class="built_in">setFixedSize</span>(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">    QHBoxLayout *bj=<span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    QPushButton *btn1=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮1&quot;</span>);</span><br><span class="line">     QPushButton *btn2=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮2&quot;</span>);</span><br><span class="line">      QPushButton *btn3=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮3&quot;</span>);</span><br><span class="line">     bj-&gt;<span class="built_in">addWidget</span>(btn1);</span><br><span class="line">     bj-&gt;<span class="built_in">addWidget</span>(btn2);</span><br><span class="line">     bj-&gt;<span class="built_in">addWidget</span>(btn3);</span><br><span class="line"></span><br><span class="line">     QWidget *w1=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">     QWidget *w2=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">     QWidget *w3=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">      QWidget *w4=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">      QWidget *w5=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">       QWidget *w6=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//     w3-&gt;setLayout(bj);</span></span><br><span class="line"><span class="comment">//     在你的代码中，你尝试将 bj 布局对象同时设置给了 w1 和 w3，这是不正确的。一个布局对象只能被设置给一个父部件，否则会导致布局对象的所有权问题。</span></span><br><span class="line">     w1-&gt;<span class="built_in">setLayout</span>(bj);</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">     tw-&gt;<span class="built_in">addTab</span>(w1,<span class="string">&quot;111&quot;</span>);</span><br><span class="line">     tw-&gt;<span class="built_in">addTab</span>(w2,<span class="string">&quot;222&quot;</span>);</span><br><span class="line">     tw-&gt;<span class="built_in">addTab</span>(w4,<span class="string">&quot;222&quot;</span>);</span><br><span class="line">     tw-&gt;<span class="built_in">addTab</span>(w5,<span class="string">&quot;222&quot;</span>);</span><br><span class="line">     tw-&gt;<span class="built_in">addTab</span>(w6,<span class="string">&quot;222&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     tw-&gt;<span class="built_in">insertTab</span>(<span class="number">1</span>,w3,<span class="string">&quot;333&quot;</span>);</span><br><span class="line">     <span class="comment">//插入到下标为index的位置</span></span><br><span class="line">     tw-&gt;<span class="built_in">removeTab</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//     delete w3;</span></span><br><span class="line"></span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">count</span>();</span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">currentIndex</span>();</span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">currentWidget</span>();</span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">elideMode</span>();</span><br><span class="line"><span class="comment">//设置当文本不适合的时候省略号出现的位置</span></span><br><span class="line">     tw-&gt;<span class="built_in">setElideMode</span>(Qt::ElideMiddle);</span><br><span class="line"><span class="comment">//     Qt::ElideLeft（值为0）表示省略号应该出现在文本的开头。</span></span><br><span class="line"><span class="comment">//     Qt::ElideRight（值为1）表示省略号应该出现在文本的末尾。</span></span><br><span class="line"><span class="comment">//     Qt::ElideMiddle（值为2）表示省略号应该出现在文本的中间。</span></span><br><span class="line"><span class="comment">//     Qt::ElideNone（值为3）表示省略号不应该出现在文本中。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">//设置具体的选项卡的icon</span></span><br><span class="line">     tw-&gt;<span class="built_in">setTabIcon</span>(<span class="number">0</span>,<span class="built_in">QIcon</span>(<span class="string">&quot;://D:/icon/hig.png&quot;</span>));</span><br><span class="line">     <span class="comment">//设置所有选项卡的icon的尺寸</span></span><br><span class="line">     tw-&gt;<span class="built_in">setIconSize</span>(<span class="built_in">QSize</span>(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="comment">//得到具体位置的icon的信息</span></span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">tabIcon</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">isMovable</span>();</span><br><span class="line">     <span class="comment">//是指选项卡的移动，不是整个tab移动</span></span><br><span class="line"></span><br><span class="line">     tw-&gt;<span class="built_in">setMovable</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">tabBarAutoHide</span>();</span><br><span class="line"><span class="comment">//     tw-&gt;setTabBarAutoHide(true);</span></span><br><span class="line">     <span class="comment">//选项卡只有一个的时候会隐藏掉上面的选项卡栏</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     tw-&gt;removeTab(1);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">isTabEnabled</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//设置具体选项卡的权限</span></span><br><span class="line">     tw-&gt;<span class="built_in">setTabEnabled</span>(<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">tabPosition</span>();</span><br><span class="line">     <span class="comment">//设置选项卡的方向，东南西北</span></span><br><span class="line">     tw-&gt;<span class="built_in">setTabPosition</span>(QTabWidget::East);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">tabShape</span>();</span><br><span class="line">     tw-&gt;<span class="built_in">setTabShape</span>(QTabWidget::Triangular);</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标悬浮在上面的时候tooltip</span></span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">tabToolTip</span>(<span class="number">0</span>);</span><br><span class="line">     tw-&gt;<span class="built_in">setTabToolTip</span>(<span class="number">0</span>,<span class="string">&quot;选项阿卡！@！#@##@#&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//给选项卡添加关闭按钮</span></span><br><span class="line">     tw-&gt;<span class="built_in">setTabsClosable</span>(<span class="literal">true</span>);</span><br><span class="line">          <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">tabsClosable</span>();</span><br><span class="line">     tw-&gt;<span class="built_in">setTabEnabled</span>(<span class="number">1</span>,<span class="literal">true</span>);</span><br><span class="line">\</span><br><span class="line">      <span class="comment">//设置</span></span><br><span class="line">     tw-&gt;<span class="built_in">setUsesScrollButtons</span>(<span class="literal">false</span>);</span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">usesScrollButtons</span>();</span><br><span class="line"></span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;tw-&gt;<span class="built_in">documentMode</span>();</span><br><span class="line">     <span class="comment">//设置了文档模式就没有了边框</span></span><br><span class="line">     tw-&gt;<span class="built_in">setDocumentMode</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     tw-&gt;<span class="built_in">setCurrentWidget</span>(w1);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">connect</span>(tw,&amp;QTabWidget::tabCloseRequested,<span class="keyword">this</span>,[=](<span class="type">int</span> index)&#123;</span><br><span class="line">         tw-&gt;<span class="built_in">removeTab</span>(index);</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">connect</span>(tw,&amp;QTabWidget::tabBarClicked,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">         <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;单击&quot;</span>;</span><br><span class="line"></span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="built_in">connect</span>(tw,&amp;QTabWidget::tabBarDoubleClicked,<span class="keyword">this</span>,[=](<span class="type">int</span> index)&#123;</span><br><span class="line">         <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;双击&quot;</span>;</span><br><span class="line">         tw-&gt;<span class="built_in">removeTab</span>(index);</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230817145000425.png" class="" title="image-20230817145000425"><img src="/post/2095ef6d/image-20230817143941679.png" class="" title="image-20230817143941679"><img src="/post/2095ef6d/image-20230817144054580.png" class="" title="image-20230817144054580"><h4 id="QQueue"><a href="#QQueue" class="headerlink" title="&#x3D;&#x3D;QQueue&#x3D;&#x3D;"></a>&#x3D;&#x3D;QQueue&#x3D;&#x3D;</h4><blockquote><p><code>QQueue</code> 是 Qt 提供的一个<strong>队列（queue）容器类</strong>，用于存储一系列的元素。它是一个<strong>先进先出（FIFO）的数据结构</strong>，类似于现实生活中的排队。在 <code>QQueue</code> 中，<strong>元素从队列的尾部添加，从队列的头部移除</strong>。</p><p><code>QQueue</code> 是一个模板类，<strong>可以存储任意类型的元素</strong>。在你的代码中，<code>QQueue&lt;QWidget*&gt;</code> 表示一个存储 <code>QWidget*</code> 类型指针的队列，即存储 <code>QWidget</code> 对象的指针。</p><p>以下是一些常用的 <code>QQueue</code> 函数：</p><ul><li><code>enqueue(const T &amp;value)</code>：<strong>将元素添加到队列的尾部。</strong></li><li><code>dequeue()</code>：<strong>移除并返回队列头部的元素。</strong></li><li><code>head()</code>：<strong>返回队列头部的元素，但不会移除它。</strong></li><li><code>isEmpty()</code>：<strong>检查队列是否为空。</strong></li><li><code>size()</code>：<strong>返回队列中元素的数量。</strong></li></ul></blockquote><h3 id="Stacked-widget（addwidget）"><a href="#Stacked-widget（addwidget）" class="headerlink" title="Stacked widget（addwidget）"></a>Stacked widget（addwidget）</h3><img src="/post/2095ef6d/image-20230817162315762.png" class="" title="image-20230817162315762"><img src="/post/2095ef6d/image-20230817162347283.png" class="" title="image-20230817162347283"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QStackedWidget::<span class="built_in">QStackedWidget</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 在栈窗口中后边添加一个子窗口, 返回这个子窗口在栈窗口中的索引值(从0开始计数)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QStackedWidget::addWidget</span><span class="params">(QWidget *widget)</span></span>;</span><br><span class="line"><span class="comment">// 将子窗口widget插入到栈窗口的index位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QStackedWidget::insertWidget</span><span class="params">(<span class="type">int</span> index, QWidget *widget)</span></span>;</span><br><span class="line"><span class="comment">// 将子窗口widget从栈窗口中删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QStackedWidget::removeWidget</span><span class="params">(QWidget *widget)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回栈容器窗口中存储的子窗口的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QStackedWidget::count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到当前栈窗口中显示的子窗口的索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QStackedWidget::currentIndex</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到当前栈窗口中显示的子窗口的指针(窗口地址)</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QStackedWidget::currentWidget</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 基于索引index得到栈窗口中对应的子窗口的指针</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QStackedWidget::widget</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 基于子窗口的指针(实例地址)得到其在栈窗口中的索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QStackedWidget::indexOf</span><span class="params">(QWidget *widget)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 信号</span></span><br><span class="line"><span class="comment">// 切换栈窗口中显示子窗口, 该信息被发射出来, index为新的当前窗口对应的索引值</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QStackedWidget::currentChanged</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">// 当栈窗口的子窗口被删除, 该信号被发射出来, index为被删除的窗口对应的索引值</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QStackedWidget::widgetRemoved</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 槽函数</span></span><br><span class="line"><span class="comment">// 基于子窗口的index索引指定当前栈窗口中显示哪一个子窗口</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QStackedWidget::setCurrentIndex</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QStackedWidget::setCurrentWidget</span><span class="params">(QWidget *widget)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">QStackedWidget *sw=<span class="keyword">new</span> <span class="built_in">QStackedWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">sw-&gt;<span class="built_in">setFixedSize</span>(<span class="number">400</span>,<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QHBoxLayout *bj=<span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">QPushButton *btn1=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮1&quot;</span>);</span><br><span class="line"> QPushButton *btn2=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮2&quot;</span>);</span><br><span class="line">  QPushButton *btn3=<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮3&quot;</span>);</span><br><span class="line"> bj-&gt;<span class="built_in">addWidget</span>(btn1);</span><br><span class="line"> bj-&gt;<span class="built_in">addWidget</span>(btn2);</span><br><span class="line"> bj-&gt;<span class="built_in">addWidget</span>(btn3);</span><br><span class="line"></span><br><span class="line"> QWidget *w1=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> QWidget *w2=<span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"> w1-&gt;<span class="built_in">setLayout</span>(bj);</span><br><span class="line">          sw-&gt;<span class="built_in">addWidget</span>(w1);</span><br><span class="line">          sw-&gt;<span class="built_in">addWidget</span>(w2);</span><br><span class="line">                        <span class="built_in">qDebug</span>()&lt;&lt;sw-&gt;<span class="built_in">count</span>();</span><br><span class="line"> sw-&gt;<span class="built_in">setCurrentWidget</span>(w1);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;sw-&gt;<span class="built_in">currentIndex</span>();</span><br><span class="line"></span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;sw-&gt;<span class="built_in">widget</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;sw-&gt;<span class="built_in">indexOf</span>(w2);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230817163236990.png" class="" title="image-20230817163236990"><img src="/post/2095ef6d/image-20230817163341666.png" class="" title="image-20230817163341666"><img src="/post/2095ef6d/image-20230817164113991.png" class="" title="image-20230817164113991"><blockquote><p>可以在属性面板直接（添加页）,然后拖拽相应的 控件！！！所有控件都是他妈的容器</p></blockquote><h2 id="QT事件处理"><a href="#QT事件处理" class="headerlink" title="QT事件处理"></a>QT事件处理</h2><img src="/post/2095ef6d/image-20230818135346990.png" class="" title="image-20230818135346990"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">//框架内部开始事件检测了</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>事件在Qt中产生之后，的分发过程是这样的：</strong></p><ol><li><p>当事件产生之后，Qt使用用应用程序对象调用notify()(通知)函数将事件<strong>发送到指定的窗口</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">override</span> <span class="keyword">virtual</span>] <span class="function"><span class="type">bool</span> <span class="title">QApplication::notify</span><span class="params">(QObject *receiver, QEvent *e)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>事件在发送过程中可以通过事件<strong>过滤器进行过滤，默认不对任何产生的事件进行过滤。</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span>] <span class="function"><span class="type">bool</span> <span class="title">QObject::eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span></span><br></pre></td></tr></table></figure></li><li><p>当事件发送到指定窗口之后，窗口的<strong>事件分发器会对收到的事件进行分类:</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">override</span> <span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">bool</span> <span class="title">QWidget::event</span><span class="params">(QEvent *event)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>事件分发器会将分类之后的事件<strong>（鼠标事件、键盘事件、绘图事件。。。）</strong>&#x3D;&#x3D;分发给对应的事件处理器函数进行处理&#x3D;&#x3D;，每个<strong>事件处理器函数都有默认的处理动作（我们也可以重写这些事件处理器函数）</strong>，比如：鼠标事件：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 鼠标按下</span></span><br><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line"><span class="comment">// 鼠标释放</span></span><br><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line"><span class="comment">// 鼠标移动</span></span><br><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="事件处理器函数"><a href="#事件处理器函数" class="headerlink" title="事件处理器函数"></a>事件处理器函数</h3><img src="/post/2095ef6d/image-20230818140257416.png" class="" title="image-20230818140257416"><h4 id="鼠标事件mouse…-Event-特别2"><a href="#鼠标事件mouse…-Event-特别2" class="headerlink" title="鼠标事件mouse….Event,特别2"></a>鼠标事件mouse….Event,特别2</h4><blockquote><ol><li><h3 id="鼠标按下事件"><a href="#鼠标按下事件" class="headerlink" title="鼠标按下事件"></a>鼠标按下事件</h3><blockquote><p><strong>当鼠标左键、鼠标右键、鼠标中键被按下，该函数被&#x3D;&#x3D;自动调用&#x3D;&#x3D;<strong>，</strong>通过参数可以得到当前按下的是哪个鼠标键</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;event-&gt;<span class="built_in">button</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>()==Qt::RightButton)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="comment">//        Qt::RightButton</span></span><br><span class="line"><span class="comment">//            Qt::LeftButton</span></span><br><span class="line"><span class="comment">//            Qt::MiddleButtonq</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;event-&gt;<span class="built_in">position</span>();</span><br><span class="line">     <span class="comment">//设置一个菜单栏menu!+menubar</span></span><br><span class="line">     QMenu *bar=<span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="keyword">this</span>);</span><br><span class="line">     bar-&gt;<span class="built_in">addAction</span>(<span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;C++&quot;</span>));</span><br><span class="line">     bar-&gt;<span class="built_in">addAction</span>(<span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;Python&quot;</span>));</span><br><span class="line">     bar-&gt;<span class="built_in">addAction</span>(<span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;Javascript&quot;</span>));</span><br><span class="line">     <span class="comment">//        bar-&gt;show();</span></span><br><span class="line">     <span class="comment">//设置显示的位置，点击位置的右下角！</span></span><br><span class="line">     bar-&gt;<span class="built_in">exec</span>(QCursor::<span class="built_in">pos</span>());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><h3 id="鼠标释放事件"><a href="#鼠标释放事件" class="headerlink" title="鼠标释放事件"></a>鼠标释放事件</h3><blockquote><p>当鼠标左键、鼠标右键、鼠标中键被释放，该函数被自动调用，<strong>通过参数可以得到当前释放的是哪个鼠标键</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;event-&gt;<span class="built_in">button</span>();</span><br><span class="line"> <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>()==Qt::RightButton)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;你按下了右键&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上面的触发相比，只是触发时机不</p></blockquote></li><li><h3 id="鼠标移动事件"><a href="#鼠标移动事件" class="headerlink" title="鼠标移动事件"></a>鼠标移动事件</h3><blockquote><p>当鼠标移动（也可以按住一个或多个鼠标键移动），该函数被自动调用，通过参数可以得到在移动过程中哪些鼠标键被按下了。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> MainWindow:: <span class="built_in">mouseMoveEvent</span>(QMouseEvent *event)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;event-&gt;<span class="built_in">buttons</span>()&lt;&lt;<span class="string">&quot;经过&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><code>event-&gt;buttons()</code>：这是一个成员函数，用于获取鼠标移动事件发生时的鼠标按钮状态。它返回一个枚举值，表示当前按下的鼠标按钮。在 <code>qDebug()</code> 输出语句中，<strong>它将输出当前按钮状态。</strong></li><li><code>event-&gt;button()</code>：这也是一个成员函数，用于获取鼠标移动事件发生时的鼠标按钮。它返回一个枚举值，表示最后一次按下或释放的鼠标按钮。在 <code>qDebug()</code> 输出语句中，<strong>它将输出最后一次按下或释放的按钮。</strong></li></ol><p>所以，<code>event-&gt;buttons()</code> 输出的是当前按钮状态，而 <code>event-&gt;button()</code> 输出的是最后一次按下或释放的按钮。</p></blockquote></li><li><h3 id="鼠标双鸡事件"><a href="#鼠标双鸡事件" class="headerlink" title="鼠标双鸡事件"></a>鼠标双鸡事件</h3><blockquote><p>当鼠标双击该函数被调用，通过参数可以得到是通过哪个鼠标键进行了双击操作。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::mouseDoubleClickEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::mouseDoubleClickEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;event-&gt;<span class="built_in">buttons</span>()&lt;&lt;<span class="string">&quot;双鸡了&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><h3 id="鼠标进入事件——————————————–"><a href="#鼠标进入事件——————————————–" class="headerlink" title="鼠标进入事件——————————————–"></a>鼠标进入事件——————————————–</h3><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::enterEvent</span><span class="params">(QEvent *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::enterEvent</span><span class="params">(QEnterEvent *event)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::enterEvent</span><span class="params">(QEnterEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;event-&gt;<span class="built_in">button</span>()&lt;&lt;<span class="string">&quot;大苏打&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::enterEvent</span><span class="params">(QEnterEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;dasdasd&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别注意一下，这里面不是qevent而是qenterevent</p></blockquote></li><li><h3 id="鼠标离开事件"><a href="#鼠标离开事件" class="headerlink" title="鼠标离开事件"></a>鼠标离开事件</h3><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::enterEvent</span><span class="params">(QEnterEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;dasdasd&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::leaveEvent</span><span class="params">(QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;移出去了&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><hr><p>&#x2F;&#x2F;    void mousePressEvent(QMouseEvent *event);<br>&#x2F;&#x2F;    void mouseReleaseEvent(QMouseEvent *event);<br>&#x2F;&#x2F;    void mouseMoveEvent(QMouseEvent *event);<br>&#x2F;&#x2F;    void mouseDoubleClickEvent(QMouseEvent *event);<br>&#x2F;&#x2F;    void enterEvent(QEnterEvent *event);<br>&#x2F;&#x2F;    void leaveEvent(QEvent *event);</p></li></ol></blockquote><h4 id="键盘事件key……Event"><a href="#键盘事件key……Event" class="headerlink" title="键盘事件key……Event"></a>键盘事件key……Event</h4><blockquote><ol><li><p>键盘按下事件</p><blockquote><p>当键盘上的按键被按下了，该函数被自动调用，通过参数可以得知按下的是哪个键。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::keyPressEvent</span><span class="params">(QKeyEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::keyPressEvent</span><span class="params">(QKeyEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;event-&gt;<span class="built_in">key</span>()&lt;&lt;<span class="string">&quot;被按下了&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>键盘释放事件</p><blockquote><p>当键盘上的按键被释放了，该函数被自动调用，通过参数可以得知释放的是哪个键。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::keyReleaseEvent</span><span class="params">(QKeyEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::keyReleaseEvent</span><span class="params">(QKeyEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;event-&gt;<span class="built_in">key</span>()&lt;&lt;<span class="string">&quot;被按下了&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230820101016537.png" class="" title="image-20230820101016537"></blockquote></li></ol></blockquote><h4 id="窗口重绘事件paintEvent"><a href="#窗口重绘事件paintEvent" class="headerlink" title="窗口重绘事件paintEvent"></a>窗口重绘事件paintEvent</h4><blockquote><p>当窗口需要刷新的时候，该函数就会自动被调用。窗口需要刷新的情景很多，比如：<strong>窗口大小发生变化，窗口显示等，另外我们还可以通过该函数给窗口绘制背景图</strong>，总之这是一个需要经常被重写的一个事件处理器函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::paintEvent</span><span class="params">(QPaintEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::paintEvent</span><span class="params">(QPaintEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    event-&gt;type();</span></span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;窗口他妈重绘了！！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>窗口的缩放，打开，都有</p></blockquote><h4 id="窗口关闭事件closeEvent"><a href="#窗口关闭事件closeEvent" class="headerlink" title="窗口关闭事件closeEvent"></a>窗口关闭事件closeEvent</h4><blockquote><p>当窗口标题栏的<strong>关闭按钮被按下并且在窗口关闭之前该函数被调用</strong>，可以通过该函数控制窗口是否被关闭。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::closeEvent</span><span class="params">(QCloseEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::closeEvent</span><span class="params">(QCloseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//在点击了关闭按钮之后，窗口关闭之前，这个函数被调用</span></span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;窗口被关闭；了啊&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="重置窗口大小事件resize-Event"><a href="#重置窗口大小事件resize-Event" class="headerlink" title="重置窗口大小事件resize Event"></a>重置窗口大小事件resize Event</h4><blockquote><pre><code>    当窗口的大小发生变化，该函数被调用。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QWidget::resizeEvent</span><span class="params">(QResizeEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::resizeEvent</span><span class="params">(QResizeEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;我去&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当窗口的大小发生变化，该函数被调用。</code></pre></blockquote><p>&#x2F;&#x2F;    void keyPressEvent(QKeyEvent *event);<br>&#x2F;&#x2F;    void keyReleaseEvent(QKeyEvent *event);<br>&#x2F;&#x2F;    void paintEvent(QPaintEvent *event);<br>&#x2F;&#x2F;    void closeEvent(QCloseEvent *event);<br>&#x2F;&#x2F;    void resizeEvent(QResizeEvent *event);</p><hr><h4 id="以上总结的规律"><a href="#以上总结的规律" class="headerlink" title="以上总结的规律"></a>以上总结的规律</h4><p>除此之外，关于Qt窗口提供的其他事件处理器函数还有很多，感兴趣的话可以仔细阅读Qt的帮助文档，窗口的事件处理器函数非常好找，规律是这样的：</p><blockquote><p><strong>受保护的虚函数</strong><br>函数名分为两部分: <strong>事件描述+Event</strong><br><strong>函数带一个事件类型的参数</strong></p></blockquote><h4 id="重写得到你自己的方案"><a href="#重写得到你自己的方案" class="headerlink" title="重写得到你自己的方案"></a>重写得到你自己的方案</h4><img src="/post/2095ef6d/image-20230818155940410.png" class="" title="image-20230818155940410"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>(<span class="number">828</span>,<span class="number">509</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">MainWindow::closeEvent</span><span class="params">(QCloseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=QMessageBox::<span class="built_in">question</span>(<span class="keyword">this</span>,<span class="string">&quot;信息&quot;</span>,<span class="string">&quot;你确定要关闭吗&quot;</span>,QMessageBox::Yes|QMessageBox::No);</span><br><span class="line">    <span class="keyword">if</span>(ret==QMessageBox::Yes)</span><br><span class="line">    &#123;</span><br><span class="line">        event-&gt;<span class="built_in">accept</span>();</span><br><span class="line"><span class="comment">//        event-&gt;ignore();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        event-&gt;<span class="built_in">ignore</span>();</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>,<span class="string">&quot;!&quot;</span>,<span class="string">&quot;干嘛想要干我&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::resizeEvent</span><span class="params">(QResizeEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;老的尺寸&quot;</span>&lt;&lt;event-&gt;<span class="built_in">oldSize</span>()&lt;&lt;<span class="string">&quot;新的尺寸&quot;</span>&lt;&lt;event-&gt;<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230818161109114.png" class="" title="image-20230818161109114"><img src="/post/2095ef6d/image-20230818161127925.png" class="" title="image-20230818161127925"><h3 id="自定义按钮"><a href="#自定义按钮" class="headerlink" title="自定义按钮"></a>自定义按钮</h3><img src="/post/2095ef6d/image-20230818161233519.png" class="" title="image-20230818161233519"><p>在Qt中，<code>p.drawPixmap(rect(), img)</code> 是用于在绘图设备上绘制一个图片的函数调用。</p><p><code>p</code> 是一个绘图设备（通常是一个 <code>QPainter</code> 对象），用于在其上进行绘制操作。</p><p><code>drawPixmap()</code> 是 <code>QPainter</code> 类的成员函数，用于绘制一个 <code>QPixmap</code> 对象或者其子类的图像。</p><p><strong><code>rect()</code> 是一个成员函数，用于获取当前对象的矩形区域。在这个上下文中，<code>rect()</code> 是 <code>QWidget</code> 类的成员函数，用于获取 <code>QWidget</code> 对象的矩形区域。</strong></p><p>所以，<code>rect()</code> 返回了一个描述当前 <code>QWidget</code> 对象矩形区域的 <code>QRect</code> 对象。</p><p>在 <code>p.drawPixmap(rect(), img)</code> 中，<code>rect()</code> 返回的矩形区域作为绘制的目标区域，**<code>img</code> 是要绘制的图片对象。**</p><p>这样的调用将在绘图设备上绘制 <code>img</code> 图片对象，绘制的区域为当前 <code>QWidget</code> 对象的矩形区域。</p><img src="/post/2095ef6d/image-20230818171009657.png" class="" title="image-20230818171009657"><h4 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mybutton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line">mybutton::<span class="built_in">mybutton</span>(QWidget *parent)</span><br><span class="line">    : QWidget&#123;parent&#125;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    img.<span class="built_in">load</span>(<span class="string">&quot;://D:/sucai/girl1.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">setFixedSize</span>(<span class="number">500</span>,<span class="number">800</span>);</span><br><span class="line">    <span class="comment">//提升，相当于把父类当成子类，</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mybutton::mousePressEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">img.<span class="built_in">load</span>(<span class="string">&quot;://D:/sucai/girl2.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//相当于手动刷新</span></span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mybutton::mouseReleaseEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">img.<span class="built_in">load</span>(<span class="string">&quot;://D:/sucai/girl3.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mybutton::enterEvent</span><span class="params">(QEnterEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">img.<span class="built_in">load</span>(<span class="string">&quot;://D:/sucai/girl7.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mybutton::leaveEvent</span><span class="params">(QEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">img.<span class="built_in">load</span>(<span class="string">&quot;://D:/sucai/girl6.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mybutton::paintEvent</span><span class="params">(QPaintEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(),img);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYBUTTON_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYBUTTON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mybutton</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">mybutton</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setImage</span><span class="params">(QString normal, QString hover, QString pressed)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent* ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent* ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enterEvent</span><span class="params">(QEnterEvent* ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">leaveEvent</span><span class="params">(QEvent* ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span></span>;</span><br><span class="line">    <span class="comment">//qt框架调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要自己写信号发射</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPixmap m_normal;</span><br><span class="line">    QPixmap img;</span><br><span class="line">    QPixmap m_press;</span><br><span class="line">    QPixmap m_hover;</span><br><span class="line"><span class="comment">//    qpixmap专注于显示，效率更高，qimg是像素级别的修改，绘图</span></span><br><span class="line"><span class="comment">//    都能用于显示</span></span><br><span class="line"><span class="comment">//    QPixmap(const QString &amp;fileName, const char *format = nullptr)</span></span><br><span class="line"><span class="comment">//    加在磁盘图片</span></span><br><span class="line"><span class="comment">//    或者load加载</span></span><br><span class="line">    QPixmap m_current;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYBUTTON_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>对于没有使用的函数参数有两种解决方案</p><ol><li><h3 id="Q-UNUSED-ev"><a href="#Q-UNUSED-ev" class="headerlink" title="Q_UNUSED(ev);"></a>Q_UNUSED(ev);</h3><img src="/post/2095ef6d/image-20230819082950999.png" class="" title="image-20230819082950999"></li><li><h4 id="通过省略参数名，你告诉编译器你不会在函数体内使用该参数，这样就不会再收到未使用参数的警告。这是一种常见的做法，特别是在事件处理函数中，因为有些事件处理函数可能不需要使用事件对象的信息。"><a href="#通过省略参数名，你告诉编译器你不会在函数体内使用该参数，这样就不会再收到未使用参数的警告。这是一种常见的做法，特别是在事件处理函数中，因为有些事件处理函数可能不需要使用事件对象的信息。" class="headerlink" title="通过省略参数名，你告诉编译器你不会在函数体内使用该参数，这样就不会再收到未使用参数的警告。这是一种常见的做法，特别是在事件处理函数中，因为有些事件处理函数可能不需要使用事件对象的信息。"></a>通过省略参数名，你告诉编译器你不会在函数体内使用该参数，这样就不会再收到未使用参数的警告。这是一种常见的做法，特别是在事件处理函数中，因为有些事件处理函数可能不需要使用事件对象的信息。</h4><img src="/post/2095ef6d/image-20230819083020837.png" class="" title="image-20230819083020837"></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mybtn::mousePressEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    img.<span class="built_in">load</span>(<span class="string">&quot;://D:/sucai/girl5.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">    QPushButton::<span class="built_in">mousePressEvent</span>(ev);</span><br><span class="line">    <span class="function">emit <span class="title">clicked</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//    QPushButton::mouseReleaseEvent(ev);</span></span><br><span class="line"><span class="comment">//    在默认情况下，QPushButton 的 mousePressEvent() 函数会在鼠标按钮按下后发射 clicked() 信号，</span></span><br><span class="line"><span class="comment">//    并在鼠标按钮释放后再次发射 clicked() 信号。这是为了模拟按钮的点击效果。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/post/2095ef6d/image-20230819092014059.png" class="" title="image-20230819092014059"><p>这样才能发射出父亲原来的信号</p><img src="/post/2095ef6d/image-20230819092044956.png" class="" title="image-20230819092044956"><p>qwidget窗口的特点指定父亲就内嵌进去了 </p><h4 id="案例！"><a href="#案例！" class="headerlink" title="案例！"></a>案例！</h4><ol><li><pre><code class="c++">ui-&gt;setupUi(this);Buterfly *win=new Buterfly(this);win-&gt;move((width()-win-&gt;width())/2,(height()-win-&gt;height())/2);<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```c++</span><br><span class="line">   #include &quot;buterfly.h&quot;</span><br><span class="line">   #include &lt;QPainter&gt;</span><br><span class="line">   Buterfly::Buterfly(QWidget *parent)</span><br><span class="line">       : QWidget&#123;parent&#125;</span><br><span class="line">   &#123;</span><br><span class="line">       img.load(&quot;:/1&quot;);</span><br><span class="line">       setFixedSize(img.size());</span><br><span class="line">       startTimer(100);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   void Buterfly::paintEvent(QPaintEvent *ev)</span><br><span class="line">   &#123;</span><br><span class="line">       QPainter p(this);</span><br><span class="line">       p.drawPixmap(rect(),img);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   void Buterfly::timerEvent(QTimerEvent *ev)</span><br><span class="line">   &#123;</span><br><span class="line">       //123</span><br><span class="line">       //</span><br><span class="line">       m++;</span><br><span class="line">       if(m==2)</span><br><span class="line">       &#123;</span><br><span class="line">           m=2;</span><br><span class="line">       &#125;</span><br><span class="line">       else if(m==3)</span><br><span class="line">       &#123;</span><br><span class="line">           m=3;</span><br><span class="line">       &#125;</span><br><span class="line">       else if(m==4)</span><br><span class="line">       &#123;</span><br><span class="line">           m=4;</span><br><span class="line">       &#125;</span><br><span class="line">       else</span><br><span class="line">           m=1;</span><br><span class="line">       QString name=QString(&quot;:%1&quot;).arg(m);</span><br><span class="line">       img.load(name);</span><br><span class="line">       update();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="c++">#ifndef BUTERFLY_H#define BUTERFLY_H#include &lt;QWidget&gt;class Buterfly : public QWidget&#123;    Q_OBJECTpublic:    explicit Buterfly(QWidget *parent = nullptr);protected:    void paintEvent(QPaintEvent *ev);    void timerEvent(QTimerEvent *ev);private:    QPixmap img;    int m=1;&#125;;#endif // BUTERFLY_H<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20230819100809654.png image-20230819100809654 %&#125;</span><br><span class="line"></span><br><span class="line">&gt; 222222222222222222</span><br><span class="line"></span><br><span class="line">###### 2.73逻辑运算符-与或非-</span><br><span class="line"></span><br><span class="line">1. 与and   **==第一个为0就返回0，第一个为1就返回第二个操作数==**</span><br><span class="line"></span><br><span class="line">2. ###### 或or   ==第一个为1就返回1，第一个为0就返回第二个操作数==</span><br><span class="line"></span><br><span class="line">3. 根据第一个操作数的真假来确定是否返回第二个操作数</span><br><span class="line"></span><br><span class="line">4. 非not</span><br><span class="line"></span><br><span class="line">5. ==注意逻辑运算符左右不能直接与操作数直接接触==</span><br><span class="line"></span><br><span class="line">`if(ev-&gt;buttons() &amp; Qt::LeftButton)` 是一个条件判断语句，用于检查鼠标事件中的按钮状态。</span><br><span class="line"></span><br><span class="line">`ev-&gt;buttons()` 返回一个表示当前鼠标按钮状态的整数值。`Qt::LeftButton` 是一个常量，表示鼠标左键。</span><br><span class="line"></span><br><span class="line">通过使用位运算符 `&amp;`，将 `ev-&gt;buttons()` 和 `Qt::LeftButton` 进行按位与运算。如果结果为非零值，则表示鼠标左键处于按下状态。</span><br><span class="line"></span><br><span class="line">因此，`if(ev-&gt;buttons() &amp; Qt::LeftButton)` 的意思是，如果鼠标左键处于按下状态，就执行 `if` 语句块中的代码。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">void Buterfly::mousePressEvent(QMouseEvent *ev)</span><br><span class="line">&#123;</span><br><span class="line">    //得到一个非零的数，然后与操作，就相当于看后面的数据了</span><br><span class="line">    if(ev-&gt;button()==Qt::LeftButton)</span><br><span class="line">    &#123;</span><br><span class="line">        index=ev-&gt;globalPos()-this-&gt;geometry().topLeft();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Buterfly::mouseMoveEvent(QMouseEvent *ev)</span><br><span class="line">&#123;</span><br><span class="line">    if(ev-&gt;buttons()&amp;Qt::LeftButton)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;move(ev-&gt;globalPos()-index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ol><hr><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> setpx=QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">10</span>,<span class="number">50</span>);</span><br><span class="line"><span class="type">int</span> setpy=QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">10</span>,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> curx=<span class="keyword">this</span>-&gt;<span class="built_in">geometry</span>().<span class="built_in">topLeft</span>().<span class="built_in">x</span>()+setpx;</span><br><span class="line"><span class="type">int</span> cury=<span class="keyword">this</span>-&gt;<span class="built_in">geometry</span>().<span class="built_in">topLeft</span>().<span class="built_in">y</span>()+setpy;</span><br><span class="line"></span><br><span class="line">QScreen *screen = QGuiApplication::<span class="built_in">primaryScreen</span>();</span><br><span class="line"><span class="keyword">if</span>(curx&gt;=screen-&gt;<span class="built_in">geometry</span>().<span class="built_in">right</span>())</span><br><span class="line">&#123;</span><br><span class="line">    curx=screen-&gt;<span class="built_in">geometry</span>().<span class="built_in">left</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cury&gt;=screen-&gt;<span class="built_in">geometry</span>().<span class="built_in">bottom</span>())</span><br><span class="line">&#123;</span><br><span class="line">    cury=screen-&gt;<span class="built_in">geometry</span>().<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">move</span>(curx,cury);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现移动和边界处理</p><p>Mainwindow文件cpp</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;buterfly.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRandomGenerator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QScreen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCloseEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QInputDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//    this-&gt;setFixedSize(2560,1440);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//去掉边框</span></span><br><span class="line">    <span class="built_in">setWindowFlags</span>(<span class="built_in">windowFlags</span>()|Qt::FramelessWindowHint);</span><br><span class="line"><span class="comment">//设置窗口透明</span></span><br><span class="line">    <span class="built_in">setAttribute</span>(Qt::WA_TranslucentBackground);</span><br><span class="line"><span class="comment">//窗口最大化显示</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">showMaximized</span>();</span><br><span class="line">    QScreen *screen = QGuiApplication::<span class="built_in">primaryScreen</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;screen-&gt;<span class="built_in">geometry</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">25</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Buterfly *win=<span class="keyword">new</span> <span class="built_in">Buterfly</span>(<span class="keyword">this</span>);</span><br><span class="line">        win-&gt;<span class="built_in">move</span>(QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="keyword">this</span>-&gt;<span class="built_in">width</span>()),QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="keyword">this</span>-&gt;<span class="built_in">height</span>()));</span><br><span class="line">        win-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::closeEvent</span><span class="params">(QCloseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    ev-&gt;ignore;</span></span><br><span class="line">    ev-&gt;<span class="built_in">ignore</span>();</span><br><span class="line">    QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>,<span class="string">&quot;warning&quot;</span>,<span class="string">&quot;你真的以为你能关掉我嘛？&quot;</span>,QMessageBox::No);</span><br><span class="line"><span class="comment">//    int ret=QMessageBox::question(this,&quot;作答&quot;,&quot;4+4=?&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret=QInputDialog::<span class="built_in">getInt</span>(<span class="keyword">this</span>,<span class="string">&quot;作答&quot;</span>,<span class="string">&quot;4+4=?&quot;</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret!=<span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        ev-&gt;<span class="built_in">ignore</span>();</span><br><span class="line">        QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>,<span class="string">&quot;不对！&quot;</span>,<span class="string">&quot;再试试吧&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        ev-&gt;<span class="built_in">accept</span>();</span><br><span class="line">        QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>,<span class="string">&quot;恭喜!&quot;</span>,<span class="string">&quot;恭喜你答对了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>butfly.h</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUTERFLY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUTERFLY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buterfly</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Buterfly</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">timerEvent</span><span class="params">(QTimerEvent *ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent*ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enterEvent</span><span class="params">(QEnterEvent* ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">int</span> min,<span class="type">int</span> max)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPixmap img;</span><br><span class="line">    <span class="type">int</span> m=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    ----</span></span><br><span class="line">    QPoint index;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// BUTERFLY_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>butflycpp</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buterfly.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMouseEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRandomGenerator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QScreen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGuiApplication&gt;</span></span></span><br><span class="line">Buterfly::<span class="built_in">Buterfly</span>(QWidget *parent)</span><br><span class="line">    : QWidget&#123;parent&#125;</span><br><span class="line">&#123;</span><br><span class="line">    img.<span class="built_in">load</span>(<span class="string">&quot;:/1&quot;</span>);</span><br><span class="line">    <span class="built_in">setFixedSize</span>(img.<span class="built_in">size</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">startTimer</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buterfly::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(),img);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buterfly::timerEvent</span><span class="params">(QTimerEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fly</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buterfly::mousePressEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//得到一个非零的数，然后与操作，就相当于看后面的数据了</span></span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">button</span>()==Qt::LeftButton)</span><br><span class="line">    &#123;</span><br><span class="line">        index=ev-&gt;<span class="built_in">globalPos</span>()-<span class="keyword">this</span>-&gt;<span class="built_in">geometry</span>().<span class="built_in">topLeft</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buterfly::mouseMoveEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">buttons</span>()&amp;Qt::LeftButton)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">move</span>(ev-&gt;<span class="built_in">globalPos</span>()-index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buterfly::enterEvent</span><span class="params">(QEnterEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fly</span>(<span class="number">-200</span>,<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buterfly::fly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fly</span>(<span class="number">10</span>,<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buterfly::fly</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m++;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m=<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        m=<span class="number">1</span>;</span><br><span class="line">    QString name=<span class="built_in">QString</span>(<span class="string">&quot;:%1&quot;</span>).<span class="built_in">arg</span>(m);</span><br><span class="line">    img.<span class="built_in">load</span>(name);</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">    <span class="type">int</span> setpx=QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(min,max);</span><br><span class="line">    <span class="type">int</span> setpy=QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(min,max);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> curx=<span class="keyword">this</span>-&gt;<span class="built_in">geometry</span>().<span class="built_in">topLeft</span>().<span class="built_in">x</span>()+setpx;</span><br><span class="line">    <span class="type">int</span> cury=<span class="keyword">this</span>-&gt;<span class="built_in">geometry</span>().<span class="built_in">topLeft</span>().<span class="built_in">y</span>()+setpy;</span><br><span class="line"></span><br><span class="line">    QScreen *screen = QGuiApplication::<span class="built_in">primaryScreen</span>();</span><br><span class="line">    <span class="keyword">if</span>(curx&gt;=screen-&gt;<span class="built_in">geometry</span>().<span class="built_in">right</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        curx=screen-&gt;<span class="built_in">geometry</span>().<span class="built_in">left</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cury&gt;=screen-&gt;<span class="built_in">geometry</span>().<span class="built_in">bottom</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cury=screen-&gt;<span class="built_in">geometry</span>().<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">move</span>(curx,cury);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 Qt 6 中，可以直接使用 <code>QGuiApplication::primaryScreen()</code> 来获取主屏幕的 <code>QScreen</code> 对象。所以你可以继续使用这个方法来获取屏幕对象。</p><p>简单地说，在 Qt 6 中，没有替代 <code>QGuiApplication::primaryScreen()</code> 的更简单的方法来获取主屏幕的 <code>QScreen</code> 对象。因此，你可以继续使用这个方法来获取主屏幕信息。</p><h2 id="QT事件分发器"><a href="#QT事件分发器" class="headerlink" title="QT事件分发器"></a>QT事件分发器</h2><img src="/post/2095ef6d/image-20230820091925794.png" class="" title="image-20230820091925794"><p><strong>关于窗口事件的分发，对应一个事件分发器，叫做event</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">override</span> <span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">bool</span> <span class="title">QWidget::event</span><span class="params">(QEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><h4 id="override-是-C-11-中的一个关键字，用于显式地指示派生类中的成员函数是对基类中的虚函数的重写（override）。在你提到的情况下，override-关键字用于指示派生类中的-event-函数是对-QWidget-基类中的-event-函数的重写。"><a href="#override-是-C-11-中的一个关键字，用于显式地指示派生类中的成员函数是对基类中的虚函数的重写（override）。在你提到的情况下，override-关键字用于指示派生类中的-event-函数是对-QWidget-基类中的-event-函数的重写。" class="headerlink" title="override 是 C++11 中的一个关键字，用于显式地指示派生类中的成员函数是对基类中的虚函数的重写（override）。在你提到的情况下，override 关键字用于指示派生类中的 event 函数是对 QWidget 基类中的 event 函数的重写。"></a><code>override</code> 是 C++11 中的一个关键字，用于显式地指示派生类中的成员函数是对基类中的虚函数的重写（override）。在你提到的情况下，<code>override</code> 关键字用于指示派生类中的 <code>event</code> 函数是对 <code>QWidget</code> 基类中的 <code>event</code> 函数的重写。</h4></blockquote><p>通过事件分发器的函数原型可以得知，<strong>关于事件类型的判断是基于参数完成的，</strong>这个参数是一个<strong>QEvent类</strong>型的对象，下面来看一下这个类中常用的一些API函数:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void QEvent::accept();</span><br></pre></td></tr></table></figure><p>该函数的作用是<strong>让窗口接受传递过来的事件</strong>，<strong>事件不会向上层窗口（父窗口）传递</strong>。–到此为止</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void QEvent::ignore();</span><br></pre></td></tr></table></figure><p>该函数的作用是<strong>让窗口忽略传递过来的事件</strong>，事件<strong>被传递给父窗口（向上传递）</strong>。–继续传递</p><hr><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool QEvent::isAccepted() const;</span><br><span class="line">void QEvent::setAccepted(bool accepted);</span><br></pre></td></tr></table></figure><blockquote><p><strong>设置传递过来的事件是被接受还是被忽略</strong><br><strong>setAccepted(true) &#x3D;&#x3D; accept()</strong><br><strong>setAccepted(false) &#x3D;&#x3D; ignore()</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QEvent::Type <span class="title">QEvent::type</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><strong>得到传递的窗口的事件的类型</strong>，<strong>返回值是一个枚举类型</strong>，内容很多可以自己查帮助文档，简单的贴个图：</p><img src="/post/2095ef6d/image-20230820093000591.png" class="" title="image-20230820093000591"><h3 id="事件分发器"><a href="#事件分发器" class="headerlink" title="事件分发器"></a>事件分发器</h3><p><strong>在不需要人为干预的情况下</strong>，<strong>事件分发器会自主的完成相关事件的分发</strong>，下面来还原一下事件分发器的分发流程，以下是这个函数的部分源码展示：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QWidget::event</span><span class="params">(QEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(ev-&gt;<span class="built_in">type</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 鼠标移动</span></span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseMove:</span><br><span class="line">        <span class="built_in">mouseMoveEvent</span>((QMouseEvent*)event);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 鼠标按下</span></span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonPress:</span><br><span class="line">        <span class="built_in">mousePressEvent</span>((QMouseEvent*)event);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 鼠标释放</span></span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonRelease:</span><br><span class="line">        <span class="built_in">mouseReleaseEvent</span>((QMouseEvent*)event);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 鼠标双击</span></span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonDblClick:</span><br><span class="line">        <span class="built_in">mouseDoubleClickEvent</span>((QMouseEvent*)event);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 键盘按键被按下事件</span></span><br><span class="line">    <span class="keyword">case</span> QEvent::KeyPress:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>看到事件分发器在对事件进行判定之后会调用相关的事件处理器函数，这样事件就被最终处理掉了。</p></blockquote><p>如果我们不想让某些触发的事件进入到当前窗口中，<strong>可以在事件分发器中进行拦截</strong>，拦截之前<strong>先来了解一下事件分发器函数的返回值：</strong></p><blockquote><p>如果传入的事件<strong>已被识别并且处理，则需要返回 true，否则返回 false。</strong>如果<strong>返回值是 true，那么 Qt 会认为这个事件已经处理完毕</strong>，<strong>不会再将这个事件发送给其它对象</strong>，而<strong>是会继续处理事件队列中的下一事件</strong>。</p><p>在event()函数中，<strong>调用事件对象的 accept() 和 ignore() 函数是没有作用的，不会影响到事件的传播。</strong></p></blockquote><p>举个例子，在窗口中<strong>过滤掉鼠标按下的事件</strong>:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::event</span><span class="params">(QEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">type</span>() == QEvent::MouseButtonPress ||</span><br><span class="line">            ev-&gt;<span class="built_in">type</span>() == QEvent::MouseButtonDblClick)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 过滤调用鼠标按下的事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">event</span>(ev);</span><br><span class="line">    <span class="comment">/////是具体的窗口</span></span><br><span class="line">    <span class="keyword">return</span> qtextevent::<span class="built_in">event</span>(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这样窗口就再也收不到鼠标的单击和双击事件了</strong>，对于这两个事件以外的其他事件是没有任何影响的，因为在重写的事件分发器函数的&#x3D;&#x3D;<strong>最后调用了父类的事件分发器函数</strong>&#x3D;&#x3D;</p><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> QWidget::<span class="built_in">event</span>(ev);</span><br></pre></td></tr></table></figure><h5 id="这样就能保证其他事件按照默认的分发流程进行分发，并最终被窗口处理掉。"><a href="#这样就能保证其他事件按照默认的分发流程进行分发，并最终被窗口处理掉。" class="headerlink" title="这样就能保证其他事件按照默认的分发流程进行分发，并最终被窗口处理掉。"></a>这样就能保证其他事件按照默认的分发流程进行分发，并最终被窗口处理掉。</h5></blockquote><h2 id="QT事件过滤器-fliter"><a href="#QT事件过滤器-fliter" class="headerlink" title="QT事件过滤器(fliter)"></a>QT事件过滤器(fliter)</h2><p><strong>除了使用事件分发器来过滤Qt窗口中产生的事件，还可以通过事件过滤器过滤相关的事件</strong>。当Qt的事件通过应用程序对象发送给相关窗口之后，<strong>窗口接收到数据之前这个期间可对事件进行过滤</strong>，<strong>过滤掉的事件就不能被继续处</strong>理了。**&#x3D;&#x3D;QObject有一个eventFilter()函数，用于建立事件过滤器。函数原型如下：&#x3D;&#x3D;**</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">virtual</span>] <span class="function"><span class="type">bool</span> <span class="title">QObject::eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>watched：要过滤的事件的所有者对象</strong>  过滤流<br><strong>event：要过滤的具体的事件</strong>    过滤对象</p><p><strong>返回值：</strong>*<strong>如果想过滤掉这个事件，停止它被进一步处理，返回true，否则返回 false</strong></p><h3 id="方法！！"><a href="#方法！！" class="headerlink" title="方法！！"></a>方法！！</h3><p>既然要过滤传递中的事件，<strong>首当其冲还是要搞明白如何通过事件过滤器进行事件的过滤，主要分为两步：</strong></p><blockquote><ol><li><p>给要被过滤事件的<strong>类对象安装事件过滤器</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QObject::installEventFilter</span><span class="params">(QObject *filterObj)</span></span>;</span><br></pre></td></tr></table></figure><p>假设调用installEventFilter()函数的对象为当前对象，那么就可以基于参数指定的filterObj对象来过滤当前对象中的指定的事件了。</p><p>*<em>QObject <em>filterObj);是修改过默认事件过滤器的对象</em></em></p></li><li><p>在要进行事件过滤的类中<strong>（filterObj 参数对应的类）</strong>**&#x3D;&#x3D;<strong>重写从QObject类继承的虚函数eventFilter()</strong>&#x3D;&#x3D;</p></li></ol></blockquote><h3 id="事件过滤器的使用"><a href="#事件过滤器的使用" class="headerlink" title="事件过滤器的使用"></a>事件过滤器的使用</h3><p><a href="https://blog.csdn.net/xideaha/article/details/132389149?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22132389149%22,%22source%22:%22xideaha%22%7D">举一个例子</a></p><blockquote><p>在一个窗口中<strong>有一个多行文本输入框QTextEdit，****需要让我们屏蔽掉键盘上的回车键</strong>，也就是按回车键之<strong>后在这个文本编辑框中再也不能换行了。</strong></p></blockquote><p>这三种方法 </p><p>1.自定义一个新的类让其继承QTextEdit，在这个子类中重写键盘事件keyPressEvent，在这个函数里边屏蔽掉回车键</p><p>2.自定义一个新的类让其继承QTextEdit，在这个子类中重写事件分发器event，在这个函数里边屏蔽掉回车键</p><p>3.给QTextEdit安装事件过滤器，基于QTextEdit的父窗口对这个控件的事件进行过滤</p><p><strong>820</strong></p><p><strong>Qt::Key_Enter是小键盘上的回车（确认）键，有些键盘没有小键盘，因此也就没有该按键。</strong><br><strong>Qt::Key_Return是大键盘上的回车键</strong></p><p><strong>通过这样的处理，事件在被应用程序对象发送出去之后，进入到对应的窗口之前就被其父窗口过滤掉了。</strong></p><p><strong>如果在Qt的窗口中有多层嵌套的窗口，如下图：</strong></p><img src="/post/2095ef6d/image-20230820105739083.png" class="" title="image-20230820105739083"><p>先来描述一下这四层窗口的关系：</p><p>顶层窗口A的直接子窗口是 B，间接子窗口是 C，QTextEdit<br>二级窗口B的直接子窗口是 C，间接子窗口是 QTextEdit<br>三级窗口C的直接子窗口是 QTextEdit</p><p>在这种多层嵌套窗口中如果想要过滤掉QTextEdit的某些事件，可以交给A或者B或者C去处理，当然也可以给QTextEdit同时安装多个过滤器：</p><p><strong>ui-&gt;textEdit-&gt;installEventFilter(窗口A对象);</strong><br><strong>ui-&gt;textEdit-&gt;installEventFilter(窗口B对象);</strong><br><strong>ui-&gt;textEdit-&gt;installEventFilter(窗口C对象);</strong></p><blockquote><p>如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是说窗口C先进行事件过滤，然后窗口B，最后窗口A。 </p><hr><hr><p>注意事项：</p><p><strong>事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</strong></p></blockquote><hr><blockquote><h3 id="在Qt中，事件传递是根据对象树结构进行的，从父级对象向子级对象传递。"><a href="#在Qt中，事件传递是根据对象树结构进行的，从父级对象向子级对象传递。" class="headerlink" title="在Qt中，事件传递是根据对象树结构进行的，从父级对象向子级对象传递。"></a><strong>在Qt中，事件传递是根据对象树结构进行的，从父级对象向子级对象传递。</strong></h3><p>当一个事件发生时，<strong>它首先被发送给顶层窗口</strong>（也就是<strong>应用程序的主窗口</strong>），然后<strong>通过对象树结构一层层向下传递，直到找到合适的接收者</strong>。</p><p>具体来说，事件传递的过程如下：</p><ol><li>事件首先被发送给顶层窗口，即应用程序的主窗口。</li><li>如果顶层窗口不处理该事件，它会将事件传递给它的直接子窗口（也就是窗口A）。</li><li>如果窗口A不处理该事件，它会将事件继续传递给它的直接子窗口（也就是窗口B）。</li><li>如果窗口B不处理该事件，它会将事件继续传递给它的直接子窗口（也就是窗口C）。</li><li>如果窗口C不处理该事件，它会将事件继续传递给它的直接子窗口（也就是QTextEdit）。</li><li><strong>如果QTextEdit不处理该事件，事件将被丢弃。</strong></li></ol><p>在这个过程中，<strong>每个窗口或控件都有机会处理事件。如果某个窗口或控件处理了事件，那么该事件就不会继续传递给它的子窗口或控件。</strong></p><p>在这种多层嵌套窗口的情况下，如果你想要过滤掉 <code>QTextEdit</code> 的某些事件，你有几种选择：</p><ol><li><p>将事件过滤器安装在顶层窗口A上：你可以在顶层窗口A的代码中安装一个事件过滤器，并在过滤器中对 <code>QTextEdit</code> 的事件进行处理。这样，所有发生在 <code>QTextEdit</code> 上的事件都会首先经过顶层窗口A的事件过滤器，然后再传递给 <code>QTextEdit</code> 进行处理。</p></li><li><p>将事件过滤器安装在二级窗口B上：类似地，你也可以在二级窗口B的代码中安装一个事件过滤器，并在过滤器中对 <code>QTextEdit</code> 的事件进行处理。这样，所有发生在 <code>QTextEdit</code> 上的事件都会首先经过二级窗口B的事件过滤器，然后再传递给 <code>QTextEdit</code> 进行处理。</p></li><li><p>将事件过滤器安装在三级窗口C上：同样地，你可以在三级窗口C的代码中安装一个事件过滤器，并在过滤器中对 <code>QTextEdit</code> 的事件进行处理。这样，所有发生在 <code>QTextEdit</code> 上的事件都会首先经过三级窗口C的事件过滤器，然后再传递给 <code>QTextEdit</code> 进行处理。</p></li><li><p>给 <code>QTextEdit</code> 同时安装多个过滤器：你也可以给 <code>QTextEdit</code> 同时安装多个事件过滤器。这样，每个过滤器都会对 <code>QTextEdit</code> 的事件进行处理。这种方法适用于需要多个过滤器分别处理不同类型的事件的情况。</p><p>流下来的时候直接被过滤掉了</p></li></ol><p>事件过滤器是按照安装的顺序依次处理事件的。**&#x3D;&#x3D;如果多个过滤器都对同一个事件进行了处理，最后安装的过滤器会先被调用。&#x3D;&#x3D;**</p></blockquote><h2 id="QT基于TCP的Qt网络通信"><a href="#QT基于TCP的Qt网络通信" class="headerlink" title="QT基于TCP的Qt网络通信"></a>QT基于TCP的Qt网络通信</h2><img src="/post/2095ef6d/image-20230820170203941.png" class="" title="image-20230820170203941"><p>tcp安全较于udp双向断开</p><h3 id="1-QTcpServer"><a href="#1-QTcpServer" class="headerlink" title="1.QTcpServer"></a>1.QTcpServer</h3><p>1.可以监听有没有客户端连接我</p><p>2.可以建立和客户端的连接</p><hr><h4 id="常用API！"><a href="#常用API！" class="headerlink" title="常用API！"></a>常用API！</h4><blockquote><ol><li><p>构造函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QTcpServer::<span class="built_in">QTcpServer</span>(QObject *parent = Q_NULLPTR);</span><br></pre></td></tr></table></figure></li><li><pre><code class="c++">// 判断当前对象是否在监听, 是返回true，没有监听返回falsebool QTcpServer::isListening() const;// 如果当前对象正在监听返回监听的服务器地址信息, 否则返回 QHostAddress::NullQHostAddress QTcpServer::serverAddress() const;// 如果服务器正在侦听连接，则返回服务器的端口; 否则返回0quint16 QTcpServer::serverPort() const//设置监听对象bool QTcpServer::listen(const QHostAddress &amp;address = QHostAddress::Any, quint16 port = 0);参数：address：通过类QHostAddress可以封装IPv4、IPv6格式的IP地址，QHostAddress::Any表示自动绑定port：如果指定为0表示//随机//绑定一个可用端口。【0，65535】》=5000返回值：绑定成功返回true，失败返回false<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. ```c++</span><br><span class="line">   //////////////////////////////////////////////</span><br><span class="line">   QTcpSocket *QTcpServer::nextPendingConnection();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   得到和客户端建立连接之后用于通信的QTcpSocket套接字对象</span><br><span class="line">   它是QTcpServer的一个子对象</span><br><span class="line">   当QTcpServer对象析构的时候会自动析构这个子对象，当然也可自己手动析构</span><br><span class="line">   建议用完之后自己手动析构这个通信的QTcpSocket对象。</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="c++">bool QTcpServer::waitForNewConnection(int msec = 0, bool *timedOut = Q_NULLPTR);阻塞等待客户端发起的连接请求不推荐在单线程程序中使用，建议使用非阻塞方式处理新连接，即使用信号 newConnection() 。    参数：msec：指定阻塞的最大时长，单位为毫秒（ms）timeout：传出参数，如果操作超时timeout为true，没有超时timeout为false<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 信号</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">[signal] void QTcpServer::acceptError(QAbstractSocket::SocketError socketError);</span><br><span class="line">当接受新连接导致错误时，将发射如下信号。socketError参数描述了发生的错误相关的信息。</span><br></pre></td></tr></table></figure></code></pre></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QTcpServer::newConnection</span><span class="params">()</span></span>;</span><br><span class="line">每次有新连接可用时都会发出 <span class="built_in">newConnection</span>() 信号。</span><br></pre></td></tr></table></figure><h3 id="2-QTcpsSocket继承于qtcpserver"><a href="#2-QTcpsSocket继承于qtcpserver" class="headerlink" title="2.QTcpsSocket继承于qtcpserver"></a>2.QTcpsSocket继承于qtcpserver</h3><img src="/post/2095ef6d/image-20230820171252982.png" class="" title="image-20230820171252982"><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><blockquote><ol><li><pre><code class="c++">QTcpSocket::QTcpSocket(QObject *parent = Q_NULLPTR);构造函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```c++</span><br><span class="line">   virtual] void QAbstractSocket::connectToHost(const QString &amp;hostName, quint16 port, OpenMode openMode = ReadWrite, NetworkLayerProtocol protocol = AnyIPProtocol);</span><br><span class="line">   </span><br><span class="line">   [virtual] void QAbstractSocket::connectToHost(const QHostAddress &amp;address, quint16 port, OpenMode openMode = ReadWrite);</span><br><span class="line">   连接服务器</span><br><span class="line">   </span><br></pre></td></tr></table></figure>**在Qt中不管调用读操作函数接收数据，还是调用写函数发送数据**，操作的对象都是**本地的由Qt框架维护的一块内存**。因此，调用了发送函数数据不一定会马上被发送到网络中，调用了接收函数也不是直接从网络中接收数据，**关于底层的相关操作是不需要使用者来维护的.**</code></pre></li><li><pre><code class="c++">// 指定可接收的最大字节数 maxSize 的数据到指针 data 指向的内存中qint64 QIODevice::read(char *data, qint64 maxSize);// 指定可接收的最大字节数 maxSize，返回接收的字符串QByteArray QIODevice::read(qint64 maxSize);// 将当前可用操作数据全部读出，通过返回值返回读出的字符串QByteArray QIODevice::readAll();接收数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. ```c++</span><br><span class="line">   // 发送指针 data 指向的内存中的 maxSize 个字节的数据</span><br><span class="line">   qint64 QIODevice::write(const char *data, qint64 maxSize);</span><br><span class="line">   // 发送指针 data 指向的内存中的数据，字符串以 \0 作为结束标记</span><br><span class="line">   qint64 QIODevice::write(const char *data);</span><br><span class="line">   // 发送参数指定的字符串</span><br><span class="line">   qint64 QIODevice::write(const QByteArray &amp;byteArray);</span><br><span class="line">   发送数据</span><br></pre></td></tr></table></figure></code></pre></li></ol></blockquote><h4 id="信号-1"><a href="#信号-1" class="headerlink" title="信号"></a>信号</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QIODevice::readyRead</span><span class="params">()</span></span>;</span><br><span class="line">在使用QTcpSocket进行套接字通信的过程中，如果该类对象发射出<span class="built_in">readyRead</span>()信号，说明对端发送的数据达到了，之后就可以调用 read 函数接收数据了。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractSocket::connected</span><span class="params">()</span></span>;</span><br><span class="line">调用<span class="built_in">connectToHost</span>()函数并成功建立连接之后发出<span class="built_in">connected</span>()信号。</span><br><span class="line">    检测客户端是否与服务器连接成功，再客户端使用</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractSocket::disconnected</span><span class="params">()</span></span>;</span><br><span class="line">在套接字断开连接时发出<span class="built_in">disconnected</span>()信号。</span><br><span class="line">    两端都能使用，一旦使用就发出disconnect的信号</span><br></pre></td></tr></table></figure><p><strong>qt维护的那一块内存是中间人</strong></p><h3 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h3><p><em><strong>使用Qt提供的类进行套接字通信比使用标准C API进行网络通信要简单</strong></em>（因为在内部进行了封装）</p><p><strong>接收就是读，发送就是写</strong></p><ol><li><p>服务器端</p><blockquote><p>1.创建套接字服务器QTcpServer对象</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_s=<span class="keyword">new</span> <span class="built_in">QTcpServer</span>(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>2.通过QTcpServer对象设置监听，即：QTcpServer::listen()</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">connect</span>(m_s,&amp;QTcpServer::newConnection,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">     <span class="comment">//接受连接成功后的子对象qtcpsocket</span></span><br><span class="line"><span class="comment">//        QTcpSocket *tcp=m_s-&gt;nextPendingConnection();</span></span><br><span class="line">     m_o=m_s-&gt;<span class="built_in">nextPendingConnection</span>();</span><br><span class="line">      m_l-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/pass.png&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>));</span><br><span class="line"><span class="comment">//        ui-&gt;hmsg-&gt;append(&quot;和客户端连接成功!&quot;);</span></span><br><span class="line">      ui-&gt;hmsg-&gt;<span class="built_in">append</span>(<span class="string">&quot;帅到汽车爆胎的小帅上线了&quot;</span>);</span><br><span class="line">      QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>,<span class="string">&quot;提示&quot;</span>,<span class="string">&quot;小帅上线了！！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">connect</span>(m_o,&amp;QTcpSocket::readyRead,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line"><span class="comment">//            qDebug()&lt;&lt;&quot;信息来咯&quot;;</span></span><br><span class="line">         <span class="comment">//先读取信息</span></span><br><span class="line">         QByteArray data=m_o-&gt;<span class="built_in">readAll</span>();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//把信息添加到历史画框里</span></span><br><span class="line">         QDateTime now= QDateTime::<span class="built_in">currentDateTime</span>();</span><br><span class="line">         QString str=now.<span class="built_in">toString</span>(<span class="string">&quot;[yyyy-MM-dd hh:mm:ss AP]&gt;&gt;&quot;</span>);</span><br><span class="line">         ui-&gt;hmsg-&gt;<span class="built_in">append</span>(<span class="string">&quot;小帅&quot;</span>+str+data);</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="built_in">connect</span>(m_o,&amp;QTcpSocket::disconnected,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">         m_o-&gt;<span class="built_in">close</span>();</span><br><span class="line">         m_o-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">         m_l-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/pass.png&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>));</span><br><span class="line">         ui-&gt;hmsg-&gt;<span class="built_in">append</span>(<span class="string">&quot;小帅断开了连接....难道是我不够美吗？呜呜呜&quot;</span>);</span><br><span class="line">         m_l-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/wrong.png&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>));</span><br><span class="line">         ui-&gt;playserver-&gt;<span class="built_in">setDisabled</span>(<span class="literal">false</span>);</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure><p>3.基于QTcpServer::newConnection()信号检测是否有新的客户端连接<br>4.如果有新的客户端连接调用QTcpSocket *QTcpServer::nextPendingConnection()得到通信的套接字对象<br>5.使用通信的套接字对象QTcpSocket和客户端进行通信</p></blockquote></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
